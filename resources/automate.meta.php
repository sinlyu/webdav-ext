<?php

namespace edoc\appserver\migration {
    abstract class AbstractMigration
    {
        protected $app = null;
        final public function __construct(\edoc\appserver\App $app, string $id)
        {
        }
        public function id()
        {
        }
        abstract public function exec(): bool;
    }
    class GitIgnoreAddonVendor extends \edoc\appserver\migration\AbstractMigration
    {
        public function exec(): bool
        {
        }
    }
    class AddDecsTaskURLToFlows extends \edoc\appserver\migration\AbstractMigration
    {
        public function exec(): bool
        {
        }
    }
}
namespace edoc\appserver\app {
    #[\edoc\appserver\stubs\attributes\PluginAPI]
    trait ExecParamAction
    {
        abstract public function parent(): ?\edoc\appserver\app\AbstractComponent;
        abstract protected function logger(): ?\Monolog\Logger;
        protected function getActionResult(\edoc\appserver\app\AbstractAction $action, $actionConfig): mixed
        {
        }
        protected function execParamAction($param, ?\edoc\appserver\app\AbstractAction &$action = null)
        {
        }
    }
    #[\edoc\appserver\stubs\attributes\PluginAPI]
    trait GetComponentId
    {
        private function getContextId($fieldId)
        {
        }
        protected function parentReplication(): ?\edoc\appserver\app\AbstractComponent
        {
        }
        /**
         * @param $fieldId
         * @return string
         */
        protected function getRealId(string $fieldId, $addBaseComponent = true): string
        {
        }
        protected function getParentViewId(?\edoc\appserver\app\AbstractComponent $current, ?string &$replicationCompRow, ?int &$replicationCompLevel): ?string
        {
        }
    }
    /**
     * Class Action
     *
     * @package edoc\appserver
     */
    #[\edoc\appserver\stubs\attributes\PluginAPI]
    abstract class AbstractAction
    {
        use \edoc\appserver\app\ExecParamAction;
        use \edoc\appserver\app\GetComponentId;
        protected function logger(): ?\Monolog\Logger
        {
        }
        public function getActionLogger(): \edoc\appserver\app\logging\ActionLogger
        {
        }
        /**
         * valid options: defaultValue, ...
         */
        public const ACTION_TYPE_TEXT = 'text';
        /**
         * valid options: options, default, callback, action_result_validation, select_groups, ...
         */
        public const ACTION_TYPE_SELECT = 'select';
        /**
         * valid options: max, multiple, callback,
         */
        public const ACTION_TYPE_COMPONENT = 'component';
        /**
         * valid options: max, ...
         */
        public const ACTION_TYPE_COMPONENTLIST = 'componentlist';
        /**
         * valid options: key_disabled, add_disabled, ...
         */
        public const ACTION_TYPE_KEYVALUELIST = 'keyvaluelist';
        /**
         * valid options: ?
         */
        public const ACTION_TYPE_VALUELIST = 'valuelist';
        /**
         * valid options: ?
         */
        public const ACTION_TYPE_ACTIONLIST = 'actionlist';
        /**
         * valid options: ?
         */
        public const ACTION_TYPE_KEYACTIONLIST = 'keyactionlist';
        /**
         * valid options: requires (not implemented!)
         */
        public const ACTION_TYPE_ACTION = 'action';
        /**
         * valid options: mode, autocomplete, ...
         */
        public const ACTION_TYPE_EDITOR = 'editor';
        /**
         * valid options: callback, type, ...
         */
        public const ACTION_TYPE_DATASOURCE = 'datasource';
        /**
         * valid options: callback, ...
         */
        public const ACTION_TYPE_WORKFLOW = 'workflow';
        /**
         * valid options: ?
         */
        public const ACTION_TYPE_VIEWROUTE = 'route';
        /** @var Logger */
        protected $logger;
        /**
         * @var ActionHelper|null
         */
        protected $helper = null;
        public function __debugInfo()
        {
        }
        protected function translateParams(array $names)
        {
        }
        public function getLanguageKeys()
        {
        }
        /**
         * AbstractAction constructor.
         *
         * @param array|null $config
         * @param AbstractComponent|null $parent
         */
        final public function __construct(?\edoc\appserver\app\AbstractComponent $parent, array $config = null, ?\Monolog\Logger $logger = null)
        {
        }
        protected function initParameterActions()
        {
        }
        public function displayName()
        {
        }
        public function setParent(?\edoc\appserver\app\AbstractComponent $parent)
        {
        }
        /**
         * @param Logger $logger
         */
        public function setLogger(\Monolog\Logger $logger)
        {
        }
        abstract protected function init();
        /**
         * This function returns an array of javascript callbacks.
         * each callback has to be a function like this: function(param){...}
         */
        public static function addJSCallbacks()
        {
        }
        public function name()
        {
        }
        public function getJsonObject()
        {
        }
        /**
         * @param $value
         */
        public function setElementValue($value)
        {
        }
        public function getParameters()
        {
        }
        public function hasReturnFields()
        {
        }
        /**
         * @param bool $render
         */
        public function setRenderResponse($render = true)
        {
        }
        protected function config()
        {
        }
        /**
         * @return mixed
         */
        protected function elementValue()
        {
        }
        protected function addParameter(
            string|null $name,
            #[\JetBrains\PhpStorm\ExpectedValues([self::ACTION_TYPE_TEXT, self::ACTION_TYPE_SELECT, self::ACTION_TYPE_COMPONENT, self::ACTION_TYPE_COMPONENTLIST, self::ACTION_TYPE_KEYVALUELIST, self::ACTION_TYPE_VALUELIST, self::ACTION_TYPE_ACTIONLIST, self::ACTION_TYPE_KEYACTIONLIST, self::ACTION_TYPE_ACTION, self::ACTION_TYPE_EDITOR, self::ACTION_TYPE_DATASOURCE, self::ACTION_TYPE_WORKFLOW, self::ACTION_TYPE_VIEWROUTE, self::ACTION_FILTER_TYPE])]
            string $type,
            #[\JetBrains\PhpStorm\ArrayShape(["options" => "array", "callback" => "array", "default" => "string", "requires" => "mixed", "mode" => "string", "type" => 'string', "value" => "string", "defaultValue" => "string", "required" => "boolean", "multiple" => "boolean", "action_result_validation" => "boolean", "autocompletion" => "boolean", "key_disabled" => "boolean", "add_disabled" => "boolean", "select_groups" => "boolean"])]
            array $options = [],
            bool $required = false
        ): void
        {
        }
        protected function setReturnFields($set = true)
        {
        }
        protected function requiredFields(): array
        {
        }
        protected function mapParamName($name): string
        {
        }
        /**
         * @param  $name
         * @return mixed
         * @throws \Exception
         */
        protected function param($name, $translate = false)
        {
        }
        /**
         * @param  $name
         * @return array
         * @throws \Exception
         */
        protected function paramList($name)
        {
        }
        /**
         * @return int
         */
        protected function paramCount()
        {
        }
        protected function validateParamActionResult($name, $value)
        {
        }
        /**
         * @return AbstractAction|null
         * @throws ActionNotFoundException|InvalidActionConfigurationException
         */
        public static function create(array $config, ?\edoc\appserver\app\AbstractComponent $parent, ?\Monolog\Logger $logger = null, int $executionMethod = \edoc\appserver\app\ActionExecutionMethod::UNKNOWN): ?\edoc\appserver\app\AbstractAction
        {
        }
        protected function execValidations(array $validations): bool
        {
        }
        protected function validateComponent($id, \edoc\appserver\app\AbstractValidator $validator): bool
        {
        }
        /**
         * @return AbstractAction
         * @throws \ReflectionException
         */
        public function run(int $executionMethod = \edoc\appserver\app\ActionExecutionMethod::UNKNOWN): \edoc\appserver\app\AbstractAction
        {
        }
        /**
         * @return AbstractAction
         */
        abstract protected function exec(): \edoc\appserver\app\AbstractAction;
        protected function returnField($name)
        {
        }
        /**
         * @return array|mixed
         */
        public function returnFields()
        {
        }
        /**
         * @return AbstractComponent|null
         */
        public function parent(): ?\edoc\appserver\app\AbstractComponent
        {
        }
        /**
         * @return $this
         * @deprecated use returnEnd()!
         */
        protected function noReturn()
        {
        }
        protected function returnEnd()
        {
        }
        /**
         * @param string $errorMessage
         * @param mixed|null $errorCode
         * @return $this
         */
        protected function returnError(string $errorMessage, $errorCode = null)
        {
        }
        protected function returnRenderComponent(\edoc\appserver\app\AbstractComponent $component)
        {
        }
        protected function returnDownload($content, $filename, $mimetype)
        {
        }
        /**
         * @return bool
         */
        protected function renderResponse(): bool
        {
        }
        protected function findComponent($componentId)
        {
        }
        /**
         * @throws \ReflectionException
         * @throws InvalidActionConfigurationException
         * @throws ActionNotFoundException
         * @throws Exception
         */
        protected function buildViewURL(array $route, bool $addServerAddr = true): string
        {
        }
        public function docs(): array
        {
        }
        public function logInfo(): array
        {
        }
        /**
         * @param QuickAddAction $action
         * @return void
         */
        protected function addQuickAddAction(\edoc\appserver\app\QuickAddAction $action): void
        {
        }
        /**
         * @return QuickAddAction[]
         */
        public function getQuickAddActions(): array
        {
        }
        public function setExecutionMethod(int $method)
        {
        }
        public function executionMethod(): int
        {
        }
    }
}
namespace edoc\appserver\addons\d3\lib {
    abstract class AbstractD3Action extends \edoc\appserver\app\AbstractAction
    {
        abstract protected function initD3();
        protected function getDatasource(): ?\edoc\appserver\addons\d3\datasources\D3
        {
        }
        final protected function init()
        {
        }
    }
}
namespace edoc\appserver\addons\d3\actions {
    /**
     * DeleteDocument-Aktion
     *
     * Mit der **DeleteDocument**-Aktion können Sie ein Dokument im ausgewählten d.3-Repository
     * (d.velop-Dokumentenverwaltung) löschen.
     *
     * @param TEXT $docid Gibt die Dokument-ID (**DocId**) des zu löschenden Dokuments an.
     */
    class DeleteDocument extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        protected function initD3()
        {
        }
        public function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * DeleteDocumentFromWorkPath-Aktion
     *
     * Mit der **DeleteDocumentFromWorkPath**-Aktion können Sie ein Dokument aus dem gestarteten Workflow entfernen.
     *
     * @param TEXT $docid Gibt die Dokument-ID (**DocId**) des Dokuments an, dessen Workflow abgebrochen werden soll.
     */
    class DeleteDocumentFromWorkPath extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        public function exec(): \edoc\appserver\app\AbstractAction
        {
        }
        protected function initD3()
        {
        }
    }
}
namespace edoc\appserver\app\actions {
    #[\edoc\appserver\app\actions\PluginAPI]
    trait DatasetAction
    {
        private $isDatasetSet = false;
        private $dataset = [];
        /**
         * @return array
         */
        public function dataset()
        {
        }
        /**
         * @param  $dataset
         * @return $this
         */
        protected function returnDataset($dataset)
        {
        }
        public function isDatasetSet()
        {
        }
    }
}
namespace edoc\appserver\addons\d3\actions {
    /**
     * GetAttributes-Aktion
     *
     * Die **GetAttributes**-Aktion gibt die Attribute des angegebenen Dokuments zurück.
     *
     * @param TEXT $docid Gibt die Dokument-ID (**DocId**) des entsprechenden Dokuments an.
     *
     * @return DATASET Gibt den Datensatz der Eigenschaften des angegebenen Dokuments zurück.
     */
    class GetAttributes extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function initD3()
        {
        }
        public function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetDocumentList-Aktion
     *
     * Mit der **GetDocumentList**-Aktion können Sie nach Dokumenten im angegebenen d.3-Repository (Dokumentenverwaltung)
     * suchen.
     *
     * Weitere Informationen, auch zu den Importparametern (**Importparams**), finden Sie in der d.3-API-Referenz.
     *
     * @param KEYVALUELIST $Importparams Gibt die Liste der entsprechenden Importparameter an.
     *
     * @return DATASET Gibt die Liste der gesuchten Dokumente zurück.
     */
    class GetDocumentList extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function initD3()
        {
        }
        public function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetDocumentTypeTitleUser-Aktion
     *
     * Mit der **GetDocumentTypeTitleUser**-Aktion können Sie Informationen zu den Dokumentenarten und den zugeordneten
     * erweiterten Eigenschaften ermitteln.
     *
     * Weitere Informationen, auch zu den Importparametern (**Importparams**), finden Sie in der d.3-API-Referenz.
     *
     * @param KEYVALUELIST $Importparams Gibt die Liste der entsprechenden Importparameter an.
     *
     * @return DATASET Gibt die Liste der Dokumentarten und deren erweiterte Eigenschaften zurück.
     */
    class GetDocumentTypeTitleUser extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function initD3()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetFolderSchemeExt-Aktion
     *
     * Mit der **GetFolderSchemeExt**-Aktion können Sie die Struktur des d.3-Aktenplans abrufen.
     *
     * Weitere Informationen zum Rückgabewert finden Sie in der d.3-API-Referenz.
     *
     * @return DATASET Gibt den Datensatz des d.3-Aktenplans zurück.
     */
    class GetFolderSchemeExt extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
        protected function initD3()
        {
        }
    }
    /**
     * GetStructureDocument-Aktion
     *
     * Mit der **GetStructureDocument**-Aktion können Sie zu einem Dokument alle verknüpften übergeordneten oder
     * untergeordneten Dokumente ermitteln.
     *
     * Weitere Informationen, auch zu den Importparametern (**Importparams**), finden Sie in der d.3-API-Referenz.
     *
     * @param TEXT $docid Gibt die Dokument-ID (**DocId**) des Dokuments an.
     * @param KEYVALUELIST $Importparams Gibt die Liste der entsprechenden Importparameter an.
     *
     * @return DATASET Gibt die Verknüpfungen des angegebenen Dokuments zurück.
     */
    class GetStructureDocument extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function initD3()
        {
        }
        public function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetUserVariablesInWorkPath-Aktion
     *
     * Die **GetUserVariablesInWorkPath**-Aktion lädt aktuelle Workflowvariablen zu einer Dokument-ID (**DocId**).
     *
     * Weitere Informationen, auch zu den Importparametern (**Importparams**), finden Sie in der d.3-API-Referenz.
     *
     * @param TEXT $docid Gibt die Dokument-ID (**DocId**) des Dokuments an.
     * @param KEYVALUELIST $Importparams Gibt die Liste der entsprechenden Importparameter an.
     *
     * @return DATASET Gibt die Datensätze mit den Variablennamen und den Variablenwerten zurück.
     */
    class GetUserVariablesInWorkPath extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        use \edoc\appserver\app\actions\DatasetAction;
        public function exec(): \edoc\appserver\app\AbstractAction
        {
        }
        protected function initD3()
        {
        }
    }
    /**
     * GetValidValuesForAttribute-Aktion
     *
     * Mit der **GetValidValuesForAttribute**-Aktion können Sie alle Werte der Wertemenge zu einer oder allen
     * Dokumenteigenschaften einer Kategorie (Dokumentart) ermitteln.
     *
     * Weitere Informationen, auch zu den Importparametern (**Importparams**), finden Sie in der d.3-API-Referenz.
     *
     * @param KEYVALUELIST $Importparams Gibt die Liste der entsprechenden Importparameter an.
     *
     * @return DATASET Gibt die Datensätze mit Feldnummer, Werten und Datentyp zurück.
     */
    class GetValidValuesForAttribute extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function initD3()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions {
    #[\edoc\appserver\app\actions\PluginAPI]
    trait SingleValueAction
    {
        private $isSingleValueSet = false;
        private $singleValue = false;
        /**
         * @return mixed
         */
        public function singleValue()
        {
        }
        /**
         * @param  $value
         * @return $this
         */
        protected function returnSingleValue($value)
        {
        }
        public function isSingleValueSet()
        {
        }
    }
}
namespace edoc\appserver\addons\d3\actions {
    /**
     * ImportDocument-Aktion
     *
     * Mit der **ImportDocument**-Aktion können Sie eine Datei und Eigenschaftswerte als Dokument in ein d.3-Repository
     * (Dokumentenverwaltung) importieren.
     *
     * Weitere Informationen, auch zu den Importparametern (**Importparams**), finden Sie in der d.3-API-Referenz.
     *
     * @param TEXT $filename Gibt den Dateinamen an.
     * @param TEXT $extension Gibt die Dateierweiterung an.
     * @param TEXT $doc\_type\_short Gibt den Kurznamen der Kategorie (Dokumentart) an.
     * @param TEXT $content Gibt den Inhalt der Datei an.
     * @param KEYVALUELIST $Importparams Gibt die Liste der entsprechenden Importparameter an.
     *
     * @return SINGLEVALUE Gibt die Dokument-ID des importierten Dokuments zurück.
     */
    class ImportDocument extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function initD3()
        {
        }
        public function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * ImportNewVersionDocument-Aktion
     *
     * Mit **ImportNewVersionDocument**-Aktion können Sie eine Datei und Eigenschaftswerte als neue Dokumentversion
     * importieren.
     *
     * Weitere Informationen, auch zu den Importparametern (**Importparams**), finden Sie in der d.3-API-Referenz.
     *
     * @param TEXT $docid Gibt die Dokument-ID (**DocId**) des vorhandenen Dokuments an.
     * @param TEXT $filename Gibt den Dateinamen an.
     * @param TEXT $extension Gibt die Dateierweiterung an.
     * @param TEXT $doc\_type\_short Gibt den Kurznamen der Kategorie (Dokumentart) an.
     * @param TEXT $content Gibt den Inhalt der Datei an.
     * @param KEYVALUELIST $Importparams Gibt die Liste der entsprechenden Importparameter an.
     */
    class ImportNewVersionDocument extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        protected function initD3()
        {
        }
        public function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * LinkDocuments-Aktion
     *
     * Mit der **LinkDocuments**-Aktion können Sie zwei Dokumente verknüpfen.
     *
     * @param TEXT $docid Gibt die Dokument-ID (**DocId**) des übergeordneten (**parent**) Dokuments an.
     * @param TEXT $childdocid Gibt die Dokument-ID (**DocId**) des untergeordneten (**child**) Dokuments an.
     */
    class LinkDocuments extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        protected function initD3()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * ProceedToNextStepWorkPath-Aktion
     *
     * Die **ProceedToNextStepWorkPath**-Aktion leitet ein Dokument in einem Workflow den nächsten Workflowschritt.
     *
     * Weitere Informationen auch zu den Importparametern (**Importparams**) finden Sie in der d.3-API-Referenz.
     *
     * @param TEXT $docid Gibt die Dokument-ID (**DocId**) des Dokuments im Workflow an.
     * @param KEYVALUELIST $Importparams Gibt die Liste der entsprechenden Parameter an.
     */
    class ProceedToNextStepWorkPath extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        public function exec(): \edoc\appserver\app\AbstractAction
        {
        }
        protected function initD3()
        {
        }
    }
    /**
     * PutDocumentIntoWorkPath-Aktion
     *
     * Mit der **PutDocumentIntoWorkPath**-Aktion sendet ein Dokument manuell in einen Workflow. Sie können diese Funktion
     * nur verwenden, wenn der Workflowstart manuell durchgeführt werden darf.
     *
     * Weitere Informationen, auch zu den Importparametern (**Importparams**), finden Sie in der d.3-API-Referenz.
     *
     * @param TEXT $docid Gibt die Dokument-ID (**DocId**) des Dokuments an.
     * @param KEYVALUELIST $Importparams Gibt die Liste der entsprechenden Importparameter an.
     */
    class PutDocumentIntoWorkPath extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        public function exec(): \edoc\appserver\app\AbstractAction
        {
        }
        protected function initD3()
        {
        }
    }
    /**
     * ReceiveNote-Aktion
     *
     * Die **ReceiveNote**-Aktion gibt die Notizdatei zu einem Dokument im ausgewählten d.3-Repository
     * (Dokumentenverwaltung) zurück.
     *
     * @param TEXT $docid Gibt die Dokument-ID (**DocId**) des Dokuments an.
     *
     * @return DATASET Gibt Datensätze mit den Notizen und Eigenschaften der Notizen zum Dokument zurück.
     */
    class ReceiveNote extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function initD3()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * ReleaseDocument-Aktion
     *
     * Die **ReleaseDocument**-Aktion überführt ein geprüftes Dokument im Status **Prüfung** in den Status **Freigabe**.
     *
     * @param TEXT $docid Gibt die Dokument-ID (**DocId**) des Dokuments an.
     *
     */
    class ReleaseDocument extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        protected function initD3()
        {
        }
        public function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * SearchDocument-Aktion
     *
     * Mit der **SearchDocument**-Aktion können Sie zu vorgegebenen Suchkriterien die Kenndaten der entsprechenden Dokumente
     * ermitteln. Es werden Eigenschaften und Informationen zu den Dokumenten zurückgegeben.
     *
     * Weitere Informationen, auch zu den Importparametern (**Importparams**), finden Sie in der d.3-API-Referenz.
     *
     * @param KEYVALUELIST $Importparams Gibt die Liste der entsprechenden Importparameter an.
     *
     * @return DATASET Gibt Datensätze mit den Eigenschaften der gefundenen Dokumente zurück.
     */
    class SearchDocument extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function initD3()
        {
        }
        public function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * SendNote-Aktion
     *
     * Mit der **SendNote**-Aktion können Sie die Notizdatei zu einem Dokument um einen Eintrag ergänzen oder die Notizdatei
     * erstellen, falls sie noch nicht im d.3-Repository (Dokumentenverwaltung) existiert.
     *
     * @param TEXT $docid Gibt die Dokument-ID (**DocId**) des Dokuments an.
     * @param TEXT $message Gibt den Inhalt der Notiz an.
     */
    class SendNote extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        protected function initD3()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * SetUserVariablesInWorkPath-Aktion
     *
     * Mit der **SetUserVariablesInWorkPath**-Aktion können Sie die Workflowvariablen eines Dokuments im d.3-Repository
     * (Dokumentenverwaltung) aktualisieren.
     *
     * Weitere Informationen, auch zu den Importparametern (**Importparams**), finden Sie in der d.3-API-Referenz.
     *
     * @param TEXT $docid Gibt die Dokument-ID (**DocId**) des Dokuments an.
     * @param KEYVALUELIST $Importparams Gibt die Liste der entsprechenden Importparameter an.
     */
    class SetUserVariablesInWorkPath extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        public function exec(): \edoc\appserver\app\AbstractAction
        {
        }
        protected function initD3()
        {
        }
    }
    /**
     * TransferDocument-Aktion
     *
     * Mit der **TransferDocument**-Aktion überführen Sie ein Dokument in einen anderen Dokumentstatus.\
     * Mögliche Statuswechsel sind:
     * - **Bearbeitung** \<> **Bearbeitung**
     * - **Bearbeitung** \<> **Prüfung**
     * - **Bearbeitung** > **Freigabe**
     * - **Bearbeitung** \<> **Archiv**
     * - **Prüfung** \<> **Prüfung**
     * - **Prüfung** > **Freigabe**
     * - **Prüfung** > **Archiv**
     * - **Freigabe** > **Archiv**
     *
     * Weitere Informationen, auch zu den Importparametern (**Importparams**), finden Sie in der d.3-API-Referenz.
     *
     * @param TEXT $docid Gibt die Dokument-ID (**DocId**) des Dokuments an.
     * @param TEXT $source\_status Gibt den aktuellen Status des Dokuments an.
     * @param TEXT $destination\_status Gibt den neuer Status des Dokuments an.
     * @param KEYVALUELIST $Importparams Gibt die Liste der entsprechenden Importparameter an.
     */
    class TransferDocument extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        protected function initD3()
        {
        }
        public function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * UnlinkDocuments-Aktion
     *
     * Mit der **UnlinkDocuments**-Aktion können Sie die Verknüpfung von zwei Dokumenten lösen.
     *
     * @param TEXT $docid Gibt die Dokument-ID (**DocId**) des übergeordneten (**parent**) Dokuments an.
     * @param TEXT $childdocid Gibt die Dokument-ID (**DocId**) des untergeordneten (**child**) Dokuments an.
     */
    class UnlinkDocuments extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        protected function initD3()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * UpdateAttributes-Aktion
     *
     * Mit der **UpdateAttributes**-Aktion können Sie die erweiterten Eigenschaften eines Dokuments in einem d.3-Repository
     * (Dokumentenverwaltung) aktualisieren.
     *
     * Weitere Informationen, auch zu den Importparametern (**Importparams**), finden Sie in der d.3-API-Referenz.
     *
     * @param TEXT $docid Gibt die Dokument-ID (**DocId**) des Dokuments an.
     * @param KEYVALUELIST $Importparams Gibt die Liste der entsprechenden Importparameter an.
     */
    class UpdateAttributes extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        protected function initD3()
        {
        }
        public function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * ViewDocument-Aktion
     *
     * Die **ViewDocument**-Aktion lädt eine Datei, um sie anzuzeigen oder zu speichern.
     *
     * @param TEXT $docid Gibt die Dokument-ID (**DocId**) des Dokuments an.
     *
     * @return DATASET Gibt einen Datensatz mit dem Inhalt der Datei und den Eigenschaften der Datei zurück.
     */
    class ViewDocument extends \edoc\appserver\addons\d3\lib\AbstractD3Action
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function initD3()
        {
        }
        public function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\datasources {
    #[\edoc\appserver\stubs\attributes\PluginAPI]
    interface ConnectionHandler
    {
        /**
         * @template T
         * @return T
         */
        public function handle();
    }
    /**
     * Class DataSource
     *
     * @package edoc\appserver\datasources
     */
    #[\edoc\appserver\stubs\attributes\PluginAPI]
    abstract class DataSource
    {
        public const PROP_TYPE_TEXT = 'text';
        public const PROP_TYPE_PASSWORD = 'password';
        public const PROP_TYPE_NUMBER = 'number';
        public const PROP_TYPE_BOOLEAN = 'boolean';
        public const PROP_TYPE_SELECT = 'select';
        protected $config = [];
        protected $name = null;
        protected $params = [];
        protected $properties = [];
        abstract protected function init();
        protected static function catchPluginError(string $type, string $class, string $appName, string $pluginName, \Throwable $exception): void
        {
        }
        public static function catchPluginErrors(bool $enable = true): void
        {
        }
        public static function getPluginErrors(): array
        {
        }
        public static function list()
        {
        }
        public static function findNameById(string $id): string
        {
        }
        public function properties()
        {
        }
        public static function getRawInstance($dsName)
        {
        }
        /**
         * @param  $name
         * @return bool|mixed
         * @throws Exception
         */
        public static function getInstance($name, $instanceType = null)
        {
        }
        /**
         * @param array $params
         */
        public function setParams(array $params)
        {
        }
        /**
         * @return array
         */
        abstract public function details();
        public function isReady()
        {
        }
        protected function setReady($ready = true)
        {
        }
        public function errorMessage()
        {
        }
        protected function addProperty($name, $type, $defaultValue = null, array $options = [])
        {
        }
        protected function setErrorMessage($message)
        {
        }
        public function docs(): array
        {
        }
    }
    #[\edoc\appserver\stubs\attributes\PluginAPI]
    abstract class RestAPI extends \edoc\appserver\datasources\DataSource implements \edoc\appserver\datasources\ConnectionHandler
    {
        protected $srvHeaders = [];
        public const OPT_FOLLOWLOCATION = CURLOPT_FOLLOWLOCATION;
        public function addRequesOption($name, $value)
        {
        }
        protected function initAPI($host)
        {
        }
        protected function processResponse(string $url, int $status, string $body, array $header): string
        {
        }
        public function requestGet($url, $headerFields = [], &$responseHeader = null)
        {
        }
        public function requestPost($url, $postData, $headerFields = [], &$responseHeader = null)
        {
        }
        public function requestPatch($url, $postData, $headerFields = [], &$responseHeader = null)
        {
        }
        public function requestDelete($url, $postData, $headerFields = [], &$responseHeader = null)
        {
        }
        public function requestPut($url, $postData, $headerFields = [], &$responseHeader = null)
        {
        }
        public function handle(): ?\CurlHandle
        {
        }
    }
}
namespace edoc\appserver\addons\d3\datasources {
    /**
     * d3-Datenquelle
     *
     * Die **d3**-Datenquelle ermöglicht die Interaktion mit einem d.3-DMS.
     * Mit der Datenquelle können App-Entwickler auf das d.3-Repository (Dokumentenverwaltung) zugreifen, um Daten abzurufen, einzufügen oder zu
     * aktualisieren.
     *
     * @param TEXT $d3.host Gibt die  Adresse des d.3-Servers von d.velop an.
     * @param TEXT $d3.user Gibt den Benutzer an, der für die Verbindung verwendet wird.
     * @param PASSWORD $d3.password Gibt das Passwort des Benutzers an.
     * @param TEXT $d3.archive Gibt das zu verwendende d.3-Repository (Archiv) an.
     * @param BOOLEAN $d3.utf8 Gibt an, ob die Daten im UTF-8-Encoding übertragen werden. Standard: UTF-8 (Wert: **1**)
     * @param TEXT $d3.language Gibt die Sprache für die Verbindung an, um z.B. Meldungen korrekt zurückzugeben. Mit dem
     * Wert **auto** wird automatisch die vom Benutzer verwendete Sprache verwendet.
     */
    class D3 extends \edoc\appserver\datasources\RestAPI
    {
        protected function init()
        {
        }
        public function details()
        {
        }
        public function getHeaders()
        {
        }
        public function validateUserPassword($user, $password, $package = 'Basic')
        {
        }
        public function getAttributes($docid)
        {
        }
        public function getDocumentList($parameter = [])
        {
        }
        public function searchDocument($parameter = [])
        {
        }
        public function downloadDocument($docid, $parameter = [])
        {
        }
        public function getStructureDocument($docid, $parameter = [])
        {
        }
        public function showDocument($docid)
        {
        }
        public function importDocument($docType, $filename, $extension, $content, $importParams = [])
        {
        }
        public function importNewVersionDocument($docId, $docType, $filename, $extension, $content, $importParams = [])
        {
        }
        public function updateAttributes($docId, $importParams): void
        {
        }
        public function deleteDocument($docId): void
        {
        }
        public function transferDocument($docId, $params): void
        {
        }
        public function releaseDocument($docId, $params = []): void
        {
        }
        public function receiveNote($docId)
        {
        }
        public function getFolderSchemeExt()
        {
        }
        public function sendNote($docId, $note)
        {
        }
        public function getDocumentTypeTitleUser($parameter = [])
        {
        }
        public function getValidValuesForAttribute($parameter = [])
        {
        }
        public function putDocumentIntoWorkPath($docId, $parameter = [])
        {
        }
        public function deleteDocumentFromWorkPath($docId)
        {
        }
        public function proceedToNextStepWorkPath($docId, $parameter = [])
        {
        }
        public function getUserVariablesInWorkPath($docId, $parameter = [])
        {
        }
        public function setUserVariablesInWorkPath($docId, $parameter = [])
        {
        }
        public function linkDocuments($docId, $childDocId)
        {
        }
        public function unlinkDocuments($docId, $childDocId)
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\script {
    /**
     * ExecJavaScript-Aktion
     *
     * Die **ExecJavaScript**-Aktion führt den angegebenen JavaScript-Code im Client aus.
     *
     *  <div class="panel info">
     *  Die Änderungen an Komponenten werden ggf. nicht durch andere Aktionen übernommen. Sie müssen bei Bedarf das
     *  **Change/Keyup**-Event einer Komponente triggern.
     *  </div>
     *
     * Sie können Platzhalter in dem JavaScript-Code verwenden, die zur Laufzeit durch einen statischen Wert oder die Rückgabe einer
     * Aktion ersetzt werden.
     *
     * **Syntax**: `:<param-name>`\
     * **Beispiel**: `var id = :value`
     *
     *
     * **Optionen für Parameter**
     *
     * Mit zusätzlichen Optionen zu den Parametern können Sie das Verhalten der Parameterersetzung beeinflussen.
     * Die Optionen können Sie mit eckigen Klammern nach dem Parameternamen einfügen. Beispiel: `:<paramname>[<optionen>]`
     * Wenn Sie mehrere Optionen verwenden möchten, können Sie diese mit einem Komma trennen.
     *
     * Standardmäßig werden alle Parameter bei Bedarf automatisch mit umschließenden Anführungszeichen ersetzt. Zahlen und
     * **null** ohne Anführungszeichen eingefügt.
     * Mit den Optionen **QUOTES** und **NO_QUOTES** können Sie das Hinzufügen von Anführungszeichen um die Parameterwerte
     * steuern.
     * - **QUOTES** Der Parameterwert, außer **null**, wird mit Anführungszeichen eingefügt. *Bitte Sicherheitshinweis
     *  beachten!**
     * - **NO_QUOTES** Der Parameterwert wird ohne umschließende Anführungszeichen eingefügt. **Bitte Sicherheitshinweis
     * beachten!**
     *
     * Folgende Optionen stehen außerdem zur Verfügung:
     * - **DEFAULT** Gibt einen Wert an, der verwendet wird, wenn der Parameterwert **null** ist.
     * - **ISEMPTY** Gibt einen Wert an, der verwendet wird, wenn der Parameterwert leer ist.
     * - **ISSTRING** Gibt einen Wert an, der verwendet wird, wenn der Parameterwert eine Zeichenfolge (String) ist.
     * - **ISNUMERIC** Gibt einen Wert an, der verwendet wird, wenn der Parameterwert eine Zahl ist.
     *
     * Beispiel: `:param1[QUOTES,ISEMPTY:Default value]`
     *
     * Sie können die Platzhalter in der **ExecJavaScript**-Aktion durch **Dataset**-Aktionen ersetzen, z.B. **DatasetFromCSV** und **DatasetFromJSON**. Die Werte werden im JSON-Format zurückgegeben.
     *
     * <div class="panel warning">
     * Das Verwenden von **NO_QUOTES** und **QUOTES** kann zu potenziellen JavaScript-Sicherheitslücken führen (u.a. Angriffe durch Cross-Site-Scripting (XSS).
     * Wenn Sie die Option dennoch nutzen, achten Sie unbedingt darauf, dass die Parameterwerte durch die App validiert und ggf. maskiert werden, um mögliche Sicherheitslücken in Ihrer App zu vermeiden.
     * </div>
     *
     * @param EDITOR $code Gibt den auszuführenden JavaScript-Code an.
     */
    class ExecJavaScript extends \edoc\appserver\app\AbstractAction
    {
        public const ACTIONKEY = 'evalJS';
        public static function addJSCallbacks()
        {
        }
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\addons\dvelop\lib {
    abstract class AbstractDvelopJSAction extends \edoc\appserver\app\actions\lib\script\ExecJavaScript
    {
        protected function setJSCode(string $code): void
        {
        }
        protected function param($name, $translate = false)
        {
        }
        protected function init(): void
        {
        }
    }
}
namespace edoc\appserver\addons\dvelop\actions {
    /**
     * CloseResource-Aktion
     *
     * Die **CloseResource**-Aktion ermöglicht das Schließen einer Ressource im Kontext von d.3one (d.velop documents), um automatisch zur vorherigen Ansicht zu wechseln.
     *
     */
    class CloseResource extends \edoc\appserver\addons\dvelop\lib\AbstractDvelopJSAction
    {
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * Navigate-Aktion
     *
     * Die **Navigate**-Aktion ermöglicht das Öffnen von URLs im Kontext von d.3one (d.velop documents).
     *
     * @param TEXT $target Gibt die zu öffnende URL an.
     */
    class Navigate extends \edoc\appserver\addons\dvelop\lib\AbstractDvelopJSAction
    {
        protected function init(): void
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\addons\dvelopdms\lib {
    abstract class AbstractDvelopDMSAction extends \edoc\appserver\app\AbstractAction
    {
        abstract protected function initDMS();
        final public function init()
        {
        }
        public function changedDatasource(?\edoc\appserver\app\AppEntity $entity, array $currentParameter): array
        {
        }
        public function getDatasource(): ?\edoc\appserver\addons\dvelopdms\datasources\Dvelopdms
        {
        }
        protected function getCategories(): array
        {
        }
    }
}
namespace edoc\appserver\addons\dvelopdms\actions {
    /**
     * CreateDossier-Aktion
     *
     * Die **CreateDossier**-Aktion erstellt eine neue Akte mit den angegebenen
     * Eigenschaften.
     *
     * @param TEXT $Category Gibt die ID der Kategorie an, in der die Akte erstellt wird.
     * @param KEYVALUELIST $Properties Gibt die Liste aller festzulegenden Eigenschaften und deren Werte an.
     * - **Key**: Gibt die ID der Eigenschaft an.
     * - **Value**: Gibt den festzulegenden Wert der Eigenschaft an.
     *
     * @return SINGLEVALUE Gibt die ID des neuen Dokuments zurück.
     */
    class CreateDossier extends \edoc\appserver\addons\dvelopdms\lib\AbstractDvelopDMSAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        public function changedDatasource(?\edoc\appserver\app\AppEntity $entity, array $currentParameter): array
        {
        }
        protected function initDMS()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * DeleteDocument-Aktion
     *
     * Mit der **DeleteDocument**-Aktion können Sie das angegebene Dokument im d.velop-DMS-System löschen.
     *
     * @param TEXT $Doc-Id Gibt die ID des zu löschenden Dokuments an.
     * @param TEXT $Message Gibt den Kommentar zum Löschen an.
     *
     */
    class DeleteDocument extends \edoc\appserver\addons\dvelopdms\lib\AbstractDvelopDMSAction
    {
        protected function initDMS()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * DownloadDocument-Aktion
     *
     * Die **DownloadDocument**-Aktion lädt die Datei der aktuellen Version des angegebenen Dokuments.
     *
     * @param TEXT $Doc-Id Gibt die ID des anzuzeigenden Dokuments an.
     * @param SELECT $Rendition Gibt an, ob das abhängige PDF-Dokument anstelle des Originaldokuments zurückgegeben wird.
     *
     * @return DATASET Gibt einen Datensatz mit den Spalten **content-type** und **value** zurück.
     */
    class DownloadDocument extends \edoc\appserver\addons\dvelopdms\lib\AbstractDvelopDMSAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function initDMS()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetDefaultSourceProperties-Aktion
     *
     * Die **GetDefaultSourceProperties**-Aktion gibt die Eigenschaften des Repositorys zurück, das Sie in der Datenquelle
     * angegeben haben.
     *
     * @return DATASET Gibt die Eigenschaften des Repositorys zurück.
     */
    class GetDefaultSourceProperties extends \edoc\appserver\addons\dvelopdms\lib\AbstractDvelopDMSAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected $dataName = 'properties';
        protected function mapData($entry)
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
        protected function initDMS()
        {
        }
    }
    /**
     * GetDefaultSourceCategories-Aktion
     *
     * Die **GetDefaultSourceCategories**-Aktion gibt die Kategorien des Repositorys zurück, das Sie in der Datenquelle
     * angegeben haben.
     *
     * @return DATASET Gibt die Kategorien des Repositorys zurück.
     */
    class GetDefaultSourceCategories extends \edoc\appserver\addons\dvelopdms\actions\GetDefaultSourceProperties
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected $dataName = 'categories';
        protected function mapData($entry)
        {
        }
    }
    /**
     * GetDocumentDetails-Aktion
     *
     * Die **GetDocumentDetails**-Aktion gibt die Details zum angegebenen Dokument zurück.
     *
     * @param TEXT $Doc-Id Gibt die ID des entsprechenden Dokuments an.
     * @param SELECT $MapPropertyName Legt fest, ob der Name einer Eigenschaft mit dem Anzeigenamen oder der ID angegeben
     * wird.
     * - **Yes**: Der Anzeigename wird angegeben.
     * - **No**: Die ID wird angegeben.
     *
     * @return DATASET Gibt einen Datensatz mit allen Eigenschaften zum Dokument zurück.
     */
    class GetDocumentDetails extends \edoc\appserver\addons\dvelopdms\lib\AbstractDvelopDMSAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function initDMS()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetMultiValues-Aktion
     *
     * Die **GetMultiValues**-Aktion gibt die Mehrfachwerte zum angegebenen Dokument und zur Eigenschaft zurück.
     *
     * @param TEXT $Doc-Id Gibt die ID des entsprechenden Dokuments an.
     * @param TEXT $PropertyId Gibt die ID der entsprechenden Eigenschaft an.
     *
     * @return DATASET Gibt einen Datensatz mit allen Mehrfachwerten zum Dokument und zur Eigenschaft zurück.
     */
    class GetMultiValues extends \edoc\appserver\addons\dvelopdms\lib\AbstractDvelopDMSAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function initDMS()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetRepositories-Aktion
     *
     * Die **GetRepositories**-Aktion gibt alle verfügbaren Repositorys und die dazugehörigen Eigenschaften zurück.
     *
     * @return DATASET Gibt einen Datensatz mit den folgenden Werten zurück:
     * - **id**
     * - **name**
     * - **version**
     * - **fulltextsearch**
     * - **available**
     * - **default**
     * - **serverid**
     */
    class GetRepositories extends \edoc\appserver\addons\dvelopdms\lib\AbstractDvelopDMSAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function initDMS()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * LinkDocuments-Aktion
     *
     * Die **LinkDocuments**-Aktion verknüpft ein Dokument oder mehrere Dokumente mit dem angegebenen Dokument.
     *
     * @param TEXT $Doc-Id Gibt die ID des übergeordneten (**parent**) Dokuments an.
     * @param VALUELIST $Children Gibt eine ID oder mehrere IDs für die untergeordneten (**child**) Dokumente an.
     *
     * @return DATASET Gibt einen Datensatz mit möglichen vorhandenen Meldungen zu den angegebenen untergeordneten Dokumenten zurück.
     */
    class LinkDocuments extends \edoc\appserver\addons\dvelopdms\lib\AbstractDvelopDMSAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function initDMS()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * Search-Aktion
     *
     * Die **Search**-Aktion sucht nach Dokumenten und gibt einen Datensatz mit allen Eigenschaften der gefundenen Dokumente
     * zurück.
     *
     * @param VALUELIST $CategoryIds Gibt eine Liste mit allen IDs der Kategorien an, in denen gesucht werden soll.
     * @param KEYVALUELIST $Properties Gibt eine Liste mit allen Eigenschaften an, nach denen gesucht wird.
     * - **Key**: Ist die ID der entsprechenden Eigenschaft.
     * - **Value**: Ist der Wert, mit dem die Eigenschaft des Dokuments übereinstimmen muss.
     * @param TEXT $Page Gibt die gewünschte Seite des gesamten Suchergebnisses an.
     * @param TEXT $PageSize Gibt die Anzahl der Dokumente pro Seite im Suchergebnis an.
     * @param SELECT $MapPropertyName Legt fest, ob der Name einer Eigenschaft mit dem Anzeigenamen oder der ID angegeben
     * wird.
     * - **Yes**: Der Anzeigename wird angegeben.
     * - **No**: Die ID wird angegeben.
     *
     * @return DATASET Gibt einen Datensatz mit allen Eigenschaften der gefundenen Dokumente zurück.
     */
    class Search extends \edoc\appserver\addons\dvelopdms\lib\AbstractDvelopDMSAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function initDMS()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * UnlinkDocuments-Aktion
     *
     * Die **UnlinkDocuments**-Aktion hebt die Verknüpfung von zwei Dokumenten auf.
     *
     * @param TEXT $Doc-Id Gibt die ID des übergeordneten (**parent**) Dokuments an.
     * @param VALUELIST $Children Gibt die ID des untergeordneten (**child**) Dokuments an.
     */
    class UnlinkDocuments extends \edoc\appserver\addons\dvelopdms\lib\AbstractDvelopDMSAction
    {
        protected function initDMS()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * UploadDocument-Aktion
     *
     * Die **UploadDocument**-Aktion erstellt ein neues Dokument mit der angegebenen Datei und den angegebenen
     * Eigenschaften.
     *
     * @param TEXT $Category Gibt die ID der Kategorie an, in der das Dokument erstellt wird.
     * @param TEXT $File Gibt den Inhalt der Datei an.
     * @param TEXT $Filename Gibt den Namen der Datei an.
     * @param KEYVALUELIST $Properties Gibt die Liste aller festzulegenden Eigenschaften und deren Werte an.
     * - **Key**: Gibt die ID der Eigenschaft an.
     * - **Value**: Gibt den festzulegenden Wert der Eigenschaft an.
     *
     * @return SINGLEVALUE Gibt die ID des neuen Dokuments zurück.
     */
    class UploadDocument extends \edoc\appserver\addons\dvelopdms\lib\AbstractDvelopDMSAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        public function changedDatasource(?\edoc\appserver\app\AppEntity $entity, array $currentParameter): array
        {
        }
        protected function initDMS()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * UpdateDocument-Aktion
     *
     * Die **UpdateDocument**-Aktion erstellt eine neue Version für das Dokument mit der angegebenen Datei und den angegebenen
     * Eigenschaften.
     *
     * @param TEXT $DocId Gibt die ID des Dokuments an, das aktualisiert wird.
     * @param TEXT $AlterationText Gibt den Text der Aktualisierung an.
     *
     */
    class UpdateDocument extends \edoc\appserver\addons\dvelopdms\actions\UploadDocument
    {
        protected function initDMS()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * UpdateProperties-Aktion
     *
     * Die **UpdateProperties**-Aktion aktualisiert die angegebenen Eigenschaften des angegebenen Dokuments.
     *
     * @param TEXT $Doc-Id Gibt die ID des entsprechenden Dokuments an.
     * @param KEYVALUELIST $Properties Gibt eine Liste mit allen Eigenschaften an, die aktualisiert werden.
     * - **Key**: Gibt die ID der entsprechenden Eigenschaft an.
     * - **Value**: Gibt den Wert an, mit dem die Eigenschaft des Dokuments aktualisiert wird.
     * @param TEXT $Message Gibt einen Kommentar zur Aktualisierung der Eigenschaften an.
     */
    class UpdateProperties extends \edoc\appserver\addons\dvelopdms\lib\AbstractDvelopDMSAction
    {
        protected function initDMS()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\addons\dvelopdms\datasources {
    /**
     * Dvelopdms-Datenquelle
     *
     * Die **Dvelopdms**-Datenquelle ermöglicht die Interaktion mit dem d.velop-DMS-System (Dokumentenverwaltung, Repository).
     * Mit der Datenquelle können App-Entwickler auf das d.velop-DMS zugreifen, um Daten abzurufen,
     * einzufügen oder zu aktualisieren.
     *
     * @param TEXT $Server Gibt die Basisadresse des Servers mit d.velop documents.
     * @param PASSWORD $Api-Key Gibt den API-Key zur Authentifizierung bei der Dokumentenverwaltung von d.velop documents an.
     * @param TEXT $Repo-Id Gibt die ID der zu verwendenden Dokumentenverwaltung (Repository) an.
     * @param TEXT $Language Gibt die Sprache für die Verbindung an, um z.B. Meldungen in der korrekten Sprache korrekt zurückzugeben. Mit dem
     * Wert **auto** wird automatisch die vom Benutzer verwendete Sprache verwendet.
     */
    class Dvelopdms extends \edoc\appserver\datasources\RestAPI
    {
        protected function getRedisKey(string $type): string
        {
        }
        protected function setAuthSessionId(string $sessionId, string $exp): void
        {
        }
        protected function getAuthSessionId(): string
        {
        }
        protected function setRepoLinks(string $id, array $links): void
        {
        }
        protected function getRepoId(): string
        {
        }
        protected function setAllowedResponseStatus(array $status): void
        {
        }
        protected function processResponse(string $url, int $status, string $body, array $header): string
        {
        }
        protected function init(): void
        {
        }
        public function details(): array
        {
        }
        protected function login(): void
        {
        }
        protected function getDefaultRequestHeader(): array
        {
        }
        public function getRepositories(): array
        {
        }
        public function getDefaultSource(): array
        {
        }
        protected function mapSourceProperty(string $key): string
        {
        }
        protected function convertPropertyValue(string|int $value, string $key): string|int
        {
        }
        protected function validateSourcePropertyType(string $type, array $value): bool
        {
        }
        protected function prepareSourceProperties(array $properties): array
        {
        }
        protected function mapAndConvertProperties(array $item, bool $mapPropNames = true): array
        {
        }
        public function search(array $categories, array $properties, int $page = 1, int $pageSize = 200, bool $mapPropNames = true): array
        {
        }
        protected function loadDocumentDetails(string $docId): array
        {
        }
        public function documentDetails(string $docId, bool $mapPropNames = true, ?array &$links = null): array
        {
        }
        public function getMultiValues(string $docId, string $propertyId): array
        {
        }
        public function upload(string $catId, string $fileName, string $fileContent, array $properties, ?string $docId = null, ?string $alterationText = null): string|bool
        {
        }
        public function updateProperties(string $docId, array $properties, ?string $message, ?string $catId = null): string
        {
        }
        public function deleteDocument(string $docId, string $message): bool
        {
        }
        public function downloadDocument(string $docId, bool $rendition = false): array|bool
        {
        }
        public function unlinkDocuments(string $docId, string $childId): void
        {
        }
        public function linkDocuments(string $docId, array $children): array
        {
        }
        public function createDossier(string $catId, array $properties): string|bool
        {
        }
    }
}
namespace edoc\appserver\addons\rest\actions {
    /**
     * JsonResponse-Aktion
     *
     * Die **rest\JsonResponse**-Aktion wandelt die Rückgabe der Aktion **rest\Request** in einen Datensatz um.
     *
     * @param ACTION $Request_Action Gibt die Aktion an, deren Rückgabe in einen Datensatz umgewandelt werden soll.
     *
     * @return DATASET Gibt einen Datensatz mit den Daten des JSON aus der Antwort zurück.
     */
    class JsonResponse extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init(): void
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\addons\rest\lib {
    /**
     * @param SELECT $datasource Gibt den Namen der Datenquelle an, die für die Anfrage verwendet werden soll.
     */
    abstract class AbstractRestAPIAction extends \edoc\appserver\app\AbstractAction
    {
        abstract protected function initRest(): void;
        protected function getDatasourceList(): array
        {
        }
        protected function getDatasource(): ?\edoc\appserver\addons\rest\datasources\RestAPI
        {
        }
        final protected function init()
        {
        }
    }
}
namespace edoc\appserver\addons\rest\actions {
    /**
     * Request-Aktion
     *
     * Die **rest\Request**-Aktion ermöglicht das Zugreifen auf die REST-API-Funktionen.
     *
     * @param TEXT $Path Gibt den Pfad der REST-API an.
     * @param SELECT $Method Gibt die HTTP-Methode an, die für die Anfrage verwendet werden soll.
     * @param KEYVALUELIST $Headers Gibt die Header für die Anfrage an.
     * @param TEXT $Timeout Gibt die Zeitdauer in Millisekunden an, die auf die Antwort gewartet werden soll.
     * @param EDITOR $Body Gibt den Inhalt des Request-Body (Anforderungstext) an.
     * @param KEYVALUELIST $Body_Variables Gibt die Variablen an, die im Request-Body ersetzt werden sollen.
     * @param TEXT $Expected_Status Gibt den erwarteten HTTP-Statuscode an. Mehrere gültige Status müssen mit einem Komma getrennt werden.
     *
     * @return DATASET Gibt einen Datensatz mit dem Inhalt der Antwort zurück. Definierte Spalten im Datensatz: `content-type`, `value`, `status`.
     */
    class Request extends \edoc\appserver\addons\rest\lib\AbstractRestAPIAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function initRest(): void
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\addons\rest\datasources {
    /**
     * RestAPI-Datenquelle
     *
     * Die **RestAPI**-Datenquelle ermöglicht das Zugreifen auf REST-API-Funktionen.
     * Mit der Datenquelle werden die grundlegenden Parameter für den Zugriff auf die API festgelegt.
     *
     * @param TEXT $Host Gibt die Basis-URL der REST-API an.
     * @param SELECT $Auth_Type Gibt den Authentifizierungstyp an. Mögliche Werte sind: `noauth`, `basic` und `apikey`.
     * @param TEXT $Username Gibt den Benutzernamen für die Authentifizierung an.\nWird nur für **Auth Type** in Verbindung mit `basic` verwendet.
     * @param PASSWORD $Password Gibt das Passwort für die Authentifizierung an.\nWird nur für **Auth Type** in Verbindung mit `basic` verwendet.
     * @param SELECT $API-Key_Location Gibt an, wo der API-Key platziert werden soll. Mögliche Werte sind: `header` und `query`.\nWird nur für **Auth Type** in Verbindung mit `apikey` verwendet.
     * @param TEXT $API-Key_Name Gibt den Namen des API-Keys an.\nWird nur für **Auth Type** in Verbindung mit `apikey` verwendet.
     * @param PASSWORD $API-Key_Secret Gibt den geheimen Schlüssel des API-Keys an.\nWird nur für **Auth Type** in Verbindung mit `apikey` verwendet.
     */
    class RestAPI extends \edoc\appserver\datasources\DataSource implements \edoc\appserver\datasources\ConnectionHandler
    {
        protected function init(): void
        {
        }
        public function addConnectionErrorStatusCode(int $statusCode): void
        {
        }
        public function getClient(int $timeout = 5000): \Psr\Http\Client\ClientInterface
        {
        }
        public function request(string $method, string $path, string $body, array $headers, int $timeout = 5000): \Psr\Http\Message\ResponseInterface
        {
        }
        public function details(): array
        {
        }
        public function handle(): \Psr\Http\Client\ClientInterface
        {
        }
    }
}
namespace edoc\appserver\addons\rest\lib\exceptions {
    class RestConnectException extends \Exception
    {
    }
}
namespace edoc\appserver\addons\smtp\actions {
    /**
     * smtp\PrepareAttachment-Aktion
     *
     * Mit der **PrepareAttachment**-Aktion können Sie die Struktur für einen Dateianhang aus einzelnen Parametern erzeugen.
     *
     * @param TEXT $FileName Gibt den angegebenen Namen der Datei an.
     * @param TEXT $FileContent Gibt den angegebenen Inhalt der Datei an.
     * @param TEXT $FileMIME Optional: Gibt den angegebenen MIME-Type der Datei an.
     *
     * @return DATASET Gibt die Struktur für einen Dateianhang zurück.
     *
     */
    class PrepareAttachment extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * Smtp\Send-Aktion
     *
     * Mit der **Send**-Aktion können Sie eine einfache E-Mail durch eine SMTP-Datenquelle versenden.
     *
     * Sie können bei E-Mail-Adressen nur die Adresse selbst `test@example.com` oder die Adresse mit Namen
     * `Vorname Nachname <test@example.com>` angeben.
     *
     * <div class="panel note">
     * **Wichtig**\
     * Sie können für die Felder **To**, **Cc** und **Bcc** nur eine E-Mail-Adresse pro Eingabefeld verwenden.
     * </div>
     *
     * @param DATASOURCE $Datasource Gibt die Datenquelle an, durch die die E-Mail verschickt werden soll.
     * @param TEXT $From Gibt die E-Mail-Adresse des Absenders der E-Mail an.
     * @param VALUELIST $To Gibt die E-Mail-Adressen aller Empfänger an.
     * @param VALUELIST $Cc Gibt die E-Mail-Adressen aller zusätzlichen Empfänger an.
     * @param VALUELIST $Bcc Gibt die E-Mail-Adressen aller versteckten Empfänger an.
     * @param TEXT $Subject Gibt den Text der Betreffzeile der E-Mail an.
     * @param TEXT $Body Gibt den Inhalt der E-Mail an. Wenn HTML-Tags erkannt werden, wird die E-Mail automatisch als
     * HTML-E-Mail verschickt.
     * @param ACTIONLIST $Attachments Gibt die angehängten Dateien an. Sie können einen einzelnen Anhang mit der Aktion
     * **smtp\PrepareAttachment** erzeugen.
     * @param VALUELIST $ReplyTo Gibt die E-Mail-Adressen in einer Antwort-E-Mail in der An-Zeile an.
     *
     */
    class Send extends \edoc\appserver\app\AbstractAction
    {
        protected function init()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\addons\smtp\datasources {
    /**
     * SMTP-Datenquelle
     *
     * Mit der SMTP-Datenquelle können Sie eine SMTP-Verbindung konfigurieren, um z.B. mit der Aktion **smtp\Send** eine
     * E-Mail zu versenden.
     *
     * @param TEXT $smtp.host Gibt die Adresse des SMTP-Servers an.
     * @param TEXT $smtp.user Gibt den Benutzer zur Authentifizierung am SMTP-Server an.
     * @param PASSWORD $smtp.password Gibt das Passwort für den angegebenen Benutzer an.
     * @param NUMBER $smtp.port Gibt den Port zum Herstellen einer Verbindung mit dem SMTP-Server an.
     * @param TEXT $smtp.verify_peer Dient als Sicherheitsoption. Wenn der Wert nicht **1** ist, wird ein möglicherweise vorhandenes TLS-Zertifikat nicht validiert.
     */
    class Smtp extends \edoc\appserver\datasources\DataSource implements \edoc\appserver\datasources\ConnectionHandler
    {
        protected function init()
        {
        }
        /**
         * @inheritDoc
         */
        public function details()
        {
        }
        public function send(string $from, array $to, array $cc, array $bcc, string $subject, string $body, array $attachments, array $replyTo)
        {
        }
        public function handle(): ?\PHPMailer\PHPMailer\PHPMailer
        {
        }
    }
}
namespace edoc\appserver\app {
    /**
     * Class Layout
     *
     * @package edoc\appserver\app
     */
    class Layout
    {
        /**
         * @param App $app
         * @param string $layout
         */
        public function __construct(private \edoc\appserver\App $app, private string $layout)
        {
        }
        public function setPrintMode(?string $mode): void
        {
        }
        public function addHeaderContent(string $content): void
        {
        }
        public function addContent(string $content, bool $overrideLayout = false): void
        {
        }
        public function addHeadScriptTags(array $scriptTags): void
        {
        }
        public function appendScripts(array $scriptTags): void
        {
        }
        public function appendStylesheets(array $styles): void
        {
        }
        public static function appendHeadContent(string $content): void
        {
        }
        public static function prependHeadContent(string $content): void
        {
        }
        public function html(): string
        {
        }
    }
}
namespace edoc\appserver\admin {
    class AdminLayout extends \edoc\appserver\app\Layout
    {
        public function __construct(private string $layout)
        {
        }
    }
    abstract class AdminView
    {
        protected static string $templateDir = __DIR__ . '/templates/';
        abstract public function title(): string;
        abstract public function description(): string;
        public static function init(
            \FastRoute\RouteCollector $routeCollector,
            #[\JetBrains\PhpStorm\ArrayShape(['access' => 'string[]', 'views' => 'array<string, string[]'])]
            array $roles = []
        ): void
        {
        }
        protected static function layout(string $content, bool $addContainer = true): string
        {
        }
        /**
         * @throws KeycloakAuthenticationRequired
         */
        protected static function initAuthentication(array $roles, ?\edoc\appserver\services\Keycloak $kc = null): \edoc\appserver\app\Layout
        {
        }
        public static function backToAdminOverView(): string
        {
        }
        public static function view(string $template = '', array $params = []): false|string
        {
        }
        public static function renderIndex(array $params): string
        {
        }
        protected function setOrder(int $index): void
        {
        }
        protected function setIndex(string $path, callable $callback, array $defaults = []): void
        {
        }
        protected function addRoute(string $path, callable $callback, string $method = 'GET', array $defaults = []): void
        {
        }
        protected function link(string $path, array $routeParameter = []): string
        {
        }
        public function indexPath(): string
        {
        }
        protected function hasRole(string $role): bool
        {
        }
    }
}
namespace edoc\appserver\admin\views {
    class Apps extends \edoc\appserver\admin\AdminView
    {
        public function __construct()
        {
        }
        public function title(): string
        {
        }
        public function description(): string
        {
        }
        public function maintenanceEnable(array $params): string
        {
        }
        public function maintenanceDisable(array $params): string
        {
        }
        public function brokenFlagRemove(array $params): string
        {
        }
        public function index(array $params): string
        {
        }
    }
    class ClearSession extends \edoc\appserver\admin\AdminView
    {
        public function __construct()
        {
        }
        public function title(): string
        {
        }
        public function description(): string
        {
        }
    }
    class Configuration extends \edoc\appserver\admin\AdminView
    {
        public function __construct()
        {
        }
        public function title(): string
        {
        }
        public function description(): string
        {
        }
    }
    class ErrorLog extends \edoc\appserver\admin\AdminView
    {
        public function __construct()
        {
        }
        public function title(): string
        {
        }
        public function description(): string
        {
        }
    }
    class FPMStatus extends \edoc\appserver\admin\AdminView
    {
        public function __construct()
        {
        }
        public function title(): string
        {
        }
        public function description(): string
        {
        }
    }
    class Info extends \edoc\appserver\admin\AdminView
    {
        public function __construct()
        {
        }
        public function title(): string
        {
        }
        public function description(): string
        {
        }
    }
    class Services extends \edoc\appserver\admin\AdminView
    {
        public function __construct()
        {
        }
        public function title(): string
        {
        }
        public function description(): string
        {
        }
        public function index(): string
        {
        }
        public function startSync(): string
        {
        }
    }
    class Session extends \edoc\appserver\admin\AdminView
    {
        public function __construct()
        {
        }
        public function home(): string
        {
        }
        public function clear(): string
        {
        }
        public function destroy(): string
        {
        }
        protected function flatValues($values, &$array = [], $path = ''): void
        {
        }
        public function title(): string
        {
        }
        public function description(): string
        {
        }
    }
}
namespace edoc\appserver\app {
    #[\edoc\appserver\stubs\attributes\PluginAPI]
    class AppEntity
    {
    }
    #[\edoc\appserver\stubs\attributes\PluginAPI]
    class EntityWithRoutes extends \edoc\appserver\app\AppEntity
    {
        protected function setRoutes($routes): void
        {
        }
        public function routes(): array
        {
        }
    }
}
namespace edoc\appserver\utils {
    #[\edoc\appserver\stubs\attributes\PluginAPIIgnore]
    trait BitwiseFlags
    {
        private $flags = 0x0;
        public static function value()
        {
        }
        public function addFlag($flag)
        {
        }
        public function removeFlag($flag)
        {
        }
        public function isFlagSet($flag)
        {
        }
    }
}
namespace edoc\appserver\app {
    /**
     * AbstractComponent-Klasse
     *
     * @param TEXT $Value Gibt den aktuellen Wert der Komponente an.
     */
    #[\edoc\appserver\stubs\attributes\PluginAPI]
    abstract class AbstractComponent extends \edoc\appserver\app\EntityWithRoutes
    {
        use \edoc\appserver\utils\BitwiseFlags;
        public const FLAG_IS_EMBEDDED = 1;
        public const FLAG_IS_BASE = 2;
        public const MODE_DEFAULT = 0;
        public const MODE_PREVIEW = 1;
        public const MODE_EMBEDDED_PREVIEW = 2;
        public const PROP_TYPE_INPUT = 'input';
        public const PROP_TYPE_SELECT = 'select';
        public const PROP_TYPE_NUMBER = 'number';
        public const PROP_TYPE_BOOL = 'boolean';
        /**
         * @var array
         */
        public $config = [];
        // TODO: make it private!
        /**
         * @var array
         */
        public $properties = [];
        /**
         * @var array holds all embedded components
         */
        protected $components = [];
        /**
         * @var Logger
         */
        public $logger;
        protected $autoRegisterComponent = true;
        protected $options = [];
        public function getOptions(): array
        {
        }
        public function docs(): array
        {
        }
        public static function fixName($name)
        {
        }
        /**
         * AbstractComponent constructor.
         *
         * @param  array                  $config
         * @param  AbstractComponent|null $parent
         * @param  $mode
         * @throws \Exception
         */
        final public function __construct(array $config, \edoc\appserver\app\AbstractComponent &$parent = null, $mode = self::MODE_DEFAULT, ?\Monolog\Logger $logger = null, $initValue = true)
        {
        }
        /**
         * @param $mode
         */
        public function setRenderMode($mode)
        {
        }
        public function basicId()
        {
        }
        abstract protected function init();
        /**
         * @param string         $event
         * @param AbstractAction $action
         */
        public function registerEvent(string $event, \edoc\appserver\app\AbstractAction $action)
        {
        }
        public function events($withLoad = false, $includeChildren = false)
        {
        }
        public function isEventDisabled(string $event, bool $inherit = true): bool
        {
        }
        public function disableEvent(string $event): void
        {
        }
        public function enableEvent(string $event): void
        {
        }
        public static function setCurrentValue($id, $value)
        {
        }
        /**
         * returns events from all loaded components
         *
         * @return array
         */
        public static function registeredEvents()
        {
        }
        public static function registeredEventsById($id)
        {
        }
        /**
         * clears all registered events!
         */
        public static function clearRegisteredEvents($keepComponentId = null)
        {
        }
        public static function enableOnload($enable = true)
        {
        }
        public function __debugInfo()
        {
        }
        /**
         * @return string|null
         */
        public function id()
        {
        }
        /**
         * @return mixed|null
         */
        public function name()
        {
        }
        /**
         * @return string
         */
        public function realName()
        {
        }
        /**
         * @return mixed
         * @throws \Exception
         */
        public function value()
        {
        }
        public function namedValue($name)
        {
        }
        /**
         * @return AbstractComponent|null
         */
        public function parent()
        {
        }
        public function getDocReadyEventName()
        {
        }
        public function execEvent($event = 'load')
        {
        }
        /**
         * @param  $name
         * @param null $default
         *
         * @return mixed|null
         * @throws Exception
         */
        public function param($name, $default = null)
        {
        }
        public function defaultParam($name, $value)
        {
        }
        /**
         * @param $name
         * @param $value
         */
        public function setParam($name, $value)
        {
        }
        /**
         * @param $value
         */
        public function setValue($value, $name = null)
        {
        }
        public function tags()
        {
        }
        public function setTags($tags)
        {
        }
        /**
         * @return string
         */
        public function group()
        {
        }
        /**
         * @return mixed|null
         * @throws \Exception
         */
        public function label()
        {
        }
        /**
         * @param  $name
         * @return bool|AbstractComponent
         * @throws \Exception
         */
        public function getComponentByName($name)
        {
        }
        /**
         * @param  $id
         * @return bool|AbstractComponent
         * @throws Exception
         */
        public function getComponentById($id)
        {
        }
        /**
         * @param  $event
         * @return Actions
         */
        public function getActionsByEvent($event)
        {
        }
        /**
         * @return array
         */
        public function properties()
        {
        }
        public function getActions()
        {
        }
        public function setVisibility($visibility = true)
        {
        }
        public function getVisibility()
        {
        }
        public function html()
        {
        }
        protected function containerNode(array $attributes, string $content): string
        {
        }
        abstract public function htmlContent();
        protected function isEmbedded()
        {
        }
        /**
         * @param  $config
         * @param  $isEmbedded
         * @return AbstractComponent|null
         * @throws \Exception
         */
        protected function createComponent($config, $execLoad = false, $addAsChild = true): ?\edoc\appserver\app\AbstractComponent
        {
        }
        protected function setAddAsChildRowAndCol($row, $col = null, $pos = null)
        {
        }
        protected function currentAddChildRow()
        {
        }
        protected function currentAddChildCol()
        {
        }
        protected function currentAddChildPos()
        {
        }
        protected function addAsChild($component)
        {
        }
        public function isBase()
        {
        }
        public function setBase($base = true)
        {
        }
        protected function setEmbedded($embedded = true)
        {
        }
        /**
         * @return int
         */
        protected function renderMode()
        {
        }
        protected function setMetadata($name, $description, $icon)
        {
        }
        public function getMetadata()
        {
        }
        /**
         * @param $group
         */
        protected function setGroup($group)
        {
        }
        /**
         * @param $name
         * @param $type
         * @param array $options
         * @param mixed $defaultValue
         *
         * @throws \Exception
         */
        protected function addProperty($name, $type, array $options = [], $defaultValue = null, $hidden = false)
        {
        }
        protected function hideProperty($name)
        {
        }
        protected function addNamedValue($name)
        {
        }
        public function getNamedValues()
        {
        }
        protected function addRawProperty($name, $value)
        {
        }
        /**
         * @param $script
         * @param string $type
         */
        public function appendScript($script, $type = 'text/javascript'): void
        {
        }
        /**
         * @return array
         */
        public function getAppendScripts()
        {
        }
        /**
         * @param $file
         * @param string $type
         * @throws \ReflectionException
         */
        public function appendScriptFile($file, $type = 'text/javascript', $bottom = false): void
        {
        }
        public function addHeadScriptFile($file, $type = 'text/javascript'): void
        {
        }
        /**
         * @param $file
         * @throws \ReflectionException
         */
        public function appendStylesheet($file): void
        {
        }
        public function getStylesheets()
        {
        }
        /**
         * @param $url
         * @param string $method
         * @param callable|null $callback
         * @throws \ReflectionException
         */
        public function addApiEndpoint($url, $method, string $callback)
        {
        }
        public function getApiEndpoints()
        {
        }
        public const REPLICATION_ROW_DELIM = '-';
        public function isReplication()
        {
        }
        public function replicationRow()
        {
        }
        public function replicationComponentId()
        {
        }
        public function setReplication($rowId)
        {
        }
        public function isView()
        {
        }
        public function setCurrentRepetitionRow($row)
        {
        }
        public function currentRepetitionRow()
        {
        }
        protected function setRouteParameter(array $params)
        {
        }
        protected function app(): \edoc\appserver\App
        {
        }
        public static function iterateChildComponents(array $config, callable $callback, bool $recursive = false): void
        {
        }
    }
    /**
     * AbstractEmbeddedComponent-Klasse
     *
     * @param LIST $components Gibt die Liste der untergeordneten Komponenten an.\nDas direkte Bearbeiten ist nicht möglich.
     */
    abstract class AbstractEmbeddedComponent extends \edoc\appserver\app\AbstractComponent
    {
        public function properties()
        {
        }
        /**
         * @throws Exception
         */
        final protected function init()
        {
        }
        abstract protected function initEmbedded();
        protected function createEmbeddedComponent($config, array $data, $execLoad = false): ?\edoc\appserver\app\AbstractComponent
        {
        }
        public function execEvent($event = 'load')
        {
        }
        protected function setRowNumberProps(array $props)
        {
        }
        public function setParam($name, $value)
        {
        }
    }
    class AbstractRepeater
    {
    }
    #[\edoc\appserver\stubs\attributes\PluginAPI]
    abstract class AbstractValidator implements \JsonSerializable
    {
        public const PARAM_TYPE_STRING = 'string';
        public const REQ_FIELD_KEY = 'reqfield';
        public const REQ_FIELD_KEY_RESET = 'reqfieldreset';
        public function jsonSerialize(): mixed
        {
        }
        public static function list(): array
        {
        }
        /**
         * AbstractValidator constructor.
         *
         * @param AbstractAction|null $parent
         * @param array $config
         */
        final public function __construct(?\edoc\appserver\app\AbstractAction $parent, array $config)
        {
        }
        /**
         * Add a parameter
         *
         * @param string $name
         * @param string $type
         * @param string $defaultValue
         */
        protected function addParameter(string $name, string $type, $defaultValue = ''): void
        {
        }
        /**
         * Get all validator parameters
         * @return array
         */
        public function parameters(): array
        {
        }
        public static function addJSCallbacks(): void
        {
        }
        /**
         * @param AbstractAction|null $parent
         * @param array $config
         *
         * @return AbstractValidator|null
         */
        public static function create(?\edoc\appserver\app\AbstractAction $parent, array $config): ?\edoc\appserver\app\AbstractValidator
        {
        }
        /**
         * @param string $fieldId
         * @param  $value
         *
         * @return bool
         */
        public function validate(string $fieldId, $value): bool
        {
        }
        abstract protected function exec($value): bool;
        abstract protected function init(): void;
        /**
         * Update the message returned to the HTML DOM
         *
         * @param string|null $message
         *
         * @return void
         */
        protected function setMessage(?string $message): void
        {
        }
        /**
         * Get the current message
         * @return string
         */
        public function message(): string
        {
        }
        /**
         * Get the id of the current component
         * @return string
         */
        protected function currentComponentId(): string
        {
        }
        protected function mapParamName($name): string
        {
        }
        /**
         * Get current parameter value
         *
         * @param string $name
         *
         * @return false|mixed
         */
        protected function param(string $name): mixed
        {
        }
    }
    class ActionExecutionMethod
    {
        public const UNKNOWN = 0x1;
        public const VIEW_LOAD = 0x2;
        public const VIEW_EVENT = 0x4;
        public const TASK_TRIGGER = 0x8;
        public const WEBSERVICE_LOAD = 0x10;
        public const FLOW_EXEC_SCRIPT = 0x20;
        /**
         * @param int $providedMethod
         * @param int $expectedMethod
         * @return bool
         */
        public static function is(int $providedMethod, int $expectedMethod): bool
        {
        }
    }
    /**
     *
     */
    #[\edoc\appserver\stubs\attributes\PluginAPI]
    class ActionHelper
    {
        const ACTION_RETURN_TYPE_EMPTY = 'empty';
        const ACTION_RETURN_TYPE_VALUE = 'value';
        const ACTION_RETURN_TYPE_DATASET = 'dataset';
        /**
         * @param AbstractAction $parent
         */
        public function __construct(?\edoc\appserver\app\AbstractAction $parent, ?\Monolog\Logger $logger)
        {
        }
        /**
         * @param string $actionName
         * @param array $params
         * @param $returnFields
         * @param $returnType
         * @return null
         * @throws \ReflectionException
         */
        public function exec(string $actionName, array $params, ?array $returnFields = null, &$returnType = null)
        {
        }
        public function isSingleValue($value)
        {
        }
        public function isDataset($value)
        {
        }
    }
}
namespace edoc\appserver\app\actions {
    abstract class AbstractParameterValidationAction extends \edoc\appserver\app\AbstractAction
    {
        public const PARAM_VALIDATION_TYPE = 'validation type';
        public const PARAM_VALIDATION_PATTERN = 'validation pattern';
        public const PARAM_VALIDATION_OPTIONS = ['' => 'No Validation', 'number' => 'Number', 'text' => 'Text', 'regex' => 'Regex'];
        protected function addValidationParams(): void
        {
        }
        /**
         * @throws \Exception
         */
        protected function validateRequestParam(null|int|string $value): bool
        {
        }
        /**
         * @throws \Exception
         */
        protected function buildValidatorReturnError(string $prepend = 'The value ', string $append = '.'): \edoc\appserver\app\AbstractAction
        {
        }
        protected function isValueValid(?string $type, ?string $pattern, null|int|string $value): bool
        {
        }
        protected function isNumberMatchPattern(?string $pattern, int|string|null $value): bool
        {
        }
        protected function isTextMatchPattern(?string $pattern, int|string|null $value): bool
        {
        }
        protected function isMatchRegex(?string $pattern, int|string|null $value): bool
        {
        }
    }
    trait DisableParameterActionValidation
    {
        protected function validateParamActionResult($name, $value)
        {
        }
    }
    trait DocumentServiceSchemaList
    {
        protected function getSchemaList(): array
        {
        }
    }
}
namespace edoc\appserver\app\actions\interfaces {
    interface SingleValue
    {
    }
}
namespace edoc\appserver\app\actions\lib {
    /**
     * ActionGroup-Aktion
     *
     * Die **ActionGroup**-Aktion können Sie verwenden, um mehrere Aktionen zu gruppieren. 
     *
     * @param ACTIONLIST $actions Gibt die Liste aller auszuführenden Aktionen an.
     */
    class ActionGroup extends \edoc\appserver\app\AbstractAction
    {
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\app {
    /**
     * GetConstant-Aktion
     *
     * Mit der **GetConstant**-Aktion können Sie  einen fixen Wert aus der aktuellen App auslesen.
     *
     * @param SELECT $Name Gibt die Liste aller verfügbaren Werte zum Auswählen an.
     *
     * @return SINGLEVALUE Gibt den Wert der ausgewählten Konstante zurück.
     */
    class GetConstant extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetVariable-Aktion
     *
     * Mit der **GetVariable**-Aktion können Sie eine Variable aus den App-Einstellungen auslesen.
     *
     * @param SELECT $Name Gibt eine Liste aller erstellten Variablen zum Auswählen an.
     *
     * @return SINGLEVALUE Gibt den aktuellen Wert der App-Variable zurück.
     */
    class GetVariable extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        public function loadVariables(?\edoc\appserver\app\AppEntity $entity, array $currentParameter): array
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * SetVariable-Aktion
     *
     * Mit der **SetVariable**-Aktion können Sie die in den App-Details definierten App-Variablen zur Laufzeit anpassen.
     * Die Werte werden für alle Anwender:innen angepasst.
     *
     * Sie können den jeweils aktuellen Wert in den App-Details anzeigen oder mit der Aktion **app\GetVariable** abfragen.
     *
     * @param SELECT $Name Gibt den Namen der festzulegenden Variablen aus einer Liste mit allen verfügbaren App-Variablen
     * an.
     * @param TEXT $Value Gibt den festzulegenden Wert für die Variable an.
     */
    class SetVariable extends \edoc\appserver\app\AbstractAction
    {
        protected function init()
        {
        }
        public function loadVariables(?\edoc\appserver\app\AppEntity $entity, array $currentParameter): array
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib {
    /**
     * Condition-Aktion
     *
     * Mit der **Condition**-Aktion können Sie eine Bedingung überprüfen. Je nachdem, welcher Fall der Bedingung zutrifft,
     * wird eine entsprechende Gruppe von Aktionen ausgeführt.
     *
     * @param TEXT $left Gibt einen fixen Wert oder die Ergebnisse einer Aktion an.
     * @param SELECT $operator Stellt Vergleichsoperatoren zur Verfügung. \
     * Mögliche Werte:\
     * \<, >, ==, !=, >=, \<=
     * @param TEXT $right Gibt einen fixen Wert oder die Ergebnisse einer Aktion an.
     * @param ACTIONLIST $true Gibt Aktionen an, die beim Eintreffen der Bedingung ausgeführt werden.
     * @param ACTIONLIST $false Gibt Aktionen an, die ausgeführt werden, wenn die Bedingung nicht zutrifft.
     *
     * @return SINGLEVALUE Übernimmt den zurückgegebenen Wert der zuletzt ausgeführten Aktion.
     * @return DATASET Übernimmt den zurückgegebenen Datensatz der zuletzt ausgeführten Aktion.
     */
    class Condition extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        use \edoc\appserver\app\actions\DatasetAction;
        public function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\convert {
    abstract class AbstractHTML2PDFAction extends \edoc\appserver\app\AbstractAction
    {
        protected function validatePDFOption($name, $value)
        {
        }
        protected function render($headers, $html)
        {
        }
    }
    /**
     * HTML2PDF-Aktion
     *
     * Mit der **HTML2PDF**-Aktion können Sie HTML-Seiten in PDF-Dateien mithilfe des HTML-To-PDF-Services konvertieren.
     *
     * Folgende Informationen unterstützen Sie beim Konvertieren:
     * - **Grundlegende Informationen zum CSS**:\
     *   [](https://pd4ml.tech/css-keywords/)
     * - **Einfügen von Seitenumbrüchen (Page break)**:\
     *   `<pd4ml:page.break>` \
     *   Weitere Infos unter:\
     *   [](https://old.pd4ml.com/cookbook/pdf_dynamic_format_change.htm)
     * - **Einfügen von bedingten Seitenumbrüchen (Conditional page break)**:\
     *   `<pd4ml:page.break ifSpaceBelowLessThan="330">`
     * - **Informationen zum Einfügen von Kopf-/Fußzeilen**:\
     *   [](https://old.pd4ml.com/cookbook/pdf_header_footer_generation.htm)\
     *   **Beispiel:**
     *   ```html
     *   <pd4ml:page.footer>
     *   footer: $[page] of $[total]
     *   </pd4ml:page.footer>
     *   ```
     * - **Verhindern eines Seitenumbruchs im Bild**:
     *   ```css
     *    \@media pdf {
     *     TR, IMG {page-break-inside: avoid;}
     *   }
     *   ```
     *
     * @param TEXT $HTML Erstellt aus einem HTML-Code eine PDF-Datei.
     * @param KEYVALUELIST $Options Gibt die Parameter für die Konvertierung mit den Optionen von pd4ml an.
     *
     * @return DATASET Gibt einen Datensatz mit dem Inhalt (**value**) der PDF-Datei und dem Mime-Type (**content-type**)
     * zurück.
     */
    class HTML2PDF extends \edoc\appserver\app\actions\lib\convert\AbstractHTML2PDFAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * View2PDF-Aktion
     *
     * Mit der **View2PDF**-Aktion konvertieren Sie eine View in der aktuellen App in ein PDF-Dokument.
     *
     * @param VIEWROUTE $View Wählt eine View aus.
     * @param SELECT $Mode Bietet den Modus **Raw** oder **Print**.
     * @param KEYVALUELIST $Options Gibt die Parameter für die Konvertierung mit den Optionen von pd4ml an.
     *
     * @return DATASET Gibt den Datensatz mit den Spalten **value** und **content-type** zurück.
     */
    class View2PDF extends \edoc\appserver\app\actions\lib\convert\AbstractHTML2PDFAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\database {
    /**
     * LastInsert-Aktion
     *
     * Die **LastInsert**-Aktion liefert die letzte verwendete ID in einer Datenquelle innerhalb eines Events zurück.
     *
     * @param DATASOURCE $datasource Gibt die entsprechend ausgewählte Datenquelle an.
     *
     * @return SINGLEVALUE Gibt die ID des zuletzt eingefügten Datensatzes zurück.
     */
    class LastInsertID extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        public function init()
        {
        }
        /**
         * @return AbstractAction
         * @throws Exception
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * Query-Action
     *
     * Mit der **Query**-Action können Sie Abfragen von Datenbanken ausführen.
     *
     * Sie können Platzhalter in der Abfrage verwenden, die zur Laufzeit durch einen statischen Wert oder die Rückgabe einer
     * Aktion ersetzt werden.
     *
     * **Syntax**: `:<param-name>`\
     * **Beispiel**: `SELECT * FROM table WHERE col = :value`
     *
     *
     * **Optionen für Parameter**
     *
     * Mit zusätzlichen Optionen zu den Parametern können Sie das Verhalten der Parameterersetzung beeinflussen.
     * Die Optionen können Sie mit eckigen Klammern nach dem Parameternamen einfügen. Beispiel: `:<paramname>[<optionen>]`
     * Wenn Sie mehrere Optionen verwenden möchten, können Sie diese mit einem Komma trennen.
     *
     * Standardmäßig werden alle Parameter bei Bedarf automatisch mit umschließenden Anführungszeichen ersetzt. Zahlen und
     * **null** ohne Anführungszeichen eingefügt.
     * Mit den Optionen **QUOTES** und **NO_QUOTES** können Sie das Hinzufügen von Anführungszeichen um die Parameterwerte
     * steuern.
     * - **QUOTES** Der Parameterwert, außer **null**, wird mit Anführungszeichen eingefügt.
     * - **NO_QUOTES** Der Parameterwert wird ohne umschließende Anführungszeichen eingefügt. **Bitte Sicherheitshinweis
     * beachten!**
     *
     * Folgende Optionen stehen außerdem zur Verfügung:
     * - **DEFAULT** Gibt einen Wert an, der verwendet wird, wenn der Parameterwert **null** ist.
     * - **ISEMPTY** Gibt einen Wert an, der verwendet wird, wenn der Parameterwert leer ist.
     * - **ISSTRING** Gibt einen Wert an, der verwendet wird, wenn der Parameterwert eine Zeichenfolge (String) ist.
     * - **ISNUMERIC** Gibt einen Wert an, der verwendet wird, wenn der Parameterwert eine Zahl ist.
     *
     * Beispiel: `:param1[QUOTES,ISEMPTY:Default value]`
     *
     *
     * <div class="panel warning">
     * Aus Sicherheitsgründen sollte die Option **NO_QUOTES** vermieden werden, insbesondere wenn
     * direkte Benutzereingaben an die Datenbank übertragen werden sollen.\
     * Das Verwenden dieser Option kann zu potenziellen SQL-Injektionen (Angriff durch Einschleusen von SQL-Befehlen) führen.\
     * Wenn Sie die Option dennoch nutzen, achten Sie unbedingt darauf, dass die Parameterwerte durch die App validiert und ggf.
     * maskiert werden, um mögliche Sicherheitslücken in Ihrer App zu vermeiden.
     * </div>
     *
     * @param DATASOURCE $datasource Gibt die zu verwendende Datenquelle an.
     * @param EDITOR $query Definiert die Abfrage der Datenbank, z.B. in SQL.
     * @param KEYVALUELIST $params Gibt eine Liste mit Parametern an, die in der Abfrage ersetzt werden sollen.
     *
     * @return DATASET Gibt das Ergebnis der Abfrage zurück.
     */
    class Query extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        /**
         *
         */
        public function init()
        {
        }
        public function logInfo(): array
        {
        }
        /**
         * @return AbstractAction
         * @throws \Exception
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * QueryValue-Aktion
     *
     * Mit der **QueryValue**-Aktion können Sie eine Abfrage auf einer Datenquelle ausführen. Das Ergebnis wird als
     * einzelner Wert zurückgegeben.
     *
     * Sie können Platzhalter in der Abfrage verwenden, die zur Laufzeit durch einen statischen Wert oder die Rückgabe einer
     * Aktion ersetzt werden.
     *
     * **Syntax**: `:<param-name>`\
     * **Beispiel**: `SELECT * FROM table WHERE col = :value`
     *
     * **Optionen für Parameter**
     *
     * Mit zusätzlichen Optionen zu den Parametern können Sie das Verhalten der Parameterersetzung beeinflussen.
     * Die Optionen können Sie mit eckigen Klammern nach dem Parameternamen einfügen. Beispiel: `:<paramname>[<optionen>]`
     * Wenn Sie mehrere Optionen verwenden möchten, können Sie diese mit einem Komma trennen.
     *
     * Standardmäßig werden alle Parameter bei Bedarf automatisch mit umschließenden Anführungszeichen ersetzt. Zahlen und
     * **null** werden ohne Anführungszeichen eingefügt.
     * Mit den Optionen **QUOTES** und **NO_QUOTES** können Sie das Hinzufügen von Anführungszeichen um die Parameterwerte
     * steuern.
     * - **QUOTES** Der Parameterwert, außer **null**, wird mit Anführungszeichen eingefügt.
     * - **NO_QUOTES** Der Parameterwert wird ohne umschließende Anführungszeichen eingefügt. **Bitte Sicherheitshinweis
     * beachten!**
     *
     * Folgende Optionen stehen außerdem zur Verfügung:
     * - **DEFAULT** Gibt einen Wert an, der verwendet wird, wenn der Parameterwert **null** ist.
     * - **ISEMPTY** Gibt einen Wert an, der verwendet wird, wenn der Parameterwert leer ist.
     * - **ISSTRING** Gibt einen Wert an, der verwendet wird, wenn der Parameterwert eine Zeichenfolge (String) ist.
     * - **ISNUMERIC** Gibt einen Wert an, der verwendet wird, wenn der Parameterwert eine Zahl ist.
     *
     * Beispiel: `:param1[QUOTES,ISEMPTY:Default value]`
     *
     *
     * <div class="panel warning">
     * Aus Sicherheitsgründen sollte die Option **NO_QUOTES** vermieden werden, insbesondere wenn
     * direkte Benutzereingaben an die Datenbank übertragen werden sollen.\
     * Das Verwenden dieser Option kann zu potenziellen SQL-Injektionen (Angriff durch Einschleusen von SQL-Befehlen) führen.\
     * Wenn Sie die Option dennoch nutzen, achten Sie unbedingt darauf, dass die Parameterwerte durch die App validiert und ggf.
     * maskiert werden, um mögliche Sicherheitslücken in Ihrer App zu vermeiden.
     * </div>
     *
     * @param DATASOURCE $datasource Gibt die zu verwendende Datenquelle an.
     * @param EDITOR $query Definiert die Abfrage der Datenbank, z.B. in SQL.
     * @param KEYVALUELIST $params Gibt eine Liste mit Parametern an, die in der Abfrage ersetzt werden sollen.
     *
     * @return SINGLEVALUE Gibt das Ergebnis der Abfrage zurück.
     */
    class QueryValue extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        /**
         *
         */
        public function init()
        {
        }
        public function logInfo(): array
        {
        }
        /**
         * @return AbstractAction
         * @throws \Exception
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\dataset {
    /**
     * Each-Aktion
     *
     * Mit der **Each**-Aktion können Sie die angegebenen Aktionen für jede Zeile der ausgewählten Tabelle ausführen.
     *
     * @param COMPONENT $Table Gibt die Tabelle an, für die die Aktionen ausgeführt werden sollen.
     * @param ACTIONLIST $Actions Gibt die auszuführenden Aktionen an.
     */
    class Each extends \edoc\appserver\app\AbstractAction
    {
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetAll-Aktion
     *
     * Mit der **GetAll**-Aktion können Sie z.B. den Inhalt einer kompletten Tabelle laden, um Daten aus der Tabelle
     * weiterzuverarbeiten.
     *
     * @param COMPONENT $Table Ruft die Daten aus einer Tabelle ab.
     *
     * @return DATASET Gibt alle Werte der angegebenen Tabelle zurück.
     */
    class GetAll extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetSingleValue-Aktion
     *
     * Die **GetSingleValue**-Aktion gibt einen einzelnen Wert aus einem Datensatz zurück.
     *
     * @param ACTION $Dataset Gibt den Datensatz an, aus dem der Wert ausgelesen wird.
     * @param TEXT $Row Gibt die Zeilennummer im Datensatz an. Zeilen: **0-n**
     * @param TEXT $Column Gibt den Namen der Spalte im Datensatz an.
     *
     * @return SINGLEVALUE Gibt den Wert an der angegebenen Stelle im Datensatz zurück.
     */
    class GetSingleValue extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * SearchValue-Aktion
     *
     * Die **SearchValue**-Aktion gibt einen Wert in einer gefundenen Zeile zurück.
     *
     * Die Aktion gibt den Wert der Spalte zurück, die Sie mit **ValueColumn** angegeben haben, und zwar den Wert in ersten
     * gefundenen Zeile des angegebenen Datensatzes.\
     * Mit **SearchColumn** legen Sie fest, in welcher Spalte nach dem mit **SearchValue** angegebenen Wert gesucht wird.
     *
     * @param DATASET $Dataset Gibt einen bestimmten Datensatz an, z.B. `dataset\GetAll`.
     * @param TEXT $SearchColumn Gibt die Spalte an, in der nach dem Wert gesucht wird.
     * @param TEXT $SearchValue Gibt den zu suchenden Wert an.
     * @param TEXT $ValueColumn Gibt die Spalte mit dem entsprechenden Wert an.
     *
     * @return SINGLEVALUE Gibt den gefundenen Wert zurück.
     */
    class SearchValue extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions {
    /**
     * Class SetValueAction
     *
     * @package edoc\appserver\app\actions
     */
    abstract class SetValueAction extends \edoc\appserver\app\AbstractAction
    {
        public const ACTIONKEY = 'setvalue';
        public static function addJSCallbacks()
        {
        }
        /**
         * @param  $field
         * @param  $value
         * @return $this
         */
        public function returnValue($field, $value)
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\dataset {
    /**
     * SetValues-Aktion
     *
     * Mit der **SetValues**-Aktion können Sie für eine Komponente oder mehrerer Komponenten einen Wert über ein Datensatz
     * ändern oder festlegen.
     *
     * ## Rückgabefelder
     * Rückgabefelder enthalten eine Liste der Komponenten, deren Wert mit den Daten aus dem Datensatz geändert werden soll.
     *
     * @param ACTION $Dataset Gibt eine Aktion an, die ein Datensatz zurückgeben muss.
     * @param SELECT $Data_Mapping Gibt an, auf welche Art die Werte des Datensatzes einer Komponente zugewiesen werden.
     * - **Ignore return fields, map by column name**: Die Werte werden einer Komponente anhand des Spaltennamens im
     *   Datensatz per vollständiger ID (z.B. `table.input1`) zugewiesen. Sie müssen kein Rückgabefeld angeben.
     * - **Use return fields, map by column name**: Die Werte werden den ausgewählten Komponenten anhand des Spaltennamens
     *   im Datensatz mit der Eigenschaft **Name** zugewiesen.
     * - **Use return fields, map by order**: Die Werte werden den ausgewählten Komponenten der Reihe nach aus dem
     *   Datensatz zugewiesen.
     */
    class SetValues extends \edoc\appserver\app\actions\SetValueAction
    {
        const DefaultDataMapping = 'ignore';
        protected function init()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\document {
    /**
     * DeleteDocument-Aktion
     *
     * Mit der **DeleteDocument**-Aktion können Sie ein Dokument mit der angegebenen Dokument-ID im angebundenen edoc
     * document-Service löschen.
     *
     * @param TEXT $DocumentId Gibt die ID des zu löschenden Dokuments an.
     *
     * @return SINGLEVALUE Gibt entweder **true** oder **false** zurück.
     */
    class DeleteDocument extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetDocument-Aktion
     *
     * Die **GetDocument**-Aktion lädt Details zum Dokument mit der angegebenen Dokument-ID aus dem angebundenen edoc
     * document-Service.
     *
     * @param TEXT $DocumentId Gibt die Dokument-ID an.
     *
     * @return DATASET Gibt einen einzeiligen Datensatz mit allen Dokumenteigenschaften zurück.
     */
    class GetDocument extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetDocumentAttributes-Aktion
     *
     * Die **GetDocumentAttributes**-Aktion gibt eine Liste mit allen Attributen zu einem Dokument und deren aktuellen Werte
     * zurück.
     *
     * @param SELECT $Schema Gibt das Schema an, in dem sich das Dokument befindet.
     * @param TEXT $DocumentId Gibt die ID vom entsprechenden Dokument an.
     *
     * @return DATASET Gibt einen Datensatz mit allen Attributen zurück.\
     * Beinhaltet pro Attribut folgende Werte: **Name**, **Label**, **Value** und **Type**.
     */
    class GetDocumentAttributes extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        use \edoc\appserver\app\actions\DocumentServiceSchemaList;
        protected function init()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetDocumentByExternalId-Aktion
     *
     * Die **GetDocumentByExternalId**-Aktion gibt die Eigenschaften zu einem Dokument und deren aktuellen Werte zurück.
     * Das Dokument wird mithilfe der externen Dokumenten-ID gefunden.
     *
     * @param SELECT $Schema Gibt das Schema an, in dem sich das Dokument befindet.
     * @param TEXT $DocumentId Gibt die externe Dokument-ID des entsprechenden Dokumentes an.
     *
     * @return DATASET Gibt einen einzeiligen Datensatz mit allen Dokumenteigenschaften zurück.
     */
    class GetDocumentByExternalId extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        use \edoc\appserver\app\actions\DocumentServiceSchemaList;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetDocumentContent-Aktion
     *
     * Die **GetDocumentContent**-Aktion gibt die Datei zu einem Dokument mit Inhalt und Mime-Type zurück.
     *
     * @param TEXT $DocumentId Gibt die ID des entsprechenden Dokuments an.
     *
     * @return DATASET Gibt einen einzeiligen Datensatz mit dem Inhalt der Datei und dem Mime-Type zurück.
     */
    class GetDocumentContent extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetDocumentOcr-Aktion
     *
     * Die **GetDocumentOcr**-Aktion gibt die OCR-Daten zu einem Dokument zurück.
     *
     * @param TEXT $DocumentId Gibt die ID des entsprechenden Dokuments an.
     * @param SELECT $Refresh Gibt an, ob die OCR-Datei neu erzeugt werden soll, wenn sie bereits einmal erzeugt wurde.
     *
     * @return DATASET Gibt den Inhalt der OCR-Datei als Datensatz zurück.
     */
    class GetDocumentOcr extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetDocumentsBySchema-Aktion
     *
     * Die **GetDocumentsBySchema**-Aktion gibt seitenweise alle Dokumente des angegebenen Schemas zurück.
     * Sie geben in den Parametern die Anzahl der Dokumente pro Seite an, und ab welcher Seite die Dokumente aufgelistet
     * werden.
     *
     * @param SELECT $Schema Gibt das ausgewählte Schema an.
     * @param TEXT $PageSize Gibt die Anzahl der Dokumente pro Seite an.
     * Standardwert: **100**.
     * @param TEXT $Page Gibt eine bestimmte Seite mit Dokumenten an.
     * Standardwert: **1**
     *
     * @return DATASET Gibt die Dokumente eines bestimmten Schema seitenweise zurück.
     */
    class GetDocumentsBySchema extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        use \edoc\appserver\app\actions\DocumentServiceSchemaList;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetNewDocumentsBySchema-Aktion
     *
     * Die **GetNewDocumentsBySchema**-Aktion gibt alle Dokumente des angegebenen Schemas seit dem angegebenen Zeitpunkt
     * zurück.
     *
     * @param SELECT $Schema Gibt das ausgewählte Schema an.
     * @param TEXT $CreatedSince Gibt den Zeitpunkt an. Format: `TIMESTAMP`
     *
     * @return DATASET Gibt alle Dokumente zurück, die seit einem bestimmten Zeitpunkt im angegeben Schema vorhanden sind.
     */
    class GetNewDocumentsBySchema extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        use \edoc\appserver\app\actions\DocumentServiceSchemaList;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetSchema-Aktion
     *
     * Die **GetSchema**-Aktion gibt alle erstellten Schemas mit entsprechenden Details zurück.
     *
     * @return DATASET Gibt ein Schema pro Zeile mit folgenden Spalten zurück:\
     * ***name**, **label**, **document_count**, **generate_image**, **ocr**, **created_by_user**.
     */
    class GetSchema extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetSchemaDetails-Aktion
     *
     * Die **GetSchemaDetails**-Aktion gibt alle Eigenschaften zum angegebenen Schema zurück.
     *
     * @param TEXT $Schema Gibt das ausgewählte Schema an.
     *
     * @return DATASET Gibt einen einzeiligen Datensatz mit folgenden Eigenschaften zurück:\
     * ***name**, **label**, **attributes**, **generated_image**, **ocr**, **created_by_user**, **document_count**,
     * ***webhooks**
     */
    class GetSchemaDetails extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * NewDocument-Aktion
     *
     * Die **NewDocument**-Aktion speichert ein neues Dokument in edoc documents mit Datei und den angegebenen Attributen.
     *
     * @param TEXT $Schema Gibt das ausgewählte Schema an, in dem das Dokument gespeichert wird.
     * @param TEXT $Content Gibt den Inhalt des zu speichernden Dokuments an.
     * @param TEXT $Filename Gibt den Dateinamen zum Dokument an, das gespeichert werden soll.
     * @param TEXT $Attributes Gibt die Liste der Attribute zum Dokument an.
     *
     * @return SINGLEVALUE Gibt die Dokument-ID zum neuen Dokument zurück.
     */
    class NewDocument extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        use \edoc\appserver\app\actions\DocumentServiceSchemaList;
        protected function init(): void
        {
        }
        public function loadAttributes(?\edoc\appserver\app\AppEntity $entity, array $currentParameter): array
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * SaveDocument-Aktion
     *
     * Die **SaveDocument**-Aktion speichert ein neues Dokument zum angegebenen Schema im edoc documents-Service.
     *
     * @param SELECT $Schema Gibt das Schema an.
     * @param TEXT $Content Gibt den Inhalt des Dokuments an.
     * @param TEXT $Filename Gibt den Dateinamen des Dokuments an.
     *
     * @return SINGLEVALUE Gibt das gespeicherte Dokument zurück.
     */
    class SaveDocument extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        use \edoc\appserver\app\actions\DocumentServiceSchemaList;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * UpdateAttributs-Aktion
     *
     * Die **UpdateAttributs**-Aktion aktualisiert die angegebenen Attribute zum angegebenen Dokument.
     *
     * @param SELECT $Schema Gibt das Schema an, in dem sich das Dokument befindet.
     * @param TEXT $DocumentId Gibt die ID des zu ändernden Dokuments an.
     * @param KEYVALUELIST $Attributes Gibt die Liste mit den Namen und Werten der Attribute an.
     */
    class UpdateAttributes extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DocumentServiceSchemaList;
        protected function init()
        {
        }
        public function loadAttributes(?\edoc\appserver\app\AppEntity $entity, array $currentParameter): array
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib {
    /**
     * ExecCondition-Aktion
     *
     * Mit der **ExecCondition**-Aktion können Sie eine Bedingung überprüfen.\
     * Das Ergebnis (**true** oder **false**) wird als **SingleValue** zurückgegeben.
     *
     * @param TEXT $left Gibt einen fixen Wert oder das Ergebnis einer Aktion an.
     * @param SELECT $operator Stellt Vergleichsoperatoren zur Verfügung.\
     * Mögliche Werte:\
     * \<, >, ==, !=, >=, \<=
     * @param TEXT $right Gibt einen fixen Wert oder das Ergebnis einer Aktion an.
     *
     * @return SINGLEVALUE Gibt das Ergebnis der Bedingung zurück.
     */
    class ExecCondition extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        public function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\fs {
    /**
     * Delete-Aktion
     *
     * Mit der **Delete**-Aktion können Sie Dateien und Verzeichnisse löschen.
     *
     * Das Arbeitsverzeichnis ist immer der **assets**-Ordner der App. Wenn Sie relative Pfade verwenden, müssen Sie den
     * **assets**-Ordner berücksichtigen.
     *
     * @param TEXT $filename Gibt den Pfad des zu löschenden Verzeichnisses oder der Datei an.
     */
    class Delete extends \edoc\appserver\app\AbstractAction
    {
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * Move-Action
     *
     * Mit der **Move**-Action können Sie eine Datei im Dateisystem verschieben.
     *
     * @param TEXT $source Gibt den aktuellen Pfad zur Datei an.
     * @param TEXT $target Gibt den neuen Pfad zur Datei an.\
     * **Wichtig**: Der angegebene Pfad darf nicht existieren.
     */
    class Move extends \edoc\appserver\app\AbstractAction
    {
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * Read-Aktion
     *
     * Die **Read**-Aktion liest den Inhalt der festgelegten Datei.
     *
     * Legen Sie das aktuelle Arbeitsverzeichnis auf **<app_dir>/assets** fest.\
     * Sie können dann auch die verwendeten Dateien direkt über den Browser abrufen.
     *
     * @param TEXT $filename Gibt den Dateinamen inklusive Pfad an.
     *
     * @return SINGLEVALUE Gibt den Inhalt der angegebenen Datei zurück.
     */
    class Read extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * Write-Aktion
     *
     * Die **Write**-Aktion schreibt den angegebenen Inhalt in die angegebene Datei.
     *
     * Legen Sie das aktuelle Arbeitsverzeichnis auf **<app_dir>/assets** fest.\
     * Sie können dann auch die verwendeten Dateien direkt über den Browser abrufen.
     *
     * @param TEXT $filename Gibt den Dateinamen inklusive Pfad an.
     * @param TEXT $content Gibt den Inhalt an, der in die Datei geschrieben werden soll.
     */
    class Write extends \edoc\appserver\app\AbstractAction
    {
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib {
    /**
     * GetNamedValue-Aktion
     *
     * Die **GetNamedValue**-Aktion ruft die benannten Werte der ausgewählten Komponente ab.
     *
     * @param COMPONENT $component Gibt die ausgewählte Komponente an, von der der Wert gelesen werden soll.
     * @param SELECT $name Gibt die Liste der möglichen benannten Werte der ausgewählten Komponente an.
     *
     * @return SINGLEVALUE Gibt den benannten Wert der ausgewählten Komponente zurück.
     */
    class GetNamedValue extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
        public function loadNamedValues(\edoc\appserver\app\components\Component $baseComponent, array $currentParameter): array
        {
        }
    }
    /**
     * GetParameter-Aktion
     *
     * Die **GetParameter**-Aktion liefert einen beliebigen Parameter der aktiven Komponente zurück, für den die
     * Aktion definiert wurde.
     *
     * @param TEXT $Parameter Gibt den Namen des Parameters der Komponente an.
     *
     * @return SINGLEVALUE Gibt den Wert des Parameters der aktiven Komponente zurück.
     *
     */
    class GetParameter extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        /**
         *
         */
        public function init()
        {
        }
        /**
         * @return AbstractAction
         * @throws Exception
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetValue-Aktion
     *
     * Die **GetValue**-Aktion gibt den aktuellen Wert der ausgewählten Komponente zurück.
     *
     * @param COMPONENT $none Gibt die ausgewählten Komponente an.
     *
     * @return SINGLEVALUE Gibt den Wert der ausgewählten Komponente zurück.
     */
    class GetValue extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        /**
         *
         */
        public function init()
        {
        }
        /**
         * @return AbstractAction
         * @throws \Exception
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\html {
    /**
     * SetClass-Aktion
     *
     * Die **SetClass**-Aktion legt die HTML-Klasse einer Komponente zur Laufzeit fest oder überschreibt sie.
     *
     * @param COMPONENT $target Gibt die ausgewählte Komponente an.
     * @param TEXT $class Gibt die zu setzende Klasse an. Mehrere Klassen sind möglich.\
     * Kann statisch oder durch eine Aktion angegeben werden.
     * @param SELECT $mode Gibt den Modus an: Überschreiben, Entfernen oder Hinzufügen von Klassen.
     */
    class SetClass extends \edoc\appserver\app\AbstractAction
    {
        public const ACTIONKEY = 'setclass';
        public static function addJSCallbacks(): void
        {
        }
        public function init(): void
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * SetStyle-Action
     *
     * Die **SetStyle**-Action legt den angegebenen Style auf die angegebene Komponente fest.
     *
     * @param COMPONENT $target Gibt die Komponenten an, auf die der Style angewandt werden soll.
     * @param TEXT $style Gibt den CSS-Style an.
     */
    class SetStyle extends \edoc\appserver\app\AbstractAction
    {
        public const ACTIONKEY = 'setstyle';
        public static function addJSCallbacks()
        {
        }
        public function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\http {
    /**
     * GetHeader-Aktion
     *
     * Die **GetHeader**-Aktion gibt einen Header der aktuellen HTTP-Anfrage zurück.
     *
     * Die zurückgegebenen Werte können außerdem automatisch überprüft werden.
     *
     * @param TEXT $header_name Gibt den Namen des HTTP-Headers an.
     * @param SELECT $validation_type Gibt den Typ der Validierung an, der für den Wert des Parameters verwendet werden soll.
     * Folgende Validierungstypen gibt es: **Number**, **Text**, **Regex**.
     * @param TEXT $validation_pattern Gibt das Muster der Validierung an, das für den Wert des Parameters verwendet werden soll.
     * Der ausgewählte Validierungstyp bestimmt, welche Werte Sie eintragen müssen, damit die Validierung durchgeführt wird.
     * Sie können mehrere Werte durch ein Semikolon getrennt eingeben.
     * - **Number**: Erlaubt sind Zahlen und Bereiche (range). Beispiel: **1**; **2-5**
     * - **Text**: Erlaubt sind Buchstaben und Kombinationen von Buchstaben, Zahlen und Sonderzeichen. Beispiel: **Text**; **"Text1: (%)"**; **'"Text1": (?)'**
     * - **Regex**: Erlaubt sind reguläre Ausdrücke. Als Start- und Endzeichen sind alle Standardtrennzeichen (Delimiters) für reguläre Ausdrücke erlaubt. Beispiel für mehrere Zahlen: **@\d+@**.
     *
     * @return SINGLEVALUE Gibt den Wert des HTTP-Headers oder **null** zurück.
     */
    class GetHeader extends \edoc\appserver\app\actions\AbstractParameterValidationAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        public function init()
        {
        }
        /**
         * @throws \Exception
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetHeaders-Aktion
     *
     * Die **GetHeaders**-Aktion gibt alle Header der aktuellen HTTP-Anfrage zurück.
     *
     *
     * @return DATASET Gibt die Liste mit allen Header zurück.
     */
    class GetHeaders extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        public function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetPostData-Aktion
     *
     * Die **GetPostData**-Aktion lädt den Body einer POST-Anfrage.
     *
     * Die zurückgegebenen Werte können außerdem automatisch überprüft werden.
     *
     * @param SELECT $validation_type Gibt den Typ der Validierung an, der für den Wert des Parameters verwendet werden soll.
     * Folgende Validierungstypen gibt es: **Number**, **Text**, **Regex**.
     * @param TEXT $validation_pattern Gibt das Muster der Validierung an, das für den Wert des Parameters verwendet werden soll.
     * Der ausgewählte Validierungstyp bestimmt, welche Werte Sie eintragen müssen, damit die Validierung durchgeführt wird.
     * Sie können mehrere Werte durch ein Semikolon getrennt eingeben.
     * - **Number**: Erlaubt sind Zahlen und Bereiche (range). Beispiel: **1**; **2-5**
     * - **Text**: Erlaubt sind Buchstaben und Kombinationen von Buchstaben, Zahlen und Sonderzeichen. Beispiel: **Text**; **"Text1: (%)"**; **'"Text1": (?)'**
     * - **Regex**: Erlaubt sind reguläre Ausdrücke. Als Start- und Endzeichen sind alle Standardtrennzeichen (Delimiters) für reguläre Ausdrücke erlaubt. Beispiel für mehrere Zahlen: **@\d+@**.
     * @return SINGLEVALUE Gibt die gesamten POST-Daten der aktuellen Anfrage zurück.
     */
    class GetPostData extends \edoc\appserver\app\actions\AbstractParameterValidationAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        /**
         * @throws \Exception
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetRequestVariable-Aktion
     *
     * Die **GetRequestVariable**-Aktion gibt einen Parameter (**GET** oder **POST**) der aktuellen HTTP-Anfrage zurück.
     *
     * Die zurückgegebenen Werte können außerdem automatisch überprüft werden.
     *
     * @param TEXT $parameter_name Gibt den Namen des Parameters an.
     * @param SELECT $validation_type Gibt den Typ der Validierung an, der für den Wert des Parameters verwendet werden soll.
     * Folgende Validierungstypen gibt es: **Number**, **Text**, **Regex**.
     * @param TEXT $validation_pattern Gibt das Muster der Validierung an, das für den Wert des Parameters verwendet werden soll.
     * Der ausgewählte Validierungstyp bestimmt, welche Werte Sie eintragen müssen, damit die Validierung durchgeführt wird.
     * Sie können mehrere Werte durch ein Semikolon getrennt eingeben.
     * - **Number**: Erlaubt sind Zahlen und Bereiche (range). Beispiel: **1**; **2-5**
     * - **Text**: Erlaubt sind Buchstaben und Kombinationen von Buchstaben, Zahlen und Sonderzeichen. Beispiel: **Text**; **"Text1: (%)"**; **'"Text1": (?)'**
     * - **Regex**: Erlaubt sind reguläre Ausdrücke. Als Start- und Endzeichen sind alle Standardtrennzeichen (Delimiters) für reguläre Ausdrücke erlaubt. Beispiel für mehrere Zahlen: **@\d+@**.
     *
     * @return SINGLEVALUE Gibt den Wert des Parameters oder **null** zurück.
     */
    class GetRequestVariable extends \edoc\appserver\app\actions\AbstractParameterValidationAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        public function init()
        {
        }
        /**
         * @throws \Exception
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * SetHeader-Aktion
     *
     * Mit der **SetHeader**-Aktion können Sie einen HTTP-Header oder mehrere in der Antwort der aktuellen Anfrage
     * festlegen.
     * <div class="panel note">
     * **Hinweis**\
     * Das Festlegen von Headern ist nur beim Laden (**On Load** oder bei **WebService**) möglich.
     * </div>
     *
     * @param KEYVALUELIST $fields Gibt eine Liste mit den Namen und Werten der festzulegenden HTTP-Header an.
     *
     */
    class SetHeader extends \edoc\appserver\app\AbstractAction
    {
        public function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * SetStatusCode-Aktion
     *
     * Mit der **SetStatusCode**-Aktion können Sie den HTTP-Status für die Antwort der aktuellen Anfrage festlegen.
     * <div class="panel note">
     * **Hinweis**\
     * Das Festlegen eines Statuscodes ist nur beim Laden (**On Load** oder bei **WebService**) möglich.
     * </div>
     *
     * @param TEXT $status_code Gibt den HTTP-Status-Code an.\
     * Standardwert: **200**
     */
    class SetStatusCode extends \edoc\appserver\app\AbstractAction
    {
        public function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * StartDownload-Aktion
     *
     * Die **StartDownload**-Aktion startet beim Anwender einen Download mit der angegebenen Datei.
     *
     * @param TEXT $Content Gibt den herunterzuladenden Inhalt an.
     * @param TEXT $Filename Gibt den Namen der Datei an, der dem Anwender angezeigt wird.
     * @param TEXT $Mimetype Gibt den Mime-Type der Datei an.
     *
     * @return DOWNLOAD Startet den Download der Daten.
     */
    class StartDownload extends \edoc\appserver\app\AbstractAction
    {
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\i18n {
    /**
     * GetLanguage-Aktion
     *
     * Die **GetLanguage**-Aktion gibt die aktuell aktive Sprache des Anwenders zurück.
     *
     * Die Sprache wird in folgender Reihenfolge ausgelesen:
     * 1. Über den festgelegten Cookie
     * 2. Über den Browser
     * 3. Über die Systemeinstellung von edoc automate
     *
     * @return SINGLEVALUE Gibt den Sprachcode (Kürzel) der aktuell aktiven Sprache zurück.
     */
    class GetLanguage extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * SetLanguage-Aktion
     *
     * Die **SetLanguage**-Aktion aktiviert die angegebene Sprache für den aktuellen Anwender.
     *
     * <div class="panel note">
     * Es muss der passende Local-Code (z.B.: de-DE) für die gewünschte Sprache angegeben werden.
     * </div>
     *
     * @param TEXT $language Gibt den Sprachcode (Kürzel) für die zu aktivierende Sprache an.
     */
    class SetLanguage extends \edoc\appserver\app\AbstractAction
    {
        protected function init(): void
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * Translate-Aktion
     *
     * Die **Translate**-Aktion übersetzt den angegebenen Text. Die Übersetzung für die aktive Sprache muss in der App
     * vorhanden sein.\
     * Wenn keine Übersetzung vorhanden ist, wird der angegebene Text zurückgegeben.
     *
     * @param TEXT $key Gibt den zu übersetzenden Text an.
     *
     * @return SINGLEVALUE Gibt den übersetzten Text oder den Key zurück.
     */
    class Translate extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * TranslateDataset-Aktion
     *
     * Die **TranslateDataset**-Aktion übersetzt alle Text in den Werten des Datensatzes. Die Übersetzung für die aktive
     * Sprache muss in der App vorhanden sein.\
     * Wenn keine Übersetzung vorhanden ist, wird der bereits vorhandene Text in der Originalsprache beibehalten.
     *
     * @param ACTION $dataset Gibt den zu übersetzenden Datensatz an.
     *
     * @return DATASET Gibt den übersetzten Datensatz zurück.
     */
    class TranslateDataset extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init(): void
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\invoice {
    /**
     * ForwardWorkflow-Aktion
     *
     * Mit der **ForwardWorkflow**-Aktion können Sie einen edoc invoice-Workflow an eine andere Empfängergruppe
     * (Postkorb, Gruppenaufgaben) weiterleiten.
     *
     * @param TEXT $EcmId Gibt die Dokumenten-ID des betreffenden Workflows an.
     * @param TEXT $Subject Gibt einen Betreff an (optional).
     * @param TEXT $Inbox Gibt eine zugeordnete Gruppe an (optional).
     * @param TEXT $Assigne Gibt einen zugeordneten Mitarbeiter oder eine zugeordnete Mitarbeiterin an (optional).
     */
    class ForwardWorkflow extends \edoc\appserver\app\AbstractAction
    {
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * RestartWorkflow-Aktion
     *
     * Mit der **RestartWorkflow**-Aktion können Sie einen edoc invoice-Workflow neu starten.
     * Sie können mit der Aktion auch einen bereits abgeschlossenen Workflow erneut starten.
     *
     * @param TEXT $EcmId Gibt die Dokumenten-ID des zu startenden Workflows an.
     * @param TEXT $Subject Gibt einen Betreff an (optional).
     * @param TEXT $Inbox Gibt eine zugeordnete Gruppe an (optional).
     * @param TEXT $Assigne Gibt einen zugeordneten Mitarbeiter oder eine zugeordnete Mitarbeiterin an (optional).
     */
    class RestartWorkflow extends \edoc\appserver\app\AbstractAction
    {
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * SetStatus-Aktion
     *
     * Mit der **SetStatus**-Aktion können Sie für einen edoc invoice-Workflow einen Workflowstatus festlegen.
     *
     * @param TEXT $EcmId Gibt die Dokument-ID des betreffenden Workflows an.
     * @param TEXT $Event Gibt den Status des Workflows an (**verify**, **release**, **post** oder **abort**).
     */
    class SetStatus extends \edoc\appserver\app\AbstractAction
    {
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib {
    /**
     * Link-Aktion
     *
     * Mit der **Link**-Aktion können Sie eine Aktion mit einer anderen Komponente verknüpfen. Sie können nur Aktionen
     * verlinken, bei denen Sie einen Namen angegeben haben.
     *
     * @param COMPONENT $Source Gibt die ausgewählte Komponente an.
     * @param SELECT $Action Gibt den Namen der zu verlinkenden Aktion an.
     *
     * @return SINGLEVALUE Übernimmt den zurückgegebenen Wert der verlinkten Aktion.
     * @return DATASET Übernimmt den zurückgegebenen Datensatz der verlinkten Aktion.
     */
    class Link extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        use \edoc\appserver\app\actions\DatasetAction;
        /**
         * @return AbstractAction
         * @throws Exception
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
        /**
         * @param  Component $baseComponent
         * @param  array     $currentParameter
         * @return array
         * @throws Exception
         */
        public function loadActions(\edoc\appserver\app\components\Component $baseComponent, array $currentParameter)
        {
        }
        protected function init()
        {
        }
    }
}
namespace edoc\appserver\app\actions {
    /**
     * Class MessageAction
     *
     * @package edoc\appserver\app\actions
     */
    abstract class MessageAction extends \edoc\appserver\app\AbstractAction
    {
        // TODO: move class into a trait?!
        public const ACTIONKEY = 'message';
        public static function addJSCallbacks()
        {
        }
        /**
         * @param  $message
         * @param  null $type
         * @return $this
         */
        protected function returnMessage($message, $type = null, $title = null)
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib {
    /**
     * Message-Aktion
     *
     * Die **Message**-Aktion zeigt einen Dialog mit einer Meldung an.
     *
     * @param TEXT $message Gibt die darzustellende Nachricht an.
     * @param TEXT $title Gibt den Titel des Dialogs an.
     * @param SELECT $type Gibt den Typ der Nachricht an.
     * Mögliche Werte:
     * - **info**
     * - **warning**
     * - **error**
     */
    class Message extends \edoc\appserver\app\actions\MessageAction
    {
        /**
         *
         */
        public function init()
        {
        }
        /**
         * @return AbstractAction
         * @throws \Exception
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * OpenURL-Aktion
     *
     * Mit der **OpenURL**-Aktion können Sie eine URL öffnen.
     *
     * @param TEXT $url Tragen Sie die entsprechende URL ein.
     * @param SELECT $target Sie können das Verhalten im Browser mit folgenden Werten steuern:
     * - **self**: Öffnet die URL im selben Tab.
     * - **blank**: Öffnet die URL in einem neuen Tab.
     */
    class OpenURL extends \edoc\appserver\app\AbstractAction
    {
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\permissions {
    /**
     * CheckUserGroup-Aktion
     *
     * Mit der **CheckUserGroup**-Aktion können Sie überprüfen, ob einem Benutzer einer bestimmten Gruppe zugewiesen ist.
     *
     * @param TEXT $User Gibt den Benutzer an, für den die Gruppe geprüft wird.
     * @param KEYVALUELIST $Group Gibt den Namen der Gruppe an, die geprüft werden sollen.
     * @param SELECT $Validation Gibt die Art der Prüfung an.
     * - **every group**: Alle Gruppen müssen zugewiesen sein.
     * - **at least one role**: Eine der angegebenen Gruppen muss zugewiesen sein.
     *
     * @return SINGLEVALUE Gibt folgende Werte zurück:
     * - **true**: Der Benutzer ist Mitglied der Gruppe.
     * - **false**: Der Benutzer ist kein Mitglied der Gruppe.
     */
    class CheckUserGroup extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * CheckUserRole-Aktion
     *
     * Mit der **CheckUserRole**-Aktion können Sie überprüfen, ob einem Benutzer eine bestimmte Rolle zugewiesen ist.
     *
     * @param TEXT $User Gibt den Benutzer an, für den die Rolle geprüft wird.
     * @param KEYVALUELIST $Role Gibt den Namen der Rollen an, die geprüft werden sollen.
     * @param SELECT $Validation Gibt die Art der Prüfung an.
     * - **every role**: Alle Rollen müssen zugewiesen sein.
     * - **at least one role**: Eine der angegebenen Rollen muss zugewiesen sein.
     *
     * @return SINGLEVALUE Gibt folgende Werte zurück:
     * - **true**: Der Benutzer hat die Rolle.
     * - **false**: Der Benutzer hat nicht die Rolle.
     */
    class CheckUserRole extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * CurrentUser-Aktion
     *
     * Die **CurrentUser**-Aktion gibt den aktuellen Benutzer zurück.
     * Der Wert **false** wird zurückgegeben, wenn kein Benutzer angemeldet ist.
     *
     * @return SINGLEVALUE Gibt den Benutzernamen des aktuellen Benutzers zurück.
     */
    class CurrentUser extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetGroups-Aktion
     *
     * Die **GetGroups**-Aktion gibt alle verfügbaren Gruppen auf dem angebundenen Keycloak-Server in einer sortierten Liste
     * zurück.
     *
     * @return DATASET Gibt die Liste alle Gruppen zurück.
     */
    class GetGroups extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetUserAttribute-Aktion
     *
     * Die **GetUserAttribute**-Aktion gibt den Wert zu einem Attribut des angegebenen Benutzers zurück.
     *
     * @param TEXT $username Gibt den Benutzernamen an.
     * @param TEXT $attribute Gibt den Namen des Attributs an.
     *
     * @return SINGLEVALUE Gibt den aktuellen Wert des Attributs zurück.
     */
    class GetUserAttribute extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetUserAttributes-Aktion
     *
     * Die **GetUserAttributes**-Aktion gibt eine Liste mit allen Attributen für den angegebenen Benutzer zurück.
     *
     * @param TEXT $username Gibt den Benutzernamen an.
     *
     * @return DATASET Gibt die Liste mit allen Attributen zurück.
     */
    class GetUserAttributes extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetUserDetail-Aktion
     *
     * Die **GetUserDetail**-Aktion gibt einen einzelnen Wert mit den ausgewählten Informationen zum Benutzer zurück.
     *
     * Sie können folgende Werte auswählen:
     * - **username**: aktueller Benutzername.
     * - **displayname**: zusammengesetzter Name aus Nachname und Vorname.
     * - **firstname**: Vorname des Benutzers.
     * - **lastname**: Nachname des Benutzers.
     * - **email**: E-Mail-Adresse des Benutzers.
     * - **uuid**: UUID des Benutzers.
     *
     * @param TEXT $username Gibt den entsprechenden Benutzernamen an.
     * @param SELECT $detail Gibt den zurückzugebenen Wert an.
     *
     * @return SINGLEVALUE Gibt den Wert zum angegebenen Benutzer und entsprechendem Detail zurück.
     */
    class GetUserDetail extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetUserDetails-Aktion
     *
     * Die **GetUserDetails**-Aktion gibt einen Datensatz mit Informationen zum Benutzer zurück.
     *
     * Der Datensatz enthält folgende Werte:
     * - **username**: aktueller Benutzername.
     * - **displayname**: zusammengesetzter Name aus Nachname und Vorname.
     * - **firstname**: Vorname des Benutzers.
     * - **lastname**: Nachname des Benutzers.
     * - **email**: E-Mail-Adresse des Benutzers.
     *
     * @param TEXT $username Gibt den entsprechenden Benutzernamen an.
     *
     * @return DATASET Gibt einen Datensatz mit den Informationen zum Benutzer zurück.
     */
    class GetUserDetails extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetUserDisplayName-Aktion
     *
     * Die **GetUserDisplayName**-Aktion gibt den Anzeigenamen zum angegebenen Benutzer zurück.
     *
     * @param TEXT $username Gibt den Benutzernamen an.
     *
     * @return SINGLEVALUE Gibt den Anzeigenamen des Benutzers zurück.
     */
    class GetUserDisplayName extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        public function init()
        {
        }
        public function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetUserGroups-Aktion
     *
     *  Die **GetUserGroups**-Aktion gibt eine Liste mit allen Gruppen des angegebenen Benutzers zurück.
     *
     * @param TEXT $username Gibt den Namen des Benutzers an, zu dem die Gruppen zurückgegeben werden sollen.
     *
     * @return DATASET Gibt die Liste mit allen Gruppen und IDs der Gruppen zurück.
     *
     */
    class GetUserGroups extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetUsers-Aktion
     *
     * Die **GetUsers**-Aktion gibt eine Liste mit allen Benutzern auf dem verbundenen Keycloak-Server zurück.
     *
     * @return DATASET Gibt die Liste mit allen Benutzern zurück.
     */
    class GetUsers extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetUsersByGroupId-Aktion
     *
     * Die **GetUsersByGroupId**-Aktion gibt alle Benutzer einer Benutzergruppe mit der angegebenen ID zurück.
     *
     * @param TEXT $Id Gibt die ID der Benutzergruppe an.
     *
     * @return DATASET Gibt eine Liste der Benutzer in der Benutzergruppe zurück.
     */
    class GetUsersByGroupId extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetUsersByGroupName-Aktion
     *
     * Die **GetUsersByGroupName**-Aktion gibt eine Liste mit allen Benutzern in einer Benutzergruppe mit dem angegebenen
     * Namen zurück.
     *
     * @param TEXT $Name Gibt den Namen der Benutzergruppe an.
     *
     * @return DATASET Gibt eine Liste der Benutzer zurück.
     */
    class GetUsersByGroupName extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\properties {
    /**
     * Set-Aktion
     *
     * Die **Set**-Aktion legt die Eigenschaft einer Komponente auf den angegebenen Wert fest.\
     * Die Komponente wird anschließend neu gerendert.
     *
     * @param COMPONENT $Component Gibt die Komponente an, die aktualisiert werden soll.
     * @param TEXT $Name Gibt den Namen der Eigenschaft an.
     * @param TEXT $Value Gibt den Wert an, auf den die Eigenschaft festgelegt werden soll.
     */
    class Set extends \edoc\appserver\app\AbstractAction
    {
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
        protected function execParamAction($param, ?\edoc\appserver\app\AbstractAction &$action = null)
        {
        }
    }
    /**
     * SetDisabled-Aktion
     *
     * Mit der **SetDisabled**-Aktion können Sie die ausgewählte Komponente aktivieren oder deaktivieren.\
     * Sie können nur Komponenten deaktivieren, die über das HTML-Standardattribut **disable** verfügen.
     *
     * @param COMPONENT $Target Gibt die Komponente an, die entweder aktiviert oder deaktiviert werden soll.
     * @param SELECT $Disabled Gibt folgende Werte an:
     * - **true**: Deaktiviert die Komponente.
     * - **false**: Aktiviert die Komponente.
     */
    class SetDisabled extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DisableParameterActionValidation;
        public static function addJSCallbacks()
        {
        }
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * SetVisibility-Aktion
     *
     * Mit der **SetVisibility**-Aktion können Sie die Sichtbarkeit der angegebenen Komponente ändern.
     *
     * @param COMPONENT $Target Gibt die Komponente an, die die Sichtbarkeit geändert werden soll.
     * @param SELECT $Visibility Gibt folgende Werte an:
     * - **true**: Komponente ist sichtbar.
     * - **false**: Komponente ist unsichtbar.
     */
    class SetVisibility extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DisableParameterActionValidation;
        public static function addJSCallbacks()
        {
        }
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib {
    /**
     * RawText-Aktion
     *
     * Die **RawText**-Aktion gibt den angegebenen Text zurück.
     *
     * @param TEXT $text Gibt den Text an.
     *
     * @return SINGLEVALUE Gibt den Wert des Texts zurück.
     */
    class RawText extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\route {
    /**
     * GetParam-Aktion
     *
     * Die **GetParam**-Aktion gibt den angegebenen Parameter der aktuellen Route der aufgerufenen Views zurück.
     *
     * Die zurückgegebenen Werte können außerdem automatisch überprüft werden.
     *
     * @param TEXT $name Gibt die Bezeichnung des Parameters in der Route an.
     * @param SELECT $validation_type Gibt den Typ der Validierung an, der für den Wert des Parameters verwendet werden soll.
     * Folgende Validierungstypen gibt es: **Number**, **Text**, **Regex**.
     * @param TEXT $validation_pattern Gibt das Muster der Validierung an, das für den Wert des Parameters verwendet werden soll.
     * Der ausgewählte Validierungstyp bestimmt, welche Werte Sie eintragen müssen, damit die Validierung durchgeführt wird.
     * Sie können mehrere Werte durch ein Semikolon getrennt eingeben.
     * - **Number**: Erlaubt sind Zahlen und Bereiche (range). Beispiel: **1**; **2-5**
     * - **Text**: Erlaubt sind Buchstaben und Kombinationen von Buchstaben, Zahlen und Sonderzeichen. Beispiel: **Text**; **"Text1: (%)"**; **'"Text1": (?)'**
     * - **Regex**: Erlaubt sind reguläre Ausdrücke. Als Start- und Endzeichen sind alle Standardtrennzeichen (Delimiters) für reguläre Ausdrücke erlaubt. Beispiel für mehrere Zahlen: **@\d+@**.
     *
     * @return SINGLEVALUE Gibt den Wert des Parameters zurück.
     */
    class GetParam extends \edoc\appserver\app\actions\AbstractParameterValidationAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        const PARAM_NAME = 'name';
        public function init()
        {
        }
        public function loadParameter(?\edoc\appserver\app\EntityWithRoutes $entity, array $currentParameter): array
        {
        }
        /**
         * @throws \Exception
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetURL-Aktion
     *
     * Mit der **GetURL**-Aktion erzeugen Sie aus einer Route eine URL, die direkt aufgerufen werden kann.
     *
     * @param VIEWROUTE $Route Gibt die ausgewählte Route einer Views an.
     *
     * @return SINGLEVALUE Gibt die erzeugte URL aus der Route zurück.
     */
    class GetURL extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\script\api {
    abstract class AbstractPHPAction extends \edoc\appserver\app\actions\MessageAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function launch($script, $callback = false, $parameter = [])
        {
        }
        protected function result($json)
        {
        }
    }
}
namespace edoc\appserver\ScriptAPI {
    class Action
    {
        public static function getInstance()
        {
        }
        /**
         * Execute a action
         * @param string $actionName The name of the action
         * @param array $params
         * @param array $return
         *
         * @return null
         * @throws \ReflectionException
         */
        public function exec($actionName, $params = [], array $return = [])
        {
        }
        /**
         * Get Datasource (d.3/db/...)
         * @param $name
         *
         * @return DataSource|null
         * @throws \Exception
         */
        public function getDatasource($name): ?\edoc\appserver\datasources\DataSource
        {
        }
        public function getAppVariables()
        {
        }
        public function getAppVariable($name)
        {
        }
        public function info()
        {
        }
        public static function setReturnValue($value)
        {
        }
        public function returnValue($value)
        {
        }
        public static function setReturnDataset($dataset)
        {
        }
        public function returnDataset($dataset)
        {
        }
        public static function getResponseType()
        {
        }
        public static function getResponse()
        {
        }
    }
    abstract class Callback
    {
        protected $api;
        public static function postParams(array $postData)
        {
        }
        public static function postParam($name)
        {
        }
        final public function __construct($parameters = [])
        {
        }
        /**
         * Get parameter with provided name
         * @param $name
         *
         * @return mixed|null
         */
        public function param($name)
        {
        }
        /**
         * Return all provided parameters
         * @return array|mixed
         */
        public function params()
        {
        }
        /**
         * Check if a given parameter was provided
         * @param $name
         *
         * @return bool
         */
        public function paramExists($name)
        {
        }
        abstract public function init();
        abstract public function exec();
    }
}
namespace edoc\appserver\app\actions\lib\script {
    /**
     * PHPCallback-Aktion
     *
     * Die **PHPCallback**-Aktion führt einen Callback der App aus. Der Callback muss als Datei und als Klasse im App-Ordner
     * vorhanden sein.
     *
     * Sie müssen einen Callback von der Klasse `\edoc\appserver\ScriptAPI\Callback` ableiten.
     *
     * **Beispiel**
     * ```php
     * < ?php
     *
     * use edoc\appserver\ScriptAPI\Callback;
     *
     * // Simple example for a callback
     * // The class name must match the file name!
     * class Example extends Callback
     * {
     *   public function init()
     *   {
     *   }
     *   public function exec()
     *   {
     *     $name = $this->param('name');
     *     $this->api->returnValue('Hello ' . $name . '!');
     *   }
     * }
     * ```
     *
     * **Script API**
     * ```php
     * class Action {
     *   // Executes an action.
     *   // @param string $actionName Type of action, e.g. default\\Message.
     *   // @param array $params The parameter for the selected action.
     *   public function exec($actionName, $params);
     *
     *   // Get datasource instance (d.3/db/...)
     *   // @param $name
     *   // @return DataSource|null
     *   public function getDatasource($name): ?DataSource;
     *
     *   // Sets return value of the callback. If called several times, the previous value will be overwritten!
     *   // @param string|int|boolean $value The return value.
     *   public function returnValue($value);
     *
     *   // Sets the return dataset of the callback. If called several times, the previous value will be overwritten!
     *   // @param array $value The return dataset.
     *   public function returnDataset($value);
     *
     *   // Returns information about the current app.
     *   // @return array
     *   public function info();
     *
     *   // Returns all app variables.
     *   // @return array
     *   public function getAppVariables();
     *
     *   // Returns the app variable with the name $name.
     *   // @return mixed
     *   public function getAppVariable($name);
     * }
     *
     * class Callback {
     *   // Returns all parameter passed.
     *   // @return array
     *   public function params();
     *
     *   // Returns the passed parameter with the specified names.
     *   // @return mixed
     *   public function param($name);
     *
     *   // Checks whether a parameter with the name $name was returned. Returns true or false.
     *   // @return boolean
     *   public function paramExists($name);
     *
     *   abstract public function init();
     *   abstract public function exec();
     * }
     * ```
     *
     * @param TEXT $file Gibt den Pfad und den Namen des PHP-Skripts auf dem Server im **plugins**-Verzeichnis der App an.
     * @param KEYVALUELIST $params Gibt die Liste mit dem Namen und Werten der Parameter an, die an den Callback übergeben
     * werden.
     *
     * @return SINGLEVALUE Gibt den Wert des Callbacks zurück.
     * @return DATASET Gibt den Datensatz des Callbacks zurück.
     */
    class PHPCallback extends \edoc\appserver\app\actions\lib\script\api\AbstractPHPAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        use \edoc\appserver\app\actions\DatasetAction;
        public function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
        public function loadCallbacks(?\edoc\appserver\app\components\Component $baseComponent, array $currentParameter)
        {
        }
    }
    /**
     * PHPCode-Aktion
     *
     * Die **PHPCode**-Aktion führt einen PHP-Code aus. Die Daten (**SingleValue** oder **Dataset**) werden über die
     * API-Funktion zurückgegeben.
     *
     * <div class="panel info">
     * **Wichtig**\
     * Jede Aktion wird in einem separaten Kontext ausgeführt, sodass kein Zugriff auf temporäre Daten,
     * Variablen usw. zwischen Aktionen besteht.
     * </div>
     *
     * **Beispiel**
     * ```php
     * <?php
     *
     * use edoc\appserver\ScriptAPI\Action;
     *
     * $data = [];
     * $value = 123;
     * $i = 0;
     * $value = Action::getInstance()->exec('GetValue', ['rows']);
     *
     * for($i = 0; $i < $value; $i++) {
     *   $data[] = [
     *     'value1' => $i,
     *     'value2' => 'col2: '.$i
     *   ];
     * }
     *
     * Action::getInstance()->returnDataset($data);
     * ```
     *
     * **Script API**
     * ```php
     * class Action {
     *   // creates a new instance
     *   public static function getInstance();
     *
     *   // Executes an action.
     *   // @param string $actionName Type of action, e.g. default\\Message.
     *   // @param array $params Parameter for the selected action.
     *   public function exec($actionName, $params);
     *
     *   // Get datasource instance (d.3/db/...)
     *   // @param $name
     *   // @return DataSource|null
     *   public function getDatasource($name): ?DataSource;
     *
     *   // Sets return value of the callback. If called several times, the previous value will be overwritten!
     *   // @param string|int|boolean $value The return value.
     *   public function returnValue($value);
     *
     *   // Sets the return dataset of the callback. If called several times, the previous value will be overwritten!
     *   // @param array $value The return dataset.
     *   public function returnDataset($value);
     *
     *   // Returns information about the current app.
     *   // @return array
     *   public function info();
     *
     *   // Returns all app variables.
     *   // @return array
     *   public function getAppVariables();
     *
     *   // Returns the app variable with the name $name.
     *   // @return mixed
     *   public function getAppVariable($name);
     * }
     * ```
     *
     * @param EDITOR $code Gibt den auszuführenden PHP-Code an.
     *
     * @return SINGLEVALUE Gibt den Wert des Callbacks zurück.
     * @return DATASET Gibt den Datensatz des Callbacks zurück.
     */
    class PHPCode extends \edoc\appserver\app\actions\lib\script\api\AbstractPHPAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        use \edoc\appserver\app\actions\SingleValueAction;
        public function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\session {
    /**
     * Clear-Aktion
     *
     * Die **Clear**-Aktion löscht alle Sitzungsdaten, die Sie mit den **session**-Aktionen in edoc automate festgelegt
     * haben.
     */
    class Clear extends \edoc\appserver\app\AbstractAction
    {
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * Get-Aktion
     *
     * Die **Get**-Aktion gibt den aktuellen Wert einer Sitzungsvariablen zurück, die Sie mit den **session**-Aktionen in
     * edoc automate festgelegt haben.
     *
     * @param TEXT $Name Gibt den Namen der Sitzungsvariable an.
     *
     * @return SINGLEVALUE Gibt den aktuellen Wert der Variablen zurück.
     */
    class Get extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * Set-Aktion
     *
     * Mit der **Set**-Aktion legen Sie einen Wert der angegebenen Sitzungsvariable fest.
     * Die Aktion legt nur den Wert für die Sitzung in edoc automate fest, jedoch nicht auf die PHP-Sitzungsvariablen.
     *
     * @param TEXT $Name Gibt den Namen der Sitzungsvariable an.
     * @param TEXT $Value Gibt den Wert der Variablen an.
     *
     */
    class Set extends \edoc\appserver\app\AbstractAction
    {
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    class UpdateValue extends \edoc\appserver\app\AbstractAction
    {
        public function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions {
    /**
     * Class SetDatasetAction
     *
     * @package edoc\appserver\app\actions
     */
    abstract class SetDatasetAction extends \edoc\appserver\app\AbstractAction
    {
        public const ACTIONKEY = 'dataset';
        // private $datasets = [];
        public static function addJSCallbacks()
        {
        }
        /**
         * @param  $field
         * @param  $dataset
         * @return $this
         * @throws \Exception
         */
        public function returnDataset($field, $dataset)
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib {
    /**
     * SetDataset-Aktion
     *
     * Die **SetDataset**-Aktion füllt eine Komponente (z.B. eine Tabelle) mit einem Datensatz aus einer Aktion (z.B.
     * **database\Query**).
     *
     * ## Rückgabefelder
     * Sie können mit dieser Aktion Rückgabefelder angeben. Die einzelnen Aktionen werden der Reihe nach ausgeführt und der
     * Rückgabewert wird jeweils an ein Rückgabefeld übergeben.
     *
     * Sie können in diesem Fall keine Zuweisung über Feldnamen vornehmen.
     *
     * @param ACTIONLIST $actions Gibt die Liste der einzelnen Aktionen an.
     */
    class SetDataset extends \edoc\appserver\app\actions\SetDatasetAction
    {
        /**
         *
         */
        public function init()
        {
        }
        /**
         * @return AbstractAction
         * @throws \Exception
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * SetValue-Aktion
     *
     * Mit der **SetValue**-Aktion können Sie für eine Komponente oder mehrerer Komponenten einen Wert ändern oder festlegen.
     *
     * ## Rückgabefelder
     * Sie können mit dieser Aktion Rückgabefelder angeben. Die einzelnen Aktionen werden der Reihe nach ausgeführt und der
     * Rückgabewert wird jeweils an ein Rückgabefeld übergeben.
     *
     * Sie können in diesem Fall keine Zuweisung über Feldnamen vornehmen.
     *
     *
     * <div class="panel note">
     * **Gut zu wissen**\
     * Sie können als Parameter auch eine Aktion übergeben, die einen Datensatz zurückgibt. Die Spaltennamen des Datensatzes
     * müssen in diesem Fall den zu füllenden Komponenten entsprechen. Die angegebenen Komponenten in den Rückgabefeldern
     * werden dann ignoriert.
     * </div>
     *
     * <div class="panel warning">
     * Sie müssen den vollständigen Namen der Komponente im Datensatz angeben, z.B.: `table1.input1`.
     * </div>
     *
     * @param VALUELIST $value Gibt eine Liste von Werten (befüllbar mit Aktionen) an.
     */
    class SetValue extends \edoc\appserver\app\actions\SetValueAction
    {
        /**
         *
         */
        public function init()
        {
        }
        /**
         * @return AbstractAction
         * @throws \Exception
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
        protected function execParamAction($param, ?\edoc\appserver\app\AbstractAction &$action = null)
        {
        }
    }
    /**
     * SwitchCase-Aktion
     *
     * Mit der **SwitchCase**-Aktion kann ein Rückgabewert einer Aktion ausgewertet werden, um abhängig vom Wert
     * unterschiedliche Aktionen auszuführen.
     * Wenn mehrere Aktionen zu einem Wert ausgeführt werden sollen, können Sie diesen Fall z.B. mit der
     * Aktion **default\ActionGroup** umsetzen.
     *
     * ## Bedingungen
     * Wenn der Parameter **Case Expressions** auf **Enabled** festgelegt wird, werden die einzelnen Fälle mit erweiterten
     * Bedingungen geprüft.
     * Mögliche Operatoren für die Bedingungen sind:
     * - **\<|\<=|>|>= \<wert>**
     * - **!\<wert>**
     * - **IN(\<wert1>,\wert2>,...)**
     * - **!IN(\<wert1>,\<wert2>,...)**
     * - **[default]**: Wird ausgeführt, wenn kein anderer Fall zutrifft. Weitere Fälle werden nicht überprüft.
     *
     * @param ACTION $CheckValue Gibt den zu prüfenden Wert an. Sie müssen eine Aktion angeben, die **SingleValue**
     * zurückgibt.
     * @param KEYACTIONLIST $Cases Gibt eine Liste mit den einzelnen Fällen an:
     * - **Key**: Der Wert, mit dem die Rückgabe der Aktion im **CheckValue**-Parameter verglichen wird.
     * - **Value**: Die Aktion, die ausgeführt wird, wenn der Fall zutrifft.
     * @param SELECT $Case_Expressions Gibt an, ob die Werte mit verschiedenen Bedingungen geprüft werden.
     */
    class SwitchCase extends \edoc\appserver\app\AbstractAction
    {
        protected function init()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\user {
    /**
     * CloseModal-Aktion
     *
     * Die **CloseModal**-Aktion schließt das aktuell geöffnete Modal. Das Modal muss zuvor mit **user\OpenModal** geöffnet
     * worden sein.
     *
     * Sie können die Daten **Result_Data** mit **user\GetResultData** anfragen.
     *
     * @param TEXT $Result_Data Gibt die Daten an, die als Ergebnis des Modals zurückgegeben werden können.
     */
    class CloseModal extends \edoc\appserver\app\AbstractAction
    {
        public const ACTIONKEY = 'closemodal';
        public const EVENTCLOSE = 'modal-close';
        public static function addJSCallbacks()
        {
        }
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * Confirm-Aktion
     *
     * Die **Confirm**-Aktion öffnet einen Bestätigungsdialog mit dem angegebenen Text und den angegebenen Button.
     *
     * Die angegebenen Buttons werden im Dialog angezeigt, und beim Klicken auf die Buttons werden die dazugehörigen
     * Aktionen ausgeführt.
     *
     * Wenn Sie mehrere **Confirm**-Aktionen für einen Button festlegen, z.B. in einer **default\Condition**-Aktion, MÜSSEN
     * Sie den Aktionen einen eindeutigen Namen geben.
     *
     * @param TEXT $Message Gibt den angezeigten Text im Bestätigungsdialog an.
     * @param TEXT $Title Gibt den angezeigten Titel des Bestätigungsdialogs an.
     * @param KEYVALUEACTIONLIST $Buttons Gibt die Konfiguration für die angezeigten Buttons an.
     */
    class Confirm extends \edoc\appserver\app\AbstractAction
    {
        public const ACTIONKEY = 'confirm';
        public static function addJSCallbacks()
        {
        }
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetModalResult-Aktion
     *
     * Mit der **GetModalResult**-Aktion können Sie das Ergebnis des letzten mit **user\OpenModal** geöffneten Dialogs
     * abfragen, der wieder mit der Aktion **user\CloseModal** geschlossen wurde.
     *
     * @return SINGLEVALUE Gibt den Wert zurück, den Sie in der **user\CloseModal**-Aktion festgelegt haben.
     */
    class GetModalResult extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * OpenModal-Aktion
     *
     * Die **OpenModal**-Aktion öffnet eine View in einem Modal.
     *
     * @param VIEWROUTE $View Gibt die Route zur View an, die im Modal angezeigt werden soll
     * @param ACTIONLIST $Close_Actions Gibt die Aktionen an, die beim Schließen des Modals ausgeführt werden.
     * @param SELECT $Size Gibt die Größe des zu öffnenden Modals an. Mögliche Werte: **auto**, **small**, **large** und
     * **full**
     * @param SELECT $Backdrop_Click Gibt an, ob das Modal mit einem Klick auf den Hintergrund geschlossen wird.
     */
    class OpenModal extends \edoc\appserver\app\AbstractAction
    {
        public const ACTIONKEY = 'openmodal';
        public const EVENTCLOSE = 'modal-close';
        public const BACKDROP_CLICK_ON = 'on';
        public const BACKDROP_CLICK_OFF = 'off';
        public static function addJSCallbacks()
        {
        }
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\utils {
    /**
     * Calc-Aktion
     *
     * Die **Calc**-Aktion berechnet die im Parameter **Formula** angegebene Formel.
     *
     * Beachten Sie Folgendes, wenn Sie eine Formel erstellen:
     * - **Dezimalzahlen**: Dezimalzahlen in der Formel müssen mit einem Punkt (**.**) angegeben werden. Beispiel: 5.2
     * - **Variablen**: In der Formel können Variablen verwendet werden. Der Name darf nur Buchstaben (a-z) enthalten. Der
     *   Wert für die Variable muss numerisch sein.
     * - **Funktionen**: Sie können in der Formel folgende mathematischen Funktionen verwenden: **abs**, **aCos**, **aCosH**
     *   , **aSin**, **aSinH**, **aTan**, **aTanH**, **aTanTwo**, **ceil**, **cos**, **cosH**, **degToRad**, **en**, **exp**
     *   , **expMOne**, **floor**, **fMod**, **intVal**, **hypot**, **log**, **logOneP**, **logTen**, **max**, **min**,
     *   **pow**, **radToDeg**, **round**, **sin**, **sinH**, **sqrt**, **tan**, **tanH**
     * - **Konstanten**: Sie können in der Formel folgende Konstanten verwenden: **e**, **euler**, **lnPi**, **lnTen**,
     *   **lnTwo**, **logTenE**, **logTwoE**, **onePi**, **pi**, **piFour**, **piTwo**, **sqrtOneTwo**, **sqrtPi**,
     *   **sqrtThree**, **sqrtTwo**, **twoPi**, **twoSqrtPi**
     *
     * @param TEXT $Formula Gibt die zu berechnende Formel an.
     * @param KEYVALUELIST $Variables Gibt die Liste mit den Variablen an, die in der Formel verwendet werden.
     *
     * @return SINGLEVALUE Gibt das berechnete Ergebnis der Formel zurück.
     */
    class Calc extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * CombineDatasets-Aktion
     *
     * Mit der **CombineDatasets**-Aktion können Sie die angegebenen Datensätze (Datasets) zusammenführen und in einem neuen
     * Datensatz zurückgeben.
     *
     * @param ACTIONLIST $datasets Gibt Aktionen an, die jeweils einen Datensatz zurückgeben.
     *
     * @return DATASET Gibt den zusammengeführten Datensatz zurück.
     */
    class CombineDatasets extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        /**
         *
         */
        public function init()
        {
        }
        /**
         * @return AbstractAction
         * @throws \Exception
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * Concat-Aktion
     *
     * Die **Concat**-Aktion fügt die als Parameter angegebenen Werte der Reihe nach aneinander.
     *
     * @param VALUELIST $Kein_Name Gibt die Liste der zu verbindenden Werte an.
     *
     * @return SINGLEVALUE Gibt den zusammengesetzten Wert zurück.
     */
    class Concat extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        /**
         *
         */
        public function init()
        {
        }
        /**
         * @return AbstractAction
         * @throws Exception
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * DatasetFromCSV-Aktion
     *
     * Die **DatasetFromCSV**-Aktion erzeugt aus einem CSV-String (Zeichenfolge) einen Datensatz, der an andere Aktionen
     * übergeben werden kann.
     *
     * @param EDITOR $CSV Gibt den umzuwandelnden CSV-String an.
     * @param TEXT $Delimiter Gibt das Trennzeichen für die Werte im CSV-String an.
     *
     * @return DATASET Gibt einen Datensatz mit den Werten aus dem CSV-String zurück.
     */
    class DatasetFromCSV extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * DatasetFromJSON-Aktion
     *
     * Die **DatasetFromJSON**-Aktion erzeugt aus einem JSON-String (Zeichenfolge) einen Datensatz, der an andere Aktionen
     * übergeben werden kann.
     *
     * @param TEXT $JSON Gibt den umzuwandelnden JSON-String an.
     *
     * @return DATASET Gibt den Datensatz mit den Werten aus dem JSON-String zurück.
     */
    class DatasetFromJSON extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * DatasetToJSON-Aktion
     *
     * Die **DatasetToJSON**-Aktion wandelt einen übergebenen Datensatz in ein JSON-String (Zeichenfolge) um.
     *
     * @param ACTION $Dataset Gibt eine Aktion an, die einen beliebigen Datensatz angibt.
     *
     * @return SINGLEVALUE Gibt den erzeugten JSON-String zurück.
     */
    class DatasetToJSON extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * DateDiff-Aktion
     *
     * Mit der **DateDiff**-Aktion können Sie die Differenz in Tagen zwischen zwei Daten berechnen.
     *
     * @param TEXT $Start Gibt das Startdatum an.
     * @param TEXT $End Gibt das Enddatum an.
     *
     * @return SINGLEVALUE Gibt die Differenz in Tagen zurück.
     */
    class DateDiff extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * FilterDataset-Aktion
     *
     * Die **FilterDataset**-Aktion gibt einen neuen Datensatz zurück, der nur die angegebenen Spalten in der angegebenen
     * Reihenfolge enthält.
     *
     * @param ACTION $Dataset Gibt eine Aktion an, die einen Datensatz zurückgibt.
     * @param VALUELIST $Columns Gibt eine Liste mit den Namen der zu übernehmenden Spalten an.
     * @param SELECT $Filter_Type Gibt an, ob die angegebenen Spalten enthalten sein sollen oder ob ausgewählte Spalten ausgeschlossen werden.
     *
     * @return DATASET Gibt den erzeugten Datensatz zurück.
     */
    class FilterDataset extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
        /**
         * @param array $columns
         * @param array $dataset
         * @return array
         */
        protected function includeColumns(array $columns, array $dataset): array
        {
        }
        /**
         * @param array $columns
         * @param array $dataset
         * @return array
         */
        protected function excludeColumns(array $columns, array $dataset): array
        {
        }
    }
    /**
     * HelpFunction-Aktion
     *
     * Mit der **HelpFunction**-Aktion können Sie verschiedene PHP-Funktionen aufrufen.
     *
     * **Funktionen mit variabler Anzahl von Parametern**\
     * Es gibt Funktionen, denen eine variable Anzahl von Parametern übergeben werden kann, z.B. **sprintf**.\
     * Bei den entsprechenden Parametern muss der Name nummeriert werden. Aus **values** wird dann **value1**, **value2**
     * usw.
     *
     * **Funktionen freischalten**\
     * Sie können zusätzliche Funktionen hinzufügen, die Sie in der Aktion dann auswählen können. Die Funktion müssen Sie in
     * der Systemkonfiguration von edoc automate im Bereich **actions.helper** angeben. Weitere Informationen finden Sie in
     * der Hilfe zu edoc automate.
     *
     * **Einschränkungen**
     * - Sie können nur Funktionen verwenden, die bei allen Parametern eine Zeichenfolge (String) oder eine Zahl übergeben
     *   werden.
     * - Sie können nur PHP-Funktionen verwenden, die eine Zeichenfolge (String) oder eine Zahl zurückgeben. Arrays, Objekte
     *   usw. werden nicht unterstützt.
     *
     * **Beispiel**
     * ```php
     * <?php
     *
     * return  [
     *   'actions' => [
     *      'helper' => [
     *          'mb_convert_case' => [
     *              'function' => 'mb_convert_case',
     *              'params' => [
     *                  'default' => [
     *                      'mode' => 'MB_CASE_UPPER'
     *                  ]
     *              ]
     *          ]
     *      ]
     *   ]
     * ];
     * ```
     *
     * @return SINGLEVALUE Gibt den Wert der aufgerufenen Funktion zurück.
     */
    class HelpFunction extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        public function loadParameters(?\edoc\appserver\app\AppEntity $entity, array $currentParameter): array
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * TriggerEvent-Aktion
     *
     * Die **TriggerEvent**-Aktion löst ein bestimmtes Event auf einer Komponente aus.
     *
     * @param COMPONENT $Target Gibt die Komponente an, auf der das Event getriggert werden soll.
     * @param SELECT $Event Gibt folgende zu triggernde Events an:\
     * **change**, **click**, **keyup**
     *
     */
    class TriggerEvent extends \edoc\appserver\app\AbstractAction
    {
        public static function addJSCallbacks()
        {
        }
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * Uuid-Aktion
     *
     * Die **Uuid**-Aktion erzeugt eine UUID.
     *
     * @return SINGLEVALUE Gibt die erzeugte UUID zurück.
     */
    class Uuid extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\variables {
    /**
     * Get-Aktion
     *
     * Die **Get**-Aktion gibt den Wert einer Variable zurück.\
     * Sie müssen die Variable mit der Aktion **variables\Set** festlegen.
     *
     * @param TEXT $name Gibt den Namen der Variablen an.
     *
     * @return SINGLEVALUE Gibt den aktuellen Wert der Variablen zurück.
     */
    class Get extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        // use DatasetAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\variables\lib {
    class Storage
    {
        public static function set($name, $value)
        {
        }
        public static function get($name)
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\variables {
    /**
     * Set-Aktion
     *
     * Die **Set**-Aktion legt den Wert einer Variablen fest.\
     * Sie können den Wert mit der Aktion **variables\Get** auslesen.\
     * Der Wert wird nicht dauerhaft gespeichert und ist immer nur für die Dauer des aktuellen Events oder Requests
     * (Anforderung) verfügbar.
     *
     * @param TEXT $name Gibt den Namen der Variablen an.
     * @param TEXT $value Gibt den festzulegenden Wert an.
     */
    class Set extends \edoc\appserver\app\AbstractAction
    {
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\workflow {
    /**
     * AbortInstance-Aktion
     *
     * Die **AbortInstance**-Aktion bricht die angegebene Instanz des Flows ab.
     *
     * @param TEXT $FlowInstance Gibt die abzubrechende Instanz-ID des Flows an. Wenn kein Wert übergeben wird, wird die
     * Instanz der aktuellen Aufgabe (Task) verwendet.
     *
     * @return SINGLEVALUE Gibt den Wert **true** zurück, wenn die Flowinstanz erfolgreich abgebrochen wurde.\
     * Gibt den Wert **false** zurück, wenn die Flowinstanz nicht abgebrochen werden kann.
     */
    class AbortInstance extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app\actions {
    abstract class WorkflowAction extends \edoc\appserver\app\AbstractAction
    {
        public function run(int $executionMethod = \edoc\appserver\app\ActionExecutionMethod::UNKNOWN): \edoc\appserver\app\AbstractAction
        {
        }
        protected function getClient(): \GuzzleHttp\Client
        {
        }
        protected function requireFlowContext()
        {
        }
        protected function setFlowContextRequired($required = true)
        {
        }
        protected function getFlowInstanceUuid()
        {
        }
        protected function getTaskUuid()
        {
        }
        protected function getVariables()
        {
        }
        protected function getVariable($name)
        {
        }
        protected function getFlowDetails()
        {
        }
        protected function getAllAppFlowVariables()
        {
        }
    }
}
namespace edoc\appserver\app\actions\lib\workflow {
    /**
     * BackToWorkplace-Aktion
     *
     * Die **BackToWorkplace**-Aktion leitet einen Benutzer direkt zurück in die persönliche Aufgabenübersicht (Workplace).
     *
     */
    class BackToWorkplace extends \edoc\appserver\app\actions\WorkflowAction
    {
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * CloseTask-Aktion
     *
     * Die **CloseTask**-Aktion beendet den aktuellen Task (Aufgabe) in der Workflowinstanz.
     *
     * @param SELECT $Redirect Legt fest, was nach dem Beenden des Tasks passiert. Es gibt folgende Werte:
     * - **none** bedeutet, dass nichts passiert.
     * - **url** bedeutet, es findet eine Weiterleitung zur angegeben URL statt.
     * - **auto** bedeutet, es findet eine Weiterleitung zum persönlichen Workplace statt.
     *
     * @param TEXT $Url Gibt die URL für den **Redirect**-Parameter an.
     *
     * @return SINGLEVALUE Gibt zurück, ob die Aufgabe geschlossen wurde (**true**) oder nicht (**false**).
     */
    class CloseTask extends \edoc\appserver\app\actions\WorkflowAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * CreateInstance-Aktion
     *
     * Die **CreateInstance**-Aktion erzeugt eine neue Instanz des angegebenen Workflows.\
     * Sie müssen die angegebenen Variablen beim Erstellen des Flows bereits definiert haben.
     *
     * @param WORKFLOW $Flow Gibt den zu startenden Flow an.
     * @param TEXT $DocumentId Gibt eine Dokument-ID bei dokumentengebundenen Flows an.
     * @param KEYVALUELIST $Variables Gibt eine Liste mit den Workflowvariablen und deren initialen Werten an.
     *
     * @return SINGLEVALUE Gibt die Flowinstanz-ID zurück. Bei einem Fehler wird **false** zurückgegeben.
     *
     */
    class CreateInstance extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
        public function loadVariables(?\edoc\appserver\app\AppEntity $entity, array $currentParameter): array
        {
        }
    }
    /**
     * Delegate-Aktion
     *
     * Die **Delegate**-Aktion delegiert einen Task (Aufgabe) einer Flowinstanz an eine andere Person oder Gruppe.
     *
     * @param TEXT $User Gibt die Person an, an die die Aufgabe delegiert wird.
     * @param TEXT $Group Gibt die Gruppe an, an die die Aufgabe delegiert wird.
     * @param TEXT $Subject Gibt den Betreff für die neue Aufgabe an.
     * @param SELECT $Redirect Gibt an, was nach dem Delegieren passiert.\
     * Es gibt folgende Werte:
     * - **none** bedeutet, dass nichts passiert.
     * - **url** bedeutet, es findet eine Weiterleitung zur angegeben URL statt.
     * - **auto** bedeutet, es findet eine Weiterleitung zum persönlichen Workplace statt.
     * @param TEXT $Url Gibt die URL für den **Redirect**-Parameter an.
     *
     */
    class Delegate extends \edoc\appserver\app\actions\WorkflowAction
    {
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetFlowTasksForGroup-Aktion
     *
     * Die **GetFlowTasksForGroup**-Aktion lädt alle Einträge eines Gruppenpostkorbes (Aufgaben) für eine bestimmte\
     * Flowdefinition.
     *
     * @param TEXT $Flow Gibt die ID der Flowdefinition an.
     * @param TEXT $Group Gibt den Namen der Gruppe an.
     *
     * @return DATASET Gibt die aktiven Aufgaben der angegebenen Gruppe im angegebenen Workflow zurück.
     */
    class GetFlowTasksForGroup extends \edoc\appserver\app\AbstractAction
    {
        use \edoc\appserver\app\actions\DatasetAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetParameter-Aktion
     *
     * Die **GetParameter**-Aktion ruft Parametern eines Workflows ab.
     *
     * @param SELECT $Parameter Gibt den ausgewählten Parameter an.
     *
     * @return SINGLEVALUE Gibt den Wert des ausgewählten Parameters zurück.
     */
    class GetParameter extends \edoc\appserver\app\actions\WorkflowAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * GetVariable-Aktion
     *
     * Die **GetVariable**-Aktion gibt den Wert einer Workflowvariablen innerhalb einer Instanz zurück.
     *
     * @param TEXT $Name Gibt den Namen der Variablen an.
     *
     * @return SINGLEVALUE Gibt den aktuellen Wert der Variablen zurück.
     */
    class GetVariable extends \edoc\appserver\app\actions\WorkflowAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        const PARAM_NAME = 'Name';
        protected function init()
        {
        }
        public function loadVariables(?\edoc\appserver\app\AppEntity $entity, array $currentParameter): array
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * ResubmitTask-Aktion
     *
     * Mit der **ResubmitTask**-Aktion kann der aktuelle Task bis zum angegebenen Datum zurückgestellt werden.
     *
     * @param TEXT $Date Gibt den Zeitpunkt an, bis zu dem der Task zurückgestellt wird. Datumsformat: JJJJ-MM-DD hh:mm:ss
     * @param SELECT $Redirect Legt fest, was nach dem Zurückstellen des Tasks passiert. Es gibt folgende Werte:
     * - **none** bedeutet, dass nichts passiert.
     * - **url** bedeutet, es findet eine Weiterleitung zur angegeben URL statt.
     * - **auto** bedeutet, es findet eine Weiterleitung zum persönlichen Workplace statt.
     * @param TEXT $Url Gibt die URL für den **Redirect**-Parameter an.
     *
     */
    class ResubmitTask extends \edoc\appserver\app\actions\WorkflowAction
    {
        public const ACTIONKEY = 'taskDelegate';
        protected function init()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * SetFlowInstanceVariable-Aktion
     *
     * Die **SetFlowInstanceVariable**-Aktion legt eine Variable für eine angegebene Flowinstanz fest.
     *
     * @param TEXT $FlowInstanceId Gibt die ID der Flowinstanz an.
     * @param TEXT $Name Gibt den Namen der Variablen an.
     * @param TEXT $Value Gibt den Wert der Variablen an.
     */
    class SetFlowInstanceVariable extends \edoc\appserver\app\actions\WorkflowAction
    {
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    /**
     * SetVariable-Aktion
     *
     * Die **SetVariable**-Aktion legt eine Variable für die aktuelle Flowinstanz fest.
     *
     * @param TEXT $Name Gibt den Namen der Variablen an.
     * @param TEXT $Value Gibt den Wert der Variablen an.
     */
    class SetVariable extends \edoc\appserver\app\actions\WorkflowAction
    {
        const PARAM_NAME = 'Name';
        const PARAM_VALUE = 'Value';
        protected function init()
        {
        }
        public function loadVariables(?\edoc\appserver\app\AppEntity $entity, array $currentParameter): array
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    class ValidateTask extends \edoc\appserver\app\actions\WorkflowAction
    {
        use \edoc\appserver\app\actions\SingleValueAction;
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\app {
    /**
     * Class Actions
     *
     * @package edoc\appserver\app
     */
    class Actions
    {
        /**
         * Actions constructor.
         *
         * @param array $callbacks
         */
        public function __construct(array $callbacks, ?\Monolog\Logger $logger = null)
        {
        }
        /**
         * @return array
         */
        public static function list($addPath = false, ?callable $mapFunc = null, array &$errors = []): array
        {
        }
        public static function listGroups($withPath = false)
        {
        }
        public function setElementValue($value)
        {
        }
        public function exec($executionMethod = \edoc\appserver\app\ActionExecutionMethod::UNKNOWN, ?callable $handleLogging = null, ?\edoc\appserver\app\AppEntity $parent = null): void
        {
        }
        /**
         * @return int
         */
        public function count()
        {
        }
    }
}
namespace edoc\appserver\app\component {
    /**
     * CustomSetDataset-Trait
     *
     */
    abstract class CustomSetDataset extends \edoc\appserver\app\AbstractComponent
    {
        abstract public function returnDataset();
        abstract public static function addJSCallbacks();
    }
    /**
     * DateTimeField-Trait
     *
     */
    trait DateTimeField
    {
        /**
         * @var array[]
         */
        protected $FORMATS = [
            // Dateformats
            'Timestamp' => ['type' => 'datetime', 'format' => 'U', 'flatpickr' => 'U'],
            'DD.MM.YYYY' => ['type' => 'date', 'format' => 'd.m.Y', 'flatpickr' => 'd.m.Y'],
            'DD.MM.YY' => ['type' => 'date', 'format' => 'd.m.y', 'flatpickr' => 'd.m.y'],
            'DDDD, DD.MM.YYYY' => ['type' => 'date', 'format' => 'l, d.m.Y', 'flatpickr' => 'l, d.m.Y'],
            'M/D/YYYY' => ['type' => 'date', 'format' => 'n/j/Y', 'flatpickr' => 'n/j/Y'],
            'DDDD, MMMM D, YYYY' => ['type' => 'date', 'format' => 'l, F j, Y', 'flatpickr' => 'l, F j, Y'],
            'DD/MM/YYYY' => ['type' => 'date', 'format' => 'd/m/Y', 'flatpickr' => 'd/m/Y'],
            'DD/MM/YY' => ['type' => 'date', 'format' => 'd/m/y', 'flatpickr' => 'd/m/y'],
            'DD MMMM YYYY' => ['type' => 'date', 'format' => 'd F Y', 'flatpickr' => 'd F Y'],
            'YYYY-MM-DD' => ['type' => 'date', 'format' => 'Y-m-d', 'flatpickr' => 'Y-m-d'],
            'YY-MM-DD' => ['type' => 'date', 'format' => 'y-m-d', 'flatpickr' => 'y-m-d'],
            // Timeformats
            'hh:mm' => ['type' => 'time', 'format' => 'H:i', 'flatpickr' => 'H:i'],
            'hh:mm:ss' => ['type' => 'time', 'format' => 'H:i:s', 'flatpickr' => 'H:i:S'],
            'h:mm aa' => ['type' => 'time', 'format' => 'h:i A', 'flatpickr' => 'h:i K'],
            'h:mm:ss aa' => ['type' => 'time', 'format' => 'h:i:s A', 'flatpickr' => 'h:i:S K'],
            // Datetimeformats
            'DD.MM.YYYY hh:mm' => ['type' => 'datetime', 'format' => 'd.m.Y H:i', 'flatpickr' => 'd.m.Y H:i'],
            'DD.MM.YYYY hh:mm:ss' => ['type' => 'datetime', 'format' => 'd.m.Y H:i:s', 'flatpickr' => 'd.m.Y H:i:S'],
            'DD.MM.YY hh:mm' => ['type' => 'datetime', 'format' => 'd.m.y H:i', 'flatpickr' => 'd.m.y H:i'],
            'DD.MM.YY hh:mm:ss' => ['type' => 'datetime', 'format' => 'd.m.y H:i:s', 'flatpickr' => 'd.m.y H:i:S'],
            'M/D/YYYY h:mm aa' => ['type' => 'datetime', 'format' => 'n/j/Y g:i A', 'flatpickr' => 'n/j/Y h:i K'],
            'M/D/YYYY h:mm:ss aa' => ['type' => 'datetime', 'format' => 'n/j/Y g:i:s A', 'flatpickr' => 'n/j/Y h:i:S K'],
            'DD/MM/YYYY hh:mm' => ['type' => 'datetime', 'format' => 'd/m/Y H:i', 'flatpickr' => 'd/m/Y H:i'],
            'DD/MM/YYYY hh:mm:ss' => ['type' => 'datetime', 'format' => 'd/m/Y H:i:s', 'flatpickr' => 'd/m/Y H:i:S'],
            'DD/MM/YY hh:mm' => ['type' => 'datetime', 'format' => 'd/m/y H:i', 'flatpickr' => 'd/m/y H:i'],
            'DD/MM/YY hh:mm:ss' => ['type' => 'datetime', 'format' => 'd/m/y H:i:s', 'flatpickr' => 'd/m/y H:i:S'],
            'DD MMMM YYYY hh:mm' => ['type' => 'datetime', 'format' => 'd F Y H:i', 'flatpickr' => 'd F Y H:i'],
            'DD MMMM YYYY hh:mm:ss' => ['type' => 'datetime', 'format' => 'd F Y H:i:s', 'flatpickr' => 'd F Y H:i:S'],
            'YYYY-MM-DD hh:mm' => ['type' => 'datetime', 'format' => 'Y-m-d H:i', 'flatpickr' => 'Y-m-d H:i'],
            'YYYY-MM-DD hh:mm:ss' => ['type' => 'datetime', 'format' => 'Y-m-d H:i:s', 'flatpickr' => 'Y-m-d H:i:S'],
            'YY-MM-DD hh:mm' => ['type' => 'datetime', 'format' => 'y-m-d H:i', 'flatpickr' => 'y-m-d H:i'],
            'YY-MM-DD hh:mm:ss' => ['type' => 'datetime', 'format' => 'y-m-d H:i:s', 'flatpickr' => 'y-m-d H:i:S'],
            'YYYY-MM-DDThh:mm:ss.uuu+hh:mm' => ['type' => 'datetime', 'format' => 'Y-m-d\TH:i:s.v P', 'flatpickr' => 'Y-m-d\TH:i:S.000 $date(p)$'],
        ];
        protected array $defaults = [self::BACKEND_FORMAT => 'YYYY-MM-DD', self::FRONTEND_FORMAT => 'DD.MM.YYYY', self::TYPE => 'DD.MM.YYYY'];
        /**
         * @return array
         */
        protected function supportedFormats(): array
        {
        }
        protected function convert(string $sourceFormat, string $targetFormat, mixed $value): string
        {
        }
        public function getFormatKey($format, $type = self::BACKEND_FORMAT): string
        {
        }
        /**
         * @param string $key
         * @return array|null
         */
        protected function getFormat(string $key, $format = self::BACKEND_FORMAT): string
        {
        }
        /**
         * @return void
         */
        public function initDateTime()
        {
        }
    }
    interface DateTimeInterface
    {
        const BACKEND_FORMAT = 'format';
        const FRONTEND_FORMAT = 'flatpickr';
        const TYPE = 'type';
    }
    /**
     * Disableable-Trait
     *
     * @param BOOLEAN $Disabled Gibt an, ob die Komponente deaktiviert ist.
     */
    trait Disableable
    {
        public function initDisableable()
        {
        }
        public function isDisabled()
        {
        }
    }
    /**
     * Editable-Trait
     *
     * @param INPUT $Editable Gibt an, ob die Komponente editierbar ist.
     */
    trait Editable
    {
        public function initEditable()
        {
        }
        protected function isEditable()
        {
        }
    }
    /**
     * PropertyClass-Trait
     *
     * @param INPUT $Class Gibt weitere CSS-Klassen der Komponenten an.
     */
    trait PropertyClass
    {
        public function initPropertyClass()
        {
        }
        public function getClass($classes = [])
        {
        }
    }
    /**
     * PropertyMaxLength-Trait
     *
     * @param INPUT $Max_Length Gibt die maximale Länge für den Wert der Komponente an.
     */
    trait PropertyMaxLength
    {
        public function initPropertyMaxLength()
        {
        }
        public function getMaxLength($default = "")
        {
        }
    }
    /**
     * Visibility-Trait
     *
     * @param BOOLEAN $Visibility Gibt an, ob die Komponente sichtbar ist.
     */
    trait Visibility
    {
        public function initVisibility()
        {
        }
        protected function isVisible()
        {
        }
    }
}
namespace edoc\appserver\app {
    /**
     * Class Component
     *
     * @package edoc\appserver\app
     */
    class Component
    {
        public function __construct()
        {
        }
        public function handleApiRequest(\edoc\appserver\core\AppLoader $al, string $method, array $params): void
        {
        }
        public function handleUpdateRequest(\edoc\appserver\core\AppLoader $al, array $params): void
        {
        }
        /**
         *
         */
        public static function list($returnObject = false)
        {
        }
        public static function findPath($componentName)
        {
        }
        public static function render($type, $value, $properties)
        {
        }
        /**
         * @param  AbstractComponent $parent
         * @param  array             $config
         * @param  $mode
         * @return bool|AbstractComponent
         * @throws \Exception
         */
        public static function createComponent(?\edoc\appserver\app\AbstractComponent &$parent, array $config, $mode = \edoc\appserver\app\AbstractComponent::MODE_DEFAULT, \Monolog\Logger $logger = null): ?\edoc\appserver\app\AbstractComponent
        {
        }
        public static function addHeadScriptFile($component, $file, $type, $app = null)
        {
        }
        public static function getHeadScriptFiles(): array
        {
        }
        public static function appendScriptFile($component, $file, $type, $app = null)
        {
        }
        public static function getAppendScripts($withoutFiles = false, $raw = false): array
        {
        }
        public static function clearAppendScripts()
        {
        }
        public static function appendScript($script, $type)
        {
        }
        public static function appendStylesheet($component, $file, $app = null)
        {
        }
        public static function getAppendStylesheets(): array
        {
        }
    }
    interface ComponentInstanceValue
    {
    }
    class Config
    {
        public const DEFAULT_ID = 'default';
        /**
         * @param  App|null   $app
         * @param  array|null $config
         * @return Config
         */
        public static function &getInstance(\edoc\appserver\App $app = null, array $config = null)
        {
        }
        public function get($key, $default = null)
        {
        }
        /**
         * @param array $config
         */
        public function update(array $config, $key = null)
        {
        }
    }
}
namespace edoc\appserver\app\exceptions {
    class AutomateException extends \Exception
    {
    }
    class AbstractActionException extends \edoc\appserver\app\exceptions\AutomateException
    {
    }
    class ActionNotFoundException extends \edoc\appserver\app\exceptions\AbstractActionException
    {
        public function __construct(private readonly array $action, private readonly ?\edoc\appserver\app\AbstractComponent $parent, string $message = "", int $code = 0, ?\Throwable $previous = null)
        {
        }
    }
    class ComponentNotRenderedException extends \edoc\appserver\app\exceptions\AutomateException
    {
        public function __construct(private array $component, string $message = "", int $code = 0, ?\Throwable $previous = null)
        {
        }
        public function getComponentId(): string
        {
        }
        public function getComponentData(): array
        {
        }
    }
    class ComposerException extends \Exception
    {
        public function __construct(private string $stdout, private string $stderr, private int $retVal = 0, private string $command = "")
        {
        }
        public function getStdout(): string
        {
        }
        public function getStderr(): string
        {
        }
        public function getCommand(): string
        {
        }
        public function getRetVal(): int
        {
        }
    }
    class DataSourceException extends \edoc\appserver\app\exceptions\AutomateException
    {
        public string $dataSourceName;
        public function __construct(string $message = "", int $code = 0, ?\Throwable $previous = null, string $dataSourceName = "")
        {
        }
    }
    class EdocServiceException extends \edoc\appserver\app\exceptions\AutomateException
    {
    }
    class EdocDatahubServiceException extends \edoc\appserver\app\exceptions\EdocServiceException
    {
        public function __construct(array $data)
        {
        }
    }
    class InvalidActionConfigurationException extends \edoc\appserver\app\exceptions\AbstractActionException
    {
        public function __construct(private readonly array $action, private readonly ?\edoc\appserver\app\AbstractComponent $parent, string $message = "", int $code = 0, ?\Throwable $previous = null)
        {
        }
    }
    class InvalidActionReturnTypeException extends \Exception
    {
    }
    class InvoiceAppException extends \edoc\appserver\app\exceptions\AutomateException
    {
    }
}
namespace edoc\appserver\app\integrations {
    abstract class AbstractIntegration
    {
        use \edoc\appserver\app\ExecParamAction;
        public function __debugInfo(): ?array
        {
        }
        public function parent(): ?\edoc\appserver\app\AbstractComponent
        {
        }
        protected function logger(): ?\Monolog\Logger
        {
        }
        public static function list(): array
        {
        }
        public function toArray(): array
        {
        }
        public static function create(array $config, ?\edoc\appserver\App $app): ?\edoc\appserver\app\integrations\AbstractIntegration
        {
        }
        public function tryDeploy($onSave = false)
        {
        }
        public function tryUndeploy()
        {
        }
        public const PARAM_TYPE_TEXT = 'text';
        public const PARAM_TYPE_LINK = 'link';
        public const PARAM_TYPE_SELECT = 'select';
        public const PARAM_TYPE_CODE = 'code';
        public const PARAM_TYPE_PERMISSION = 'permission';
        final public function __construct($config = [], ?\edoc\appserver\App $app = null)
        {
        }
        abstract protected function init(): void;
        public function status(): \edoc\appserver\app\integrations\Status
        {
        }
        protected function deploy(): void
        {
        }
        protected function undeploy(): void
        {
        }
        public function handleEvent(\edoc\appserver\app\integrations\AppEventTypes $event): void
        {
        }
        protected function app(): ?\edoc\appserver\App
        {
        }
        public function name(): string
        {
        }
        public function setName($name): void
        {
        }
        public function typeName(): string
        {
        }
        public function description(): string
        {
        }
        public function setDescription($desc): void
        {
        }
        public function addParameter(
            string $name,
            #[\JetBrains\PhpStorm\ExpectedValues([self::PARAM_TYPE_TEXT, self::PARAM_TYPE_LINK, self::PARAM_TYPE_CODE, self::PARAM_TYPE_SELECT, self::PARAM_TYPE_PERMISSION])]
            string $type,
            #[\JetBrains\PhpStorm\ArrayShape(["defaultValue" => "string", "options" => "array", "required" => "boolean", "mode" => "string"])]
            array $options = []
        ): void
        {
        }
        public function param(string $name, $default = null)
        {
        }
        protected function updateParametertValue($name, $value): void
        {
        }
        public function updated(): bool
        {
        }
        protected function deployOnSave(): void
        {
        }
        protected function deployOnCron($expression): void
        {
        }
    }
    class Status
    {
        const TYPE_OK = "ok";
        const TYPE_WARNING = "warning";
        const TYPE_ERROR = "error";
        public function __construct()
        {
        }
        public function ok($message): self
        {
        }
        public function warning($message): self
        {
        }
        public function error($message): self
        {
        }
        public function getType(): string
        {
        }
        public function getMessage(): string
        {
        }
    }
}
namespace edoc\appserver\app\logging {
    class ActionLogger
    {
        use \edoc\appserver\app\ExecParamAction;
        public function parent(): ?\edoc\appserver\app\AbstractComponent
        {
        }
        protected function logger(): ?\Monolog\Logger
        {
        }
        public function __construct(private \edoc\appserver\app\AbstractAction $action)
        {
        }
        public function __debugInfo(): ?array
        {
        }
        public function result(): array
        {
        }
        public function addParameter(string $name, mixed $value, ?\edoc\appserver\app\AbstractAction $action, ?string $type): void
        {
        }
        public function updateListParameter(string $name, int $index, mixed $value, ?\edoc\appserver\app\AbstractAction $action): void
        {
        }
        public function addComponentValidation(\edoc\appserver\app\AbstractValidator $validator, string $componentId, bool $result): void
        {
        }
        public function addReturnField(string $componentId): void
        {
        }
        public function addError(string $message, mixed $code): void
        {
        }
        public function success(): void
        {
        }
        public function error(\Throwable $t): void
        {
        }
    }
}
namespace edoc\appserver\app\quickaddaction {
    /**
     *
     */
    class ParameterPreset
    {
        /**
         * @param string|null $paramName
         * @param ParameterPresetValue $paramValue
         */
        public function __construct(private ?string $paramName, private \edoc\appserver\app\quickaddaction\ParameterPresetValue $paramValue)
        {
        }
        /**
         * @return object
         */
        public function toJSON(): object
        {
        }
    }
    abstract class ParameterPresetValue
    {
        protected $value = null;
        public function getValue()
        {
        }
    }
    class ScalarValue extends \edoc\appserver\app\quickaddaction\ParameterPresetValue
    {
        public function __construct($value)
        {
        }
    }
    class StartSelectComponent extends \edoc\appserver\app\quickaddaction\ParameterPresetValue
    {
    }
    class StartSelectReturnField
    {
        /**
         * @return object
         */
        public function toJSON(): object
        {
        }
    }
}
namespace edoc\appserver\app {
    /**
     *
     */
    class QuickAddAction
    {
        /**
         * @param string $group
         * @param string $action
         * @param ParameterPreset[] $parameters
         */
        public function __construct(private string $group, private string $action, private array $parameters)
        {
        }
        /**
         * @param string $name
         * @return $this
         */
        public function setName(string $name): self
        {
        }
        /**
         * @param string $label
         * @return $this
         */
        public function setLabel(string $label): self
        {
        }
        /**
         * @return $this
         */
        public function editAfterCreation(): self
        {
        }
        /**
         * @param StartSelectReturnField[] $presets
         * @return $this
         */
        public function setReturnFieldPresets(array $presets): self
        {
        }
        /**
         * @return object
         */
        public function toJSON(): object
        {
        }
    }
    /**
     * Class Response
     *
     * @package edoc\appserver\app
     */
    class Response
    {
        public static function getInstance()
        {
        }
        public function addHeader($header)
        {
        }
        public function getHeaders($defaults)
        {
        }
        public function addFile($content, $mime = null, $name = null)
        {
        }
        public function getContent()
        {
        }
        /**
         * @param string $type
         * @param array $params
         * @param false $prepend
         */
        public static function addResponse(string $type, array $params, $prepend = false)
        {
        }
        /**
         * @return array
         */
        public static function responseData()
        {
        }
        /**
         *
         */
        public static function clearResponseData()
        {
        }
        /**
         * @param $callbacks
         */
        public static function addJSCallbacks($callbacks)
        {
        }
        /**
         * @return array
         */
        public static function jsCallbacks()
        {
        }
    }
    class Session
    {
        public function setDefaultMode(string $mode, ?string $url = null): void
        {
        }
        public function clearComponentValues($componentName, $clearRouteSession = true): void
        {
        }
        public static function clear(): void
        {
        }
        /**
         * @return Session|null
         */
        public static function getInstance(): ?\edoc\appserver\app\Session
        {
        }
        /**
         * @param string $id
         * @param mixed $value
         *
         * @return void
         */
        public function setElementValue(string $id, $value): void
        {
        }
        /**
         * @param string $id
         * @param $name
         * @param mixed $value
         *
         * @return void
         */
        public function setNamedElementValue(string $id, $name, $value): void
        {
        }
        /**
         * @param  string $id
         * @return mixed
         */
        public function elementValue(string $id): mixed
        {
        }
        public function namedElementValue(string $id, string $name): mixed
        {
        }
    }
}
namespace edoc\appserver\app\tasks {
    /**
     * Class Task
     *
     * @package edoc\appserver\app\tasks
     */
    class Task
    {
        public $lastExecution = 0;
        /**
         * Task constructor.
         *
         * @param array $config
         */
        public function __construct(array $config, ?\Monolog\Logger $logger = null, $lastExecution = 0)
        {
        }
        /**
         * @return bool
         */
        public function wait()
        {
        }
        public function evalTrigger()
        {
        }
        /**
         *
         */
        public function exec(bool $logActions = false)
        {
        }
        /**
         * @return int|mixed
         */
        public function startMode()
        {
        }
        public function updateLastExecution()
        {
        }
        public function historyKey(string $appId): string
        {
        }
    }
    /**
     * Class Trigger
     *
     * @package edoc\appserver\app\tasks
     */
    abstract class Trigger implements \JsonSerializable
    {
        /**
         *
         */
        public const PROP_TYPE_TIME = 'time';
        public const PROP_TYPE_TEXT = 'text';
        public const PROP_TYPE_SELECT = 'select';
        public const PROP_TYPE_FILEPATH = 'filepath';
        /**
         * default check-loop delay
         *
         * @var int
         */
        protected $delay = 100;
        protected $lastExecuted = 0;
        public function jsonSerialize(): mixed
        {
        }
        /**
         * @return mixed
         */
        abstract protected function init();
        /**
         * factory for trigger
         *
         * @param  $config
         * @return bool
         */
        public static function create($config)
        {
        }
        /**
         * @return array
         */
        public static function list()
        {
        }
        /**
         * @return array
         */
        protected function metadata()
        {
        }
        /**
         * @return array
         */
        protected function properties()
        {
        }
        /**
         * @param  $timeout
         * @return bool
         */
        public function changed($timeout)
        {
        }
        /**
         * @return mixed
         */
        abstract protected function check();
        public function evaluate()
        {
        }
        /**
         * @param $Name
         * @param $Description
         * @param $IconName
         */
        protected function setMetadata($Name, $Description, $IconName)
        {
        }
        /**
         * @param $id
         * @param $caption
         * @param $type
         * @param array $options
         */
        protected function addProperty($id, $caption, $type, $options = [])
        {
        }
        protected function getPropertyValue($name)
        {
        }
        public function setLastExecutionTime($time)
        {
        }
    }
}
namespace edoc\appserver\app\tasks\trigger {
    class Cron extends \edoc\appserver\app\tasks\Trigger
    {
        protected function init()
        {
        }
        protected function check()
        {
        }
    }
    /**
     * Class Datetime
     *
     * @package edoc\appserver\app\tasks\trigger
     */
    class Datetime extends \edoc\appserver\app\tasks\Trigger
    {
        /**
         *
         */
        protected function init()
        {
        }
        protected function check()
        {
        }
    }
    /**
     * Class File
     *
     * @package edoc\appserver\app\tasks\trigger
     */
    class File
    {
        /**
         *
         */
        protected function init()
        {
        }
        protected function check()
        {
        }
    }
    class Interval extends \edoc\appserver\app\tasks\Trigger
    {
        protected function init()
        {
        }
        protected function check()
        {
        }
    }
}
namespace edoc\appserver\app\validators {
    /**
     * Regex-Validator
     *
     * Mit dem **Regex**-Validator können Sie den Wert einer Komponente auf einen RegEx prüfen.
     *
     * @param TEXT $expression Gibt den regulären Ausdruck an, auf den geprüft werden soll.
     */
    class Regex extends \edoc\appserver\app\AbstractValidator
    {
        protected function init(): void
        {
        }
        protected function exec($value): bool
        {
        }
    }
    /**
     * Required-Validator
     *
     * Der **Required**-Validator prüft, ob der Wert einer Komponente nicht null oder leer ist.
     */
    class Required extends \edoc\appserver\app\AbstractValidator
    {
        protected function init(): void
        {
        }
        protected function exec($value): bool
        {
        }
    }
}
namespace edoc\appserver\app {
    class WebService extends \edoc\appserver\app\EntityWithRoutes
    {
        public function __construct(array $config, ?\Monolog\Logger $logger = null)
        {
        }
        public function name(): string
        {
        }
        public function description(): string
        {
        }
    }
}
namespace edoc\appserver\app\webservices {
    abstract class AbstractAuthentication
    {
        use \edoc\appserver\app\ExecParamAction;
        public const PARAM_TYPE_TEXT = 'text';
        protected array $parameters;
        protected array $config;
        public function parent(): ?\edoc\appserver\app\AbstractComponent
        {
        }
        protected function logger(): ?\Monolog\Logger
        {
        }
        final public function __construct(array $config = [])
        {
        }
        abstract public function init();
        abstract public function exec(): bool;
        /**
         * Add a parameter for auth
         *
         * @param string $name
         * @param string $type
         *
         * @return void
         */
        public function addParam(string $name, string $type = self::PARAM_TYPE_TEXT): void
        {
        }
        protected function mapParamName($name): string
        {
        }
        /**
         * Get single parameter value
         * @param string $name Name of the parameter
         *
         * @return null|string
         */
        protected function param(string $name)
        {
        }
        /**
         * Get array with all params values
         * @return array
         */
        public function params(): array
        {
        }
        public function parameters(): array
        {
        }
        public static function list()
        {
        }
    }
    abstract class AbstractResponse
    {
        protected $response = [];
        final public function __construct()
        {
        }
        abstract public function init();
        public function setAction(\edoc\appserver\app\AbstractAction $action)
        {
        }
        public function response()
        {
        }
        public function error($data, $status = 500)
        {
        }
        abstract public function responseContent();
        abstract public function errorContent($data);
        protected function setDefaultContentType($type)
        {
        }
    }
}
namespace edoc\appserver\app\webservices\authentication {
    /**
     * Apikey-Authentifizierung
     *
     * Mit der **Apikey**-Authentifizierung werden Anfragen auf einen festgelegten API-Schlüssel geprüft.
     *
     * @param TEXT $HeaderName Gibt den Namen des HTTP-Headers an, der den API-Schlüssel enthält.
     * @param TEXT $ApiKey Gibt den erwarteten API-Schlüssel an.
     *
     */
    class Apikey extends \edoc\appserver\app\webservices\AbstractAuthentication
    {
        public function init()
        {
        }
        public function exec(): bool
        {
        }
    }
    /**
     * Basicauth-Authentifizierung
     *
     * Mit der **Basic-Auth**-Authentifizierung können Sie den Benutzernamen und das Passwort überprüfen.\nTechnisch wird der HTTP-Header **Authorization** überprüft.
     *
     * @param TEXT $Username Gibt den erwarteten Benutzernamen an.
     * @param TEXT $Username Gibt das erwartete Passwort an.
     *
     */
    class Basicauth extends \edoc\appserver\app\webservices\AbstractAuthentication
    {
        public function init()
        {
        }
        public function exec(): bool
        {
        }
    }
    /**
     * Noauth-Authentifizierung
     *
     * Mit der **No-Auth**-Authentifizierung wird keine Authentifizierung überprüft.
     *
     */
    class Noauth extends \edoc\appserver\app\webservices\AbstractAuthentication
    {
        public function init()
        {
        }
        public function exec(): bool
        {
        }
    }
}
namespace edoc\appserver\app\webservices\response {
    class Html extends \edoc\appserver\app\webservices\AbstractResponse
    {
        public function init()
        {
        }
        public function responseContent()
        {
        }
        public function errorContent($data)
        {
        }
    }
    class Json extends \edoc\appserver\app\webservices\AbstractResponse
    {
        public function init()
        {
        }
        public function responseContent()
        {
        }
        public function errorContent($data)
        {
        }
    }
    class Raw extends \edoc\appserver\app\webservices\AbstractResponse
    {
        public function init()
        {
        }
        public function responseContent()
        {
        }
        public function errorContent($data)
        {
        }
    }
    class Xml extends \edoc\appserver\app\webservices\AbstractResponse
    {
        public function init()
        {
        }
        public function responseContent()
        {
        }
        public function errorContent($data)
        {
        }
    }
}
namespace edoc\appserver {
    class App
    {
        use \edoc\appserver\utils\BitwiseFlags;
        /**
         * App constructor.
         *
         * @param array            $appConfig
         * @param ClassLoader|null $loader
         */
        public function __construct(array $appConfig, \Composer\Autoload\ClassLoader $loader = null, ?\Monolog\Logger $logger = null)
        {
        }
        public function enableMaintenance()
        {
        }
        public function disableMaintenance()
        {
        }
        public function isMaintenance()
        {
        }
        /**
         * @return App|null
         */
        public static function &currentInstance(): ?\edoc\appserver\App
        {
        }
        public static function &currentComponent(): ?\edoc\appserver\app\components\Component
        {
        }
        public function getActionsConfig(): array
        {
        }
        public function getActionByName($name): \edoc\appserver\app\AbstractAction
        {
        }
        public function setActions(array $actions): void
        {
        }
        /**
         * @return array|bool
         */
        public function getTasksConfig()
        {
        }
        public function getTaskConfigById($taskId)
        {
        }
        /**
         * @param  string $name
         * @return array|bool|mixed|null
         * @throws Exception
         */
        public function getComponentConfigByName(string $name)
        {
        }
        /**
         * @uses App::loadPluginComponents()
         * @uses App::loadPluginActions()
         *
         * @return array
         */
        public function listPlugins(string $type, ?callable $mapFunc = null, bool $withPackages = true): array
        {
        }
        protected function execShowLoading(bool $isWorkflowRequest): string|bool
        {
        }
        protected function execSetSameSiteCookie(): void
        {
        }
        /**
         * @param string $componentName
         * @param array $params
         *
         * @return array|string|string[]
         *
         * @throws \RedisException
         */
        public function exec(string $componentName, array $params)
        {
        }
        /**
         * @param  string $name
         * @return bool|Component
         * @throws Exception
         */
        public function getViewByName(string $name)
        {
        }
        /**
         * @param  string $name
         * @return bool|Component
         * @throws Exception
         */
        public function getComponentByName(string $name)
        {
        }
        public function getWebserviceByName(string $name)
        {
        }
        public function isPreviewEnabled(): bool
        {
        }
        /**
         * @param $event
         * @param $elementId
         * @param $elementValue
         * @param array $routeParams
         * @return array|bool
         * @throws Exception
         */
        public function execEvent($event, $elementId, $elementValue, $routeParams = [])
        {
        }
        protected function fixNameForPath($name)
        {
        }
        /**
         * @param  string $id
         * @return bool|Component
         * @throws Exception
         */
        public function getComponentById(string $id)
        {
        }
        /**
         * @param $webserviceName
         * @param array $params
         * @throws Exception
         */
        public function execWebService($webserviceName, array $params)
        {
        }
        public function getWebServiceConfig()
        {
        }
        public function getFlowsConfig()
        {
        }
        /**
         * @return array|mixed|null
         */
        public function getRoles()
        {
        }
        public function updateActionParameter($entityDef, $actionConfig, $currentParameter)
        {
        }
        public function datasources()
        {
        }
        public function integrations()
        {
        }
        /**
         * @return string|null
         */
        public function name()
        {
        }
        /**
         * @return string|null
         */
        public function version()
        {
        }
        /*
         *
         */
        /**
         * @return string|null
         */
        public function description()
        {
        }
        /**
         * @return string|null
         */
        public function author()
        {
        }
        public function license()
        {
        }
        public function copyright()
        {
        }
        public function layout()
        {
        }
        public function layoutContent()
        {
        }
        public function setLayoutContent($content)
        {
        }
        /**
         * @return array
         */
        public function tags()
        {
        }
        public function setGroups($type, $groups)
        {
        }
        public function addGroup($type, $name)
        {
        }
        public function groups($type = null)
        {
        }
        public function save($modeCreate = false)
        {
        }
        /**
         * @return Logger|null
         */
        public function getLogger()
        {
        }
        /**
         * @return string|null
         */
        public function id()
        {
        }
        /**
         * @param $name
         */
        public function setName($name)
        {
        }
        /**
         * @param $description
         */
        public function setDescription($description)
        {
        }
        public function setAuthor($author)
        {
        }
        public function setLicense($license)
        {
        }
        public function setCopyright($copyright)
        {
        }
        public function setVersion($version)
        {
        }
        public function setLanguages(array $languages)
        {
        }
        public function languages()
        {
        }
        protected function getVariablesPath()
        {
        }
        public function setVariables(array $variables)
        {
        }
        public function variables()
        {
        }
        public function updateVariable($name, $value)
        {
        }
        public function settings($name = null)
        {
        }
        public function setSettings($settings)
        {
        }
        /**
         * @return array|null
         */
        public function routes()
        {
        }
        /**
         * @return array|bool
         */
        public function getComponentsConfig()
        {
        }
        /**
         * @param $routes
         */
        public function setRoutes($routes)
        {
        }
        /**
         * @param $roles
         */
        public function setRoles($roles)
        {
        }
        /**
         * @param $roles
         */
        public function addRoles($roles)
        {
        }
        /**
         * @param $datasources
         */
        public function setDatasources($datasources)
        {
        }
        /**
         * @param $integrations
         */
        public function setIntegrations($integrations): void
        {
        }
        /**
         * @param $tags
         */
        public function setTags($tags)
        {
        }
        public function enviroments()
        {
        }
        public function enablePreviewMode()
        {
        }
        public function getAppPath()
        {
        }
        public function getLanguageKeys($lang = null)
        {
        }
        public function getDefaultLanguage()
        {
        }
        protected function setOrder($order, $elements, $type)
        {
        }
        public function setComponentOrder($order)
        {
        }
        public function setTaskOrder($order)
        {
        }
        public function setWebServiceOrder($order)
        {
        }
        public function setFlowOrder($order)
        {
        }
        protected function catchPluginError(string $type, string $class, string $appName, string $pluginName, \Throwable $exception): void
        {
        }
        public function catchPluginErrors(bool $enable = true): void
        {
        }
        public function clearPluginErrors(): void
        {
        }
        public function getPluginErrors(): array
        {
        }
        public function getAssetsPath(): string
        {
        }
        public function getAssetsUrl(): string
        {
        }
        public function getPluginsPath(?string $type = null): string
        {
        }
        public function getAddonsPath(): string
        {
        }
        public function setPermissions(bool $requireAuth, array $permissions): void
        {
        }
        public function getPermissions(): array
        {
        }
        public function isInstance(): bool
        {
        }
        public function instanceFrom(string $sourceAppId, array $flowMapping, ?string $flowNameSuffix = null): void
        {
        }
        public function instance(): ?array
        {
        }
    }
}
namespace edoc\appserver\core {
    /**
     * Class AppLoader
     *
     * @package edoc\appserver\core
     */
    class AppLoader
    {
        /**
         * AppLoader constructor.
         *
         * @param ClassLoader $loader
         */
        public function __construct(\Monolog\Logger $logger, ?\Composer\Autoload\ClassLoader $loader = null)
        {
        }
        public static function chroot()
        {
        }
        public static function chrootReset()
        {
        }
        /**
         * @param  \FastRoute\RouteCollector $r
         * @throws Exception
         */
        public function loadRoutes(\FastRoute\RouteCollector $r)
        {
        }
        /**
         * @return App[]
         * @throws Exception
         */
        public function loadApps(&$brokenApps = [])
        {
        }
        public function initApp($appId, $appPath)
        {
        }
        public function loadApp($appName, $reload = false, $setAsCurrent = true, $loadComposer = true)
        {
        }
        public function createApp($data)
        {
        }
        public function deleteApp($id)
        {
        }
    }
    class AssetProxy
    {
        public function __construct($type, $param)
        {
        }
        public static function getPluginComponentPath($appName, $componentName)
        {
        }
        public static function getComponentFilePath($componentName, $filePath)
        {
        }
        protected function addCacheHeader($filePath)
        {
        }
        protected function sendFile($dir, $filePath): bool
        {
        }
        /**
         * @uses \edoc\appserver\core\AssetProxy::deliverAppcomponents()
         * @uses \edoc\appserver\core\AssetProxy::deliverAssets()
         * @uses \edoc\appserver\core\AssetProxy::deliverComponents()
         * @uses \edoc\appserver\core\AssetProxy::deliverData()
         */
        public function deliver()
        {
        }
    }
    class Autoloader
    {
        public const LOG_TYPE_PLUGIN_ACTIONS = 'plugin-action';
        public const LOG_TYPE_PLUGIN_COMPONENTS = 'plugin-component';
        public const LOG_TYPE_PLUGIN_VALIDATOR = 'plugin-validator';
        public const LOG_TYPE_PLUGIN_VALIDATORS = self::LOG_TYPE_PLUGIN_VALIDATOR;
        public const LOG_TYPE_PLUGIN_DATASOURCES = 'plugin-datatsource';
        public const LOG_TYPE_DATASOURCES = 'datatsource';
        public const LOG_TYPE_COMPONENT = 'component';
        public static function getErrors(string $type, bool $clearErrors = false): array
        {
        }
        public static function clearCache(): void
        {
        }
        public function __construct(private readonly \edoc\appserver\core\Config $config, private readonly \edoc\appserver\core\Environment $environment, private readonly \edoc\appserver\utils\FilesystemWrapper $filesystem, private readonly bool $throwErrors = true)
        {
        }
        protected function resolvePathCaseInsensitive(string $path): string
        {
        }
        /**
         * @throws \Throwable
         */
        protected function requirePluginFile(?\edoc\appserver\App $app, string $path, string $type, string $name, string $class): void
        {
        }
        /**
         * @throws \Throwable
         */
        protected function loadAutomateClass(string $class): void
        {
        }
        protected function loadDatasourceClass(string $class): void
        {
        }
        /**
         * @throws \Throwable
         */
        protected function loadAddonClass(string $class): void
        {
        }
        /**
         * @throws \Throwable
         */
        public function loadClass(string $class): void
        {
        }
    }
    class Config
    {
        public function merge(array $config): void
        {
        }
        /**
         * @throws \Exception
         */
        public static function &getInstance(?array $default = null): \edoc\appserver\core\Config
        {
        }
        /**
         * @param string $key Get a key from config. The $key is dot separated for arrays in arrays (i.E. server.base_path)
         */
        public function get(string $key, mixed $default = null): mixed
        {
        }
        public function dump(?array $config = null, string $path = '', array $maskedKeys = [], ?callable $render = null, ?callable $sort = null): void
        {
        }
    }
    class Database
    {
        public static function &GetInstance()
        {
        }
        public function handle()
        {
        }
    }
    class Environment
    {
        public static function &getInstance()
        {
        }
        /**
         * @param App $app
         */
        public function setCurrentApp(\edoc\appserver\App $app, $reload = false)
        {
        }
        /**
         * @param $component
         */
        public function setCurrentComponent(\edoc\appserver\app\components\Component $component)
        {
        }
        /**
         * @return null
         */
        public function currentBaseComponent(): ?\edoc\appserver\app\components\Component
        {
        }
        /**
         * @return App
         */
        public function currentApp(): ?\edoc\appserver\App
        {
        }
        /**
         * @param bool $mode
         */
        public function setEditorMode($mode = true)
        {
        }
        /**
         * @return bool
         */
        public function isEditorMode()
        {
        }
        public function printMode()
        {
        }
        public function setPrintMode($mode)
        {
        }
        /**
         * @return bool
         */
        public function setExecLoadEvents($exec = true)
        {
        }
        /**
         * @return bool
         */
        public function execLoadEvents()
        {
        }
    }
    class RequestHeaders
    {
        /**
         * Get a specific request header - returns null if header not found
         * @param string $name
         *
         * @return mixed|null
         */
        public static function get(string $name)
        {
        }
        /**
         * Get all request headers - default with original lower/uppercase letters
         *
         * @param $lowerCase bool return all headers with lowercase letters or original letters
         *
         * @return array
         */
        public static function getAll(bool $lowerCase = false): array
        {
        }
    }
    /**
     * Class Storage
     *
     * @package edoc\appserver\core
     */
    class Storage
    {
        /**
         * @param $key
         * @param $value
         */
        public static function add($key, $value)
        {
        }
        /**
         * @param  $key
         * @return mixed|null
         */
        public static function get($key, $default = null)
        {
        }
        /**
         * @return array
         */
        public static function getAll()
        {
        }
        public static function merge($new)
        {
        }
    }
}
namespace edoc\appserver\datasources {
    #[\edoc\appserver\stubs\attributes\PluginAPI]
    abstract class Database extends \edoc\appserver\datasources\DataSource
    {
        public function getLastParsedQuery(): ?string
        {
        }
        abstract public function querySingle($SQL);
        abstract public function query($SQL);
        abstract public function lastInsertId();
        abstract public function escape($string, bool &$addedQuotes);
        /**
         * @param  $Sql
         * @return string|string[]|null
         */
        protected function parseQuery($Sql)
        {
        }
    }
}
namespace edoc\appserver\datasources\driver {
    /**
     * PDO-Datenquelle.
     *
     * Die **PDO**-Datenquelle ermöglicht die Interaktion mit verschiedenen Datenbankservern.
     * Mit dieser Datenquelle können App-Entwickler auf Datenbanken zugreifen, Abfragen ausführen und Daten in ihre Apps
     * einbinden.
     *
     * Sie können mit den Verbindungsparametern, wie z.B. **DSN** und Anmeldeinformationen (**User** und **Password**), 
     * die Verbindung herstellen. Sie können dann SQL-Abfragen verwenden, um Daten abzurufen, einzufügen,
     * zu aktualisieren oder zu löschen.
     *
     * @param TEXT $dsn Gibt die benötigten Informationen zum Verbinden der Datenbank an, z.B.: `mysql:dbname=demo;host=127.0.0.1`.
     * @param TEXT $user Gibt den Benutzer zum Herstellen der Verbindung an.
     * @param PASSWORD $password Gibt das Passwort des angegebenen Benutzers an.
     */
    class PDO extends \edoc\appserver\datasources\Database implements \edoc\appserver\datasources\ConnectionHandler
    {
        /** @var \PDO|null  */
        protected $handle = null;
        /**
         * @throws \Exception
         */
        protected function init($addProperties = true)
        {
        }
        /**
         * @return array
         */
        public function details()
        {
        }
        /**
         * @param $Sql
         * @return array|mixed
         * @throws \Exception
         */
        public function querySingle($Sql)
        {
        }
        /**
         * @param $Sql
         * @return array
         * @throws \Exception
         */
        public function query($Sql)
        {
        }
        /**
         * @return string
         */
        public function lastInsertId()
        {
        }
        /**
         * @param $string
         * @return false|string
         */
        public function escape($string, bool &$addedQuotes)
        {
        }
        public function handle(): ?\PDO
        {
        }
    }
    /**
     * MSSQL-Datenquelle
     *
     * Die **Mssql**-Datenquelle ermöglicht die Interaktion mit Microsoft SQL Server.
     * Mit dieser Datenquelle können App-Entwickler auf Datenbanken zugreifen, Abfragen ausführen und Daten in ihre Apps
     * einbinden.
     *
     * Sie können mit den Verbindungsparametern, wie z.B. **Host**, **Port** und Anmeldeinformationen (**User** und **Password**), 
     * die Verbindung herstellen. Sie können dann SQL-Abfragen verwenden, um Daten abzurufen, einzufügen,
     * zu aktualisieren oder zu löschen.
     *
     * @param TEXT $host Gibt die Serveradresse des Servers mit SQL Server an.
     * @param NUMBER $port Gibt den Port an, auf den SQL Server auf dem Server lauscht.
     * @param TEXT $user Gibt den Benutzer zum Herstellen der Verbindung an.
     * @param PASSWORD $password Gibt das Passwort des angegebenen Benutzers an.
     * @param TEXT $database Gibt die Datenbank an, die beim Herstellen der Verbindung ausgewählt wird.
     *
     */
    class Mssql extends \edoc\appserver\datasources\driver\PDO
    {
        /**
         * @param bool $addProperties
         * @throws \Exception
         */
        protected function init($addProperties = true)
        {
        }
        /**
         * @param $string
         * @param bool $addedQuotes
         * @return false|string
         */
        public function escape($string, bool &$addedQuotes)
        {
        }
    }
    /**
     * MySQL-Datenquelle
     *
     * Die **Mysql**-Datenquelle ermöglicht die Interaktion mit einem MySQL-Server.
     * Mit dieser Datenquelle können App-Entwickler auf Datenbanken zugreifen, Abfragen ausführen und Daten in ihre Apps
     * einbinden.
     *
     * Sie können mit den Verbindungsparametern, wie z.B. **Host**, **Port** und Anmeldeinformationen (**User** und **Password**), 
     * eine Verbindung herstellen. Sie können dann SQL-Abfragen verwenden, um Daten abzurufen, einzufügen,
     * zu aktualisieren oder zu löschen.
     *
     * <div class="panel note">
     * **Gut zu wissen**\
     * Die Datenquelle kann auch für kompatible Systeme wie z.B. MariaDB verwendet werden.
     * </div>
     *
     * @param TEXT $host Gibt die Serveradresse des MySQL-Servers an.
     * @param NUMBER $port Gibt den Port an, auf den der MySQL-Server auf dem Server lauscht.
     * @param TEXT $user Gibt den Benutzer zum Herstellen der Verbindung an.
     * @param PASSWORD $password Gibt das Passwort des angegebenen Benutzers an.
     * @param TEXT $database Gibt die Datenbank an, die beim Herstellen der Verbindung ausgewählt wird.
     * @param TEXT $encoding Gibt das Encoding an. Mit dem leeren Wert wird utf8mb4 als Encoding für die Verbindung verwendet.
     *
     */
    class Mysql extends \edoc\appserver\datasources\Database implements \edoc\appserver\datasources\ConnectionHandler
    {
        /**
         * @throws DataSourceException
         */
        public function init()
        {
        }
        /**
         *
         */
        public function __destruct()
        {
        }
        public function escape($string, bool &$addedQuotes)
        {
        }
        /**
         * @param  $SQL
         * @return mixed|null
         * @throws \Exception
         */
        public function querySingle($SQL)
        {
        }
        /**
         * @param  $SQL
         * @return array|bool
         * @throws \Exception
         */
        public function query($SQL)
        {
        }
        public function lastInsertId(): int|string
        {
        }
        public function details(): array
        {
        }
        public function handle(): ?\mysqli
        {
        }
    }
    /**
     * Oracle-Datenquelle
     *
     * Die **Oracle**-Datenquelle ermöglicht die Interaktion mit einem Oracle-Datenbankserver.
     * Mit dieser Datenquelle können App-Entwickler auf Datenbanken zugreifen, Abfragen ausführen und Daten in ihre Apps
     * einbinden.
     *
     * Sie können mit den Verbindungsparametern, wie z.B. **Host** und Anmeldeinformationen (**User** und **Password**), 
     * die Verbindung herstellen. Sie können dann SQL-Abfragen verwenden, um Daten abzurufen, einzufügen,
     * zu aktualisieren oder zu löschen.
     *
     * <div class="panel note">
     * **Gut zu wissen**\
     * Um den Parameter **host** anzugeben, können Sie einen Connection String (Verbindungszeichenfolge) oder die Easy
     * Connect-Methode verwenden.\
     * \
     * Die Syntax für einen Connection String lautet:\
     * `(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=[host_name])(PORT=[port]))(CONNECT_DATA=(SID=[sid])))`\
     * \
     * Die Syntax für die Easy Connect-Methode lautet:\
     * `[//]host_name[:port][/service_name][:server_type][/instance_name]`\
     * \
     * Die Servicenamen können Sie ermitteln, indem Sie das Oracle-Hilfswerkzeug `lsnrctl status` auf dem Datenbankserver
     * ausführen.
     * </div>
     *
     * @param TEXT $host Gibt die Serveradresse des Oracle-Servers an. Beispiel: `dbserver:1521/service`
     * @param TEXT $user Gibt den Benutzer zum Herstellen der Verbindung an.
     * @param PASSWORD $password Gibt das Passwort des angegebenen Benutzers an.
     *
     */
    class Oracle extends \edoc\appserver\datasources\Database implements \edoc\appserver\datasources\ConnectionHandler
    {
        /**
         * @throws \Exception
         */
        protected function init()
        {
        }
        /**
         * @return array
         */
        public function details()
        {
        }
        /**
         * @param $string
         * @param bool $addedQuotes
         * @return string
         */
        public function escape($string, bool &$addedQuotes)
        {
        }
        /**
         * @param $Sql
         * @return string|string[]|null
         */
        protected function parseQuery($sql)
        {
        }
        /**
         * @param $sql
         * @return array
         * @throws \Exception
         */
        public function query($sql): array
        {
        }
        /**
         * @param $SQL
         * @return array|mixed
         * @throws \Exception
         */
        public function querySingle($sql)
        {
        }
        /**
         * @throws \Exception
         */
        public function lastInsertId()
        {
        }
        /**
         * @return resource|null
         */
        public function handle()
        {
        }
    }
    #[\edoc\appserver\stubs\attributes\PluginAPI]
    class RestAPI extends \edoc\appserver\datasources\RestAPI
    {
        protected function init()
        {
        }
        public function details()
        {
        }
        public function post($url, $data, $header = [], &$responseHeader = null)
        {
        }
    }
}
namespace Laminas\I18n\Translator\Loader {
    /**
     * File loader interface.
     */
    interface FileLoaderInterface
    {
        /**
         * Load translations from a file.
         *
         * @param  string $locale
         * @param  string $filename
         * @return TextDomain|null
         */
        public function load($locale, $filename);
    }
    /**
     * Abstract file loader implementation; provides facilities around resolving
     * files via the include_path.
     */
    abstract class AbstractFileLoader implements \Laminas\I18n\Translator\Loader\FileLoaderInterface
    {
        /**
         * Whether or not to consult the include_path when locating files
         *
         * @var bool
         */
        protected $useIncludePath = false;
        /**
         * Indicate whether or not to use the include_path to resolve translation files
         *
         * @param bool $flag
         * @return self
         */
        public function setUseIncludePath($flag = true)
        {
        }
        /**
         * Are we using the include_path to resolve translation files?
         *
         * @return bool
         */
        public function useIncludePath()
        {
        }
        /**
         * Resolve a translation file
         *
         * Checks if the file exists and is readable, returning a boolean false if not; if the "useIncludePath"
         * flag is enabled, it will attempt to resolve the file from the
         * include_path if the file does not exist on the current working path.
         *
         * @param string $filename
         * @return string|false
         */
        protected function resolveFile($filename)
        {
        }
        /**
         * Resolve a translation file via the include_path
         *
         * @param string $filename
         * @return string|false
         */
        protected function resolveViaIncludePath($filename)
        {
        }
    }
}
namespace edoc\appserver\i18n {
    class JsonLoader extends \Laminas\I18n\Translator\Loader\AbstractFileLoader
    {
        /**
         * @inheritDoc
         */
        public function load($locale, $filename)
        {
        }
    }
}
namespace edoc\appserver\app\components {
    /**
     * Alert-Komponente
     *
     * Mit der **Alert**-Komponente können Sie den Anwendern:innen Hinweise anzeigen.
     *
     * @param SELECT $Color-Type Gibt die Art des Hinweises an:
     * - **primary**
     * - **secondary**
     * - **success**
     * - **danger**
     * - **warning**
     * - **info**
     * - **light**
     * - **dark**
     * @param INPUT $Header Gibt einen Text im Header an.
     * @param INPUT $Footer Gibt einen Text im Footer an.
     */
    class Alert extends \edoc\appserver\app\AbstractComponent
    {
        use \edoc\appserver\app\component\PropertyClass;
        use \edoc\appserver\app\component\Visibility;
        protected function init()
        {
        }
        public function htmlContent()
        {
        }
    }
    /**
     * AutoComplete-Komponente
     *
     * Mit der **AutoComplete**-Komponente werden beim Eingeben von Werten in einem Feld automatisch Werte aus einer
     * definierten Liste vorgeschlagen. Die Anwender:innen können dann einen Wert auswählen.
     *
     * Sie können die **AutoComplete**-Funktion z.B. mithilfe der Aktion **default\SetDataset** mit Werten füllen.
     *
     * Der angegebene Datensatz muss mindestens eine Spalte enthalten. Wenn mehrere Spalten im Datensatz vorhanden sind,
     * legen die Werte in den Spalten die benannten Werte **currentIndex** und **currentHiddenValue** fest.
     *
     * ## Funktionsweise
     * Sie können die benannten Werte (named value) mit der Aktion **default\GetNamedValue** abfragen.
     * - **currentIndex**: Wählen Sie diesen benannten Wert aus, wenn mindestens zwei Spalten im Datensatz vorhanden sind.
     *   Es wird der Wert der ersten Spalte im Datensatz verwendet.
     * - **currentHiddenValue**: Wählen Sie diesen benannten Wert aus, wenn drei Spalten im Datensatz vorhanden sind. Es
     *   wird der Wert der dritten Spalte im Datensatz verwendet.
     *
     * @param INPUT $Label Zeigt die sichtbare Bezeichnung der Komponente an.
     * @param BOOLEAN $Show_on_Focus Gibt an, ob die Liste angezeigt wird, sobald das Feld aktiviert wird.
     * @param NUMBER $Min_Length Gibt an, wie viele Zeichen mindestens eingegeben werden müssen, bevor die Vervollständigung
     * startet.
     * @param INPUT $Empty_Message Gibt einen Hinweis an, wenn kein Wert in der Liste mit dem eingegebenen Wert
     * übereinstimmt.
     * @param BOOLEAN $Show_Data_in_List Gibt zusätzliche Informationen in der Ergebnisliste an.
     * @param BOOLEAN $Only_accept_list_items Gibt an, dass nur Werte aus der Liste als Eingabe akzeptiert werden.
     * @param SELECT $Filter_Mode Gibt an, wie die Werte in der Liste gefiltert werden.
     * - **text start with**: Die Werte der Liste müssen mit dem eingegebenen Text beginnen.
     * - **somewhere in text**: Die Werte der Liste müssen irgendwo mit dem eingegebenen Text übereinstimmen.
     */
    class AutoComplete extends \edoc\appserver\app\component\CustomSetDataset
    {
        use \edoc\appserver\app\component\PropertyClass;
        use \edoc\appserver\app\component\Visibility;
        use \edoc\appserver\app\component\Editable;
        const ACTIONKEY = 'updateAutoComplete';
        public static function addJSCallbacks()
        {
        }
        public function returnDataset()
        {
        }
        public function init()
        {
        }
        public function htmlContent()
        {
        }
    }
    /**
     * Button-Komponente
     *
     * Die **Button**-Komponente zeigt eine klickbare Schaltfläche in der Anwendung an.
     */
    class Button extends \edoc\appserver\app\AbstractComponent
    {
        use \edoc\appserver\app\component\Visibility;
        use \edoc\appserver\app\component\PropertyClass;
        use \edoc\appserver\app\component\Disableable;
        public function htmlContent()
        {
        }
        protected function init()
        {
        }
    }
    /**
     * Checkbox-Komponente
     *
     * Die **Checkbox**-Komponente bietet die Option, zwischen zwei Zuständen zu wählen.
     *
     * @param INPUT $Label Gibt die Bezeichnung für die Komponente an.
     * @param INPUT $CheckedValue Gibt den Wert der Komponente an, wenn die Komponente aktiviert wurde.
     * @param INPUT $UnCheckedValue Gibt den Wert der Komponente an, wenn die Komponente deaktiviert wurde.
     */
    class Checkbox extends \edoc\appserver\app\AbstractComponent
    {
        use \edoc\appserver\app\component\Editable;
        use \edoc\appserver\app\component\Visibility;
        use \edoc\appserver\app\component\PropertyClass;
        protected function init()
        {
        }
        public function htmlContent()
        {
        }
    }
    /**
     * Columns-Komponente
     *
     * Mit der **Columns**-Komponente können Sie Komponenten in einer View nebeneinander anordnen.
     *
     * @param NUMBER $Columns Gibt an, wie viele Spalten die Komponente zur Verfügung stellt.
     */
    class Columns extends \edoc\appserver\app\AbstractEmbeddedComponent
    {
        use \edoc\appserver\app\component\Visibility;
        use \edoc\appserver\app\component\PropertyClass;
        public function getComponentById($id)
        {
        }
        /**
         * @return string
         * @throws \Exception
         */
        public function htmlContent()
        {
        }
        protected function addAsChild($component)
        {
        }
        /**
         * @throws \Exception
         */
        protected function initEmbedded()
        {
        }
    }
    class Component extends \edoc\appserver\app\AbstractComponent
    {
        use \edoc\appserver\app\component\PropertyClass;
        use \edoc\appserver\app\component\Visibility;
        /**
         * @return mixed|string
         */
        public function htmlContent()
        {
        }
        public function html()
        {
        }
        public function getParameters()
        {
        }
        /**
         * @param  string $id
         * @return AbstractComponent|null
         * @throws Exception
         */
        public function findChildComponentById(string $id): ?\edoc\appserver\app\AbstractComponent
        {
        }
        protected function addAsChild($component)
        {
        }
        /**
         * @throws Exception
         */
        protected function init()
        {
        }
        public function childComponentNames()
        {
        }
        public function execEvent($event = 'load')
        {
        }
        public function setDocReadyEventName($name)
        {
        }
        public function getDocReadyEventName()
        {
        }
    }
    /**
     * Container-Komponente
     *
     * Mit der **Container**-Komponente können Sie die Anordnung mehrerer Komponenten festlegen.
     *
     * @param SELECT $Alignment_Horizontal Gibt die Ausrichtung der Komponente an.
     * - **left**: Linksbündig
     * - **center**: Zentriert
     * - **right**: Rechtsbündig
     * @param SELECT $Arrangement Gibt die Anordnung der Komponenten an.
     * - **top to bottom**: Übereinander
     * - **left to right**: Nebeneinander
     */
    class Container extends \edoc\appserver\app\AbstractEmbeddedComponent
    {
        use \edoc\appserver\app\component\PropertyClass;
        use \edoc\appserver\app\component\Visibility;
        protected function addAsChild($component)
        {
        }
        protected function initEmbedded()
        {
        }
        public function getComponentById($id)
        {
        }
        public function htmlContent()
        {
        }
    }
    /**
     * Text-Komponente
     *
     * Die **Text**-Komponente ist eine Komponente zum Anzeigen von einfachen unformatierten Texten.
     *
     * **Hinweis**: Wenn Sie die Komponente in einem Flow verwenden, wird der Wert der Komponente beim Laden der View auf
     * den Wert einer gleichnamigen Workflowvariablen festgelegt.
     */
    class Text extends \edoc\appserver\app\AbstractComponent
    {
        use \edoc\appserver\app\component\PropertyClass;
        use \edoc\appserver\app\component\Visibility;
        public function htmlContent()
        {
        }
        protected function init()
        {
        }
    }
    /**
     * DateTime-Komponente
     *
     * Mit der **DateTime**-Komponente können Sie Datumsangaben und Uhrzeiten für die Darstellung formatieren.
     *
     * @param SELECT $io_format Gibt das Format der Daten an, wenn die Werte abgefragt (**default\GetValue**) oder
     * festgelegt (**default\SetValue**) werden.
     * @param SELECT $display_format Gibt das Format zur Darstellung der Daten an.
     *
     */
    class DateTime extends \edoc\appserver\app\components\Text implements \edoc\appserver\app\component\DateTimeInterface
    {
        use \edoc\appserver\app\component\Visibility;
        use \edoc\appserver\app\component\DateTimeField;
        use \edoc\appserver\app\component\PropertyClass;
        protected function init()
        {
        }
        public function setValue($value, $name = null)
        {
        }
        public function value()
        {
        }
    }
    /**
     * Input-Komponente
     *
     * Die **Input**-Komponente ist eine Komponente zum Eingeben einfacher unformatierter Daten.
     *
     * **Hinweis**: Wenn Sie die Komponente in einem Flow verwenden, wird der Wert der Komponente beim Laden der View auf
     * den Wert einer gleichnamigen Workflowvariablen festgelegt.
     *
     * @param INPUT $Label Gibt die Bezeichnung für die Komponente an.
     * @param INPUT $Placeholder Ist ein Platzhalter im Eingabefeld.
     * @param SELECT $Input_Type Gibt die Art des Eingabefeldes an:
     * - **text**: Einfaches Textfeld
     * - **password**: Passworteingabe
     * @param INPUT $Prepend Gibt den Wert an, der dem Eingabefeld links vorangestellt wird.
     * @param INPUT $Append Gibt den Wert an, der rechts hinter dem Eingabefeld eingefügt wird.
     */
    class Input extends \edoc\appserver\app\AbstractComponent
    {
        use \edoc\appserver\app\component\PropertyClass;
        use \edoc\appserver\app\component\PropertyMaxLength;
        use \edoc\appserver\app\component\Editable;
        use \edoc\appserver\app\component\Visibility;
        public function htmlContent()
        {
        }
        protected function init()
        {
        }
    }
    /**
     * DateTimeInput-Komponente
     *
     * Mit der **DateTimeInput**-Komponente können Sie die Darstellung und Eingabe von Datumsangaben und Uhrzeiten
     * formatieren. Sie können außerdem einen Kalender verwenden, optional ein frühestes und spätestes Datum sowie
     * Wochennummern angeben.
     *
     * @param SELECT $io_format Gibt das Format der Daten an, wenn die Werte abgefragt (**default\GetValue**) oder
     * festgelegt (**default\SetValue**) werden.
     * @param SELECT $display_format Gibt das Format zur Darstellung und bei der Eingabe der Daten durch den Anwender an.
     * @param SELECT $show_weeks_numbers Legt fest, ob eine Wochennummer (Kalenderwoche) angezeigt wird.
     * @param TEXT $earliest_date Gibt das früheste Kalenderdatum an, sodass kein früheres Datum ausgewählt werden kann.
     * @param TEXT $latest_date Gibt das späteste Kalenderdatum an, sodass kein späteres Datum ausgewählt werden kann.
     *
     */
    class DateTimeInput extends \edoc\appserver\app\components\Input implements \edoc\appserver\app\component\DateTimeInterface
    {
        use \edoc\appserver\app\component\Visibility;
        use \edoc\appserver\app\component\Editable;
        use \edoc\appserver\app\component\DateTimeField;
        use \edoc\appserver\app\component\PropertyClass;
        /**
         * Add DateTimeField Properties
         *
         * @throws \Exception
         */
        protected function addProperties(): void
        {
        }
        /**
         * @throws \ReflectionException
         * @throws \Exception
         */
        protected function init()
        {
        }
        public static function setCurrentValue($id, $value)
        {
        }
        public function setValue($value, $name = null)
        {
        }
        public function value()
        {
        }
        /**
         * @throws \Exception
         */
        public function htmlContent()
        {
        }
        /**
         * @param string $date
         * @return string
         * @throws \DateInvalidTimeZoneException
         * @throws \Exception
         */
        protected function getFlatpickrFormate(string $date): string
        {
        }
    }
    /**
     * Hidden-Komponente
     *
     * Die **Hidden**-Komponente ist eine nicht sichtbare Komponente zum Speichern von Werten im Frontend.
     *
     * **Hinweis**: Wenn Sie die Komponente in einem Flow verwenden, wird der Wert der Komponente beim Laden der View auf
     * den Wert einer gleichnamigen Workflowvariablen festgelegt.
     *
     */
    class Hidden extends \edoc\appserver\app\AbstractComponent
    {
        public function init()
        {
        }
        public function htmlContent()
        {
        }
    }
    /**
     * HTML-Komponente
     *
     * Mit der **HTML**-Komponente können Sie einen beliebigen HTML-formatierten Text darstellen.
     * Die Formularelemente innerhalb des gerenderten HTMLs bieten keine Interaktion mit edoc automate.
     *
     */
    class HTML extends \edoc\appserver\app\AbstractComponent
    {
        use \edoc\appserver\app\component\Visibility;
        use \edoc\appserver\app\component\PropertyClass;
        public function htmlContent()
        {
        }
        protected function init()
        {
        }
    }
    /**
     * NumberInput-Komponente
     *
     * Die **NumberInput**-Komponente ist eine Komponente zur Darstellung formatierter Zahlen.
     *
     * @param NUMBER $Decimal_Places Gibt die Anzahl der Nachkommastellen an.
     * @param SELECT $Decimal_Seperator Gibt an, welches Dezimaltrennzeichen verwendet wird. Bei **auto** wird das
     * Dezimaltrennzeichen der Sprache des Anwenders verwendet.
     * @param SELECT $Thousands_Seperator Gibt an, welches Zeichen für die Tausendertrennung verwendet wird. Bei **auto**
     * wird das Tausendertrennzeichen der Sprache des Anwenders verwendet.
     */
    class Number extends \edoc\appserver\app\components\Text
    {
        use \edoc\appserver\app\component\PropertyClass;
        use \edoc\appserver\app\component\Visibility;
        public function init()
        {
        }
        public function value()
        {
        }
    }
    /**
     * NumberInput-Komponente
     *
     * Die **NumberInput**-Komponente ist eine Komponente zur formatierten Eingabe von Zahlen.
     *
     * @param NUMBER $Decimal_Places Gibt die Anzahl der Nachkommastellen an.
     * @param SELECT $Decimal_Separator Gibt an, welches Dezimalzeichen verwendet wird. Bei **auto** wird das
     * Dezimaltrennzeichen der Sprache des Anwenders verwendet.
     * @param SELECT $Thousands_Separator Gibt an, welches Zeichen für die Tausendertrennung verwendet wird. Bei **auto**
     * wird das Tausendertrennzeichen der Sprache des Anwenders verwendet.
     * @param NUMBER $Min Gibt an. wie groß die eingegebene Zahl mindestens sein muss.
     * @param NUMBER $Max Gibt an, wie groß die eingegebene Zahl maximal sein darf.
     */
    class NumberInput extends \edoc\appserver\app\components\Input
    {
        use \edoc\appserver\app\component\PropertyClass;
        use \edoc\appserver\app\component\Editable;
        use \edoc\appserver\app\component\Visibility;
        public function init()
        {
        }
        public function htmlContent()
        {
        }
    }
    /**
     * PrintDataset-Komponente
     *
     * Mit der **PrintDataset**-Komponente können Sie einen Datensatz in tabellarischer Form anzeigen.
     * Die Daten müssen z.B. per **default\SetDataset**-Aktion an die Komponente übergeben werden.
     *
     * @param INPUT $Types Gibt eine Definition per JSON zum Formatieren der einzelnen Spalten an.\
     * Beispiel: `{"created":{"type":"datetime", "format": "d.m.Y"}}`
     */
    class PrintDataset extends \edoc\appserver\app\AbstractEmbeddedComponent
    {
        protected function initEmbedded()
        {
        }
        public function htmlContent()
        {
        }
    }
    /**
     * Radio-Komponente
     *
     * Die **Radio**-Komponente ist eine Komponente, mit der Sie eine Gruppe von einfachen Radio-Buttons implementieren
     * können.\
     * Daten, die z.B. mit der **default\SetDataset**-Aktion an die Komponente gegeben werden, werden zum Darstellen der
     * einzelnen **Radio**-Buttons verwendet:\
     * Jede Zeile wird dabei als Button darstellt. Als Wert wird immer die erste Spalte im Datensatz verwendet. Die zweite
     * Spalte, wenn vorhanden, wird als Label verwendet. Jede weitere Spalte wird von der Komponente ignoriert.
     *
     * @param BOOLEAN $inline Zeigt die Buttons untereinander oder nebeneinander an.
     *
     */
    class Radio extends \edoc\appserver\app\component\CustomSetDataset
    {
        use \edoc\appserver\app\component\Visibility;
        use \edoc\appserver\app\component\Editable;
        protected function init()
        {
        }
        public function returnDataset()
        {
        }
        public static function addJSCallbacks()
        {
        }
        public function htmlContent()
        {
        }
    }
    /**
     * Select-Komponente
     *
     * Die **Select**-Komponente ist eine Komponente zum Auswählen eines Wertes aus einer Wertemenge.\
     * Daten, die z.B. mit der **default\SetDataset**-Aktion an die Komponente gegeben werden, werden zum Darstellen der
     * einzelnen Zeilen verwendet:\
     * Jede Zeile im Datensatz (Dataset) wird dabei zu einer Zeile in der **Select**-Komponente. Als Wert wird immer die
     * erste Spalte im Datensatz verwendet. Die zweite Spalte, wenn vorhanden, wird als Label verwendet. Jede weitere Spalte
     * wird von der Komponente ignoriert.
     *
     * @param INPUT $Label Zeigt die sichtbare Bezeichnung der Komponente an.
     * @param INPUT $Options Mit dieser Eigenschaft können Sie Daten mithilfe einer Aktion an die Komponente weitergeben.
     * Wenn Sie keine Aktion verwenden, müssen Sie ein Event angeben, um Daten weiterzugeben.
     */
    class Select extends \edoc\appserver\app\AbstractComponent
    {
        use \edoc\appserver\app\component\Editable;
        use \edoc\appserver\app\component\Visibility;
        use \edoc\appserver\app\component\PropertyClass;
        /**
         *
         */
        public function init()
        {
        }
        /**
         *
         */
        public function htmlContent()
        {
        }
    }
    /**
     * Spacer-Komponente
     *
     * Die **Spacer**-Komponente ist eine Komponente zum Anzeigen eines Abstandes zwischen Komponenten.\
     * Optional können Sie eine Linie zur Visualisierung des Abstands angeben.
     *
     * @param NUMBER $Height Gibt die Höhe des Abstandes in Pixel an.
     * @param SELECT $Line Gibt die Position der optionalen Line an.
     */
    class Spacer extends \edoc\appserver\app\AbstractComponent
    {
        use \edoc\appserver\app\component\PropertyClass;
        use \edoc\appserver\app\component\Visibility;
        public function htmlContent()
        {
        }
        protected function init()
        {
        }
    }
    /**
     * Table-Komponente
     *
     * Mit der **Table**-Komponente können Sie eine Tabelle darstellen.\
     * Sie können die Tabelle als Strukturelement verwenden, oder um die Daten aus einem Datensatz anzuzeigen.
     *
     * Wenn die Tabelle zum Anzeigen von Daten verwendet wird, werden die angegebenen Zeilen für jede Zeile im Datensatz
     * wiederholt.
     *
     * Zu allen Zeilen und Spalten der Tabelle werden automatisch CSS-Klassen hinzugefügt:
     * - Zeilen: **eas-row eas-row-1**
     * - Spalten: **eas-col eas-col-1**
     *
     * @param NUMBER $Columns Zeigt die Anzahl der Spalten in der Tabelle an.
     * @param NUMBER $Head_Rows Zeigt die Anzahl der Zeilen für den Tabellenkopf an.
     * @param NUMBER $Data_Rows Zeigt die Anzahl der Zeilen für die Tabelle an.
     * @param INPUT $Alternative_Text Zeigt einen Text an, wenn ein leerer Datensatz an die Komponente übergeben wird.
     */
    class Table extends \edoc\appserver\app\AbstractEmbeddedComponent
    {
        use \edoc\appserver\app\component\Visibility;
        use \edoc\appserver\app\component\PropertyClass;
        public const ROWIDDELIM = '-';
        public function getComponentByName($name)
        {
        }
        public function getComponentById($id)
        {
        }
        /**
         * @return string
         * @throws \Exception
         */
        public function htmlContent()
        {
        }
        protected function initEmbedded()
        {
        }
        public function execEvent($event = 'load')
        {
        }
        public function setParam($name, $value)
        {
        }
    }
    /**
     * TextEdit-Komponente
     *
     * Die **TextEdit**-Komponente ist eine Komponente zum Eingeben von mehrzeiligen unformatierten Texten.
     *
     * **Hinweis**: Wenn Sie die Komponente in einem Flow verwenden, wird der Wert der Komponente beim Laden der View auf
     * den Wert einer gleichnamigen Workflowvariablen festgelegt.
     *
     * @param INPUT $Label Gibt die Bezeichnung der Komponente an.
     * @param NUMBER $Rows Gibt die Anzahl der sichtbaren Zeilen an.
     */
    class TextEdit extends \edoc\appserver\app\AbstractComponent
    {
        use \edoc\appserver\app\component\Visibility;
        use \edoc\appserver\app\component\Editable;
        use \edoc\appserver\app\component\PropertyClass;
        use \edoc\appserver\app\component\PropertyMaxLength;
        public function init()
        {
        }
        public function htmlContent()
        {
        }
    }
    /**
     * Title-Komponente
     *
     * Die **Title**-Komponente ist eine Komponente, um Überschriften formatiert darzustellen.
     *
     * @param NUMBER $Size Gibt die Größe der Überschrift 1-6 an.
     */
    class Title extends \edoc\appserver\app\AbstractComponent
    {
        use \edoc\appserver\app\component\Visibility;
        use \edoc\appserver\app\component\PropertyClass;
        public function htmlContent()
        {
        }
        protected function init()
        {
        }
    }
    /**
     * Toggle-Komponente
     *
     * Die **Toggle**-Komponente ist eine Komponente zum Aktivieren und Deaktivieren einer Komponente.
     *
     * @param INPUT $Label Gibt die Bezeichnung der Komponente an.
     * @param INPUT $CheckedValue Gibt den Wert der Komponente an, wenn die Komponente aktiviert wurde.
     * @param INPUT $UnCheckedValue Gibt den Wert der Komponente an, wenn die Komponente deaktiviert wurde.
     */
    class Toggle extends \edoc\appserver\app\AbstractComponent
    {
        use \edoc\appserver\app\component\Visibility;
        use \edoc\appserver\app\component\Editable;
        use \edoc\appserver\app\component\PropertyClass;
        protected function init()
        {
        }
        public function htmlContent()
        {
        }
    }
    /**
     * Upload-Komponente
     *
     * Die **Upload**-Komponente ist eine Komponente zum Hochladen von Dateien.
     *
     * Wenn Sie den Upload von mehreren Dateien aktiviert haben, können Sie im Anschluss auf alle Dateien z.B. mit der
     * **dataset\Each**-Aktion oder **dataset\GetAll**-Aktion zugreifen.
     *
     * @param INPUT $label Gibt die Bezeichnung der Komponente an.
     * @param INPUT $accept Gibt den Mime-Type an, um die Dateitypen beim Hochladen einzugrenzen.
     * @param INPUT $multiple Gibt an, ob der Upload von mehreren Dateien aktiviert und deaktiviert ist.
     *
     */
    class Upload extends \edoc\appserver\app\AbstractComponent implements \edoc\appserver\app\ComponentInstanceValue
    {
        use \edoc\appserver\app\component\Visibility;
        use \edoc\appserver\app\component\Editable;
        use \edoc\appserver\app\component\PropertyClass;
        protected function init()
        {
        }
        public function htmlContent()
        {
        }
        public function uploadFile($content, $headers)
        {
        }
        public function value()
        {
        }
        public function namedValue($name)
        {
        }
    }
    /**
     * Viewer-Komponente
     *
     * Die **Viewer**-Komponente ist eine Komponente zum Anzeigen von Dateien.
     *
     * Folgende Formate werden unterstützt: **image/jpeg**, **image/png**, **text/plain**, **text/html**,
     * **application/pdf**, **application/json**.
     *
     * Folgende CSS-Klassen werden pro unterstütztem Formattyp für die Komponente verwendet:
     * - Für **image/jpeg** wird die CSS-Klasse **image jpeg** verwendet.
     * - Für **image/png** wird die CSS-Klasse **image png** verwendet. 
     * - Für **text/plain** wird die CSS-Klasse **text plain** verwendet.
     * - Für **text/html** wird die CSS-Klasse **text html** verwendet.
     * - Für **application/pdf** wird die CSS-Klasse **pdf** verwendet.
     * - Für **application/json** wird die CSS-Klasse **json** verwendet.
     *
     * **Hinweis**: Zum Darstellen von PDF-Dateien wird die Vorschau des Browsers verwendet.
     *
     * @param SELECT $content-type Gibt den Inhaltstyp (Content-Type) der anzuzeigenden Datei an.
     */
    class Viewer extends \edoc\appserver\app\AbstractComponent
    {
        use \edoc\appserver\app\component\Visibility;
        use \edoc\appserver\app\component\PropertyClass;
        protected function init()
        {
        }
        public function value()
        {
        }
        public function setValue($value, $name = null)
        {
        }
        public function htmlContent()
        {
        }
    }
}
namespace edoc\appserver\app\integrations {
    class DecsHome extends \edoc\appserver\app\integrations\AbstractIntegration
    {
        public function init(): void
        {
        }
        public function deploy(): void
        {
        }
    }
    class DvelopDashboard extends \edoc\appserver\app\integrations\AbstractIntegration
    {
        public function status(): \edoc\appserver\app\integrations\Status
        {
        }
        public function init(): void
        {
        }
        public function deploy(): void
        {
        }
        protected function undeploy(): void
        {
        }
    }
    class DvelopDms extends \edoc\appserver\app\integrations\AbstractIntegration
    {
        public function init(): void
        {
        }
        public function deploy(): void
        {
        }
    }
    class DvelopInbound extends \edoc\appserver\app\integrations\AbstractIntegration
    {
        public function init(): void
        {
        }
        public function deploy(): void
        {
        }
    }
    /**
     * WorkplaceAppDrawer
     *
     * Mit der WorkplaceAppDrawer-Integration können zusätzliche Links im Workplace-Menü angezeigt werden.
     *
     * @param TEXT $Group Gibt an, in welcher Gruppe der Link angezeigt wird.
     * @param TEXT $Title Gibt an, welche Bezeichnung für den Link verwendet wird.
     * @param LINK $Link Gibt den aufzurufenden Link an.
     * @param LINK $Icon Gibt eine URL zu einem Icon an.
     */
    class WorkplaceAppDrawer extends \edoc\appserver\app\integrations\AbstractIntegration
    {
        protected function init(): void
        {
        }
        public function status(): \edoc\appserver\app\integrations\Status
        {
        }
        protected function request($method, $url, $data = null)
        {
        }
        public function deploy(): void
        {
        }
        public function undeploy(): void
        {
        }
        public function handleEvent(\edoc\appserver\app\integrations\AppEventTypes $event): void
        {
        }
    }
}
namespace edoc\appserver {
    class Runtime
    {
        public function __construct(private \FastRoute\Dispatcher $dispatcher)
        {
        }
        public function exec()
        {
        }
        protected function execApp(\edoc\appserver\App $app, $routeOptions, $vars)
        {
        }
        protected function showAppMaintenance(): void
        {
        }
        protected function takeoverWorkflowSession(): void
        {
        }
        protected function handleAppXHRRequest(\edoc\appserver\App $app, array $routeParams): void
        {
        }
    }
}
namespace edoc\appserver\services {
    class AppData
    {
        public function __construct()
        {
        }
        /**
         * @return string
         */
        public function getTempPath(): string
        {
        }
        /**
         * @return string
         */
        public function getPersistentPath(): string
        {
        }
        public function getPersistentUrl(): string
        {
        }
        public function clearTemp()
        {
        }
    }
    class Composer
    {
        public static function &getInstance(?\edoc\appserver\App $app = null): self
        {
        }
        public function list(): array
        {
        }
        public function exec(string $cmd, string $path)
        {
        }
    }
    #[\edoc\appserver\stubs\attributes\PluginAPI]
    abstract class EdocService
    {
        /** @var Client */
        protected $client;
        abstract protected function getConfigKey(): string;
        abstract protected function getConfigKeySecret(): string;
        public function __construct()
        {
        }
        protected function getBaseUrl(): string
        {
        }
        protected function getApiSecret(): string
        {
        }
        protected function getDefaultHeaders(): array
        {
        }
        protected function getClient(): \GuzzleHttp\Client
        {
        }
        protected function handleError(\Psr\Http\Message\ResponseInterface $response, array $wantedStatus = [200]): void
        {
        }
        public function request(string $method, string $path, array $options): \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class DatahubService extends \edoc\appserver\services\EdocService
    {
        public const SCHEMA_COLLECTION_SHAPE = ["name" => "string", "attributes" => ["prop1" => "string"]];
        public const SCHEMA_SHAPE = ["id" => "string", "createdAt" => "int", "updatedAt" => "null|int", "source" => "string", "clientShortName" => "string", "collections" => [self::SCHEMA_COLLECTION_SHAPE]];
        public const EVENT_SHAPE = ["name" => "string", "text" => "string"];
        protected function getConfigKey(): string
        {
        }
        protected function getConfigKeySecret(): string
        {
        }
        protected function handleError(\Psr\Http\Message\ResponseInterface $response, array $wantedStatus = [200]): void
        {
        }
        /**
         * ############ CLIENTS ############################################################################################
         */
        /**
         * Liefert eine Liste aller angelegten Mandanten.
         *
         * @return array
         * @throws EdocDatahubServiceException
         */
        public function getClients(): array
        {
        }
        /**
         * ############ TARGET OBJECTS #####################################################################################
         */
        /**
         * Liefert eine Liste alle angelegten Ziel-Objekten und deren Eigenschaften.
         *
         * @return array
         * @throws EdocDatahubServiceException
         */
        public function getTargetObjects(): array
        {
        }
        /**
         * Erzeugt ein neues Ziel-Objekt
         *
         * @param string $source
         * @param string $name Name des Ziel-Objekts
         * @param string $text Text des Ziel-Objekts
         * @param array $properties Liste mit den Eigenschaften des Ziel-Objektes
         * @return void
         * @throws EdocDatahubServiceException
         */
        public function createTargetObject(
            string $source,
            string $name,
            string $text,
            #[\JetBrains\PhpStorm\ArrayShape([["id" => "string", "text" => "string", "key" => "boolean", "source" => ["string"]]])]
            array $properties
        ): void
        {
        }
        /**
         * Liefert die importierten Daten des Ziel-Objektes.
         *
         * @param string $clientId
         * @param string $targetObjectName Name des Ziel-Objektes
         * @param array $propertyIds Liste mit den Ids der Eigenschaften des Ziel-Objektes
         * @param int $createdAfter Liefert nur Daten, die nach dem angegebenen Zeitstempel erzeugt wurden.
         * @param int $updatedAfter Liefert nur Daten, die nach dem angegebenen Zeitstempel aktualisiert wurden.
         * @param int $pageNumber Welche Seite der Daten soll geladen werden
         * @param int $pageSize Wieviele Zeilen soll eine Seite anzeigen.
         * @return array
         * @throws EdocDatahubServiceException
         */
        public function getTargetObjectData(string $clientId, string $targetObjectName, array $propertyIds, int $createdAfter = 0, int $updatedAfter = 0, int $pageNumber = 0, int $pageSize = 100): array
        {
        }
        /**
         * ############ WEBHOOKS ###########################################################################################
         */
        /**
         * Erzeugt einen neuen Webhook.
         *
         * @param string $host Die Adresse des Ziel-Servers. Bei Verwendung von edoc-Services nur den Service-Namen angeben.\
         * Bei externen mit angabe des zu verwendenten Protokols (http://)
         * @param string $path Relativer Pfad aufzurufenden Endpunktes.
         *
         * @return string Id des neu angelegten Webhooks
         */
        public function createWebhook(string $host, string $path): string
        {
        }
        /**
         * ############ SCHEMAS ############################################################################################
         */
        /**
         * Liefert ein Schema zur angegebenen Quelle und Client.
         *
         * @param string $source
         * @param string $clientShortName
         * @return array
         * @throws EdocDatahubServiceException
         */
        public function getSchemas(string $source, string $clientShortName): array
        {
        }
        /**
         *
         * Löscht das mit Quelle und Client angegebene Schema.
         *
         * @param string $source
         * @param string $clientShortName
         * @return array
         * @throws EdocDatahubServiceException
         */
        public function deleteSchema(string $source, string $clientShortName): array
        {
        }
        /**
         * Erstellt ein neues Schema
         *
         * @param string $source
         * @param string $clientShortName
         * @param $collections
         * @return array
         */
        public function createSchema(
            string $source,
            string $clientShortName,
            #[\JetBrains\PhpStorm\ArrayShape([self::SCHEMA_COLLECTION_SHAPE])]
            $collections
        ): array
        {
        }
        /**
         * Aktualisiert das angegebene Schema
         *
         * @param string $source
         * @param string $clientShortName
         * @param array $collections
         * @return array
         */
        public function updateSchema(
            string $source,
            string $clientShortName,
            #[\JetBrains\PhpStorm\ArrayShape([self::SCHEMA_COLLECTION_SHAPE])]
            array $collections
        ): array
        {
        }
        /**
         * ############ EVENTS #############################################################################################
         */
        /**
         * Liefert alle Events
         *
         * @param string|null $source
         * @return array
         * @throws EdocDatahubServiceException
         */
        public function getEvents(?string $source = null): array
        {
        }
        /**
         * Erstellt neue Ebents
         *
         * @param string $source
         * @param string $description
         * @param array $events
         * @return array
         */
        public function createEvents(
            string $source,
            string $description,
            #[\JetBrains\PhpStorm\ArrayShape([self::EVENT_SHAPE])]
            array $events
        ): array
        {
        }
        /**
         * Aktualisiert die angegebenen Events
         *
         * @param string $source
         * @param array $events
         * @param string|null $description
         * @return array
         * @throws EdocDatahubServiceException
         */
        public function updateEvents(string $source, array $events, ?string $description = null): array
        {
        }
        /**
         * Löscht die angegebenen Events
         *
         * @param string $source
         * @param string|null $name
         * @return void
         * @throws EdocDatahubServiceException
         */
        public function deleteEvents(string $source, ?string $name = null): void
        {
        }
        /**
         * Startet einen Bewegungsdaten-Export zum angegebenen Event
         *
         * @param $source
         * @param $eventName
         * @param $eventId
         * @param $clientShortName
         * @param $payload
         * @return void
         * @throws \Exception
         */
        public function sendEvent($source, $eventName, $eventId, $clientShortName, $payload)
        {
        }
    }
    class DocBlockReader
    {
        public function __construct($object)
        {
        }
        protected function getParentParams(\ReflectionClass $reflector)
        {
        }
        protected function parseDocBlock(\ReflectionClass $reflector, $docBlockComment)
        {
        }
        public function getShort()
        {
        }
        public function getDescription()
        {
        }
        public function getParameters()
        {
        }
        public function getReturn()
        {
        }
    }
    #[\edoc\appserver\stubs\attributes\PluginAPI]
    class DocumentService extends \edoc\appserver\services\EdocService
    {
        protected function getConfigKey(): string
        {
        }
        protected function getConfigKeySecret(): string
        {
        }
        public static function GetInstance(): self
        {
        }
        /**
         * @throws \Exception
         */
        protected function handleError(\Psr\Http\Message\ResponseInterface $response, array $wantedStatus = [200]): void
        {
        }
        public function request(string $method, string $path, array $options = []): \Psr\Http\Message\ResponseInterface
        {
        }
        public function getLabel(array $label): string
        {
        }
        public function mapDocumentProperties(array $doc): array
        {
        }
        public function getSchemaDetails($schemaName)
        {
        }
        public function getDocumentsBySchema($schemaName, $pageSize = 10000, $page = 1)
        {
        }
        public function getDocumentsBySchemaSince($schemaName, $createdSince)
        {
        }
        public function getDocument($documentId, &$responseHeaders)
        {
        }
        public function getDocumentByExternalId($documentId, $schemaName)
        {
        }
        public function getDocumentContent($documentId, &$responseHeaders)
        {
        }
        public function getDocumentOcr($documentId, $refresh = false)
        {
        }
        public function newDocument($schemaName, array $attributes, $fileContents, $fileName = "")
        {
        }
        public function saveDocument($schemaName, $fileContents, $fileName = "")
        {
        }
        public function updateAttributes($documentId, $schema, $attributes = [])
        {
        }
        public function getSchemaList(bool $noCache = false): array
        {
        }
        public function getSchemas()
        {
        }
        public function getSchema(string $schemaName)
        {
        }
        public function saveSchema(string $schemaName, array $data): void
        {
        }
        public function deleteSchema(string $schemaName): void
        {
        }
        public function getSchemaWebhooks(string $schemaName, string $appName)
        {
        }
        public function saveSchemaWebhooks(string $schemaName, string $appName, array $data): void
        {
        }
        public function deleteSchemaWebhooks(string $schemaName, string $appName): void
        {
        }
        public function deleteDocument($documentId)
        {
        }
    }
}
namespace edoc\appserver\services\dvelop {
    class Dashboard
    {
        public function __construct(string $baseUri, string $authSessionId)
        {
        }
        /**
         * Register a widget in dashboard app
         *
         * @param string $appName
         * @param string $widgetId
         * @param array $widgetData
         *
         * @return void
         * @throws GuzzleException
         */
        public function registerWidget(string $appName, string $widgetId, array $widgetData): void
        {
        }
    }
    class IdentityProvider
    {
        public function __construct(string $baseUri)
        {
        }
        public function session(string $apiKey, &$output)
        {
        }
        public function validate(string $authSessionId, $allowExternalValidation = true)
        {
        }
        public function impersonateSession(string $authSessionId, string $userId)
        {
        }
        public function appSession()
        {
        }
        public static function validateAppRegistrationValidation(string $id): bool
        {
        }
    }
    class IdentityProviderException extends \edoc\appserver\app\exceptions\AutomateException
    {
        protected string $baseUri;
        public function getBaseUri(): string
        {
        }
        public function __construct(string $message = "", int $code = 0, ?\Throwable $previous = null, string $baseUri = "")
        {
        }
    }
    class Routes
    {
        public static function init(\FastRoute\RouteCollector $routeCollector): void
        {
        }
        public static function default(): void
        {
        }
        /*public static function appEditor(): void
            {
                $addrExtern = Config::getInstance()->get('server.addr_extern');
                echo <<<HTML
        <!DOCTYPE html>
        <html>
        <head>
        <meta http-equiv="refresh" content="0;url=$addrExtern/automate">
        </head>
        <body></body>
        </html>
        HTML;
                die();
            }
        
            public static function permissions(): void
            {
                echo <<<HTML
        <html>
          <head>
          <title>Test </title>
          <script src="https://cdn.service.d-velop.cloud/dapi/latest/dapi.js"></script>
          </head>
          <body>
          <h1>Permissions</h1>
        </body>
        </html>
        HTML;
            }*/
        public static function features(): void
        {
        }
        public static function dmsObjectExtensions(): void
        {
        }
        public static function inboundExtensions(): void
        {
        }
        // Offer a config feature to configure permissions
        /*public static function configFeatures(): void
          {
              $appName = Config::getInstance()->get('dvelopaddons.app_name');
              self::response(
                  [
                      "appName" => $appName,
                      "customHeadlines" => [
                          [
                              "caption" => "edoc automate",
                              "description"=> "Konfiguration zum Tool edoc automate",
                              "menuItems" => [
                                  [
                                      "caption" => "Benutzerrollen",
                                      "description"=> "Legen Sie Benutzerrollen fest",
                                      "href"=> "/" . $appName . "/dvelop/permissions",
                                      "keywords"=>["Ergebnis"],
                                      "configurationState" => 0
                                  ]
                              ],
                              "categories" => [
                                  [
                                      "id" => "9a64b476-dc7c-4c8b-b555-6d03caf64131",
                                      "caption" => "Miscellaneous"
                                  ]
                              ]
                          ]
                      ]
                  ]
              );
          }*/
        /**
         * Callback for identity provider app sessions
         * @return void
         */
        public static function appSessionCallback($params): void
        {
        }
        public static function response($data): void
        {
        }
        /**
         * @param string $appSecret The secret generated for your app in the cloud-center
         * @param string $systemBaseUri SystemBaseUri for the tenant (found in 'x-dv-baseuri'-header)
         * @param string $tenantId ID for the tenant (found in 'x-dv-tenant-id'-header)
         * @param string $requestSignature ID for the request (found in 'x-dv-sig-1'-header)
         *
         * @throws \Exception
         */
        public static function validateRequestSignature(string $appSecret, string $systemBaseUri, string $tenantId, string $requestSignature): void
        {
        }
    }
}
namespace edoc\appserver\services {
    class ErrorLog
    {
        public static function getInstance()
        {
        }
        public function entries($limit)
        {
        }
        public function logErrorResponse($data)
        {
        }
    }
    class FileDownload
    {
        const DATA_PREFIX = 'fd-data:';
        const HASH_PREFIX = 'fd-hash:';
        const DATA_TTL = 300;
        public function __construct()
        {
        }
        public function send($id, $options)
        {
        }
        public function add($content, $mime, $name = null): string
        {
        }
    }
    class InvoiceService extends \edoc\appserver\services\EdocService
    {
        protected function getConfigKey(): string
        {
        }
        protected function getConfigKeySecret(): string
        {
        }
        public static function GetInstance(): self
        {
        }
        /**
         * @throws \Exception
         */
        protected function handleError(\Psr\Http\Message\ResponseInterface $response, array $wantedStatus = [200]): void
        {
        }
        public function restartWorkflow(string $ecmId, string $subject = "", string $inbox = "", string $assignee = "")
        {
        }
        public function forwardInvoice(string $ecmId, string $subject = "", string $inbox = "", string $assignee = "")
        {
        }
        public function setStatus(string $ecmId, string $event)
        {
        }
    }
    class Keycloak
    {
        public function __construct()
        {
        }
        public function updateCacheUsers(array $users, string $updated_at, array &$stats)
        {
        }
        public function updateCacheGroups(array $groups, string $updated_at, array &$stats)
        {
        }
        public function clearCache(string $updated_at, array &$stats)
        {
        }
        public function useCache($timeout = 600): bool
        {
        }
        public function getUsersFromCache($max = 1000)
        {
        }
        public function getGroupsFromCache($max = 1000)
        {
        }
        public function getUsersInGroupByIdFromCache($groupId, $max = 1000)
        {
        }
        public function getUsersInGroupByNameFromCache($groupName, $max = 1000)
        {
        }
        public function buildUserList(array $userList, $withUUID = false)
        {
        }
        public function startAuthentication(?\edoc\appserver\app\Layout $layout = null)
        {
        }
        public function currentUserInfo($token = null)
        {
        }
        public function isAuthenticated(&$parsedToken = null)
        {
        }
        public function validate(array $requiredRoles)
        {
        }
        public function setup(\edoc\appserver\app\Layout $layout)
        {
        }
        public function updateRoles(array $roles, $appName = null)
        {
        }
        public function getUsersFromKeycloak($max = 1000)
        {
        }
        /**
         * @return false|mixed
         */
        public function getUsers($raw = false, $max = 1000)
        {
        }
        public function getGroupsFromKeycloak($max)
        {
        }
        /**
         *
         */
        public function getGroups($max = 1000)
        {
        }
        public function getUsersInGroupByIdFromKeycloak($groupId, $max = 10000)
        {
        }
        public function getUsersInGroupById($groupId, $maxUsers = 10000, $raw = false)
        {
        }
        public function getUsersInGroupByName($groupName, $maxUsers = 10000)
        {
        }
        /**
         * @param $userId
         * @param $roleName
         * @return false
         */
        public function checkUserRoles($userId, $roleName)
        {
        }
        public function loadUserDetailsByUuid($uuid)
        {
        }
        public function getUserId($username)
        {
        }
        public function getUserDetails($username, $withUUID = false)
        {
        }
        public function getUserAttributes($username)
        {
        }
        protected function getUserGroupsFromKeycloak($userId, $max = 10000)
        {
        }
        protected function getUserGroupsFromCache($userId, $max = 10000)
        {
        }
        public function getUserGroups($username, $maxGroups = 10000, $withIds = true)
        {
        }
        public static function countRoles($permissions): int
        {
        }
    }
    class KeycloakAuthenticationRequired extends \Exception
    {
    }
    class KeycloakException extends \Exception
    {
    }
    class Language
    {
        public static function GetInstance($autoload = true, $defaultLang = null): self
        {
        }
        public static function setDefaultLanguage(string $lang): void
        {
        }
        public static function langDir(): string
        {
        }
        public function messageFilePath(string $lang): string
        {
        }
        public function map(string $key, string $to, ?string $from = null): string
        {
        }
        public function acceptFromHeader(): array
        {
        }
        protected function loadUserLocale(): void
        {
        }
        public function getLanguage(): string
        {
        }
        public function getLocale(): string
        {
        }
        public function getDecimalSeparator(): false|string
        {
        }
        public function getThousandsSeparator(): false|string
        {
        }
        public function setLangauge(string $lang): void
        {
        }
        public function setLanguage($lang): void
        {
        }
        public function load(string $lang): bool
        {
        }
        public function getAll(): array
        {
        }
        /**
         * Translates value given via $value if translation existent and returns (translated) $value
         * @param $value mixed The value to translate
         *
         * @return mixed
         */
        public function tr(string|int|float|null $value)
        {
        }
    }
    class SessionKeepAlive
    {
        public const ROUTE = '/session/keep-alive';
        public const DEFAULT_INTERVAL = 300;
        public static function init(\FastRoute\RouteCollector $routeCollector, \edoc\appserver\core\Config $config): void
        {
        }
        public static function addToLayout(\edoc\appserver\app\Layout $layout, \edoc\appserver\core\Config $config): void
        {
        }
        public function __construct(private readonly \edoc\appserver\utils\FilesystemWrapper $filesystem)
        {
        }
        public function keepAlive(): void
        {
        }
    }
    class Supervisor
    {
        public function __construct(\edoc\appserver\App $app)
        {
        }
        public function isRunning($taskId): bool
        {
        }
        /**
         * creates or updates a job config
         *
         * @param $taskId string
         * @param bool|null $autostart
         * @param bool $restartTask
         */
        public function updateJob(string $taskId, ?bool $autostart = null, $restartTask = true): void
        {
        }
        public function jobStatus(string $taskId): array
        {
        }
        public function jobExists(string $taskId): bool
        {
        }
        public function jobLog(string $taskId)
        {
        }
        public function deleteJob(string $taskId): void
        {
        }
        public function start(string $taskId): void
        {
        }
        public function stop(string $taskId): void
        {
        }
    }
}
namespace Laminas\Translator {
    interface TranslatorInterface
    {
        /**
         * Translate a message.
         *
         * @param string $message
         * @param string $textDomain
         * @param string $locale
         * @return string
         */
        public function translate($message, $textDomain = 'default', $locale = null);
        /**
         * Translate a plural message.
         *
         * @param string      $singular
         * @param string      $plural
         * @param int         $number
         * @param string      $textDomain
         * @param string|null $locale
         * @return string
         */
        public function translatePlural($singular, $plural, $number, $textDomain = 'default', $locale = null);
    }
}
namespace Laminas\I18n\Translator {
    /**
     * Translator interface.
     *
     * @deprecated Since 2.27.0 The translator interface is now in a separate package `laminas/laminas-translator` and this
     *             interface should be replaced by `Laminas\Translator\TranslatorInterface`
     */
    interface TranslatorInterface extends \Laminas\Translator\TranslatorInterface
    {
    }
    /**
     * Translator.
     */
    class Translator implements \Laminas\I18n\Translator\TranslatorInterface
    {
        /**
         * Event fired when the translation for a message is missing.
         */
        public const EVENT_MISSING_TRANSLATION = 'missingTranslation';
        /**
         * Event fired when no messages were loaded for a locale/text-domain combination.
         */
        public const EVENT_NO_MESSAGES_LOADED = 'noMessagesLoaded';
        /**
         * Messages loaded by the translator.
         *
         * @var array
         */
        protected $messages = [];
        /**
         * Files used for loading messages.
         *
         * @var array
         */
        protected $files = [];
        /**
         * Patterns used for loading messages.
         *
         * @var array
         */
        protected $patterns = [];
        /**
         * Remote locations for loading messages.
         *
         * @var array
         */
        protected $remote = [];
        /**
         * Default locale.
         *
         * @var string|null
         */
        protected $locale;
        /**
         * Locale to use as fallback if there is no translation.
         *
         * @var string|null
         */
        protected $fallbackLocale;
        /**
         * Translation cache.
         *
         * @var CacheStorage|null
         */
        protected $cache;
        /**
         * Plugin manager for translation loaders.
         *
         * @var LoaderPluginManager
         */
        protected $pluginManager;
        /**
         * Event manager for triggering translator events.
         *
         * @var EventManagerInterface
         */
        protected $events;
        /**
         * Whether events are enabled
         *
         * @var bool
         */
        protected $eventsEnabled = false;
        /**
         * Instantiate a translator
         *
         * @param  array|Traversable $options
         * @return static
         * @throws Exception\InvalidArgumentException
         */
        public static function factory($options)
        {
        }
        /**
         * Set the default locale.
         *
         * @param  string|null $locale
         * @return $this
         */
        public function setLocale($locale)
        {
        }
        /**
         * Get the default locale.
         *
         * @return string
         */
        public function getLocale()
        {
        }
        /**
         * Set the fallback locale.
         *
         * @param  string|null $locale
         * @return $this
         */
        public function setFallbackLocale($locale)
        {
        }
        /**
         * Get the fallback locale.
         *
         * @return string|null
         */
        public function getFallbackLocale()
        {
        }
        /**
         * Sets a cache
         *
         * @return $this
         */
        public function setCache(?\Laminas\Cache\Storage\StorageInterface $cache = null)
        {
        }
        /**
         * Returns the set cache
         *
         * @return CacheStorage|null The set cache
         */
        public function getCache()
        {
        }
        /**
         * Set the plugin manager for translation loaders
         *
         * @return $this
         */
        public function setPluginManager(\Laminas\I18n\Translator\LoaderPluginManager $pluginManager)
        {
        }
        /**
         * Retrieve the plugin manager for translation loaders.
         *
         * Lazy loads an instance if none currently set.
         *
         * @return LoaderPluginManager
         */
        public function getPluginManager()
        {
        }
        /**
         * Translate a message.
         *
         * @param  string      $message
         * @param  string      $textDomain
         * @param  string|null $locale
         * @return string
         */
        public function translate($message, $textDomain = 'default', $locale = null)
        {
        }
        /**
         * Translate a plural message.
         *
         * @param  string      $singular
         * @param  string      $plural
         * @param  int         $number
         * @param  string      $textDomain
         * @param  string|null $locale
         * @return string
         * @throws Exception\OutOfBoundsException
         */
        public function translatePlural($singular, $plural, $number, $textDomain = 'default', $locale = null)
        {
        }
        /**
         * Get a translated message.
         *
         * @triggers getTranslatedMessage.missing-translation
         * @param    string $message
         * @param    string $locale
         * @param    string $textDomain
         * @return   string|null
         */
        protected function getTranslatedMessage($message, $locale, $textDomain = 'default')
        {
        }
        /**
         * Add a translation file.
         *
         * @param  string      $type
         * @param  string      $filename
         * @param  string      $textDomain
         * @param  string|null $locale
         * @return $this
         */
        public function addTranslationFile($type, $filename, $textDomain = 'default', $locale = null)
        {
        }
        /**
         * Add multiple translations with a file pattern.
         *
         * @param  string $type
         * @param  string $baseDir
         * @param  string $pattern
         * @param  string $textDomain
         * @return $this
         */
        public function addTranslationFilePattern($type, $baseDir, $pattern, $textDomain = 'default')
        {
        }
        /**
         * Add remote translations.
         *
         * @param  string $type
         * @param  string $textDomain
         * @return $this
         */
        public function addRemoteTranslations($type, $textDomain = 'default')
        {
        }
        /**
         * Get the cache identifier for a specific textDomain and locale.
         *
         * @param  string $textDomain
         * @param  string $locale
         * @return string
         */
        public function getCacheId($textDomain, $locale)
        {
        }
        /**
         * Clears the cache for a specific textDomain and locale.
         *
         * @param  string $textDomain
         * @param  string $locale
         * @return bool
         */
        public function clearCache($textDomain, $locale)
        {
        }
        /**
         * Load messages for a given language and domain.
         *
         * @triggers loadMessages.no-messages-loaded
         * @param    string $textDomain
         * @param    string $locale
         * @throws   Exception\RuntimeException
         * @return   void
         */
        protected function loadMessages($textDomain, $locale)
        {
        }
        /**
         * Load messages from remote sources.
         *
         * @param  string $textDomain
         * @param  string $locale
         * @return bool
         * @throws Exception\RuntimeException When specified loader is not a remote loader.
         */
        protected function loadMessagesFromRemote($textDomain, $locale)
        {
        }
        /**
         * Load messages from patterns.
         *
         * @param  string $textDomain
         * @param  string $locale
         * @return bool
         * @throws Exception\RuntimeException When specified loader is not a file loader.
         */
        protected function loadMessagesFromPatterns($textDomain, $locale)
        {
        }
        /**
         * Load messages from files.
         *
         * @param  string $textDomain
         * @param  string $locale
         * @return bool
         * @throws Exception\RuntimeException When specified loader is not a file loader.
         */
        protected function loadMessagesFromFiles($textDomain, $locale)
        {
        }
        /**
         * Return all the messages.
         *
         * @param string      $textDomain
         * @param string|null $locale
         * @return mixed
         */
        public function getAllMessages($textDomain = 'default', $locale = null)
        {
        }
        /**
         * Get the event manager.
         *
         * @return EventManagerInterface
         */
        public function getEventManager()
        {
        }
        /**
         * Set the event manager instance used by this translator.
         *
         * @return $this
         */
        public function setEventManager(\Laminas\EventManager\EventManagerInterface $events)
        {
        }
        /**
         * Check whether the event manager is enabled.
         *
         * @return bool
         */
        public function isEventManagerEnabled()
        {
        }
        /**
         * Enable the event manager.
         *
         * @return $this
         */
        public function enableEventManager()
        {
        }
        /**
         * Disable the event manager.
         *
         * @return $this
         */
        public function disableEventManager()
        {
        }
    }
}
namespace edoc\appserver\services {
    class Translator extends \Laminas\I18n\Translator\Translator
    {
        public function setFallbackLocales(array $locales)
        {
        }
        protected function translateWithoutFallback($message, $textDomain, $locale)
        {
        }
        public function translate($message, $textDomain = 'default', $locale = null)
        {
        }
    }
    class Workflow
    {
        protected static $variables = [];
        /**
         * @return bool
         */
        public function isWorkflowRequest()
        {
        }
        public function isDecsTask()
        {
        }
        /**
         * @return bool
         */
        public function validateTask($taskId = null, $url = null)
        {
        }
        public function closeTask($taskId = null)
        {
        }
        public function getVariables()
        {
        }
        public function updateVariable($name, $value, ?string $flowInstanceId = null)
        {
        }
        public function createInstance($flow, $variables, $docId = null)
        {
        }
        public function delegate($variables, $taskId = null)
        {
        }
        public function store(array $flowData)
        {
        }
        public function getDefinitions(): mixed
        {
        }
        public function tasksForGroup(string $flowDefinitionName, string $groupName)
        {
        }
        public function startSession()
        {
        }
        public function closeSession($sessionUuid)
        {
        }
        public function getFlowInstanceDetails()
        {
        }
        public function getWorkplacePath()
        {
        }
        public function delete($name): bool
        {
        }
        public function abortInstance($instanceId)
        {
        }
        public function resubmit($date, $taskId = null, $flowId = null)
        {
        }
    }
    class WorkflowSessionRequestException extends \Exception
    {
        public function __construct($sessionUuid, $userUuid, $sessionStart)
        {
        }
        public function sessionUuid()
        {
        }
        public function userUuid()
        {
        }
        public function sessionStart()
        {
        }
    }
    class WorkflowVariables extends \edoc\appserver\app\AbstractAction
    {
        /**
         * @param Workflow $workflow
         */
        public function setWorkflow(\edoc\appserver\services\Workflow $workflow)
        {
        }
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\stubs\attributes {
    #[\Attribute(\Attribute::TARGET_CLASS)]
    class PluginAPI
    {
    }
    #[\Attribute(\Attribute::TARGET_CLASS)]
    class PluginAPIIgnore
    {
    }
}
namespace edoc\appserver\stubs {
    class Generator
    {
        public function __construct(private readonly string $srcDir, private readonly string $outputFile)
        {
        }
        /**
         * @throws \ReflectionException
         */
        public function run(): void
        {
        }
        /**
         * Returns all parent classes, interfaces, and traits that are used by
         * PluginAPI-annotated classes, but do not themselves have the PluginAPI attribute.
         *
         * These might be missing in the stub output and should be reviewed.
         *
         * @throws \ReflectionException
         */
        public function getUsedNonPluginAPIElements(): array
        {
        }
    }
}
namespace edoc\appserver\utils {
    class AppMigration
    {
        public function __construct(\edoc\appserver\App $app, string $migrationsPath, string $statusFile)
        {
        }
        public function exec(): void
        {
        }
    }
    class FilesystemWrapper
    {
        public function fileExists(string $path): bool
        {
        }
        public function isFile(string $path): bool
        {
        }
        public function isDir(string $path): bool
        {
        }
        public function requireFile(string $path): void
        {
        }
        public function glob(string $pattern, int $flags = 0): array
        {
        }
    }
}
namespace Monolog\Handler {
    /**
     * Interface to describe loggers that have processors
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    interface ProcessableHandlerInterface
    {
        /**
         * Adds a processor in the stack.
         *
         * @phpstan-param ProcessorInterface|(callable(LogRecord): LogRecord) $callback
         *
         * @param  ProcessorInterface|callable $callback
         * @return HandlerInterface            self
         */
        public function pushProcessor(callable $callback): \Monolog\Handler\HandlerInterface;
        /**
         * Removes the processor on top of the stack and returns it.
         *
         * @phpstan-return ProcessorInterface|(callable(LogRecord): LogRecord) $callback
         *
         * @throws \LogicException             In case the processor stack is empty
         * @return callable|ProcessorInterface
         */
        public function popProcessor(): callable;
    }
    /**
     * Interface to describe loggers that have a formatter
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    interface FormattableHandlerInterface
    {
        /**
         * Sets the formatter.
         *
         * @return HandlerInterface self
         */
        public function setFormatter(\Monolog\Formatter\FormatterInterface $formatter): \Monolog\Handler\HandlerInterface;
        /**
         * Gets the formatter.
         */
        public function getFormatter(): \Monolog\Formatter\FormatterInterface;
    }
}
namespace Monolog {
    /**
     * Handler or Processor implementing this interface will be reset when Logger::reset() is called.
     *
     * Resetting ends a log cycle gets them back to their initial state.
     *
     * Resetting a Handler or a Processor means flushing/cleaning all buffers, resetting internal
     * state, and getting it back to a state in which it can receive log records again.
     *
     * This is useful in case you want to avoid logs leaking between two requests or jobs when you
     * have a long running process like a worker or an application server serving multiple requests
     * in one process.
     *
     * @author Grégoire Pineau <lyrixx@lyrixx.info>
     */
    interface ResettableInterface
    {
        public function reset(): void;
    }
}
namespace Monolog\Handler {
    /**
     * Interface that all Monolog Handlers must implement
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    interface HandlerInterface
    {
        /**
         * Checks whether the given record will be handled by this handler.
         *
         * This is mostly done for performance reasons, to avoid calling processors for nothing.
         *
         * Handlers should still check the record levels within handle(), returning false in isHandling()
         * is no guarantee that handle() will not be called, and isHandling() might not be called
         * for a given record.
         *
         * @param LogRecord $record Partial log record having only a level initialized
         */
        public function isHandling(\Monolog\LogRecord $record): bool;
        /**
         * Handles a record.
         *
         * All records may be passed to this method, and the handler should discard
         * those that it does not want to handle.
         *
         * The return value of this function controls the bubbling process of the handler stack.
         * Unless the bubbling is interrupted (by returning true), the Logger class will keep on
         * calling further handlers in the stack with a given log record.
         *
         * @param  LogRecord $record The record to handle
         * @return bool      true means that this handler handled the record, and that bubbling is not permitted.
         *                   false means the record was either not processed or that this handler allows bubbling.
         */
        public function handle(\Monolog\LogRecord $record): bool;
        /**
         * Handles a set of records at once.
         *
         * @param array<LogRecord> $records The records to handle
         */
        public function handleBatch(array $records): void;
        /**
         * Closes the handler.
         *
         * Ends a log cycle and frees all resources used by the handler.
         *
         * Closing a Handler means flushing all buffers and freeing any open resources/handles.
         *
         * Implementations have to be idempotent (i.e. it should be possible to call close several times without breakage)
         * and ideally handlers should be able to reopen themselves on handle() after they have been closed.
         *
         * This is useful at the end of a request and will be called automatically when the object
         * is destroyed if you extend Monolog\Handler\Handler.
         *
         * If you are thinking of calling this method yourself, most likely you should be
         * calling ResettableInterface::reset instead. Have a look.
         */
        public function close(): void;
    }
    /**
     * Base Handler class providing basic close() support as well as handleBatch
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    abstract class Handler implements \Monolog\Handler\HandlerInterface
    {
        /**
         * @inheritDoc
         */
        public function handleBatch(array $records): void
        {
        }
        /**
         * @inheritDoc
         */
        public function close(): void
        {
        }
        public function __destruct()
        {
        }
        public function __sleep()
        {
        }
    }
    /**
     * Base Handler class providing basic level/bubble support
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    abstract class AbstractHandler extends \Monolog\Handler\Handler implements \Monolog\ResettableInterface
    {
        protected \Monolog\Level $level = \Monolog\Level::Debug;
        protected bool $bubble = true;
        /**
         * @param int|string|Level|LogLevel::* $level  The minimum logging level at which this handler will be triggered
         * @param bool                         $bubble Whether the messages that are handled can bubble up the stack or not
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $level
         */
        public function __construct(int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        /**
         * @inheritDoc
         */
        public function isHandling(\Monolog\LogRecord $record): bool
        {
        }
        /**
         * Sets minimum logging level at which this handler will be triggered.
         *
         * @param  Level|LogLevel::* $level Level or level name
         * @return $this
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $level
         */
        public function setLevel(int|string|\Monolog\Level $level): self
        {
        }
        /**
         * Gets minimum logging level at which this handler will be triggered.
         */
        public function getLevel(): \Monolog\Level
        {
        }
        /**
         * Sets the bubbling behavior.
         *
         * @param  bool  $bubble true means that this handler allows bubbling.
         *                       false means that bubbling is not permitted.
         * @return $this
         */
        public function setBubble(bool $bubble): self
        {
        }
        /**
         * Gets the bubbling behavior.
         *
         * @return bool true means that this handler allows bubbling.
         *              false means that bubbling is not permitted.
         */
        public function getBubble(): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function reset(): void
        {
        }
    }
    /**
     * Helper trait for implementing ProcessableInterface
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    trait ProcessableHandlerTrait
    {
        /**
         * @var callable[]
         * @phpstan-var array<(callable(LogRecord): LogRecord)|ProcessorInterface>
         */
        protected array $processors = [];
        /**
         * @inheritDoc
         */
        public function pushProcessor(callable $callback): \Monolog\Handler\HandlerInterface
        {
        }
        /**
         * @inheritDoc
         */
        public function popProcessor(): callable
        {
        }
        protected function processRecord(\Monolog\LogRecord $record): \Monolog\LogRecord
        {
        }
        protected function resetProcessors(): void
        {
        }
    }
    /**
     * Helper trait for implementing FormattableInterface
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    trait FormattableHandlerTrait
    {
        protected \Monolog\Formatter\FormatterInterface|null $formatter = null;
        /**
         * @inheritDoc
         */
        public function setFormatter(\Monolog\Formatter\FormatterInterface $formatter): \Monolog\Handler\HandlerInterface
        {
        }
        /**
         * @inheritDoc
         */
        public function getFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
        /**
         * Gets the default formatter.
         *
         * Overwrite this if the LineFormatter is not a good default for your handler.
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * Base Handler class providing the Handler structure, including processors and formatters
     *
     * Classes extending it should (in most cases) only implement write($record)
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     * @author Christophe Coevoet <stof@notk.org>
     */
    abstract class AbstractProcessingHandler extends \Monolog\Handler\AbstractHandler implements \Monolog\Handler\ProcessableHandlerInterface, \Monolog\Handler\FormattableHandlerInterface
    {
        use \Monolog\Handler\ProcessableHandlerTrait;
        use \Monolog\Handler\FormattableHandlerTrait;
        /**
         * @inheritDoc
         */
        public function handle(\Monolog\LogRecord $record): bool
        {
        }
        /**
         * Writes the (already formatted) record down to the log of the implementing handler
         */
        abstract protected function write(\Monolog\LogRecord $record): void;
        public function reset(): void
        {
        }
    }
}
namespace edoc\appserver\utils {
    class MonologPDOHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        public function __construct(\PDO $pdo, $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        protected function write(\Monolog\LogRecord $record): void
        {
        }
    }
}
namespace edoc\appserver\utils\parsers {
    class ParamOptionsParser
    {
        public function __construct($params)
        {
        }
        public function result(): array
        {
        }
    }
    class ParamsParser
    {
        public const PARAMS_PATTERN = '%(\W?)(:(\w+)(\[([^\]]+)\])?)(\W?)%i';
        protected array $params = [];
        public function __construct(array $params, $text, callable|array|null $callEscape = null)
        {
        }
        protected function escape($val, bool &$addedQuotes)
        {
        }
        public function parse(): array|string|null
        {
        }
        protected function parseParamPlaceholder(array $paramParts): string
        {
        }
        protected function parseParamOptions(array $param, $val, bool &$paramQuotes, bool &$paramNoQuotes)
        {
        }
        protected function parseParamQuotes($val, bool $paramQuotes, bool $paramNoQuotes): string
        {
        }
        protected function isJson($json, $depth = 512, $flags = 0): bool
        {
        }
    }
}
namespace edoc\appserver\test {
    abstract class AppServerTestCase extends \PHPUnit\Framework\TestCase
    {
        protected function defaultDatasourceConfig(): array
        {
        }
        protected function logger(): \Monolog\Logger
        {
        }
    }
    abstract class ActionTestCase extends \edoc\appserver\test\AppServerTestCase
    {
        /** @var AbstractComponent|null  */
        protected $_component = null;
        /** @var AbstractComponent|null  */
        protected $mainView = null;
        protected $_mainViewName = 'TestView';
        protected $_fieldId = 'testElement';
        protected $_inputId = 'testInput';
        protected $_value = 'TestValue';
        /** @var App|null  */
        protected $_app = null;
        protected $childComponents = [];
        protected $baseComponents = [];
        protected function setUp(): void
        {
        }
        protected function tearDown(): void
        {
        }
    }
}
namespace edoc\appserver\test\actions {
    class ConcatActionTest extends \edoc\appserver\test\ActionTestCase
    {
        public function setUp(): void
        {
        }
        public function testSimpleConcatAction()
        {
        }
        public function testNestedConcatAction()
        {
        }
    }
    class ConditionActionTest extends \edoc\appserver\test\ActionTestCase
    {
        protected $_config = [];
        protected $_valueTrue = "";
        protected $_valueFalse = "";
        protected function setUp(): void
        {
        }
        protected function validateResponseData(array $data, string $value)
        {
        }
        public function testConditionEqualTrue()
        {
        }
        public function testConditionEqualFalse()
        {
        }
        public function testConditionUnequalTrue()
        {
        }
        public function testConditionUnequalFalse()
        {
        }
        public function testConditionGreaterTrue()
        {
        }
        public function testConditionGreaterFalse()
        {
        }
        public function testConditionSmallerTrue()
        {
        }
        public function testConditionSmallerFalse()
        {
        }
    }
    class DatabaseActionsTest extends \edoc\appserver\test\ActionTestCase
    {
        protected function setUp(): void
        {
        }
        public function testInsertAndDelete(): void
        {
        }
    }
    class GetParameterTest extends \edoc\appserver\test\ActionTestCase
    {
        protected function setUp(): void
        {
        }
        public function testInit()
        {
        }
        public function testExec()
        {
        }
    }
    class GetValueTest extends \edoc\appserver\test\ActionTestCase
    {
        protected function setUp(): void
        {
        }
        public function testExec()
        {
        }
        public function testInit()
        {
        }
    }
    class LinkTest extends \edoc\appserver\test\ActionTestCase
    {
        protected function setUp(): void
        {
        }
        public function testInit()
        {
        }
        public function testExec()
        {
        }
        public function testLoadActions()
        {
        }
    }
    class MessageActionTest extends \edoc\appserver\test\ActionTestCase
    {
        protected function setUp(): void
        {
        }
        public function testSimpleMessage()
        {
        }
    }
    class SetDatasetActionTest extends \edoc\appserver\test\ActionTestCase
    {
        protected function setUp(): void
        {
        }
        public function testAddJSCallbacks()
        {
        }
        public function testReturnDataset()
        {
        }
    }
    class SetValueTest extends \edoc\appserver\test\ActionTestCase
    {
        protected function setUp(): void
        {
        }
        /**
         * @return SetValue
         * @throws \Exception
         */
        public function createAction()
        {
        }
        public function testInit()
        {
        }
        public function testExec()
        {
        }
    }
    class ValueActionsTest extends \edoc\appserver\test\ActionTestCase
    {
        protected function setUp(): void
        {
        }
        public function testSetValueAction()
        {
        }
        public function testGetValueAction()
        {
        }
    }
}
namespace edoc\appserver\test\app\actions {
    class AbstractParameterValidationActionTest extends \PHPUnit\Framework\TestCase
    {
        protected \PHPUnit\Framework\MockObject\MockObject $validator;
        /**
         * @throws Exception
         */
        protected function setUp(): void
        {
        }
        public function callMethod(string $name, ...$args): mixed
        {
        }
        /**
         * @throws Exception
         */
        #[\PHPUnit\Framework\Attributes\TestDox('The $value of $type with $pattern is expected to be $expected')]
        public function testValidateException()
        {
        }
        #[\PHPUnit\Framework\Attributes\DataProvider('provideBuildErrorData')]
        public function testBuildError(string $expected, string $prepend, string $append, string $pattern, string $type)
        {
        }
        #[\PHPUnit\Framework\Attributes\TestWith([true, '', '', 1], 'Type Empty')]
        #[\PHPUnit\Framework\Attributes\TestWith([true, 'number', '1; 2; 5-10', '1'], 'Type number')]
        #[\PHPUnit\Framework\Attributes\TestWith([true, 'text', 'link1; ' . "'link2-22\"'", 'link2-22"'], 'Type text')]
        #[\PHPUnit\Framework\Attributes\TestWith([true, 'regex', '@\d{2,4}@', '44'], 'Type regex')]
        #[\PHPUnit\Framework\Attributes\TestDox('The $value of $type with $pattern is expected to be $expected')]
        public function testIsValueValid(bool $expected, ?string $type, ?string $pattern, string|int|null $value)
        {
        }
        #[\PHPUnit\Framework\Attributes\TestWith([true, '', 1], 'Empty pattern integer value')]
        #[\PHPUnit\Framework\Attributes\TestWith([true, '', '1'], 'Empty pattern and string value')]
        #[\PHPUnit\Framework\Attributes\TestWith([true, '55-60', '57'], 'Single pattern')]
        #[\PHPUnit\Framework\Attributes\TestWith([true, '1; 2-5; 10;      200-400', '10'], 'Numbers and ranges 1')]
        #[\PHPUnit\Framework\Attributes\TestWith([false, '1; 2-5; 10;      200-400', '500'], 'Numbers and ranges 2')]
        #[\PHPUnit\Framework\Attributes\TestDox('Number $value with $pattern is expected to be $expected')]
        public function testIsNumberMatchPattern(bool $expected, ?string $pattern, string|int|null $value)
        {
        }
        #[\PHPUnit\Framework\Attributes\TestWith([false, '', 1], 'Empty pattern integer value')]
        #[\PHPUnit\Framework\Attributes\TestWith([true, '', '1'], 'Empty pattern and string value')]
        #[\PHPUnit\Framework\Attributes\TestWith([true, 'id2332;id-3333; active-Link2002', 'active-Link2002'], 'Simple stings')]
        #[\PHPUnit\Framework\Attributes\TestWith([false, 'id2332;id-3333; active-Link2002', 'Link2002'], 'Simple strings')]
        #[\PHPUnit\Framework\Attributes\TestWith([true, '"String1-;link2/sses"; Kai; ' . "'    Nan-aria-Eboal\"a;{]53'" . "; Link1", '    Nan-aria-Eboal"a;{]53'], 'Quoted complex strings')]
        #[\PHPUnit\Framework\Attributes\TestDox('Is Text Pattern => $pattern match in $value, expected: $expected')]
        public function testIsTextMatchPattern(bool $expected, ?string $pattern, string|int|null $value)
        {
        }
        #[\PHPUnit\Framework\Attributes\TestWith([true, null, '1'], 'Empty pattern skipped truly')]
        #[\PHPUnit\Framework\Attributes\TestWith([true, '', ''], 'Empty pattern and value skipped truly')]
        #[\PHPUnit\Framework\Attributes\TestWith([true, '@\w+-\d+@', 'section-2'], 'Match word and numbers')]
        #[\PHPUnit\Framework\Attributes\TestWith([false, '@^\d{2}$@', '332'], 'Match number of 2')]
        #[\PHPUnit\Framework\Attributes\TestWith([true, '@^\d{3,5}$@', '332'], 'Match number between 3 and 5')]
        #[\PHPUnit\Framework\Attributes\TestWith([true, '@^id-\d+-offset-\d{2}-page:\d{1,3}$@s', 'id-203-offset-03-page:33'], 'Match id-number-offset-number-page:number')]
        #[\PHPUnit\Framework\Attributes\TestDox('Is Regx => $pattern matches in $value, expected: $expected')]
        public function testIsValueMatchARegex(bool $expected, ?string $pattern, string|int|null $value)
        {
        }
        #[\PHPUnit\Framework\Attributes\TestWith([false, null, []])]
        #[\PHPUnit\Framework\Attributes\TestWith([false, '', []])]
        #[\PHPUnit\Framework\Attributes\TestWith([false, '4', ['1', '2', '3']])]
        #[\PHPUnit\Framework\Attributes\TestWith([true, '10092', ['10092', '23323', '444432']])]
        #[\PHPUnit\Framework\Attributes\TestDox('Is $value in $sections => $expected')]
        public function testIsMatchAnyNumber(bool $expected, string|int|null $value, array|bool $sections)
        {
        }
        #[\PHPUnit\Framework\Attributes\DataProvider('provideInAnyRangesData')]
        #[\PHPUnit\Framework\Attributes\TestDox('Is $value in any range of $pattern => $sections expect: $expected')]
        public function testIsAValueInAnyRange(bool $expected, string|int|null $value, ?string $pattern, array|bool $sections)
        {
        }
        #[\PHPUnit\Framework\Attributes\DataProvider('provideExtractTokensData')]
        #[\PHPUnit\Framework\Attributes\TestDox('Extracted Tokens from $pattern are expected to be $expected')]
        public function testExtractTokens(array $expected, ?string $pattern)
        {
        }
        public static function provideExtractTokensData(): array
        {
        }
        public static function provideInAnyRangesData(): array
        {
        }
        public static function provideBuildErrorData(): array
        {
        }
    }
    class AbstractParameterValidationActionTestClass extends \edoc\appserver\app\actions\AbstractParameterValidationAction
    {
        protected function init()
        {
        }
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
}
namespace edoc\appserver\test\app {
    class AppTest extends \edoc\appserver\test\AppServerTestCase
    {
        public function testAppProperties()
        {
        }
    }
    class ConfigTest extends \edoc\appserver\test\AppServerTestCase
    {
        public function setUp(): void
        {
        }
        public function testGetInstance()
        {
        }
        public function testGet()
        {
        }
    }
}
namespace edoc\appserver\test {
    abstract class ComponentIntegrationTestCase extends \edoc\appserver\test\AppServerTestCase
    {
        /** @var App */
        protected $_app = null;
        protected function tearDown(): void
        {
        }
        protected function setUpApp(array $appConfig): void
        {
        }
    }
}
namespace edoc\appserver\test\app {
    class SimpleComponentTest extends \edoc\appserver\test\ComponentIntegrationTestCase
    {
        protected function setUp(): void
        {
        }
        public function testHTMLContent()
        {
        }
        public function testClickEvent()
        {
        }
    }
    class ValidatorTest extends \PHPUnit\Framework\TestCase
    {
        public function testRegEx()
        {
        }
        public function testRequired()
        {
        }
        public function testList()
        {
        }
        public function testCreationViaCreate()
        {
        }
    }
}
namespace edoc\appserver\test {
    final class AppLoaderTest extends \edoc\appserver\test\AppServerTestCase
    {
        public function testExpectUnknownApp()
        {
        }
    }
    class TestSessionHandler implements \SessionHandlerInterface
    {
        public function close(): bool
        {
        }
        public function destroy($session_id): bool
        {
        }
        public function gc($maxlifetime): int
        {
        }
        public function open($save_path, $session_name): bool
        {
        }
        public function read($sessionId): string
        {
        }
        public function write($session_id, $session_data): bool
        {
        }
    }
    class ComponentTestCase extends \edoc\appserver\test\AppServerTestCase
    {
        protected $_view = null;
        protected $_mainViewName = 'TestView';
        protected $_fieldId = 'testElement';
        protected $_value = 'TestValue';
        protected $_app = null;
        protected function setUp(): void
        {
        }
    }
}
namespace edoc\appserver\test\components {
    class AbstractComponentTest extends \edoc\appserver\test\ComponentTestCase
    {
        public function setUp(): void
        {
        }
        public function testGroup()
        {
        }
        public function testSetCurrentValue()
        {
        }
        public function testParent()
        {
        }
        public function testProperties()
        {
        }
        public function testHtml()
        {
        }
        public function testExecEvent()
        {
        }
        public function testName()
        {
        }
        public function testDefaultParam()
        {
        }
        public function testSetTags()
        {
        }
        public function testId()
        {
        }
        public function testSetValue()
        {
        }
        public function testLabel()
        {
        }
        public function test__debugInfo()
        {
        }
        public function testGetActionsByEvent()
        {
        }
        public function testIsBase()
        {
        }
        public function testTags()
        {
        }
        public function testParam()
        {
        }
        public function testGetComponentByName()
        {
        }
        public function test__construct()
        {
        }
        public function testGetComponentById()
        {
        }
        public function testRoutes()
        {
        }
        public function testSetRenderMode()
        {
        }
        public function testSetBase()
        {
        }
        public function testBasicId()
        {
        }
        public function testClearRegisteredEvents()
        {
        }
        public function testValue()
        {
        }
        public function testHtmlContent()
        {
        }
        public function testSetParam()
        {
        }
        public function testRegisteredEvents()
        {
        }
        public function testGetActions()
        {
        }
        public function testEnableOnload()
        {
        }
    }
    class AbstractEmbeddedComponentTest extends \edoc\appserver\test\ComponentTestCase
    {
        public function testProperties()
        {
        }
    }
    class ButtonComponentTest extends \edoc\appserver\test\ComponentTestCase
    {
        public function testComponent()
        {
        }
    }
    class ColumnsComponentTest extends \edoc\appserver\test\ComponentTestCase
    {
        public function testComponent()
        {
        }
        public function testEmbeddedComponent()
        {
        }
    }
    class ComponentComponentTest extends \edoc\appserver\test\ComponentTestCase
    {
        public function testComponent()
        {
        }
    }
    class ComponentInComponentTest extends \edoc\appserver\test\ComponentTestCase
    {
        public function testOnloadEventOnEmbeddedComponent()
        {
        }
    }
    class DateTimeInputComponentTest extends \edoc\appserver\test\ComponentTestCase
    {
        public function testAppendedScriptsAvailable()
        {
        }
    }
    class InputComponentTest extends \edoc\appserver\test\ComponentTestCase
    {
        public function testComponent()
        {
        }
    }
    class TableComponentTest extends \edoc\appserver\test\ComponentTestCase
    {
        public function testComponent()
        {
        }
        public function testClickEventOnButtonInTable()
        {
        }
        public function testSetDatasetOnloadToTabel()
        {
        }
        public function testOnChangeOnTableCell()
        {
        }
    }
    class TextComponentTest extends \edoc\appserver\test\ComponentTestCase
    {
        public function testComponent()
        {
        }
    }
    class TitleComponentTest extends \edoc\appserver\test\ComponentTestCase
    {
        public function testComponent()
        {
        }
    }
}
namespace edoc\appserver\test\core {
    class AutoloaderTest extends \PHPUnit\Framework\TestCase
    {
        protected function setUp(): void
        {
        }
        protected function tearDown(): void
        {
        }
        public function testClearCache(): void
        {
        }
        #[\PHPUnit\Framework\Attributes\TestWith(['/mock/path/file.php', '/mock/path/file.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['/mock/path/file.php', '/mock/path/File.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['/mock/path/file.php', '/mock/Path/file.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['/mock/path/file.php', '/mock/Path/File.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['/mock/path/File.php', '/mock/Path/File.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['/mock/Path/file.php', '/mock/path/file.php'])]
        public function testResolvePathCaseInsensitive(string $requestedPath, string $realPath): void
        {
        }
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\app\components\Input', '/app/runtime/src/plugins/components/Input/Input.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\app\components\Table', '/app/runtime/src/plugins/components/Table/Table.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\app\components\plugins\Test', '/app/apps/{appid}/plugins/components/Test/Test.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\app\validators\TestValidator', '/app/apps/{appid}/plugins/validators/TestValidator/TestValidator.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\app\validators\TEST', '/app/apps/{appid}/plugins/validators/TEST/TEST.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\app\integrations\TestIntegration', '/app/runtime/src/plugins/integrations/TestIntegration.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\app\components\plugins\Test', '/app/apps/{appid}/plugins/components/Test/Test.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\app\actions\plugins\Test', '/app/apps/{appid}/plugins/actions/Test/Test.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\datasources\driver\TEST', '/app/apps/{appid}/plugins/datasources/TEST.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\datasources\driver\Test', '/app/apps/{appid}/plugins/datasources/Test.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\datasources\driver\Test2', '/app/runtime/src/datasources/driver/Test2.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\addons\Test\actions\Test', '/app/runtime/src/addons/Test/actions/Test.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\addons\Test\datasources\Test', '/app/runtime/src/addons/Test/datasources/Test.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\addons\Test\lib\Test', '/app/runtime/src/addons/Test/lib/Test.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\addons\Test\lib\dir\Test', '/app/runtime/src/addons/Test/lib/dir/Test.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\addons\Test\actions\Test', '/app/apps/{appid}/addons/Test/actions/Test.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\addons\Test\datasources\Test', '/app/apps/{appid}/addons/Test/datasources/Test.php'])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\addons\Test\lib\Test', '/app/apps/{appid}/addons/Test/lib/Test.php'])]
        public function testLoadClass(string $className, string $expectedPath): void
        {
        }
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\app\components\Test', \edoc\appserver\core\Autoloader::LOG_TYPE_COMPONENT])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\app\validators\Test', \edoc\appserver\core\Autoloader::LOG_TYPE_PLUGIN_VALIDATOR])]
        #[\PHPUnit\Framework\Attributes\TestWith(['edoc\appserver\datasources\driver\Test', \edoc\appserver\core\Autoloader::LOG_TYPE_DATASOURCES])]
        public function testLoadClassFail(string $className, string $type): void
        {
        }
    }
    class ConfigTest extends \edoc\appserver\test\AppServerTestCase
    {
        public function setUp(): void
        {
        }
        public function testGetInstance()
        {
        }
        public function testGetValueWorks()
        {
        }
        public function testDumpWithoutRenderAndSort()
        {
        }
        public function testDumpWithRenderAndSort()
        {
        }
    }
    class SessionTest extends \edoc\appserver\test\AppServerTestCase
    {
        protected function setUp(): void
        {
        }
        protected function tearDown(): void
        {
        }
        public function testElementValue()
        {
        }
        public function testClear()
        {
        }
        public function testSetElementValue()
        {
        }
        public function testGetInstance()
        {
        }
    }
}
namespace edoc\appserver\test\Mocks {
    class ConcreteTestComponent extends \edoc\appserver\app\AbstractComponent
    {
        protected function init()
        {
        }
        public function htmlContent()
        {
        }
    }
    class ConcreteTestEmbeddedComponent extends \edoc\appserver\app\AbstractEmbeddedComponent
    {
        public function htmlContent()
        {
        }
        protected function initEmbedded()
        {
        }
    }
    class ConcreteTestSetDatasetAction extends \edoc\appserver\app\actions\SetDatasetAction
    {
        protected function init()
        {
        }
        /**
         * @inheritDoc
         */
        protected function exec(): \edoc\appserver\app\AbstractAction
        {
        }
    }
    class TestDB extends \edoc\appserver\datasources\Database
    {
        public ?\PDO $db = null;
        protected function init()
        {
        }
        /**
         * @inheritDoc
         */
        public function details()
        {
        }
        public function querySingle($SQL)
        {
        }
        public function query($SQL)
        {
        }
        public function lastInsertId()
        {
        }
        public function escape($string, bool &$addedQuotes)
        {
        }
    }
}
namespace edoc\appserver\test\services {
    class SessionKeepAliveTest extends \PHPUnit\Framework\TestCase
    {
        #[\PHPUnit\Framework\Attributes\Test]
        public function initAddsRoute(): void
        {
        }
        #[\PHPUnit\Framework\Attributes\Test]
        public function initThrowsExceptionWhenIntervalTooLarge(): void
        {
        }
        #[\PHPUnit\Framework\Attributes\Test]
        public function appLayoutShouldContainSessionKeepAliveContent(): void
        {
        }
        #[\PHPUnit\Framework\Attributes\Test]
        public function invalidSessionStatus(): void
        {
        }
        #[\PHPUnit\Framework\Attributes\Test]
        public function sessionIsAliveStatus(): void
        {
        }
    }
}
namespace ChrisKonnertz\StringCalc\Calculator {
    /**
     * The calculator has one important method: calculate()
     * It takes a container node as input and returns the
     * numeric result of the calculation.
     *
     * @package ChrisKonnertz\StringCalc\Calculator
     */
    interface CalculatorInterface
    {
        /**
         * Calculates the numeric result of nodes in the syntax tree.
         * It takes a parser node as input and returns the numeric
         * result of the calculation.
         *
         * @param AbstractNode $rootNode
         * @return float|int
         * @throws \Exception
         */
        public function calculate(\ChrisKonnertz\StringCalc\Parser\Nodes\AbstractNode $rootNode);
    }
}
namespace ChrisKonnertz\StringCalc\Support {
    /**
     * This is a trait with helper methods.
     *
     * @package ChrisKonnertz\StringCalc\Support
     */
    trait UtilityTrait
    {
        /**
         * Helper method. Throws a (custom) exception that should inherit from StringCalcException.
         *
         * @param string        $type The class name of the exception
         * @param string        $message The message f the exception. Must not contain unfiltered user input!
         * @param int|null      $position The position of the problem in the term
         * @param string|null   $subject Additional data. ATTENTION: May contain unfiltered user input!
         * @throws \Exception
         */
        protected function throwException($type, $message, $position = null, $subject = null)
        {
        }
    }
}
namespace ChrisKonnertz\StringCalc\Calculator {
    /**
     * The calculator has one important method: calculate()
     * It takes a container node as input and returns the
     * numeric result of the calculation.
     *
     * @package ChrisKonnertz\StringCalc\Calculator
     */
    class Calculator implements \ChrisKonnertz\StringCalc\Calculator\CalculatorInterface
    {
        use \ChrisKonnertz\StringCalc\Support\UtilityTrait;
        /**
         * Calculates the numeric result of nodes in the syntax tree.
         * It takes a parser node as input and returns the numeric
         * result of the calculation.
         *
         * @param AbstractNode $rootNode
         * @return float|int
         */
        public function calculate(\ChrisKonnertz\StringCalc\Parser\Nodes\AbstractNode $rootNode)
        {
        }
        /**
         * Calculates the numeric value / result of a node of
         * any known and calculable type. (For example symbol
         * nodes with a symbol of type separator are not
         * calculable.)
         *
         * @param AbstractNode $node
         * @return float|int
         */
        protected function calculateNode(\ChrisKonnertz\StringCalc\Parser\Nodes\AbstractNode $node)
        {
        }
        /**
         * This method actually calculates the results of every sub-terms
         * in the syntax tree (which consists of nodes).
         * It can call itself recursively.
         * Attention: $node must not be of type FunctionNode!
         *
         * @param ContainerNode $containerNode
         * @return float|int
         * @throws StringCalcException
         */
        protected function calculateContainerNode(\ChrisKonnertz\StringCalc\Parser\Nodes\ContainerNode $containerNode)
        {
        }
        /**
         * Returns the numeric value of a function node.
         *
         * @param FunctionNode $functionNode
         * @return int|float
         */
        protected function calculateFunctionNode(\ChrisKonnertz\StringCalc\Parser\Nodes\FunctionNode $functionNode)
        {
        }
        /**
         * Returns the numeric value of a symbol node.
         * Attention: $node->symbol must not be of type AbstractOperator!
         *
         * @param SymbolNode $symbolNode
         * @return int|float
         */
        protected function calculateSymbolNode(\ChrisKonnertz\StringCalc\Parser\Nodes\SymbolNode $symbolNode)
        {
        }
        /**
         * Detect the calculation order of a given array of nodes.
         * Does only care for the precedence of operators.
         * Does not care for child nodes of container nodes.
         * Returns a new array with ordered symbol nodes.
         *
         * @param AbstractNode[] $nodes
         * @return SymbolNode[]
         */
        protected function detectCalculationOrder(array $nodes)
        {
        }
    }
}
namespace ChrisKonnertz\StringCalc\Container {
    /**
     * A service provider returns a service object. In particular it creates
     * the service object by caring for its dependencies.
     *
     * @package ChrisKonnertz\StringCalc\Container
     */
    abstract class AbstractServiceProvider
    {
        /**
         * AbstractServiceProvider constructor.
         *
         * @param string             $serviceName
         * @param ContainerInterface $container
         */
        public function __construct($serviceName, \ChrisKonnertz\StringCalc\Container\ContainerInterface $container)
        {
        }
        /**
         * Creates the service object and returns it.
         * This method has to be implemented in the concrete service provider.
         *
         * @return object
         */
        abstract protected function createService();
        /**
         * Provides the service. This method is called by the service container.
         *
         * @return object
         */
        public function provide()
        {
        }
        /**
         * This method returns another service. This way the provider
         * can satisfy the dependencies of the service it wants to provide.
         * WARNING: The current implementation is vulnerable to cycles
         * (infinite loops)! TODO: Try to solve this issue.
         *
         * @param $serviceName
         * @return mixed
         * @throws ContainerException
         */
        protected function getService($serviceName)
        {
        }
        /**
         * Getter for the service name
         *
         * @return string
         */
        public function getServiceName()
        {
        }
    }
    /**
     * This class is the base class for all providers that mimic the singleton
     * pattern: They always return the same object. The concrete provider only
     * has to implement the createService() method.
     *
     * @package ChrisKonnertz\StringCalc\Container
     */
    abstract class AbstractSingletonServiceProvider extends \ChrisKonnertz\StringCalc\Container\AbstractServiceProvider
    {
        /**
         * The service object
         *
         * @var object
         */
        protected $service;
        /**
         * Provides the service.
         *
         * @return object
         */
        public function provide()
        {
        }
    }
    /**
     * Describes the interface of a container that exposes methods to read its entries.
     * Source: https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-11-container.md
     */
    interface ContainerInterface
    {
        /**
         * Finds an entry of the container by its identifier and returns it.
         *
         * @param string $id Identifier of the entry to look for.
         *
         * @throws NotFoundException  No entry was found for **this** identifier.
         * @throws ContainerException Error while retrieving the entry.
         *
         * @return mixed Entry.
         */
        public function get($id);
        /**
         * Returns true if the container can return an entry for the given identifier.
         * Returns false otherwise.
         *
         * `has($id)` returning true does not mean that `get($id)` will not throw an exception.
         * It does however mean that `get($id)` will not throw a `NotFoundExceptionInterface`.
         *
         * @param string $id Identifier of the entry to look for.
         *
         * @return bool
         */
        public function has($id);
    }
    /**
     * This class is a PSR-11 compatible container for all the services that this library uses.
     * ({@link https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-11-container.md})
     * Instead of directly creating objects the library uses services that create these objects.
     * Service containers can be replaced from outside the library, so they make it easy to replace
     * classes with custom implementations.
     *
     * @package ChrisKonnertz\StringCalc\Container
     */
    class Container implements \ChrisKonnertz\StringCalc\Container\ContainerInterface
    {
        /**
         * Array with the registered service providers.
         * They key of an item is the service name and
         * the value is the class name of a service provider.
         *
         * @var string[]
         */
        protected $serviceProviders;
        /**
         * Container constructor.
         *
         * @param ServiceProviderRegistry $serviceProviderRegistry
         * @throws ContainerException
         */
        public function __construct(\ChrisKonnertz\StringCalc\Container\ServiceProviderRegistry $serviceProviderRegistry)
        {
        }
        /**
         * Returns a service. The service name has to be registered.
         *
         * @param string $serviceName
         * @return object
         * @throws ContainerException
         * @throws NotFoundException
         */
        public function get($serviceName)
        {
        }
        /**
         * Returns true if a service with the given name exists.
         *
         * @param string $serviceName
         * @return bool
         */
        public function has($serviceName)
        {
        }
        /**
         * Adds a service provider to the array with registered service providers.
         * If the service name is in use, the old entry will be replaced by the new.
         *
         * @param string                  $serviceName
         * @param AbstractServiceProvider $serviceProvider
         * @return void
         */
        public function add($serviceName, \ChrisKonnertz\StringCalc\Container\AbstractServiceProvider $serviceProvider)
        {
        }
        /**
         * Returns the names of all registered services
         *
         * @return string[]
         */
        public function getNames()
        {
        }
        /**
         * Returns the number of services
         *
         * @return int
         */
        public function size()
        {
        }
    }
    interface ServiceProviderRegistryInterface
    {
        /**
         * This method has to return an array with the class names of
         * all registered service providers. Service providers have to
         * inherit from the AbstractServiceProvider class.
         *
         * @return string[]
         */
        public function getServiceProviders();
    }
    /**
     * This class is where all service providers are registered
     * (except of those that are registered at runtime).
     *
     * @package ChrisKonnertz\StringCalc\Container
     */
    class ServiceProviderRegistry implements \ChrisKonnertz\StringCalc\Container\ServiceProviderRegistryInterface
    {
        /**
         * @inheritdoc
         */
        public function getServiceProviders()
        {
        }
    }
}
namespace ChrisKonnertz\StringCalc\Container\ServiceProviders {
    /**
     * This is a service provider class for the calculator class.
     *
     * @package ChrisKonnertz\StringCalc\Container\ServiceProviders
     */
    class CalculatorServiceProvider extends \ChrisKonnertz\StringCalc\Container\AbstractSingletonServiceProvider
    {
        /**
         * @inheritdoc
         */
        protected function createService()
        {
        }
    }
    /**
     * This is a service provider class for the input stream class.
     *
     * @package ChrisKonnertz\StringCalc\Container\ServiceProviders
     */
    class InputStreamServiceProvider extends \ChrisKonnertz\StringCalc\Container\AbstractSingletonServiceProvider
    {
        /**
         * @inheritdoc
         */
        protected function createService()
        {
        }
    }
    /**
     * This is a service provider class for the string helper class.
     *
     * @package ChrisKonnertz\StringCalc\Container\ServiceProviders
     */
    class StringHelperServiceProvider extends \ChrisKonnertz\StringCalc\Container\AbstractSingletonServiceProvider
    {
        /**
         * @inheritdoc
         */
        protected function createService()
        {
        }
    }
    /**
     * This is a service provider class for the symbol container class.
     *
     * @package ChrisKonnertz\StringCalc\Container\ServiceProviders
     */
    class SymbolContainerServiceProvider extends \ChrisKonnertz\StringCalc\Container\AbstractSingletonServiceProvider
    {
        /**
         * @inheritdoc
         */
        protected function createService()
        {
        }
    }
}
namespace ChrisKonnertz\StringCalc\Exceptions {
    /**
     * This is the base class of all custom exceptions of this library.
     *
     * @package ChrisKonnertz\StringCalc\Exceptions
     */
    class StringCalcException extends \Exception
    {
        /**
         * The position in the term.
         *
         * @var int
         */
        protected $position = null;
        /**
         * Additional information.
         * ATTENTION: May include user input so use with care!
         *
         * @var string
         */
        protected $subject = null;
        /**
         * Setter for the position property.
         * Will accept invalid values but replace them with 0.
         *
         * @param int $position
         */
        public function setPosition($position)
        {
        }
        /**
         * Getter for the position property.
         *
         * @return int
         */
        public function getPosition()
        {
        }
        /**
         * Setter for the position property.
         *
         * @param string $subject
         */
        public function setSubject($subject)
        {
        }
        /**
         * Getter for the position property.
         *
         * @return string
         */
        public function getSubject()
        {
        }
    }
    /**
     * Class ParserException is thrown when something went wrong during the calculation of the term.
     *
     * @package ChrisKonnertz\StringCalc\Exceptions
     */
    class CalculatorException extends \ChrisKonnertz\StringCalc\Exceptions\StringCalcException
    {
    }
    /**
     * Class ContainerException is thrown when something went wrong in the domain of the server container.
     *
     * @package ChrisKonnertz\StringCalc\Exceptions
     */
    class ContainerException extends \ChrisKonnertz\StringCalc\Exceptions\StringCalcException
    {
    }
    /**
     * Class InvalidIdentifier is thrown when validation of an identifier fails.
     * This exception type is especially used by the AbstractSymbol class.
     *
     * @package ChrisKonnertz\StringCalc\Exceptions
     */
    class InvalidIdentifierException extends \ChrisKonnertz\StringCalc\Exceptions\StringCalcException
    {
    }
    /**
     * Class NotFoundException is thrown when something could not be found that should be available.
     *
     * @package ChrisKonnertz\StringCalc\Exceptions
     */
    class NotFoundException extends \ChrisKonnertz\StringCalc\Exceptions\StringCalcException
    {
    }
    /**
     * Class NumberOfArgumentsException is thrown when a function
     * (Symbols\AbstractFunction) is called with the wrong number
     * of arguments.
     *
     * @package ChrisKonnertz\StringCalc\Exceptions
     */
    class NumberOfArgumentsException extends \ChrisKonnertz\StringCalc\Exceptions\StringCalcException
    {
    }
    /**
     * Class ParserException is thrown when something went wrong during the parsing of the term.
     *
     * @package ChrisKonnertz\StringCalc\Exceptions
     */
    class ParserException extends \ChrisKonnertz\StringCalc\Exceptions\StringCalcException
    {
    }
}
namespace ChrisKonnertz\StringCalc\Grammar {
    /**
     * This abstract class represents a grammar. It also is a container for the rules
     * that define this grammar. You may use the constructor of a concrete grammar class
     * as a place to add concrete rules.
     *
     * @package ChrisKonnertz\StringCalc\Grammar
     */
    class AbstractGrammar
    {
        /**
         * Production rules of the grammar, will be filled at runtime
         *
         * @var Rule[]
         */
        protected $rules = [];
        /**
         * The name of the symbol that defines
         * the start for the production rules
         *
         * @var string
         */
        protected $start = null;
        /**
         * Adds a new production rule to the set of rules
         *
         * @param string $symbolName The name of the nonterminal symbol on the left side of the rule
         * @param AbstractExpression $expression The expression that represents the right side of the rule
         */
        public function addRule($symbolName, \ChrisKonnertz\StringCalc\Grammar\Expressions\AbstractExpression $expression)
        {
        }
        /**
         * Setter fot the start property
         *
         * @param $symbolName
         */
        public function setStart($symbolName)
        {
        }
        /**
         * Getter for the rules
         *
         * @return Rule[]
         */
        public function getRules()
        {
        }
        /**
         * Returns the whole grammar (or to be more precise, its rules) as a string
         *
         * @return string
         */
        public function __toString()
        {
        }
    }
}
namespace ChrisKonnertz\StringCalc\Grammar\Expressions {
    /**
     * Abstract base class for all expression classes
     *
     * @package ChrisKonnertz\StringCalc\Grammar\Expressions
     */
    abstract class AbstractExpression
    {
        /**
         * The grammar has to be printable so child classes have
         * to overwrite this method with their own implementation
         */
        abstract public function __toString();
    }
    /**
     * This expression class is the base class for all expression classes
     * that are containers for other expressions.
     *
     * @package ChrisKonnertz\StringCalc\Grammar\Expressions
     */
    abstract class AbstractContainerExpression extends \ChrisKonnertz\StringCalc\Grammar\Expressions\AbstractExpression
    {
        /**
         * Array with the expressions.
         * Attention: The order is relevant!
         *
         * @var AbstractExpression[]
         */
        protected $expressions;
        /**
         * AndExpression constructor.
         *
         * @param AbstractExpression[] ...$expressions
         */
        public function __construct(...$expressions)
        {
        }
        /**
         * Getter for the expressions array
         *
         * @return AbstractExpression[]
         */
        public function getExpressions()
        {
        }
        /**
         * Setter for the expressions array
         *
         * @param AbstractExpression[] $expressions
         */
        public function setExpressions(array $expressions)
        {
        }
        /**
         * Removes all expressions from the expressions array
         */
        public function removeExpressions()
        {
        }
        /**
         * Adds an expression at the end of the expressions array
         *
         * @param AbstractExpression $expression
         */
        public function addExpression(\ChrisKonnertz\StringCalc\Grammar\Expressions\AbstractExpression $expression)
        {
        }
    }
    /**
     * This is a container expression. The expressions that it contains are
     * linked with an AND.
     *
     * @package ChrisKonnertz\StringCalc\Grammar\Expressions
     */
    class AndExpression extends \ChrisKonnertz\StringCalc\Grammar\Expressions\AbstractContainerExpression
    {
        public function __toString()
        {
        }
    }
    /**
     * This is a container expression. The expressions that it contains are
     * linked with an AND. They (as a whole) are optional.
     *
     * @package ChrisKonnertz\StringCalc\Grammar\Expressions
     */
    class OptionalAndExpression extends \ChrisKonnertz\StringCalc\Grammar\Expressions\AbstractContainerExpression
    {
        public function __toString()
        {
        }
    }
    /**
     * This is a container expression. The expressions that it contains are
     * linked with an OR.
     *
     * @package ChrisKonnertz\StringCalc\Grammar\Expressions
     */
    class OrExpression extends \ChrisKonnertz\StringCalc\Grammar\Expressions\AbstractContainerExpression
    {
        public function __toString()
        {
        }
    }
    /**
     * This is a container expression. The expressions that it contains are
     * linked with an AND. They (as a whole) will be repeated for given times.
     *
     * @package ChrisKonnertz\StringCalc\Grammar\Expressions
     */
    class RepeatedAndExpression extends \ChrisKonnertz\StringCalc\Grammar\Expressions\AbstractContainerExpression
    {
        /**
         * Minimum of repetitions, >= 0
         *
         * @var int
         */
        protected $min = 0;
        /**
         * Maximum of repetitions, <= 0
         * @var int
         */
        protected $max = PHP_INT_MAX;
        /**
         * RepeatedAndExpression constructor.
         *
         * @param int $min 0...PHP_INT_MAX, must be <= $max
         * @param int $max 0...PHP_INT_MAX, must be >= $min
         * @param AbstractExpression[] ...$expressions
         */
        public function __construct($min, $max, ...$expressions)
        {
        }
        /**
         * Setter for min
         *
         * @return int
         */
        public function getMin()
        {
        }
        /**
         * Getter for min
         *
         * @param int $min
         */
        public function setMin($min)
        {
        }
        /**
         * Getter for max
         *
         * @return int
         */
        public function getMax()
        {
        }
        /**
         * Setter for max
         *
         * @param int $max
         */
        public function setMax($max)
        {
        }
        public function __toString()
        {
        }
    }
    /**
     * This class represents language symbols.
     *
     * @package ChrisKonnertz\StringCalc\Grammar\Expressions
     */
    class SymbolExpression extends \ChrisKonnertz\StringCalc\Grammar\Expressions\AbstractExpression
    {
        /**
         * The name of the language symbol
         *
         * @var string
         */
        protected $symbolName;
        /**
         * SymbolExpression constructor.
         *
         * @param string $symbolName
         */
        public function __construct($symbolName)
        {
        }
        /**
         * Setter for the symbol name
         *
         * @param string $symbolName
         */
        public function setSymbolMame($symbolName)
        {
        }
        /**
         * Getter for the symbol name
         *
         * @return string
         */
        public function getSymbolName()
        {
        }
        public function __toString()
        {
        }
    }
}
namespace ChrisKonnertz\StringCalc\Grammar {
    /**
     * Rule class that represents a (simplified) production rule of the grammar.
     *
     * @package ChrisKonnertz\StringCalc\Grammar
     */
    class Rule
    {
        /**
         * String used to separate the left and the right side of the rule
         * when it is printed as a string
         */
        const SIDE_SEPARATOR = ':=';
        /**
         * This is the left side of the rule. We simplify rules by
         * only allowing one non-terminal symbol on the left side of the rule.
         * We store its name in this property.
         *
         * @var string
         */
        protected $nonterminalSymbolName = '';
        /**
         * This is the right side of the rule. It is described by an
         * Expression object which can contain other expression objects.
         *
         * @var AbstractExpression
         */
        protected $expression = null;
        /**
         * AbstractRule constructor.
         *
         * @param string             $nonterminalSymbolName
         * @param AbstractExpression $expression
         */
        public function __construct($nonterminalSymbolName, \ChrisKonnertz\StringCalc\Grammar\Expressions\AbstractExpression $expression)
        {
        }
        /**
         * Getter for the name of the non-terminal symbol
         *
         * @return string
         */
        public function getNonterminalSymbolName()
        {
        }
        /**
         * Setter for the name of the non-terminal symbol
         *
         * @param string $nonterminalSymbolName
         */
        public function setNonterminalSymbolName($nonterminalSymbolName)
        {
        }
        /**
         * Getter for the expression
         *
         * @return AbstractExpression
         */
        public function getExpression()
        {
        }
        /**
         * Setter for the expression
         *
         * @param AbstractExpression $expression
         */
        public function setExpression($expression)
        {
        }
        public function __toString()
        {
        }
    }
    /**
     * This class represents the concrete grammar of StringCalc.
     * It also is a container for the rules that define this grammar.
     *
     * @package ChrisKonnertz\StringCalc\Grammar
     */
    class StringCalcGrammar extends \ChrisKonnertz\StringCalc\Grammar\AbstractGrammar
    {
        public function __construct()
        {
        }
    }
}
namespace ChrisKonnertz\StringCalc\Parser\Nodes {
    /**
     * This is the abstract base class for all parser nodes.
     * It does not implement any properties or methods.
     *
     * @package ChrisKonnertz\StringCalc\Parser
     */
    abstract class AbstractNode
    {
        /**
         * Call this method - especially on the root node of a syntax tree -
         * if you want to traverse it and all of it child nodes, no matter
         * how deep they are nested in the tree. You only have to pass a closure,
         * you do not have to pass an argument for the level parameter.
         * The callback will have two argument: The first is the node
         * (an object of type AbstractNode) and the second is the level of
         * this node. Example:
         *
         * $node->traverse(function($node, $level)
         * {
         *     var_dump($node, $level);
         * });
         *
         * @param Closure $callback
         * @param int     $level
         * @return void
         */
        abstract public function traverse(\Closure $callback, $level = 0);
        /**
         * @return string
         */
        public function __toString()
        {
        }
    }
    /**
     * A parent node is a container for a (sorted) array of nodes.
     * Notice: Do not mix this class up with the service container class.
     *
     * @package ChrisKonnertz\StringCalc\Parser
     */
    class ContainerNode extends \ChrisKonnertz\StringCalc\Parser\Nodes\AbstractNode
    {
        /**
         * Array of (sorted) child nodes
         * Notice: The number of child nodes can be 0.
         *
         * @var AbstractNode[]
         */
        protected $childNodes;
        /**
         * ContainerNode constructor.
         *
         * @param AbstractNode[] $childNodes
         */
        public function __construct(array $childNodes)
        {
        }
        /**
         * Setter for the child nodes.
         * Notice: The number of child nodes can be 0.
         *
         * @param AbstractNode[] $childNodes
         */
        public function setChildNodes(array $childNodes)
        {
        }
        /**
         * Returns the number of child nodes in this array node.
         * Does not count the child nodes of the child nodes.
         *
         * @return int
         */
        public function size()
        {
        }
        /**
         * Returns true if the array node does not have any
         * child nodes. This might sound strange but is possible.
         *
         * @return bool
         */
        public function isEmpty()
        {
        }
        /**
         * Getter for the child nodes
         *
         * @return AbstractNode[]
         */
        public function getChildNodes()
        {
        }
        /**
         * @inheritdoc
         */
        public function traverse(\Closure $callback, $level = 0)
        {
        }
    }
    /**
     * A function in a term consists of the name of the function
     * (the symbol of the function) and the brackets that follow
     * the name and everything that is in this brackets (the
     * arguments). A function node combines these two things.
     * It stores its symbol in the $symbolNode property and its
     * arguments in the $childNodes property which is inherited
     * from the ContainerNode class.
     *
     * @package ChrisKonnertz\StringCalc\Parser
     */
    class FunctionNode extends \ChrisKonnertz\StringCalc\Parser\Nodes\ContainerNode
    {
        /**
         * @var SymbolNode
         */
        protected $symbolNode;
        /**
         * ContainerNode constructor.
         * Attention: The constructor is differs from the constructor
         * of the parent class!
         *
         * @param AbstractNode[] $childNodes
         * @param SymbolNode     $symbolNode
         */
        public function __construct(array $childNodes, \ChrisKonnertz\StringCalc\Parser\Nodes\SymbolNode $symbolNode)
        {
        }
        /**
         * @return SymbolNode
         */
        public function getSymbolNode()
        {
        }
        /**
         * @param SymbolNode $symbolNode
         */
        public function setSymbolNode(\ChrisKonnertz\StringCalc\Parser\Nodes\SymbolNode $symbolNode)
        {
        }
    }
    /**
     * A symbol node is a node in the syntax tree.
     * Leaf nodes do not have any child nodes
     * (parent nodes can have child nodes). A
     * symbol node represents a mathematical symbol.
     * Nodes are created by the parser.
     *
     * @package ChrisKonnertz\StringCalc\Parser
     */
    class SymbolNode extends \ChrisKonnertz\StringCalc\Parser\Nodes\AbstractNode
    {
        /**
         * The token of the node. It contains the value.
         *
         * @var Token
         */
        protected $token;
        /**
         * The symbol of the node. It defines the type of the node.
         *
         * @var AbstractSymbol
         */
        protected $symbol;
        /**
         * Unary operators need to be treated specially.
         * Therefore a node has to know if it (or to be
         * more precise the symbol of the node)
         * represents a unary operator.
         *
         * @var bool
         */
        protected $isUnaryOperator = false;
        /**
         * SymbolNode constructor.
         *
         * @param Token          $token
         * @param AbstractSymbol $symbol
         */
        public function __construct(\ChrisKonnertz\StringCalc\Tokenizer\Token $token, \ChrisKonnertz\StringCalc\Symbols\AbstractSymbol $symbol)
        {
        }
        /**
         * Setter for the token
         *
         * @param Token $token
         */
        public function setToken(\ChrisKonnertz\StringCalc\Tokenizer\Token $token)
        {
        }
        /**
         * Getter for the token
         *
         * @return Token
         */
        public function getToken()
        {
        }
        /**
         * Setter for the symbol
         *
         * @param AbstractSymbol $symbol
         */
        public function setSymbol(\ChrisKonnertz\StringCalc\Symbols\AbstractSymbol $symbol)
        {
        }
        /**
         * Getter for the symbol
         *
         * @return AbstractSymbol
         */
        public function getSymbol()
        {
        }
        /**
         * Setter to remember that the node (or to be more precise the
         * symbol of the node) represents a unary operator
         *
         * @param bool $isUnaryOperator
         */
        public function setIsUnaryOperator($isUnaryOperator = true)
        {
        }
        /**
         * Returns true if the node (or to be more precise the
         * symbol of the node) represents a unary operator
         *
         * @return bool
         */
        public function isUnaryOperator()
        {
        }
        /**
         * @inheritdoc
         */
        public function traverse(\Closure $callback, $level = 0)
        {
        }
    }
}
namespace ChrisKonnertz\StringCalc\Parser {
    /**
     * The parsers has one important method: parse()
     * It takes an array of tokens as input and
     * returns an array of nodes as output.
     * These nodes are the syntax tree of the term.
     *
     * @package ChrisKonnertz\StringCalc\Parser
     */
    class Parser
    {
        use \ChrisKonnertz\StringCalc\Support\UtilityTrait;
        /**
         * The symbol container with all possible symbols
         *
         * @var SymbolContainerInterface
         */
        protected $symbolContainer;
        /**
         * Closure that is called at the end of the grammar checking
         *
         * @var Closure
         */
        protected $customGrammarChecker = null;
        /**
         * Parser constructor.
         *
         * @param SymbolContainerInterface $symbolContainer
         */
        public function __construct(\ChrisKonnertz\StringCalc\Symbols\SymbolContainerInterface $symbolContainer)
        {
        }
        /**
         * Parses an array with tokens. Returns an array of nodes.
         * These nodes define a syntax tree.
         *
         * @param Token[] $tokens
         * @return ContainerNode
         */
        public function parse(array $tokens)
        {
        }
        /**
         * Creates a flat array of symbol nodes from tokens.
         *
         * @param Token[] $tokens
         * @return SymbolNode[]
         * @throws NotFoundException
         * @throws ParserException
         */
        protected function detectSymbols(array $tokens)
        {
        }
        /**
         * Expects a flat array of symbol nodes and (if possible) transforms
         * it to a tree of nodes. Cares for brackets.
         * Attention: Expects valid brackets!
         * Check the brackets before you call this method.
         *
         * @param SymbolNode[] $symbolNodes
         * @return AbstractNode[]
         * @throws ParserException
         */
        protected function createTreeByBrackets(array $symbolNodes)
        {
        }
        /**
         * Replaces [a SymbolNode that has a symbol of type AbstractFunction,
         * followed by a node of type ContainerNode] by a FunctionNode.
         * Expects the $nodes not including any function nodes (yet).
         *
         * @param AbstractNode[] $nodes
         * @return AbstractNode[]
         * @throws ParserException
         */
        protected function transformTreeByFunctions(array $nodes)
        {
        }
        /**
         * Ensures the tree follows the grammar rules for terms
         *
         * @param array $nodes
         * @return void
         * @throws ParserException
         */
        protected function checkGrammar(array $nodes)
        {
        }
        /**
         * Setter for the custom grammar checker property.
         * Expects a function (closure) as a parameter.
         * This function is called at the end of the
         * grammar checking. An array with all nodes is
         * passed as an argument. If grammar checking
         * fails, the function has to throw a ParserException.
         * @param Closure $customGrammarChecker
         */
        public function setCustomGrammarChecker(\Closure $customGrammarChecker)
        {
        }
        /**
         * Removes the custom grammar checker.
         */
        public function unsetCustomGrammarChecker()
        {
        }
        /**
         * Getter for the custom grammar checker property.
         *
         * @return Closure
         */
        public function getCustomGrammarChecker()
        {
        }
    }
}
namespace ChrisKonnertz\StringCalc {
    /**
     * This is the StringCalc base class. It is the API frontend of
     * the StringCalc library. Call its calculate() method to
     * calculate a mathematical term.
     *
     * @package ChrisKonnertz\StringCalc
     */
    class StringCalc
    {
        /**
         * The current version number
         *
         * @const string
         */
        const VERSION = '2.0.0';
        /**
         * Closure that is called at the end of the grammar checking
         *
         * @var \Closure
         */
        protected $customGrammarChecker = null;
        /**
         * The service container
         *
         * @var ContainerInterface
         */
        protected $container;
        /**
         * Container that manages all symbols
         *
         * @var SymbolContainerInterface
         */
        protected $symbolContainer;
        /**
         * StringCalc constructor.
         *
         * @param ContainerInterface $container
         *
         * @throws Exceptions\ContainerException If the passed container parameter is not an object or
         *                                       if the passed container parameter does not implement ContainerInterface
         */
        public function __construct($container = null)
        {
        }
        /**
         * Calculates a term and returns the result.
         * Will return 0 if there is nothing to calculate.
         *
         * @param string $term
         * @return float|int
         * @throws Exceptions\ContainerException
         * @throws Exceptions\NotFoundException
         */
        public function calculate($term)
        {
        }
        /**
         * Tokenize the term. Returns an array with the tokens.
         *
         * @param string $term
         * @return array
         * @throws Exceptions\ContainerException
         * @throws Exceptions\NotFoundException
         */
        public function tokenize($term)
        {
        }
        /**
         * Parses an array of tokens. Returns a single node that is a container node.
         *
         * @param Token[] $tokens
         *
         * @return ContainerNode
         */
        public function parse(array $tokens)
        {
        }
        /**
         * Adds a symbol to the list of symbols.
         * This is just a shortcut method. Call getSymbolContainer() if you want to
         * call more methods directly on the symbol container.
         *
         * @param AbstractSymbol $symbol        The new symbol object
         * @param string|null    $replaceSymbol Class name of a known symbol that you want to replace
         * @return void
         */
        public function addSymbol(\ChrisKonnertz\StringCalc\Symbols\AbstractSymbol $symbol, $replaceSymbol = null)
        {
        }
        /**
         * Setter for the custom grammar checker property.
         *
         * @see Parser::setCustomGrammarChecker()
         *
         * @param \Closure $customGrammarChecker
         */
        public function setCustomGrammarChecker(\Closure $customGrammarChecker)
        {
        }
        /**
         * Removes the custom grammar checker.
         */
        public function unsetCustomGrammarChecker()
        {
        }
        /**
         * Getter for the symbol container
         *
         * @return SymbolContainerInterface
         */
        public function getSymbolContainer()
        {
        }
        /**
         * Getter for the service container
         *
         * @return ContainerInterface
         */
        public function getContainer()
        {
        }
    }
}
namespace ChrisKonnertz\StringCalc\Support {
    /**
     * A class that implements this interface has to contain methods that help dealing with strings.
     */
    interface StringHelperInterface
    {
        /**
         * Returns true if a string contains any multibyte characters.
         *
         * @param string $str
         * @return bool
         * @throws \Exception
         */
        public function containsMultibyteChar($str);
        /**
         * Validates a string:
         * - Not null
         * - Not empty
         * - Is a string
         * - Does not contain multibyte characters
         * Will throw an exception if the validation fails.
         *
         * @param mixed|null $str
         * @return void
         * @throws \Exception
         */
        public function validate($str);
    }
    /**
     * This class contains some methods that help dealing with strings.
     */
    class StringHelper implements \ChrisKonnertz\StringCalc\Support\StringHelperInterface
    {
        /**
         * Returns true if a string contains any multibyte characters.
         *
         * @param string $str
         * @return bool
         * @throws \Exception
         */
        public function containsMultibyteChar($str)
        {
        }
        /**
         * Validates a string:
         * - Not null
         * - Not empty
         * - Is a string
         * - Does not contain multibyte characters
         * Will throw an exception if the validation fails.
         *
         * @param mixed|null $str
         * @return void
         * @throws \Exception
         */
        public function validate($str)
        {
        }
    }
}
namespace ChrisKonnertz\StringCalc\Symbols {
    /**
     * A term is built of symbols: numbers/constants, variables, brackets, operators and functions.
     * - This is the abstract base class of all symbols.
     * - It is extended by a limited number of abstract classes that represent the different
     * types of symbols. These classes have an immutable semantic meaning.
     * - These classes may have child classes that are abstract as well, but are finally extended
     * by concrete classes that represent concrete symbols
     */
    abstract class AbstractSymbol
    {
        /**
         * Array with the 1-n (exception: the Numbers class may have 0)
         * unique identifiers (the textual representation of a symbol)
         * of the symbol. Example: ['/', ':']
         * Attention: The identifiers are case-sensitive, however,
         * valid identifiers in a term are always written in lower-case.
         * Therefore identifiers always have to be written in lower-case!
         *
         * @var string[]
         */
        protected $identifiers = [];
        /**
         * @var StringHelperInterface
         */
        protected $stringHelper;
        /**
         * AbstractSymbol constructor.
         *
         * @param StringHelperInterface $stringHelper
         * @throws InvalidIdentifierException
         */
        public function __construct(\ChrisKonnertz\StringCalc\Support\StringHelperInterface $stringHelper)
        {
        }
        /**
         * Create a new identifier for the symbol at runtime. All characters
         * are allowed except digits and '.'.
         *
         * @param string $identifier
         * @return void
         * @throws InvalidIdentifierException
         */
        public function addIdentifier($identifier)
        {
        }
        /**
         * Validate a given identifier. Throws an exception if the identifier
         * is invalid.
         * This method is declared as final, because the validation that is
         * done here is essential and the risk of its integrity being
         * corrupted by a subclass is too high.
         *
         * @param string $identifier
         * @return void
         * @throws InvalidIdentifierException
         */
        final public function validateIdentifier($identifier)
        {
        }
        /**
         * Validate the identifier even more than with validateIdentifier().
         * This method is meant to be overwritten by the abstract subclasses
         * (such as AbstractOperator) if they need specialised validation.
         *
         * @param string $identifier
         * @return void
         * @throws InvalidIdentifierException
         */
        protected function validateIdentifierMore($identifier)
        {
        }
        /**
         * Getter for the identifiers of the symbol.
         * Attention: The identifiers will be lower-cased!
         *
         * @return string[]
         */
        final public function getIdentifiers()
        {
        }
    }
    /**
     * This is the parent class for both bracket types:
     * Closing and opening brackets.
     *
     * @package ChrisKonnertz\StringCalc\Symbols
     */
    class AbstractBracket extends \ChrisKonnertz\StringCalc\Symbols\AbstractSymbol
    {
    }
    /**
     * This class is the base class for all symbols that are of the type "closing bracket".
     * Most likely we will only need one concrete "closing bracket" class.
     */
    abstract class AbstractClosingBracket extends \ChrisKonnertz\StringCalc\Symbols\AbstractBracket
    {
    }
    /**
     * This class is the base class for all symbols that are of the type "constant".
     * We recommend to use names as textual representations for this type of symbol.
     * Please take note of the fact that the precision of PHP float constants
     * (for example M_PI) is based on the "precision" directive in php.ini,
     * which defaults to 14.
     */
    abstract class AbstractConstant extends \ChrisKonnertz\StringCalc\Symbols\AbstractSymbol
    {
        /**
         * This is the value of the constant. We use 0 as an example here,
         * but you are supposed to overwrite this in the concrete constant class.
         * Usually mathematical constants are not integers, however,
         * you are allowed to use an integer in this context.
         *
         * @var int|float
         */
        protected $value = 0;
        /**
         * Getter for the value property.
         * Typically the value of the constant should be stored in $this->value.
         * However, in case you want to calculate the value at runtime,
         * feel free to overwrite this getter method.
         *
         * @return int|float
         */
        public function getValue()
        {
        }
        /**
         * @inheritdoc
         */
        protected function validateIdentifierMore($identifier)
        {
        }
    }
    /**
     * This class is the base class for all symbols that are of the type "function".
     * Typically the textual representation of a function consists of two or more letters.
     */
    abstract class AbstractFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractSymbol
    {
        /**
         * This method is called when the function is executed. A function can have 0-n parameters.
         * The implementation of this method is responsible to validate the number of arguments.
         * The $arguments array contains these arguments. If the number of arguments is improper,
         * the method has to throw a Exceptions\NumberOfArgumentsException exception.
         * The items of the $arguments array will always be of type int or float. They will never be null.
         * They keys will be integers starting at 0 and representing the positions of the arguments
         * in ascending order.
         * Overwrite this method in the concrete operator class.
         * If this class does NOT return a value of type int or float,
         * an exception will be thrown.
         *
         * @param  (int|float)[] $arguments
         * @return int|float
         */
        abstract public function execute(array $arguments);
        /**
         * @inheritdoc
         */
        protected function validateIdentifierMore($identifier)
        {
        }
    }
    /**
     * This class is the class that represents symbols of type "number".
     * Numbers are completely handled by the tokenizer/parser so there is no need to
     * create more than one concrete, empty number class (named "Numbers").
     * If there is more than one class that inherits this class and
     * is added to the symbol container, an exception will be thrown.
     */
    abstract class AbstractNumber extends \ChrisKonnertz\StringCalc\Symbols\AbstractSymbol
    {
    }
    /**
     * This class is the base class for all symbols that are of the type "opening bracket".
     * Most likely we will only need one concrete "opening bracket" class.
     */
    abstract class AbstractOpeningBracket extends \ChrisKonnertz\StringCalc\Symbols\AbstractBracket
    {
    }
    /**
     * This class is the base class for all symbols that are of the type "(binary) operator".
     * The textual representation of an operator consists of a single char that is not a letter.
     * It is worth noting that a operator has the same power as a function with two parameters.
     * Operators are always binary. To mimic a unary operator you might want to create a function
     * that accepts one parameter.
     */
    abstract class AbstractOperator extends \ChrisKonnertz\StringCalc\Symbols\AbstractSymbol
    {
        /**
         * The operator precedence determines which operators to perform first
         * in order to evaluate a given term.
         * You are supposed to overwrite this constant in the concrete constant class.
         * Take a look at other operator classes to see the precedences of the predefined operators.
         * 0: default, > 0: higher, < 0: lower
         *
         * @const int
         */
        const PRECEDENCE = 0;
        /**
         * Usually operators are binary, they operate on two operands (numbers).
         * But some can operate on one operand (number). The operand of a unary
         * operator is always positioned after the operator (=prefix notation).
         * Good example: "-1" Bad Example: "1-"
         * If you want to create a unary operator that operates on the left
         * operand, you should use a function instead. Functions with one
         * parameter execute unary operations in functional notation.
         * Notice: Operators can be unary AND binary (but this is a rare case)
         *
         * @const bool
         */
        const OPERATES_UNARY = false;
        /**
         * Usually operators are binary, they operate on two operands (numbers).
         * Notice: Operators can be unary AND binary (but this is a rare case)
         *
         * @const bool
         */
        const OPERATES_BINARY = true;
        /**
         * This method is called when the operator has to execute a binary operation on two numbers.
         * The arguments will always be of type int or float. They will never be null.
         * Overwrite this method in the concrete operator class.
         * If this class does NOT return a value of type int or float,
         * an exception will be thrown.
         *
         * @param  int|float $leftNumber  The number that stand left to the operator
         * @param  int|float $rightNumber The number that stands right to the operator
         * @return int|float
         */
        abstract public function operate($leftNumber, $rightNumber);
        /**
         * Getter for the self::PRECEDENCE constant.
         * This is just a convenient helper that makes accessing
         * the constant a little bit more elegant.
         *
         * @return int
         */
        public function getPrecedence()
        {
        }
        /**
         * Getter for the self::OPERATES_UNARY constant
         * This is just a convenient helper that makes accessing
         * the constant a little bit more elegant.
         *
         * @return bool
         */
        public function getOperatesUnary()
        {
        }
        /**
         * Getter for the self::OPERATES_BINARY constant
         * This is just a convenient helper that makes accessing
         * the constant a little bit more elegant.
         *
         * @return bool
         */
        public function getOperatesBinary()
        {
        }
    }
    /**
     * This class is the base class for all symbols that are of the type "separator".
     * A separator separates the arguments of a (mathematical) function.
     * Most likely we will only need one concrete "separator bracket" class.
     */
    abstract class AbstractSeparator extends \ChrisKonnertz\StringCalc\Symbols\AbstractSymbol
    {
    }
}
namespace ChrisKonnertz\StringCalc\Symbols\Concrete\Brackets {
    class ClosingBracket extends \ChrisKonnertz\StringCalc\Symbols\AbstractClosingBracket
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = [')'];
    }
    class OpeningBracket extends \ChrisKonnertz\StringCalc\Symbols\AbstractOpeningBracket
    {
        protected $identifiers = ['('];
    }
}
namespace ChrisKonnertz\StringCalc\Symbols\Concrete\Constants {
    /**
     * PHP M_E constant
     * Value: 2.71...
     * @see http://php.net/manual/en/math.constants.php
     */
    class EConstant extends \ChrisKonnertz\StringCalc\Symbols\AbstractConstant
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['e'];
        /**
         * @inheritdoc
         */
        protected $value = M_E;
    }
    /**
     * PHP M_EULER constant
     * Value: 0.57...
     * @see http://php.net/manual/en/math.constants.php
     */
    class EulerConstant extends \ChrisKonnertz\StringCalc\Symbols\AbstractConstant
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['euler'];
        /**
         * @inheritdoc
         */
        protected $value = M_EULER;
    }
    /**
     * PHP M_LNPI constant
     * Value: 1.14...
     * @see http://php.net/manual/en/math.constants.php
     */
    class LnPiConstant extends \ChrisKonnertz\StringCalc\Symbols\AbstractConstant
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['lnPi'];
        /**
         * @inheritdoc
         */
        protected $value = M_LNPI;
    }
    /**
     * PHP M_LN10 constant
     * Value: 2.30...
     * @see http://php.net/manual/en/math.constants.php
     */
    class LnTenConstant extends \ChrisKonnertz\StringCalc\Symbols\AbstractConstant
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['lnTen'];
        /**
         * @inheritdoc
         */
        protected $value = M_LN10;
    }
    /**
     * PHP M_LN2 constant
     * Value: 0.69...
     * @see http://php.net/manual/en/math.constants.php
     */
    class LnTwoConstant extends \ChrisKonnertz\StringCalc\Symbols\AbstractConstant
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['lnTwo'];
        /**
         * @inheritdoc
         */
        protected $value = M_LN2;
    }
    /**
     * PHP M_LOG10E constant
     * Value: 0.43...
     * @see http://php.net/manual/en/math.constants.php
     */
    class LogTenEConstant extends \ChrisKonnertz\StringCalc\Symbols\AbstractConstant
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['logTenE'];
        /**
         * @inheritdoc
         */
        protected $value = M_LOG10E;
    }
    /**
     * PHP M_LOG2E constant
     * Value: 1.44...
     * @see http://php.net/manual/en/math.constants.php
     */
    class LogTwoEConstant extends \ChrisKonnertz\StringCalc\Symbols\AbstractConstant
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['logTwoE'];
        /**
         * @inheritdoc
         */
        protected $value = M_LOG2E;
    }
    /**
     * PHP M_1_PI constant
     * Value: 0.31...
     * @see http://php.net/manual/en/math.constants.php
     */
    class OnePiConstant extends \ChrisKonnertz\StringCalc\Symbols\AbstractConstant
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['onePi'];
        /**
         * @inheritdoc
         */
        protected $value = M_1_PI;
    }
    /**
     * PHP M_PI constant
     * Value: 3.14...
     * @see http://php.net/manual/en/math.constants.php
     */
    class PiConstant extends \ChrisKonnertz\StringCalc\Symbols\AbstractConstant
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['pi'];
        /**
         * @inheritdoc
         */
        protected $value = M_PI;
    }
    /**
     * PHP M_PI_4 constant
     * Value: 0.78...
     * @see http://php.net/manual/en/math.constants.php
     */
    class PiFourConstant extends \ChrisKonnertz\StringCalc\Symbols\AbstractConstant
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['piFour'];
        /**
         * @inheritdoc
         */
        protected $value = M_PI_4;
    }
    /**
     * PHP M_PI_2 constant
     * Value: 1.57...
     * @see http://php.net/manual/en/math.constants.php
     */
    class PiTwoConstant extends \ChrisKonnertz\StringCalc\Symbols\AbstractConstant
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['piTwo'];
        /**
         * @inheritdoc
         */
        protected $value = M_PI_2;
    }
    /**
     * PHP M_SQRT1_2 constant
     * Value: 0.70...
     * @see http://php.net/manual/en/math.constants.php
     */
    class SqrtOneTwoConstant extends \ChrisKonnertz\StringCalc\Symbols\AbstractConstant
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['sqrtOneTwo'];
        /**
         * @inheritdoc
         */
        protected $value = M_SQRT1_2;
    }
    /**
     * PHP M_SQRTPI constant
     * Value: 1.77...
     * @see http://php.net/manual/en/math.constants.php
     */
    class SqrtPiConstant extends \ChrisKonnertz\StringCalc\Symbols\AbstractConstant
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['sqrtPi'];
        /**
         * @inheritdoc
         */
        protected $value = M_SQRTPI;
    }
    /**
     * PHP M_SQRT3 constant
     * Value: 1.73...
     * @see http://php.net/manual/en/math.constants.php
     */
    class SqrtThreeConstant extends \ChrisKonnertz\StringCalc\Symbols\AbstractConstant
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['sqrtThree'];
        /**
         * @inheritdoc
         */
        protected $value = M_SQRT3;
    }
    /**
     * PHP M_SQRT2 constant
     * Value: 1.41...
     * @see http://php.net/manual/en/math.constants.php
     */
    class SqrtTwoConstant extends \ChrisKonnertz\StringCalc\Symbols\AbstractConstant
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['sqrtTwo'];
        /**
         * @inheritdoc
         */
        protected $value = M_SQRT2;
    }
    /**
     * PHP M_2_PI constant
     * Value: 0.63...
     * @see http://php.net/manual/en/math.constants.php
     */
    class TwoPiConstant extends \ChrisKonnertz\StringCalc\Symbols\AbstractConstant
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['twoPi'];
        /**
         * @inheritdoc
         */
        protected $value = M_2_PI;
    }
    /**
     * PHP M_2_SQRTPI constant
     * Value: 1.12...
     * @see http://php.net/manual/en/math.constants.php
     */
    class TwoSqrtPiConstant extends \ChrisKonnertz\StringCalc\Symbols\AbstractConstant
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['twoSqrtPi'];
        /**
         * @inheritdoc
         */
        protected $value = M_2_SQRTPI;
    }
}
namespace ChrisKonnertz\StringCalc\Symbols\Concrete\Functions {
    /**
     * PHP abs() function. Expects one parameter.
     * Example: "abs(2)" => 2, "abs(-2)" => 2, "abs(0)" => 0
     * @see http://php.net/manual/en/ref.math.php
     */
    class AbsFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['abs'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP acos() function aka arc cosine. Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class ACosFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['acos'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP acosh() function aka inverse hyperbolic cosine. Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class ACosHFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['aCosH'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP asin() function aka arc sine. Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class ASinFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['aSin'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP asinh() function aka inverse hyperbolic sine. Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class ASinHFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['aSinH'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP atan() function aka arc tangent. Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class ATanFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['aTan'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP atanh() function aka inverse hyperbolic tangent. Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class ATanHFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['aTanH'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP atan2() function aka arc tangent of two variables.
     * Expects two parameters. The first is the dividend param,
     * the second is the divisor param.
     * @see http://php.net/manual/en/ref.math.php
     */
    class ATanTwoFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['aTanTwo'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP ceil() function aka round fractions up.
     * Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class CeilFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['ceil'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP cos() function aka cosine.
     * Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class CosFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['cos'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP cosh() function aka hyperbolic cosine.
     * Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class CosHFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['cosH'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP deg2rad() function aka converts a number in degrees
     * to the radian equivalent. Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class DegToRadFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['degToRad'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * In StringCalc it is not possible to write this valid PHP number: 2E3
     * which is called "engineering notation" and will evaluate to
     * 2 * pow(10, 3) = 2000.0 (float) in PHP. This function is a workaround,
     * so instead of "6E12" write "e(2, 3)". Example: "e(2, 3)" => 2000 (int)
     * Attention: As you might have noticed, the result of this function might
     * be an integer while the PHP code always results in a float value!
     */
    class EnFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['en'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP exp() function aka calculates the exponent of e.
     * Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class ExpFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['exp'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP expm1() function aka returns exp(number) - 1,
     * computed in a way that is accurate even when the
     * value of number is close to zero.
     * Expects one parameter.
     *
     * @see http://php.net/manual/en/ref.math.php
     */
    class ExpMOneFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['expMOne'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP floor() function aka round fractions down.
     * Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class FloorFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['floor'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP fmod() function aka returns the floating point
     * remainder (modulo) of the division of the arguments.
     * The first is the dividend param, the second is the
     * divisor param.
     * @see http://php.net/manual/en/ref.math.php
     */
    class FModFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['fMod'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP getrandmax() function aka return largest
     * possible random value. Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class GetRandMaxFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['getRandMax'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP hypot() function aka calculate the length
     * of the hypotenuse of a right-angle triangle.
     * The first is the length of the first side,
     * the second is the length of the second side.
     *
     * @see http://php.net/manual/en/ref.math.php
     */
    class HypotFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['hypot'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP intdiv() function aka integer division.
     * Expects two parameters. The first is the
     * number to be divided, the second is the
     * number which divides the dividend.
     * @see http://php.net/manual/en/ref.math.php
     */
    class IntDivFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['intDiv'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP log() function aka natural logarithm.
     * Expects one or two parameters. The second
     * parameter is the optional logarithmic base
     * to use. Defaults to PHP M_E.
     * @see http://php.net/manual/en/ref.math.php
     */
    class LogFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['log'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP log1p() function aka returns log(1 + number),
     * computed in a way that is accurate even when
     * the value of number is close to zero.
     * Expects one parameter.
     *
     * @see http://php.net/manual/en/ref.math.php
     */
    class LogOnePFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['logOneP'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP log10() function aka base-10 logarithm.
     * Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class LogTenFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['logTen'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP max() function. Expects at least one parameter.
     * Example: "max(1,2,3)" => 3, "max(1,-1)" => 1, "max(0,0)" => 0, "max(2)" => 2
     * @see http://php.net/manual/en/ref.math.php
     */
    class MaxFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['max'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP min() function. Expects at least one parameter.
     * Example: "min(1,2,3)" => 1, "min(1,-1)" => -1, "min(0,0)" => 0, "min(2)" => 2
     * @see http://php.net/manual/en/ref.math.php
     */
    class MinFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['min'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP mt_getrandmax() function aka return largest
     * possible random value that can be returned by a
     * call to PHP mt_rand(). Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class MTGetRandMaxFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['mTGetRandMax'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP mt_rand() function aka generate a random value
     * via the Mersenne Twister Random Number Generator.
     * Expects zero or two parameters. If called with two
     * parameters, the first param is the min and the
     * second param is the max value to be returned.
     *
     * @see http://php.net/manual/en/ref.math.php
     */
    class MTRandFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['mTRand'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP pow() function aka eponential expression.
     * Expects two parameters. The first is the base,
     * the second is the exponent.
     * @see http://php.net/manual/en/ref.math.php
     */
    class PowFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['pow'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP rad2deg() function aka converts a radian number to
     * the equivalent number in degrees. Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class RadToDegFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['radToDeg'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP rand() function aka generates a random integer.
     * Expects zero or two parameters. If called with two
     * parameters, the first param is the min and the
     * second param is the max value to be returned.
     *
     * @see http://php.net/manual/en/ref.math.php
     */
    class RandFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['rand'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP round() function aka rounds a float.
     * Expects one or two parameters. The first
     * parameter is the value to round, the second
     * is the number of decimal digits to round to.
     * It defaults to 0.
     * @see http://php.net/manual/en/ref.math.php
     */
    class RoundFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['round'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP sin() function aka sine.
     * Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class SinFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['sin'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP sinh() function aka hyperbolic sine.
     * Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class SinHFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['sinH'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP sqrt() function aka square root.
     * Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class SqrtFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['sqrt'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP tan() function aka tangent.
     * Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class TanFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['tan'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
    /**
     * PHP tanh() function aka hyperbolic tangent.
     * Expects one parameter.
     * @see http://php.net/manual/en/ref.math.php
     */
    class TanHFunction extends \ChrisKonnertz\StringCalc\Symbols\AbstractFunction
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['tanh'];
        /**
         * @inheritdoc
         */
        public function execute(array $arguments)
        {
        }
    }
}
namespace ChrisKonnertz\StringCalc\Symbols\Concrete {
    /**
     * This class is the class that represents symbols of type "number".
     * Numbers are completely handled by the tokenizer/parser so there is no need to
     * create more than this concrete, empty number class that does not specify
     * a textual representation of numbers (numbers always consist of digits
     * and may include a single dot).
     */
    final class Number extends \ChrisKonnertz\StringCalc\Symbols\AbstractNumber
    {
    }
}
namespace ChrisKonnertz\StringCalc\Symbols\Concrete\Operators {
    /**
     * Operator for mathematical addition.
     * Example: "1+2" => 3
     * @see https://en.wikipedia.org/wiki/Addition
     *
     * @package ChrisKonnertz\StringCalc\Symbols\Concrete\Operators
     */
    class AdditionOperator extends \ChrisKonnertz\StringCalc\Symbols\AbstractOperator
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['+'];
        /**
         * @inheritdoc
         */
        const PRECEDENCE = 100;
        /**
         * @inheritdoc
         */
        public function operate($leftNumber, $rightNumber)
        {
        }
    }
    /**
     * Operator for mathematical division.
     * Example: "6/2" => 3, "6/0" => PHP warning
     * @see https://en.wikipedia.org/wiki/Division_(mathematics)
     *
     * @package ChrisKonnertz\StringCalc\Symbols\Concrete\Operators
     */
    class DivisionOperator extends \ChrisKonnertz\StringCalc\Symbols\AbstractOperator
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['/'];
        /**
         * @inheritdoc
         */
        const PRECEDENCE = 200;
        /**
         * @inheritdoc
         */
        public function operate($leftNumber, $rightNumber)
        {
        }
    }
    /**
     * Operator for mathematical exponentiation.
     * Example: "3^2" => 9, "-3^2" => -9, "3^-2" equals "3^(-2)"
     * @see https://en.wikipedia.org/wiki/Exponentiation
     *
     * @package ChrisKonnertz\StringCalc\Symbols\Concrete\Operators
     */
    class ExponentiationOperator extends \ChrisKonnertz\StringCalc\Symbols\AbstractOperator
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['^'];
        /**
         * @inheritdoc
         */
        const PRECEDENCE = 300;
        /**
         * @inheritdoc
         */
        public function operate($leftNumber, $rightNumber)
        {
        }
    }
    /**
     * Operator for mathematical modulo operation.
     * Example: "5%3" => 2
     * @see https://en.wikipedia.org/wiki/Modulo_operation
     *
     * @package ChrisKonnertz\StringCalc\Symbols\Concrete\Operators
     */
    class ModuloOperator extends \ChrisKonnertz\StringCalc\Symbols\AbstractOperator
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['%'];
        /**
         * @inheritdoc
         */
        const PRECEDENCE = 200;
        /**
         * @inheritdoc
         */
        public function operate($leftNumber, $rightNumber)
        {
        }
    }
    /**
     * Operator for mathematical multiplication.
     * Example: "2*3" => 6
     * @see https://en.wikipedia.org/wiki/Multiplication
     *
     * @package ChrisKonnertz\StringCalc\Symbols\Concrete\Operators
     */
    class MultiplicationOperator extends \ChrisKonnertz\StringCalc\Symbols\AbstractOperator
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['*'];
        /**
         * @inheritdoc
         */
        const PRECEDENCE = 200;
        /**
         * @inheritdoc
         */
        public function operate($leftNumber, $rightNumber)
        {
        }
    }
    /**
     * Operator for mathematical multiplication.
     * Example: "1+2" => 3
     * @see https://en.wikipedia.org/wiki/Multiplication
     *
     * @package ChrisKonnertz\StringCalc\Symbols\Concrete\Operators
     */
    class SubtractionOperator extends \ChrisKonnertz\StringCalc\Symbols\AbstractOperator
    {
        /**
         * @inheritdoc
         */
        protected $identifiers = ['-'];
        /**
         * @inheritdoc
         */
        const PRECEDENCE = 100;
        /**
         * @inheritdoc
         * Notice: The subtraction operator is unary AND binary!
         */
        const OPERATES_UNARY = true;
        /**
         * @inheritdoc
         */
        public function operate($leftNumber, $rightNumber)
        {
        }
    }
}
namespace ChrisKonnertz\StringCalc\Symbols\Concrete {
    /**
     * This class is a class that represents symbols of type "separator".
     * A separator separates the arguments of a (mathematical) function.
     * Most likely we will only need one concrete "separator" class.
     */
    class Separator extends \ChrisKonnertz\StringCalc\Symbols\AbstractSeparator
    {
        protected $identifiers = [','];
    }
}
namespace ChrisKonnertz\StringCalc\Symbols {
    /**
     * This is an interface for the SymbolContainer class.
     *
     * @package ChrisKonnertz\StringCalc
     */
    interface SymbolContainerInterface
    {
        /**
         * Adds a symbol to the array of symbols.
         *
         * @param AbstractSymbol $symbol        The new symbol object
         * @param string|null    $replaceSymbol Class name of an known symbol that you want to replace
         * @return void
         */
        public function add(\ChrisKonnertz\StringCalc\Symbols\AbstractSymbol $symbol, $replaceSymbol = null);
        /**
         * Removes a symbol from the array of symbols.
         * It is recommended to only remove custom symbols
         * (that have been added via the addSymbol() method)
         *
         * @param AbstractSymbol $symbol
         * @return void
         */
        public function remove(\ChrisKonnertz\StringCalc\Symbols\AbstractSymbol $symbol);
        /**
         * Returns the symbol that has the given identifier.
         * Returns null if none is found.
         *
         * @param string $identifier
         * @return AbstractSymbol|null
         */
        public function find($identifier);
        /**
         * Returns all symbols that inherit from a given abstract
         * parent type (class): The parent type has to be an
         * AbstractSymbol.
         * Notice: The parent type name will not be validated!
         *
         * @param string $parentTypeName
         * @return AbstractSymbol[]
         */
        public function findSubtypes($parentTypeName);
        /**
         * Returns the number of managed symbols.
         *
         * @return int
         */
        public function size();
        /**
         * Getter for the array of symbols.
         *
         * @return AbstractSymbol[]
         */
        public function getAll();
    }
    /**
     * The symbol container manages an array with all symbol objects.
     *
     * @package ChrisKonnertz\StringCalc
     */
    class SymbolContainer implements \ChrisKonnertz\StringCalc\Symbols\SymbolContainerInterface
    {
        /**
         * Array with all available symbols
         *
         * @var AbstractSymbol[]
         */
        protected $symbols;
        /**
         * String helper class
         *
         * @var StringHelperInterface
         */
        protected $stringHelper;
        /**
         * SymbolManager constructor.
         *
         * @param StringHelperInterface $stringHelper
         */
        public function __construct(\ChrisKonnertz\StringCalc\Support\StringHelperInterface $stringHelper)
        {
        }
        /**
         * Validates the symbol array. This is only a high-level validation.
         * Even if this validation passes, the symbols still might be corrupt.
         * Will throw an exception if validation fails.
         *
         * @return void
         * @throws StringCalcException
         */
        protected function validate()
        {
        }
        /**
         * Retrieves the list of available symbol classes,
         * creates objects of these classes and stores them.
         *
         * @return void
         * @throws \LengthException
         */
        protected function prepare()
        {
        }
        /**
         * Adds a symbol to the array of symbols. This method allows to add symbols
         * at runtime from the outside of this library.
         *
         * @param AbstractSymbol $symbol        The new symbol object
         * @param string|null    $replaceSymbol Class name of an known symbol that you want to replace
         * @return void
         * @throws \InvalidArgumentException
         */
        public function add(\ChrisKonnertz\StringCalc\Symbols\AbstractSymbol $symbol, $replaceSymbol = null)
        {
        }
        /**
         * Removes a symbol from the array of symbols.
         * It is recommended to only remove custom symbols
         * (that have been added via the addSymbol() method)
         *
         * @param AbstractSymbol $symbol
         * @return void
         */
        public function remove(\ChrisKonnertz\StringCalc\Symbols\AbstractSymbol $symbol)
        {
        }
        /**
         * Returns the symbol that has the given identifier.
         * Returns null if none is found.
         *
         * @param string $identifier
         * @return AbstractSymbol|null
         */
        public function find($identifier)
        {
        }
        /**
         * Returns all symbols that inherit from a given abstract
         * parent type (class): The parent type has to be an
         * AbstractSymbol.
         * Notice: The parent type name will not be validated!
         *
         * @param string $parentTypeName
         * @return AbstractSymbol[]
         */
        public function findSubtypes($parentTypeName)
        {
        }
        /**
         * Returns the number of managed symbols.
         *
         * @return int
         */
        public function size()
        {
        }
        /**
         * Getter for the array of all symbols.
         *
         * @return AbstractSymbol[]
         */
        public function getAll()
        {
        }
    }
    /**
     * This class has one simple job: It contains an array with the names
     * of the initially registered symbols. It does not offer an add()
     * method - but you can add new symbols via the addSymbol() method of
     * the StringCalc class.
     *
     * @package ChrisKonnertz\StringCalc\Symbols
     */
    class SymbolRegistry
    {
        /**
         * This method has to return an array with the class names of all registered
         * symbols. Symbols have to inherit from the AbstractSymbol class.
         *
         * @return string[]
         */
        public function getSymbols()
        {
        }
    }
}
namespace ChrisKonnertz\StringCalc\Tokenizer {
    interface InputStreamInterface
    {
        /**
         * Move the pointer to the next position.
         * Will always move the pointer, even if the end of the term has been passed.
         *
         * @return string|null
         */
        public function readNext();
        /**
         * Returns the current character.
         *
         * @return string|null
         */
        public function readCurrent();
        /**
         * Returns true if there is a character at the current position
         *
         * @return bool
         */
        public function hasCurrent();
        /**
         * Resets the cursor to the beginning of the string.
         *
         * @return void
         */
        public function reset();
        /**
         * Setter for the input string
         *
         * @param string $input
         */
        public function setInput($input);
        /**
         * Getter for the input string
         *
         * @return string
         */
        public function getInput();
        /**
         * Getter for the cursor position
         *
         * @return int
         */
        public function getPosition();
    }
    /**
     * This class operates on the lowest level on an input stream.
     * It can read an input stream (in this case a string). Call
     * the readCurrent() method to read the input at the current
     * position.
     *
     * @package ChrisKonnertz\StringCalc\Tokenizer
     */
    class InputStream implements \ChrisKonnertz\StringCalc\Tokenizer\InputStreamInterface
    {
        /**
         * This class operates on this string
         *
         * @var string
         */
        protected $input = '';
        /**
         * Current position in the input stream
         *
         * @var int
         */
        protected $position = 0;
        /**
         * @var StringHelperInterface
         */
        protected $stringHelper;
        /**
         * InputStream constructor.
         *
         * @param StringHelperInterface $stringHelper
         */
        public function __construct(\ChrisKonnertz\StringCalc\Support\StringHelperInterface $stringHelper)
        {
        }
        /**
         * Move the the cursor to the next position.
         * Will always move the cursor, even if the end of the string has been passed.
         *
         * @return string|null
         */
        public function readNext()
        {
        }
        /**
         * Returns the current character.
         *
         * @return string|null
         */
        public function readCurrent()
        {
        }
        /**
         * Returns true if there is a character at the current position
         *
         * @return bool
         */
        public function hasCurrent()
        {
        }
        /**
         * Resets the position of the cursor to the beginning of the string.
         *
         * @return void
         */
        public function reset()
        {
        }
        /**
         * Setter for the input string
         *
         * @param string $input
         */
        public function setInput($input)
        {
        }
        /**
         * Getter for the input string
         *
         * @return string
         */
        public function getInput()
        {
        }
        /**
         * Getter for the cursor position
         *
         * @return int
         */
        public function getPosition()
        {
        }
    }
    /**
     * The tokenizer splits a term into an array of tokens.
     * Tokens are the parts of a term or to be more precise
     * the mathematical symbols of a term.
     *
     * @package ChrisKonnertz\StringCalc\Tokenizer
     */
    class Token
    {
        /**
         * Defines the type of a token.
         * Example token value of a token with this type:
         * 'abs'
         *
         * @const int
         */
        const TYPE_WORD = 0;
        /**
         * Defines the type of a token.
         * Example token value of a token with this type:
         * '123'
         *
         * @const int
         */
        const TYPE_NUMBER = 1;
        /**
         * Defines the type of a token.
         * Example token value of a token with this type:
         * '+'
         *
         * @const int
         */
        const TYPE_CHARACTER = 2;
        /**
         * The raw value of the token. Numbers are stored as string.
         *
         * @var string
         */
        protected $value = null;
        /**
         * The type of the token. One of these constants:
         * self::TYPE_WORD|self::TYPE_NUMBER|self::TYPE_CHARACTER
         *
         * @var int
         */
        protected $type;
        /**
         * Position of the token in the input stream.
         * It is stored as a debugging information.
         *
         * @var int
         */
        protected $position;
        /**
         * Token constructor. The position must be >= 0.
         *
         * @param string    $value
         * @param string    $type
         * @param int       $position
         */
        public function __construct($value, $type, $position)
        {
        }
        /**
         * Returns an array that contains the values of all
         * possible types of token type constants:
         * self::TYPE_WORD|self::TYPE_NUMBER|self::TYPE_CHARACTER
         *
         * @return int[]
         */
        public function getAllTypes()
        {
        }
        /**
         * Getter for the value
         *
         * @return string
         */
        public function getValue()
        {
        }
        /**
         * Getter for the type
         *
         * @return string
         */
        public function getType()
        {
        }
        /**
         * Getter for the position
         *
         * @return int
         */
        public function getPosition()
        {
        }
        /**
         * @return string
         */
        public function __toString()
        {
        }
    }
    /**
     * "Tokenization is the process of demarcating and possibly classifying
     * sections of a string of input characters" (Source: Wikipedia)
     * The tokenizer operates on the string term and tries to split it into
     * parts (these are the symbols of the term / the tokens).
     * The tokenizer is not very smart, it does not care for grammar.
     *
     * @package ChrisKonnertz\StringCalc\Tokenizer
     */
    class Tokenizer
    {
        /**
         * @var InputStreamInterface
         */
        protected $inputStream;
        /**
         * @var StringHelperInterface
         */
        protected $stringHelper;
        /**
         * Tokenizer constructor.
         *
         * @param InputStreamInterface     $inputStream
         * @param StringHelperInterface    $stringHelper
         */
        public function __construct(\ChrisKonnertz\StringCalc\Tokenizer\InputStreamInterface $inputStream, \ChrisKonnertz\StringCalc\Support\StringHelperInterface $stringHelper)
        {
        }
        /**
         * Tokenize the term. Returns an array with the tokens.
         *
         * @return Token[]
         */
        public function tokenize()
        {
        }
        /**
         * Reads a token.
         *
         * @return Token|null
         * @throws NotFoundException
         */
        protected function readToken()
        {
        }
        /**
         * Returns true, if a given character is a letter (a-z and A-Z).
         *
         * @param string $char A single character
         * @return bool
         */
        protected function isLetter($char)
        {
        }
        /**
         * Returns true, if a given character is a digit (0-9).
         *
         * @param string|null $char A single character
         * @return bool
         */
        protected function isDigit($char)
        {
        }
        /**
         * Returns true, if a given character is a period ('.').
         *
         * @param string|null $char A single character
         * @return bool
         */
        protected function isPeriod($char)
        {
        }
        /**
         * Returns true, if a given character is whitespace.
         * Notice: A null char is not seen as whitespace.
         *
         * @var string|null $char
         * @return bool
         */
        protected function isWhitespace($char)
        {
        }
        /**
         * Moves the pointer to the next char that is not whitespace.
         * Might be a null char, might not move the pointer at all.
         *
         * @return void
         */
        protected function stepOverWhitespace()
        {
        }
        /**
         * Reads a word. Assumes that the cursor of the input stream
         * currently is positioned at the beginning of a word.
         *
         * @return string
         */
        protected function readWord()
        {
        }
        /**
         * Reads a number (as a string). Assumes that the cursor
         * of the input stream currently is positioned at the
         * beginning of a number.
         *
         * @return string
         * @throws StringCalcException
         */
        protected function readNumber()
        {
        }
        /**
         * Reads a single char. Assumes that the cursor of the input stream
         * currently is positioned at a char (not on null).
         *
         * @return string
         */
        protected function readChar()
        {
        }
    }
}
namespace Clue\StreamFilter {
    /**
     * @internal
     * @see append()
     * @see prepend()
     */
    class CallbackFilter extends \php_user_filter
    {
        /** @return bool */
        #[\ReturnTypeWillChange]
        public function onCreate()
        {
        }
        /** @return void */
        #[\ReturnTypeWillChange]
        public function onClose()
        {
        }
        /** @return int */
        #[\ReturnTypeWillChange]
        public function filter($in, $out, &$consumed, $closing)
        {
        }
    }
}
namespace {
    // autoload_real.php @generated by Composer
    class ComposerAutoloaderInita7f74d8df2b0d1ec0306b29a8e0d214b
    {
        public static function loadClassLoader($class)
        {
        }
        /**
         * @return \Composer\Autoload\ClassLoader
         */
        public static function getLoader()
        {
        }
    }
}
namespace Composer\Autoload {
    class ComposerStaticInita7f74d8df2b0d1ec0306b29a8e0d214b
    {
        public static $files = array('7b11c4dc42b3b3023073cb14e519683c' => __DIR__ . '/..' . '/ralouphie/getallheaders/src/getallheaders.php', '6e3fae29631ef280660b3cdad06f25a8' => __DIR__ . '/..' . '/symfony/deprecation-contracts/function.php', '9c67151ae59aff4788964ce8eb2a0f43' => __DIR__ . '/..' . '/clue/stream-filter/src/functions_include.php', '37a3dc5111fe8f707ab4c132ef1dbc62' => __DIR__ . '/..' . '/guzzlehttp/guzzle/src/functions_include.php', 'c9d07b32a2e02bc0fc582d4f0c1b56cc' => __DIR__ . '/..' . '/laminas/laminas-servicemanager/src/autoload.php', 'decc78cc4436b1292c6c0d151b19445c' => __DIR__ . '/..' . '/phpseclib/phpseclib/phpseclib/bootstrap.php', '8df545618a279cdffa063a86c0adc576' => __DIR__ . '/..' . '/edoc/utils/src/FS/destroydir.php', '0464f735ef07cd92fd9ba0f4b49124b3' => __DIR__ . '/..' . '/edoc/utils/src/FS/tempdir.php', '59d88a3cffab20b3a9e9848553ababf3' => __DIR__ . '/..' . '/edoc/utils/src/FS/delete.php', 'c75fe0467065d4fec5a6b5d1583c64d1' => __DIR__ . '/..' . '/edoc/utils/src/FS/copy.php', 'aeb17fdb7acb899b0cbdedb62d7c17e2' => __DIR__ . '/..' . '/edoc/utils/src/Arrays/merge.php', '07d7f1a47144818725fd8d91a907ac57' => __DIR__ . '/..' . '/laminas/laminas-diactoros/src/functions/create_uploaded_file.php', 'da94ac5d3ca7d2dbab84ce561ce72bfd' => __DIR__ . '/..' . '/laminas/laminas-diactoros/src/functions/marshal_headers_from_sapi.php', '3d97c8dcdfba8cb85d3b34f116bb248b' => __DIR__ . '/..' . '/laminas/laminas-diactoros/src/functions/marshal_method_from_sapi.php', 'e6f3bc6883e449ab367280b34158c05b' => __DIR__ . '/..' . '/laminas/laminas-diactoros/src/functions/marshal_protocol_version_from_sapi.php', 'de95e0ac670b27c84ef8c5ac41fc1b34' => __DIR__ . '/..' . '/laminas/laminas-diactoros/src/functions/normalize_server.php', 'b6c2870932b0250c10334a86dcb33c7f' => __DIR__ . '/..' . '/laminas/laminas-diactoros/src/functions/normalize_uploaded_files.php', 'd02cf21124526632320d6f20b1bbf905' => __DIR__ . '/..' . '/laminas/laminas-diactoros/src/functions/parse_cookie_header.php', '253c157292f75eb38082b5acb06f3f01' => __DIR__ . '/..' . '/nikic/fast-route/src/functions.php', 'b33e3d135e5d9e47d845c576147bda89' => __DIR__ . '/..' . '/php-di/php-di/src/functions.php', '8cff32064859f4559445b89279f3199c' => __DIR__ . '/..' . '/php-http/message/src/filters.php', 'd4f41a0d8d21e2f0c73544715f64f47e' => __DIR__ . '/../..' . '/src/helpers.php');
        public static $prefixLengthsPsr4 = array('p' => array('phpseclib3\\' => 11, 'phpDocumentor\Reflection\\' => 25), 'h' => array('hollodotme\FastCGI\\' => 19), 'f' => array('fXmlRpc\\' => 8), 'e' => array('edoc\utils\\' => 11, 'edoc\appserver\test\\' => 20, 'edoc\appserver\\' => 15), 'W' => array('Webmozart\Assert\\' => 17), 'S' => array('Supervisor\\' => 11), 'P' => array('Psr\Log\\' => 8, 'Psr\Http\Message\\' => 17, 'Psr\Http\Client\\' => 16, 'Psr\Container\\' => 14, 'PhpAmqpLib\\' => 11, 'ParagonIE\ConstantTime\\' => 23, 'PHPStan\PhpDocParser\\' => 21, 'PHPMailer\PHPMailer\\' => 20), 'O' => array('OomphInc\ComposerInstallersExtender\\' => 36), 'M' => array('Monolog\\' => 8, 'Mimey\\' => 6), 'L' => array('Laravel\SerializableClosure\\' => 28, 'Laminas\Translator\\' => 19, 'Laminas\Stdlib\\' => 15, 'Laminas\ServiceManager\\' => 23, 'Laminas\I18n\\' => 13, 'Laminas\Diactoros\\' => 18), 'I' => array('Invoker\\' => 8), 'H' => array('Http\Promise\\' => 13, 'Http\Message\\' => 13, 'Http\Factory\Guzzle\\' => 20, 'Http\Discovery\\' => 15, 'Http\Client\\' => 12, 'Http\Adapter\Guzzle7\\' => 21), 'G' => array('GuzzleHttp\Psr7\\' => 16, 'GuzzleHttp\Promise\\' => 19, 'GuzzleHttp\\' => 11), 'F' => array('Firebase\JWT\\' => 13, 'FastRoute\\' => 10), 'D' => array('Doctrine\Deprecations\\' => 22, 'DI\\' => 3), 'C' => array('Cron\\' => 5, 'Composer\Installers\\' => 20, 'Clue\StreamFilter\\' => 18));
        public static $prefixDirsPsr4 = array('phpseclib3\\' => array(0 => __DIR__ . '/..' . '/phpseclib/phpseclib/phpseclib'), 'phpDocumentor\Reflection\\' => array(0 => __DIR__ . '/..' . '/phpdocumentor/reflection-docblock/src', 1 => __DIR__ . '/..' . '/phpdocumentor/type-resolver/src', 2 => __DIR__ . '/..' . '/phpdocumentor/reflection-common/src'), 'hollodotme\FastCGI\\' => array(0 => __DIR__ . '/..' . '/hollodotme/fast-cgi-client/src'), 'fXmlRpc\\' => array(0 => __DIR__ . '/..' . '/lstrojny/fxmlrpc/src/fXmlRpc'), 'edoc\utils\\' => array(0 => __DIR__ . '/..' . '/edoc/utils/src'), 'edoc\appserver\test\\' => array(0 => __DIR__ . '/../..' . '/tests'), 'edoc\appserver\\' => array(0 => __DIR__ . '/../..' . '/src'), 'Webmozart\Assert\\' => array(0 => __DIR__ . '/..' . '/webmozart/assert/src'), 'Supervisor\\' => array(0 => __DIR__ . '/..' . '/supervisorphp/supervisor/src'), 'Psr\Log\\' => array(0 => __DIR__ . '/..' . '/psr/log/src'), 'Psr\Http\Message\\' => array(0 => __DIR__ . '/..' . '/psr/http-factory/src', 1 => __DIR__ . '/..' . '/psr/http-message/src'), 'Psr\Http\Client\\' => array(0 => __DIR__ . '/..' . '/psr/http-client/src'), 'Psr\Container\\' => array(0 => __DIR__ . '/..' . '/psr/container/src'), 'PhpAmqpLib\\' => array(0 => __DIR__ . '/..' . '/php-amqplib/php-amqplib/PhpAmqpLib'), 'ParagonIE\ConstantTime\\' => array(0 => __DIR__ . '/..' . '/paragonie/constant_time_encoding/src'), 'PHPStan\PhpDocParser\\' => array(0 => __DIR__ . '/..' . '/phpstan/phpdoc-parser/src'), 'PHPMailer\PHPMailer\\' => array(0 => __DIR__ . '/..' . '/phpmailer/phpmailer/src'), 'OomphInc\ComposerInstallersExtender\\' => array(0 => __DIR__ . '/..' . '/oomphinc/composer-installers-extender/src'), 'Monolog\\' => array(0 => __DIR__ . '/..' . '/monolog/monolog/src/Monolog'), 'Mimey\\' => array(0 => __DIR__ . '/..' . '/xantios/mimey/src'), 'Laravel\SerializableClosure\\' => array(0 => __DIR__ . '/..' . '/laravel/serializable-closure/src'), 'Laminas\Translator\\' => array(0 => __DIR__ . '/..' . '/laminas/laminas-translator/src'), 'Laminas\Stdlib\\' => array(0 => __DIR__ . '/..' . '/laminas/laminas-stdlib/src'), 'Laminas\ServiceManager\\' => array(0 => __DIR__ . '/..' . '/laminas/laminas-servicemanager/src'), 'Laminas\I18n\\' => array(0 => __DIR__ . '/..' . '/laminas/laminas-i18n/src'), 'Laminas\Diactoros\\' => array(0 => __DIR__ . '/..' . '/laminas/laminas-diactoros/src'), 'Invoker\\' => array(0 => __DIR__ . '/..' . '/php-di/invoker/src'), 'Http\Promise\\' => array(0 => __DIR__ . '/..' . '/php-http/promise/src'), 'Http\Message\\' => array(0 => __DIR__ . '/..' . '/php-http/message-factory/src', 1 => __DIR__ . '/..' . '/php-http/message/src'), 'Http\Factory\Guzzle\\' => array(0 => __DIR__ . '/..' . '/http-interop/http-factory-guzzle/src'), 'Http\Discovery\\' => array(0 => __DIR__ . '/..' . '/php-http/discovery/src'), 'Http\Client\\' => array(0 => __DIR__ . '/..' . '/php-http/httplug/src'), 'Http\Adapter\Guzzle7\\' => array(0 => __DIR__ . '/..' . '/php-http/guzzle7-adapter/src'), 'GuzzleHttp\Psr7\\' => array(0 => __DIR__ . '/..' . '/guzzlehttp/psr7/src'), 'GuzzleHttp\Promise\\' => array(0 => __DIR__ . '/..' . '/guzzlehttp/promises/src'), 'GuzzleHttp\\' => array(0 => __DIR__ . '/..' . '/guzzlehttp/guzzle/src'), 'Firebase\JWT\\' => array(0 => __DIR__ . '/..' . '/firebase/php-jwt/src'), 'FastRoute\\' => array(0 => __DIR__ . '/..' . '/nikic/fast-route/src'), 'Doctrine\Deprecations\\' => array(0 => __DIR__ . '/..' . '/doctrine/deprecations/src'), 'DI\\' => array(0 => __DIR__ . '/..' . '/php-di/php-di/src'), 'Cron\\' => array(0 => __DIR__ . '/..' . '/dragonmantank/cron-expression/src/Cron'), 'Composer\Installers\\' => array(0 => __DIR__ . '/..' . '/composer/installers/src/Composer/Installers'), 'Clue\StreamFilter\\' => array(0 => __DIR__ . '/..' . '/clue/stream-filter/src'));
        public static $prefixesPsr0 = array('C' => array('ChrisKonnertz\StringCalc' => array(0 => __DIR__ . '/..' . '/chriskonnertz/string-calc/src')));
        public static $classMap = array('Composer\InstalledVersions' => __DIR__ . '/..' . '/composer/InstalledVersions.php');
        public static function getInitializer(\Composer\Autoload\ClassLoader $loader)
        {
        }
    }
}
namespace Composer\Installers {
    abstract class BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array();
        /** @var Composer */
        protected $composer;
        /** @var PackageInterface */
        protected $package;
        /** @var IOInterface */
        protected $io;
        /**
         * Initializes base installer.
         */
        public function __construct(\Composer\Package\PackageInterface $package, \Composer\Composer $composer, \Composer\IO\IOInterface $io)
        {
        }
        /**
         * Return the install path based on package type.
         */
        public function getInstallPath(\Composer\Package\PackageInterface $package, string $frameworkType = ''): string
        {
        }
        /**
         * For an installer to override to modify the vars per installer.
         *
         * @param  array<string, string> $vars This will normally receive array{name: string, vendor: string, type: string}
         * @return array<string, string>
         */
        public function inflectPackageVars(array $vars): array
        {
        }
        /**
         * Gets the installer's locations
         *
         * @return array<string, string> map of package types => install path
         */
        public function getLocations(string $frameworkType)
        {
        }
        /**
         * Replace vars in a path
         *
         * @param  array<string, string> $vars
         */
        protected function templatePath(string $path, array $vars = array()): string
        {
        }
        /**
         * Search through a passed paths array for a custom install path.
         *
         * @param  array<string, string[]|string> $paths
         * @return string|false
         */
        protected function mapCustomInstallPaths(array $paths, string $name, string $type, ?string $vendor = null)
        {
        }
        protected function pregReplace(string $pattern, string $replacement, string $subject): string
        {
        }
    }
    class AglInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'More/{$name}/');
        /**
         * Format package name to CamelCase
         */
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    class AkauntingInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'modules/{$name}');
        /**
         * Format package name to CamelCase
         */
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    class AnnotateCmsInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'addons/modules/{$name}/', 'component' => 'addons/components/{$name}/', 'service' => 'addons/services/{$name}/');
    }
    class AsgardInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'Modules/{$name}/', 'theme' => 'Themes/{$name}/');
        /**
         * Format package name.
         *
         * For package type asgard-module, cut off a trailing '-plugin' if present.
         *
         * For package type asgard-theme, cut off a trailing '-theme' if present.
         */
        public function inflectPackageVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectPluginVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectThemeVars(array $vars): array
        {
        }
    }
    class AttogramInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'modules/{$name}/');
    }
    /**
     * Installer for Bitrix Framework. Supported types of extensions:
     * - `bitrix-d7-module` — copy the module to directory `bitrix/modules/<vendor>.<name>`.
     * - `bitrix-d7-component` — copy the component to directory `bitrix/components/<vendor>/<name>`.
     * - `bitrix-d7-template` — copy the template to directory `bitrix/templates/<vendor>_<name>`.
     *
     * You can set custom path to directory with Bitrix kernel in `composer.json`:
     *
     * ```json
     * {
     *      "extra": {
     *          "bitrix-dir": "s1/bitrix"
     *      }
     * }
     * ```
     *
     * @author Nik Samokhvalov <nik@samokhvalov.info>
     * @author Denis Kulichkin <onexhovia@gmail.com>
     */
    class BitrixInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array(
            'module' => '{$bitrix_dir}/modules/{$name}/',
            // deprecated, remove on the major release (Backward compatibility will be broken)
            'component' => '{$bitrix_dir}/components/{$name}/',
            // deprecated, remove on the major release (Backward compatibility will be broken)
            'theme' => '{$bitrix_dir}/templates/{$name}/',
            // deprecated, remove on the major release (Backward compatibility will be broken)
            'd7-module' => '{$bitrix_dir}/modules/{$vendor}.{$name}/',
            'd7-component' => '{$bitrix_dir}/components/{$vendor}/{$name}/',
            'd7-template' => '{$bitrix_dir}/templates/{$vendor}_{$name}/',
        );
        public function inflectPackageVars(array $vars): array
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function templatePath(string $path, array $vars = array()): string
        {
        }
        /**
         * Duplicates search packages.
         *
         * @param array<string, string> $vars
         */
        protected function checkDuplicates(string $path, array $vars = array()): void
        {
        }
    }
    class BonefishInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('package' => 'Packages/{$vendor}/{$name}/');
    }
    class BotbleInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'platform/plugins/{$name}/', 'theme' => 'platform/themes/{$name}/');
    }
    class CakePHPInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'Plugin/{$name}/');
        /**
         * Format package name to CamelCase
         */
        public function inflectPackageVars(array $vars): array
        {
        }
        /**
         * Change the default plugin location when cakephp >= 3.0
         */
        public function getLocations(string $frameworkType): array
        {
        }
        /**
         * Check if CakePHP version matches against a version
         *
         * @phpstan-param '='|'=='|'<'|'<='|'>'|'>='|'<>'|'!=' $matcher
         */
        protected function matchesCakeVersion(string $matcher, string $version): bool
        {
        }
    }
    class ChefInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('cookbook' => 'Chef/{$vendor}/{$name}/', 'role' => 'Chef/roles/{$name}/');
    }
    class CiviCrmInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('ext' => 'ext/{$name}/');
    }
    class ClanCatsFrameworkInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('ship' => 'CCF/orbit/{$name}/', 'theme' => 'CCF/app/themes/{$name}/');
    }
    class CockpitInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'cockpit/modules/addons/{$name}/');
        /**
         * Format module name.
         *
         * Strip `module-` prefix from package name.
         */
        public function inflectPackageVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        public function inflectModuleVars(array $vars): array
        {
        }
    }
    class CodeIgniterInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('library' => 'application/libraries/{$name}/', 'third-party' => 'application/third_party/{$name}/', 'module' => 'application/modules/{$name}/');
    }
    class Concrete5Installer extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('core' => 'concrete/', 'block' => 'application/blocks/{$name}/', 'package' => 'packages/{$name}/', 'theme' => 'application/themes/{$name}/', 'update' => 'updates/{$name}/');
    }
    class ConcreteCMSInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('core' => 'concrete/', 'block' => 'application/blocks/{$name}/', 'package' => 'packages/{$name}/', 'theme' => 'application/themes/{$name}/', 'update' => 'updates/{$name}/');
    }
    class CroogoInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'Plugin/{$name}/', 'theme' => 'View/Themed/{$name}/');
        /**
         * Format package name to CamelCase
         */
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    class DecibelInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array */
        /** @var array<string, string> */
        protected $locations = array('app' => 'app/{$name}/');
    }
    class DframeInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'modules/{$vendor}/{$name}/');
    }
    class DokuWikiInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'lib/plugins/{$name}/', 'template' => 'lib/tpl/{$name}/');
        /**
         * Format package name.
         *
         * For package type dokuwiki-plugin, cut off a trailing '-plugin',
         * or leading dokuwiki_ if present.
         *
         * For package type dokuwiki-template, cut off a trailing '-template' if present.
         */
        public function inflectPackageVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectPluginVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectTemplateVars(array $vars): array
        {
        }
    }
    /**
     * Class DolibarrInstaller
     *
     * @package Composer\Installers
     * @author  Raphaël Doursenaud <rdoursenaud@gpcsolutions.fr>
     */
    class DolibarrInstaller extends \Composer\Installers\BaseInstaller
    {
        //TODO: Add support for scripts and themes
        /** @var array<string, string> */
        protected $locations = array('module' => 'htdocs/custom/{$name}/');
    }
    class DrupalInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('core' => 'core/', 'module' => 'modules/{$name}/', 'theme' => 'themes/{$name}/', 'library' => 'libraries/{$name}/', 'profile' => 'profiles/{$name}/', 'database-driver' => 'drivers/lib/Drupal/Driver/Database/{$name}/', 'drush' => 'drush/{$name}/', 'custom-theme' => 'themes/custom/{$name}/', 'custom-module' => 'modules/custom/{$name}/', 'custom-profile' => 'profiles/custom/{$name}/', 'drupal-multisite' => 'sites/{$name}/', 'console' => 'console/{$name}/', 'console-language' => 'console/language/{$name}/', 'config' => 'config/sync/', 'recipe' => 'recipes/{$name}');
    }
    class ElggInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'mod/{$name}/');
    }
    class EliasisInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('component' => 'components/{$name}/', 'module' => 'modules/{$name}/', 'plugin' => 'plugins/{$name}/', 'template' => 'templates/{$name}/');
    }
    class ExpressionEngineInstaller extends \Composer\Installers\BaseInstaller
    {
        public function getLocations(string $frameworkType): array
        {
        }
    }
    class EzPlatformInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('meta-assets' => 'web/assets/ezplatform/', 'assets' => 'web/assets/ezplatform/{$name}/');
    }
    class ForkCMSInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = ['module' => 'src/Modules/{$name}/', 'theme' => 'src/Themes/{$name}/'];
        /**
         * Format package name.
         *
         * For package type fork-cms-module, cut off a trailing '-plugin' if present.
         *
         * For package type fork-cms-theme, cut off a trailing '-theme' if present.
         */
        public function inflectPackageVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectModuleVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectThemeVars(array $vars): array
        {
        }
    }
    class FuelInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'fuel/app/modules/{$name}/', 'package' => 'fuel/packages/{$name}/', 'theme' => 'fuel/app/themes/{$name}/');
    }
    class FuelphpInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('component' => 'components/{$name}/');
    }
    class GravInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'user/plugins/{$name}/', 'theme' => 'user/themes/{$name}/');
        /**
         * Format package name
         */
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    class HuradInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'plugins/{$name}/', 'theme' => 'plugins/{$name}/');
        /**
         * Format package name to CamelCase
         */
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    class ImageCMSInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('template' => 'templates/{$name}/', 'module' => 'application/modules/{$name}/', 'library' => 'application/libraries/{$name}/');
    }
    class Installer extends \Composer\Installer\LibraryInstaller
    {
        /**
         * Disables installers specified in main composer extra installer-disable
         * list
         */
        public function __construct(\Composer\IO\IOInterface $io, \Composer\Composer $composer, string $type = 'library', ?\Composer\Util\Filesystem $filesystem = null, ?\Composer\Installer\BinaryInstaller $binaryInstaller = null)
        {
        }
        /**
         * {@inheritDoc}
         */
        public function getInstallPath(\Composer\Package\PackageInterface $package)
        {
        }
        public function uninstall(\Composer\Repository\InstalledRepositoryInterface $repo, \Composer\Package\PackageInterface $package)
        {
        }
        /**
         * {@inheritDoc}
         *
         * @param string $packageType
         */
        public function supports($packageType)
        {
        }
        /**
         * Finds a supported framework type if it exists and returns it
         *
         * @return string|false
         */
        protected function findFrameworkType(string $type)
        {
        }
        /**
         * Get the second part of the regular expression to check for support of a
         * package type
         */
        protected function getLocationPattern(string $frameworkType): string
        {
        }
        /**
         * Look for installers set to be disabled in composer's extra config and
         * remove them from the list of supported installers.
         *
         * Globals:
         *  - true, "all", and "*" - disable all installers.
         *  - false - enable all installers (useful with
         *     wikimedia/composer-merge-plugin or similar)
         */
        protected function removeDisabledInstallers(): void
        {
        }
    }
    class ItopInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('extension' => 'extensions/{$name}/');
    }
    /**
     *
     * Installer for kanboard plugins
     *
     * kanboard.net
     *
     * Class KanboardInstaller
     * @package Composer\Installers
     */
    class KanboardInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'plugins/{$name}/');
    }
    class KnownInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'IdnoPlugins/{$name}/', 'theme' => 'Themes/{$name}/', 'console' => 'ConsolePlugins/{$name}/');
    }
    class KodiCMSInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'cms/plugins/{$name}/', 'media' => 'cms/media/vendor/{$name}/');
    }
    class KohanaInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'modules/{$name}/');
    }
    class LanManagementSystemInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'plugins/{$name}/', 'template' => 'templates/{$name}/', 'document-template' => 'documents/templates/{$name}/', 'userpanel-module' => 'userpanel/modules/{$name}/');
        /**
         * Format package name to CamelCase
         */
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    class LaravelInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('library' => 'libraries/{$name}/');
    }
    class LavaLiteInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('package' => 'packages/{$vendor}/{$name}/', 'theme' => 'public/themes/{$name}/');
    }
    class LithiumInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('library' => 'libraries/{$name}/', 'source' => 'libraries/_source/{$name}/');
    }
    class MagentoInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('theme' => 'app/design/frontend/{$name}/', 'skin' => 'skin/frontend/default/{$name}/', 'library' => 'lib/{$name}/');
    }
    /**
     * Plugin/theme installer for majima
     * @author David Neustadt
     */
    class MajimaInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'plugins/{$name}/');
        /**
         * Transforms the names
         *
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    class MakoInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('package' => 'app/packages/{$name}/');
    }
    class MantisBTInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'plugins/{$name}/');
        /**
         * Format package name to CamelCase
         */
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    /**
     * Class MatomoInstaller
     *
     * @package Composer\Installers
     */
    class MatomoInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'plugins/{$name}/');
        /**
         * Format package name to CamelCase
         */
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    class MauticInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'plugins/{$name}/', 'theme' => 'themes/{$name}/', 'core' => 'app/');
        /**
         * Format package name of mautic-plugins to CamelCase
         */
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    class MayaInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'modules/{$name}/');
        /**
         * Format package name.
         *
         * For package type maya-module, cut off a trailing '-module' if present.
         */
        public function inflectPackageVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectModuleVars(array $vars): array
        {
        }
    }
    class MediaWikiInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('core' => 'core/', 'extension' => 'extensions/{$name}/', 'skin' => 'skins/{$name}/');
        /**
         * Format package name.
         *
         * For package type mediawiki-extension, cut off a trailing '-extension' if present and transform
         * to CamelCase keeping existing uppercase chars.
         *
         * For package type mediawiki-skin, cut off a trailing '-skin' if present.
         */
        public function inflectPackageVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectExtensionVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectSkinVars(array $vars): array
        {
        }
    }
    class MiaoxingInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'plugins/{$name}/');
    }
    class MicroweberInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'userfiles/modules/{$install_item_dir}/', 'module-skin' => 'userfiles/modules/{$install_item_dir}/templates/', 'template' => 'userfiles/templates/{$install_item_dir}/', 'element' => 'userfiles/elements/{$install_item_dir}/', 'vendor' => 'vendor/{$install_item_dir}/', 'components' => 'components/{$install_item_dir}/');
        /**
         * Format package name.
         *
         * For package type microweber-module, cut off a trailing '-module' if present
         *
         * For package type microweber-template, cut off a trailing '-template' if present.
         */
        public function inflectPackageVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectTemplateVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectTemplatesVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectCoreVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectModuleVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectModulesVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectSkinVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectElementVars(array $vars): array
        {
        }
    }
    class MODULEWorkInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'modules/{$name}/');
    }
    /**
     * An installer to handle MODX Evolution specifics when installing packages.
     */
    class MODXEvoInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('snippet' => 'assets/snippets/{$name}/', 'plugin' => 'assets/plugins/{$name}/', 'module' => 'assets/modules/{$name}/', 'template' => 'assets/templates/{$name}/', 'lib' => 'assets/lib/{$name}/');
    }
    /**
     * An installer to handle MODX specifics when installing packages.
     */
    class ModxInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('extra' => 'core/packages/{$name}/');
    }
    class MoodleInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('mod' => 'mod/{$name}/', 'admin_report' => 'admin/report/{$name}/', 'atto' => 'lib/editor/atto/plugins/{$name}/', 'tool' => 'admin/tool/{$name}/', 'assignment' => 'mod/assignment/type/{$name}/', 'assignsubmission' => 'mod/assign/submission/{$name}/', 'assignfeedback' => 'mod/assign/feedback/{$name}/', 'antivirus' => 'lib/antivirus/{$name}/', 'auth' => 'auth/{$name}/', 'availability' => 'availability/condition/{$name}/', 'block' => 'blocks/{$name}/', 'booktool' => 'mod/book/tool/{$name}/', 'cachestore' => 'cache/stores/{$name}/', 'cachelock' => 'cache/locks/{$name}/', 'calendartype' => 'calendar/type/{$name}/', 'communication' => 'communication/provider/{$name}/', 'customfield' => 'customfield/field/{$name}/', 'fileconverter' => 'files/converter/{$name}/', 'format' => 'course/format/{$name}/', 'coursereport' => 'course/report/{$name}/', 'contenttype' => 'contentbank/contenttype/{$name}/', 'customcertelement' => 'mod/customcert/element/{$name}/', 'datafield' => 'mod/data/field/{$name}/', 'dataformat' => 'dataformat/{$name}/', 'datapreset' => 'mod/data/preset/{$name}/', 'editor' => 'lib/editor/{$name}/', 'enrol' => 'enrol/{$name}/', 'filter' => 'filter/{$name}/', 'forumreport' => 'mod/forum/report/{$name}/', 'gradeexport' => 'grade/export/{$name}/', 'gradeimport' => 'grade/import/{$name}/', 'gradereport' => 'grade/report/{$name}/', 'gradingform' => 'grade/grading/form/{$name}/', 'h5plib' => 'h5p/h5plib/{$name}/', 'local' => 'local/{$name}/', 'logstore' => 'admin/tool/log/store/{$name}/', 'ltisource' => 'mod/lti/source/{$name}/', 'ltiservice' => 'mod/lti/service/{$name}/', 'media' => 'media/player/{$name}/', 'message' => 'message/output/{$name}/', 'mlbackend' => 'lib/mlbackend/{$name}/', 'mnetservice' => 'mnet/service/{$name}/', 'paygw' => 'payment/gateway/{$name}/', 'plagiarism' => 'plagiarism/{$name}/', 'portfolio' => 'portfolio/{$name}/', 'qbank' => 'question/bank/{$name}/', 'qbehaviour' => 'question/behaviour/{$name}/', 'qformat' => 'question/format/{$name}/', 'qtype' => 'question/type/{$name}/', 'quizaccess' => 'mod/quiz/accessrule/{$name}/', 'quiz' => 'mod/quiz/report/{$name}/', 'report' => 'report/{$name}/', 'repository' => 'repository/{$name}/', 'scormreport' => 'mod/scorm/report/{$name}/', 'search' => 'search/engine/{$name}/', 'theme' => 'theme/{$name}/', 'tiny' => 'lib/editor/tiny/plugins/{$name}/', 'tinymce' => 'lib/editor/tinymce/plugins/{$name}/', 'profilefield' => 'user/profile/field/{$name}/', 'webservice' => 'webservice/{$name}/', 'workshopallocation' => 'mod/workshop/allocation/{$name}/', 'workshopeval' => 'mod/workshop/eval/{$name}/', 'workshopform' => 'mod/workshop/form/{$name}/');
    }
    class OctoberInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'modules/{$name}/', 'plugin' => 'plugins/{$vendor}/{$name}/', 'theme' => 'themes/{$vendor}-{$name}/');
        /**
         * Format package name.
         *
         * For package type october-plugin, cut off a trailing '-plugin' if present.
         *
         * For package type october-theme, cut off a trailing '-theme' if present.
         */
        public function inflectPackageVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectPluginVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectThemeVars(array $vars): array
        {
        }
    }
    class OntoWikiInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('extension' => 'extensions/{$name}/', 'theme' => 'extensions/themes/{$name}/', 'translation' => 'extensions/translations/{$name}/');
        /**
         * Format package name to lower case and remove ".ontowiki" suffix
         */
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    class OsclassInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'oc-content/plugins/{$name}/', 'theme' => 'oc-content/themes/{$name}/', 'language' => 'oc-content/languages/{$name}/');
    }
    class OxidInstaller extends \Composer\Installers\BaseInstaller
    {
        const VENDOR_PATTERN = '/^modules\/(?P<vendor>.+)\/.+/';
        /** @var array<string, string> */
        protected $locations = array('module' => 'modules/{$name}/', 'theme' => 'application/views/{$name}/', 'out' => 'out/{$name}/');
        public function getInstallPath(\Composer\Package\PackageInterface $package, string $frameworkType = ''): string
        {
        }
        /**
         * Makes sure there is a vendormetadata.php file inside
         * the vendor folder if there is a vendor folder.
         */
        protected function prepareVendorDirectory(string $installPath): void
        {
        }
    }
    class PantheonInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('script' => 'web/private/scripts/quicksilver/{$name}', 'module' => 'web/private/scripts/quicksilver/{$name}');
    }
    class PhiftyInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('bundle' => 'bundles/{$name}/', 'library' => 'libraries/{$name}/', 'framework' => 'frameworks/{$name}/');
    }
    class PhpBBInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('extension' => 'ext/{$vendor}/{$name}/', 'language' => 'language/{$name}/', 'style' => 'styles/{$name}/');
    }
    /**
     * Class PiwikInstaller
     *
     * @package Composer\Installers
     */
    class PiwikInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'plugins/{$name}/');
        /**
         * Format package name to CamelCase
         */
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    class PlentymarketsInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => '{$name}/');
        /**
         * Remove hyphen, "plugin" and format to camelcase
         */
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    class Plugin implements \Composer\Plugin\PluginInterface
    {
        public function activate(\Composer\Composer $composer, \Composer\IO\IOInterface $io): void
        {
        }
        public function deactivate(\Composer\Composer $composer, \Composer\IO\IOInterface $io): void
        {
        }
        public function uninstall(\Composer\Composer $composer, \Composer\IO\IOInterface $io): void
        {
        }
    }
    class PortoInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('container' => 'app/Containers/{$name}/');
    }
    class PPIInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'modules/{$name}/');
    }
    class PrestashopInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'modules/{$name}/', 'theme' => 'themes/{$name}/');
    }
    class ProcessWireInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'site/modules/{$name}/');
        /**
         * Format package name to CamelCase
         */
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    class PuppetInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'modules/{$name}/');
    }
    class PxcmsInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'app/Modules/{$name}/', 'theme' => 'themes/{$name}/');
        /**
         * Format package name.
         */
        public function inflectPackageVars(array $vars): array
        {
        }
        /**
         * For package type pxcms-module, cut off a trailing '-plugin' if present.
         *
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectModuleVars(array $vars): array
        {
        }
        /**
         * For package type pxcms-module, cut off a trailing '-plugin' if present.
         *
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectThemeVars(array $vars): array
        {
        }
    }
    class RadPHPInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('bundle' => 'src/{$name}/');
        /**
         * Format package name to CamelCase
         */
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    class Redaxo5Installer extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('addon' => 'redaxo/src/addons/{$name}/', 'bestyle-plugin' => 'redaxo/src/addons/be_style/plugins/{$name}/');
    }
    class RedaxoInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('addon' => 'redaxo/include/addons/{$name}/', 'bestyle-plugin' => 'redaxo/include/addons/be_style/plugins/{$name}/');
    }
    class ReIndexInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('theme' => 'themes/{$name}/', 'plugin' => 'plugins/{$name}/');
    }
    class RoundcubeInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'plugins/{$name}/');
        /**
         * Lowercase name and changes the name to a underscores
         */
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    /**
     * Plugin/theme installer for shopware
     * @author Benjamin Boit
     */
    class ShopwareInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('backend-plugin' => 'engine/Shopware/Plugins/Local/Backend/{$name}/', 'core-plugin' => 'engine/Shopware/Plugins/Local/Core/{$name}/', 'frontend-plugin' => 'engine/Shopware/Plugins/Local/Frontend/{$name}/', 'theme' => 'templates/{$name}/', 'plugin' => 'custom/plugins/{$name}/', 'frontend-theme' => 'themes/Frontend/{$name}/');
        /**
         * Transforms the names
         */
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    class SilverStripeInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => '{$name}/', 'theme' => 'themes/{$name}/');
        /**
         * Return the install path based on package type.
         *
         * Relies on built-in BaseInstaller behaviour with one exception: silverstripe/framework
         * must be installed to 'sapphire' and not 'framework' if the version is <3.0.0
         */
        public function getInstallPath(\Composer\Package\PackageInterface $package, string $frameworkType = ''): string
        {
        }
    }
    class SiteDirectInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'modules/{$vendor}/{$name}/', 'plugin' => 'plugins/{$vendor}/{$name}/');
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        public function inflectPackageVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function parseVars(array $vars): array
        {
        }
    }
    class SMFInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'Sources/{$name}/', 'theme' => 'Themes/{$name}/');
    }
    class StarbugInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'modules/{$name}/', 'theme' => 'themes/{$name}/', 'custom-module' => 'app/modules/{$name}/', 'custom-theme' => 'app/themes/{$name}/');
    }
    class SyDESInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'app/modules/{$name}/', 'theme' => 'themes/{$name}/');
        /**
         * Format module name.
         *
         * Strip `sydes-` prefix and a trailing '-theme' or '-module' from package name if present.
         */
        public function inflectPackageVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        public function inflectModuleVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectThemeVars(array $vars): array
        {
        }
    }
    class SyliusInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('theme' => 'themes/{$name}/');
    }
    /**
     * An installer to handle TAO extensions.
     */
    class TaoInstaller extends \Composer\Installers\BaseInstaller
    {
        const EXTRA_TAO_EXTENSION_NAME = 'tao-extension-name';
        /** @var array<string, string> */
        protected $locations = array('extension' => '{$name}');
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    class TastyIgniterInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = ['module' => 'app/{$name}/', 'extension' => 'extensions/{$vendor}/{$name}/', 'theme' => 'themes/{$name}/'];
        /**
         * Format package name.
         *
         * Cut off leading 'ti-ext-' or 'ti-theme-' if present.
         * Strip vendor name of characters that is not alphanumeric or an underscore
         *
         */
        public function inflectPackageVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectModuleVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @param array<string, mixed> $extra
         * @return array<string, string>
         */
        protected function inflectExtensionVars(array $vars, array $extra): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @param array<string, mixed> $extra
         * @return array<string, string>
         */
        protected function inflectThemeVars(array $vars, array $extra): array
        {
        }
    }
    class TheliaInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'local/modules/{$name}/', 'frontoffice-template' => 'templates/frontOffice/{$name}/', 'backoffice-template' => 'templates/backOffice/{$name}/', 'email-template' => 'templates/email/{$name}/');
    }
    /**
     * Composer installer for 3rd party Tusk utilities
     * @author Drew Ewing <drew@phenocode.com>
     */
    class TuskInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('task' => '.tusk/tasks/{$name}/', 'command' => '.tusk/commands/{$name}/', 'asset' => 'assets/tusk/{$name}/');
    }
    class UserFrostingInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('sprinkle' => 'app/sprinkles/{$name}/');
    }
    class VanillaInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'plugins/{$name}/', 'theme' => 'themes/{$name}/');
    }
    class VgmcpInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('bundle' => 'src/{$vendor}/{$name}/', 'theme' => 'themes/{$name}/');
        /**
         * Format package name.
         *
         * For package type vgmcp-bundle, cut off a trailing '-bundle' if present.
         *
         * For package type vgmcp-theme, cut off a trailing '-theme' if present.
         *
         */
        public function inflectPackageVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectPluginVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectThemeVars(array $vars): array
        {
        }
    }
    class WHMCSInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('addons' => 'modules/addons/{$vendor}_{$name}/', 'fraud' => 'modules/fraud/{$vendor}_{$name}/', 'gateways' => 'modules/gateways/{$vendor}_{$name}/', 'notifications' => 'modules/notifications/{$vendor}_{$name}/', 'registrars' => 'modules/registrars/{$vendor}_{$name}/', 'reports' => 'modules/reports/{$vendor}_{$name}/', 'security' => 'modules/security/{$vendor}_{$name}/', 'servers' => 'modules/servers/{$vendor}_{$name}/', 'social' => 'modules/social/{$vendor}_{$name}/', 'support' => 'modules/support/{$vendor}_{$name}/', 'templates' => 'templates/{$vendor}_{$name}/', 'includes' => 'includes/{$vendor}_{$name}/');
    }
    class WinterInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'modules/{$name}/', 'plugin' => 'plugins/{$vendor}/{$name}/', 'theme' => 'themes/{$name}/');
        /**
         * Format package name.
         *
         * For package type winter-plugin, cut off a trailing '-plugin' if present.
         *
         * For package type winter-theme, cut off a trailing '-theme' if present.
         */
        public function inflectPackageVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectModuleVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectPluginVars(array $vars): array
        {
        }
        /**
         * @param array<string, string> $vars
         * @return array<string, string>
         */
        protected function inflectThemeVars(array $vars): array
        {
        }
    }
    class WolfCMSInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'wolf/plugins/{$name}/');
    }
    class WordPressInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('plugin' => 'wp-content/plugins/{$name}/', 'theme' => 'wp-content/themes/{$name}/', 'muplugin' => 'wp-content/mu-plugins/{$name}/', 'dropin' => 'wp-content/{$name}/');
    }
    class YawikInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'module/{$name}/');
        /**
         * Format package name to CamelCase
         */
        public function inflectPackageVars(array $vars): array
        {
        }
    }
    class ZendInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('library' => 'library/{$name}/', 'extra' => 'extras/library/{$name}/', 'module' => 'module/{$name}/');
    }
    class ZikulaInstaller extends \Composer\Installers\BaseInstaller
    {
        /** @var array<string, string> */
        protected $locations = array('module' => 'modules/{$vendor}-{$name}/', 'theme' => 'themes/{$vendor}-{$name}/');
    }
}
namespace Doctrine\Deprecations {
    /**
     * Manages Deprecation logging in different ways.
     *
     * By default triggered exceptions are not logged.
     *
     * To enable different deprecation logging mechanisms you can call the
     * following methods:
     *
     *  - Minimal collection of deprecations via getTriggeredDeprecations()
     *    \Doctrine\Deprecations\Deprecation::enableTrackingDeprecations();
     *
     *  - Uses @trigger_error with E_USER_DEPRECATED
     *    \Doctrine\Deprecations\Deprecation::enableWithTriggerError();
     *
     *  - Sends deprecation messages via a PSR-3 logger
     *    \Doctrine\Deprecations\Deprecation::enableWithPsrLogger($logger);
     *
     * Packages that trigger deprecations should use the `trigger()` or
     * `triggerIfCalledFromOutside()` methods.
     */
    class Deprecation
    {
        /**
         * Trigger a deprecation for the given package and identfier.
         *
         * The link should point to a Github issue or Wiki entry detailing the
         * deprecation. It is additionally used to de-duplicate the trigger of the
         * same deprecation during a request.
         *
         * @param float|int|string $args
         */
        public static function trigger(string $package, string $link, string $message, ...$args): void
        {
        }
        /**
         * Trigger a deprecation for the given package and identifier when called from outside.
         *
         * "Outside" means we assume that $package is currently installed as a
         * dependency and the caller is not a file in that package. When $package
         * is installed as a root package then deprecations triggered from the
         * tests folder are also considered "outside".
         *
         * This deprecation method assumes that you are using Composer to install
         * the dependency and are using the default /vendor/ folder and not a
         * Composer plugin to change the install location. The assumption is also
         * that $package is the exact composer packge name.
         *
         * Compared to {@link trigger()} this method causes some overhead when
         * deprecation tracking is enabled even during deduplication, because it
         * needs to call {@link debug_backtrace()}
         *
         * @param float|int|string $args
         */
        public static function triggerIfCalledFromOutside(string $package, string $link, string $message, ...$args): void
        {
        }
        public static function enableTrackingDeprecations(): void
        {
        }
        public static function enableWithTriggerError(): void
        {
        }
        public static function enableWithPsrLogger(\Psr\Log\LoggerInterface $logger): void
        {
        }
        public static function withoutDeduplication(): void
        {
        }
        public static function disable(): void
        {
        }
        public static function ignorePackage(string $packageName): void
        {
        }
        public static function ignoreDeprecations(string ...$links): void
        {
        }
        public static function getUniqueTriggeredDeprecationsCount(): int
        {
        }
        /**
         * Returns each triggered deprecation link identifier and the amount of occurrences.
         *
         * @return array<string,int>
         */
        public static function getTriggeredDeprecations(): array
        {
        }
    }
}
namespace Doctrine\Deprecations\PHPUnit {
    trait VerifyDeprecations
    {
        /** @var array<string,int> */
        private $doctrineDeprecationsExpectations = [];
        /** @var array<string,int> */
        private $doctrineNoDeprecationsExpectations = [];
        public function expectDeprecationWithIdentifier(string $identifier): void
        {
        }
        public function expectNoDeprecationWithIdentifier(string $identifier): void
        {
        }
        /** @before */
        public function enableDeprecationTracking(): void
        {
        }
        /** @after */
        public function verifyDeprecationsAreTriggered(): void
        {
        }
    }
}
namespace Cron {
    /**
     * CRON field interface.
     */
    interface FieldInterface
    {
        /**
         * Check if the respective value of a DateTime field satisfies a CRON exp.
         *
         * @internal
         * @param DateTimeInterface $date  DateTime object to check
         * @param string            $value CRON expression to test against
         *
         * @return bool Returns TRUE if satisfied, FALSE otherwise
         */
        public function isSatisfiedBy(\DateTimeInterface $date, $value, bool $invert): bool;
        /**
         * When a CRON expression is not satisfied, this method is used to increment
         * or decrement a DateTime object by the unit of the cron field.
         *
         * @internal
         * @param DateTimeInterface $date DateTime object to change
         * @param bool $invert (optional) Set to TRUE to decrement
         * @param string|null $parts (optional) Set parts to use
         *
         * @return FieldInterface
         */
        public function increment(\DateTimeInterface &$date, $invert = false, $parts = null): \Cron\FieldInterface;
        /**
         * Validates a CRON expression for a given field.
         *
         * @param string $value CRON expression value to validate
         *
         * @return bool Returns TRUE if valid, FALSE otherwise
         */
        public function validate(string $value): bool;
    }
    /**
     * Abstract CRON expression field.
     */
    abstract class AbstractField implements \Cron\FieldInterface
    {
        /**
         * Full range of values that are allowed for this field type.
         *
         * @var array
         */
        protected $fullRange = [];
        /**
         * Literal values we need to convert to integers.
         *
         * @var array
         */
        protected $literals = [];
        /**
         * Start value of the full range.
         *
         * @var int
         */
        protected $rangeStart;
        /**
         * End value of the full range.
         *
         * @var int
         */
        protected $rangeEnd;
        /**
         * Constructor
         */
        public function __construct()
        {
        }
        /**
         * Check to see if a field is satisfied by a value.
         *
         * @internal
         * @param int $dateValue Date value to check
         * @param string $value Value to test
         *
         * @return bool
         */
        public function isSatisfied(int $dateValue, string $value): bool
        {
        }
        /**
         * Check if a value is a range.
         *
         * @internal
         * @param string $value Value to test
         *
         * @return bool
         */
        public function isRange(string $value): bool
        {
        }
        /**
         * Check if a value is an increments of ranges.
         *
         * @internal
         * @param string $value Value to test
         *
         * @return bool
         */
        public function isIncrementsOfRanges(string $value): bool
        {
        }
        /**
         * Test if a value is within a range.
         *
         * @internal
         * @param int $dateValue Set date value
         * @param string $value Value to test
         *
         * @return bool
         */
        public function isInRange(int $dateValue, $value): bool
        {
        }
        /**
         * Test if a value is within an increments of ranges (offset[-to]/step size).
         *
         * @internal
         * @param int $dateValue Set date value
         * @param string $value Value to test
         *
         * @return bool
         */
        public function isInIncrementsOfRanges(int $dateValue, string $value): bool
        {
        }
        /**
         * Returns a range of values for the given cron expression.
         *
         * @param string $expression The expression to evaluate
         * @param int $max Maximum offset for range
         *
         * @return array
         */
        public function getRangeForExpression(string $expression, int $max): array
        {
        }
        /**
         * Convert literal.
         *
         * @param string $value
         *
         * @return string
         */
        protected function convertLiterals(string $value): string
        {
        }
        /**
         * Checks to see if a value is valid for the field.
         *
         * @param string $value
         *
         * @return bool
         */
        public function validate(string $value): bool
        {
        }
        protected function timezoneSafeModify(\DateTimeInterface $dt, string $modification): \DateTimeInterface
        {
        }
        protected function setTimeHour(\DateTimeInterface $date, bool $invert, int $originalTimestamp): \DateTimeInterface
        {
        }
    }
    /**
     * CRON expression parser that can determine whether or not a CRON expression is
     * due to run, the next run date and previous run date of a CRON expression.
     * The determinations made by this class are accurate if checked run once per
     * minute (seconds are dropped from date time comparisons).
     *
     * Schedule parts must map to:
     * minute [0-59], hour [0-23], day of month, month [1-12|JAN-DEC], day of week
     * [1-7|MON-SUN], and an optional year.
     *
     * @see http://en.wikipedia.org/wiki/Cron
     */
    class CronExpression
    {
        public const MINUTE = 0;
        public const HOUR = 1;
        public const DAY = 2;
        public const MONTH = 3;
        public const WEEKDAY = 4;
        /** @deprecated */
        public const YEAR = 5;
        public const MAPPINGS = ['@yearly' => '0 0 1 1 *', '@annually' => '0 0 1 1 *', '@monthly' => '0 0 1 * *', '@weekly' => '0 0 * * 0', '@daily' => '0 0 * * *', '@midnight' => '0 0 * * *', '@hourly' => '0 * * * *'];
        /**
         * @var array CRON expression parts
         */
        protected $cronParts;
        /**
         * @var FieldFactoryInterface CRON field factory
         */
        protected $fieldFactory;
        /**
         * @var int Max iteration count when searching for next run date
         */
        protected $maxIterationCount = 1000;
        /**
         * @var array Order in which to test of cron parts
         */
        protected static $order = [self::YEAR, self::MONTH, self::DAY, self::WEEKDAY, self::HOUR, self::MINUTE];
        /**
         * Registered a user defined CRON Expression Alias.
         *
         * @throws LogicException If the expression or the alias name are invalid
         *                         or if the alias is already registered.
         */
        public static function registerAlias(string $alias, string $expression): void
        {
        }
        /**
         * Unregistered a user defined CRON Expression Alias.
         *
         * @throws LogicException If the user tries to unregister a built-in alias
         */
        public static function unregisterAlias(string $alias): bool
        {
        }
        /**
         * Tells whether a CRON Expression alias is registered.
         */
        public static function supportsAlias(string $alias): bool
        {
        }
        /**
         * Returns all registered aliases as an associated array where the aliases are the key
         * and their associated expressions are the values.
         *
         * @return array<string, string>
         */
        public static function getAliases(): array
        {
        }
        /**
         * @deprecated since version 3.0.2, use __construct instead.
         */
        public static function factory(string $expression, ?\Cron\FieldFactoryInterface $fieldFactory = null): \Cron\CronExpression
        {
        }
        /**
         * Validate a CronExpression.
         *
         * @param string $expression the CRON expression to validate
         *
         * @return bool True if a valid CRON expression was passed. False if not.
         */
        public static function isValidExpression(string $expression): bool
        {
        }
        /**
         * Parse a CRON expression.
         *
         * @param string $expression CRON expression (e.g. '8 * * * *')
         * @param null|FieldFactoryInterface $fieldFactory Factory to create cron fields
         * @throws InvalidArgumentException
         */
        public function __construct(string $expression, ?\Cron\FieldFactoryInterface $fieldFactory = null)
        {
        }
        /**
         * Set or change the CRON expression.
         *
         * @param string $value CRON expression (e.g. 8 * * * *)
         *
         * @throws \InvalidArgumentException if not a valid CRON expression
         *
         * @return CronExpression
         */
        public function setExpression(string $value): \Cron\CronExpression
        {
        }
        /**
         * Set part of the CRON expression.
         *
         * @param int $position The position of the CRON expression to set
         * @param string $value The value to set
         *
         * @throws \InvalidArgumentException if the value is not valid for the part
         *
         * @return CronExpression
         */
        public function setPart(int $position, string $value): \Cron\CronExpression
        {
        }
        /**
         * Set max iteration count for searching next run dates.
         *
         * @param int $maxIterationCount Max iteration count when searching for next run date
         *
         * @return CronExpression
         */
        public function setMaxIterationCount(int $maxIterationCount): \Cron\CronExpression
        {
        }
        /**
         * Get a next run date relative to the current date or a specific date
         *
         * @param string|\DateTimeInterface $currentTime      Relative calculation date
         * @param int                       $nth              Number of matches to skip before returning a
         *                                                    matching next run date.  0, the default, will return the
         *                                                    current date and time if the next run date falls on the
         *                                                    current date and time.  Setting this value to 1 will
         *                                                    skip the first match and go to the second match.
         *                                                    Setting this value to 2 will skip the first 2
         *                                                    matches and so on.
         * @param bool                      $allowCurrentDate Set to TRUE to return the current date if
         *                                                    it matches the cron expression.
         * @param null|string               $timeZone         TimeZone to use instead of the system default
         *
         * @throws \RuntimeException on too many iterations
         * @throws \Exception
         *
         * @return \DateTime
         */
        public function getNextRunDate($currentTime = 'now', int $nth = 0, bool $allowCurrentDate = false, $timeZone = null): \DateTime
        {
        }
        /**
         * Get a previous run date relative to the current date or a specific date.
         *
         * @param string|\DateTimeInterface $currentTime      Relative calculation date
         * @param int                       $nth              Number of matches to skip before returning
         * @param bool                      $allowCurrentDate Set to TRUE to return the
         *                                                    current date if it matches the cron expression
         * @param null|string               $timeZone         TimeZone to use instead of the system default
         *
         * @throws \RuntimeException on too many iterations
         * @throws \Exception
         *
         * @return \DateTime
         *
         * @see \Cron\CronExpression::getNextRunDate
         */
        public function getPreviousRunDate($currentTime = 'now', int $nth = 0, bool $allowCurrentDate = false, $timeZone = null): \DateTime
        {
        }
        /**
         * Get multiple run dates starting at the current date or a specific date.
         *
         * @param int $total Set the total number of dates to calculate
         * @param string|\DateTimeInterface|null $currentTime Relative calculation date
         * @param bool $invert Set to TRUE to retrieve previous dates
         * @param bool $allowCurrentDate Set to TRUE to return the
         *                               current date if it matches the cron expression
         * @param null|string $timeZone TimeZone to use instead of the system default
         *
         * @return \DateTime[] Returns an array of run dates
         */
        public function getMultipleRunDates(int $total, $currentTime = 'now', bool $invert = false, bool $allowCurrentDate = false, $timeZone = null): array
        {
        }
        /**
         * Get all or part of the CRON expression.
         *
         * @param int|string|null $part specify the part to retrieve or NULL to get the full
         *                     cron schedule string
         *
         * @return null|string Returns the CRON expression, a part of the
         *                     CRON expression, or NULL if the part was specified but not found
         */
        public function getExpression($part = null): ?string
        {
        }
        /**
         * Gets the parts of the cron expression as an array.
         *
         * @return string[]
         *   The array of parts that make up this expression.
         */
        public function getParts()
        {
        }
        /**
         * Helper method to output the full expression.
         *
         * @return string Full CRON expression
         */
        public function __toString(): string
        {
        }
        /**
         * Determine if the cron is due to run based on the current date or a
         * specific date.  This method assumes that the current number of
         * seconds are irrelevant, and should be called once per minute.
         *
         * @param string|\DateTimeInterface $currentTime Relative calculation date
         * @param null|string               $timeZone    TimeZone to use instead of the system default
         *
         * @return bool Returns TRUE if the cron is due to run or FALSE if not
         */
        public function isDue($currentTime = 'now', $timeZone = null): bool
        {
        }
        /**
         * Get the next or previous run date of the expression relative to a date.
         *
         * @param string|\DateTimeInterface|null $currentTime Relative calculation date
         * @param int $nth Number of matches to skip before returning
         * @param bool $invert Set to TRUE to go backwards in time
         * @param bool $allowCurrentDate Set to TRUE to return the
         *                               current date if it matches the cron expression
         * @param string|null $timeZone  TimeZone to use instead of the system default
         *
         * @throws \RuntimeException on too many iterations
         * @throws Exception
         *
         * @return \DateTime
         */
        protected function getRunDate($currentTime = null, int $nth = 0, bool $invert = false, bool $allowCurrentDate = false, $timeZone = null): \DateTime
        {
        }
        /**
         * Workout what timeZone should be used.
         *
         * @param string|\DateTimeInterface|null $currentTime Relative calculation date
         * @param string|null $timeZone TimeZone to use instead of the system default
         *
         * @return string
         */
        protected function determineTimeZone($currentTime, ?string $timeZone): string
        {
        }
    }
    /**
     * Day of month field.  Allows: * , / - ? L W.
     *
     * 'L' stands for "last" and specifies the last day of the month.
     *
     * The 'W' character is used to specify the weekday (Monday-Friday) nearest the
     * given day. As an example, if you were to specify "15W" as the value for the
     * day-of-month field, the meaning is: "the nearest weekday to the 15th of the
     * month". So if the 15th is a Saturday, the trigger will fire on Friday the
     * 14th. If the 15th is a Sunday, the trigger will fire on Monday the 16th. If
     * the 15th is a Tuesday, then it will fire on Tuesday the 15th. However if you
     * specify "1W" as the value for day-of-month, and the 1st is a Saturday, the
     * trigger will fire on Monday the 3rd, as it will not 'jump' over the boundary
     * of a month's days. The 'W' character can only be specified when the
     * day-of-month is a single day, not a range or list of days.
     *
     * @author Michael Dowling <mtdowling@gmail.com>
     */
    class DayOfMonthField extends \Cron\AbstractField
    {
        /**
         * {@inheritdoc}
         */
        protected $rangeStart = 1;
        /**
         * {@inheritdoc}
         */
        protected $rangeEnd = 31;
        /**
         * {@inheritdoc}
         */
        public function isSatisfiedBy(\DateTimeInterface $date, $value, bool $invert): bool
        {
        }
        /**
         * @inheritDoc
         *
         * @param \DateTime|\DateTimeImmutable $date
         */
        public function increment(\DateTimeInterface &$date, $invert = false, $parts = null): \Cron\FieldInterface
        {
        }
        /**
         * {@inheritdoc}
         */
        public function validate(string $value): bool
        {
        }
    }
    /**
     * Day of week field.  Allows: * / , - ? L #.
     *
     * Days of the week can be represented as a number 0-7 (0|7 = Sunday)
     * or as a three letter string: SUN, MON, TUE, WED, THU, FRI, SAT.
     *
     * 'L' stands for "last". It allows you to specify constructs such as
     * "the last Friday" of a given month.
     *
     * '#' is allowed for the day-of-week field, and must be followed by a
     * number between one and five. It allows you to specify constructs such as
     * "the second Friday" of a given month.
     */
    class DayOfWeekField extends \Cron\AbstractField
    {
        /**
         * {@inheritdoc}
         */
        protected $rangeStart = 0;
        /**
         * {@inheritdoc}
         */
        protected $rangeEnd = 7;
        /**
         * @var array Weekday range
         */
        protected $nthRange;
        /**
         * {@inheritdoc}
         */
        protected $literals = [1 => 'MON', 2 => 'TUE', 3 => 'WED', 4 => 'THU', 5 => 'FRI', 6 => 'SAT', 7 => 'SUN'];
        /**
         * Constructor
         */
        public function __construct()
        {
        }
        /**
         * @inheritDoc
         */
        public function isSatisfiedBy(\DateTimeInterface $date, $value, bool $invert): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function increment(\DateTimeInterface &$date, $invert = false, $parts = null): \Cron\FieldInterface
        {
        }
        /**
         * {@inheritdoc}
         */
        public function validate(string $value): bool
        {
        }
    }
    interface FieldFactoryInterface
    {
        public function getField(int $position): \Cron\FieldInterface;
    }
    /**
     * CRON field factory implementing a flyweight factory.
     *
     * @see http://en.wikipedia.org/wiki/Cron
     */
    class FieldFactory implements \Cron\FieldFactoryInterface
    {
        /**
         * Get an instance of a field object for a cron expression position.
         *
         * @param int $position CRON expression position value to retrieve
         *
         * @throws InvalidArgumentException if a position is not valid
         */
        public function getField(int $position): \Cron\FieldInterface
        {
        }
    }
    /**
     * Hours field.  Allows: * , / -.
     */
    class HoursField extends \Cron\AbstractField
    {
        /**
         * {@inheritdoc}
         */
        protected $rangeStart = 0;
        /**
         * {@inheritdoc}
         */
        protected $rangeEnd = 23;
        /**
         * @var array|null Transitions returned by DateTimeZone::getTransitions()
         */
        protected $transitions = [];
        /**
         * @var int|null Timestamp of the start of the transitions range
         */
        protected $transitionsStart = null;
        /**
         * @var int|null Timestamp of the end of the transitions range
         */
        protected $transitionsEnd = null;
        /**
         * {@inheritdoc}
         */
        public function isSatisfiedBy(\DateTimeInterface $date, $value, bool $invert): bool
        {
        }
        public function getPastTransition(\DateTimeInterface $date): ?array
        {
        }
        /**
         * {@inheritdoc}
         *
         * @param string|null                  $parts
         */
        public function increment(\DateTimeInterface &$date, $invert = false, $parts = null): \Cron\FieldInterface
        {
        }
    }
    /**
     * Minutes field.  Allows: * , / -.
     */
    class MinutesField extends \Cron\AbstractField
    {
        /**
         * {@inheritdoc}
         */
        protected $rangeStart = 0;
        /**
         * {@inheritdoc}
         */
        protected $rangeEnd = 59;
        /**
         * {@inheritdoc}
         */
        public function isSatisfiedBy(\DateTimeInterface $date, $value, bool $invert): bool
        {
        }
        /**
         * {@inheritdoc}
         * {@inheritDoc}
         *
         * @param string|null                  $parts
         */
        public function increment(\DateTimeInterface &$date, $invert = false, $parts = null): \Cron\FieldInterface
        {
        }
    }
    /**
     * Month field.  Allows: * , / -.
     */
    class MonthField extends \Cron\AbstractField
    {
        /**
         * {@inheritdoc}
         */
        protected $rangeStart = 1;
        /**
         * {@inheritdoc}
         */
        protected $rangeEnd = 12;
        /**
         * {@inheritdoc}
         */
        protected $literals = [1 => 'JAN', 2 => 'FEB', 3 => 'MAR', 4 => 'APR', 5 => 'MAY', 6 => 'JUN', 7 => 'JUL', 8 => 'AUG', 9 => 'SEP', 10 => 'OCT', 11 => 'NOV', 12 => 'DEC'];
        /**
         * {@inheritdoc}
         */
        public function isSatisfiedBy(\DateTimeInterface $date, $value, bool $invert): bool
        {
        }
        /**
         * @inheritDoc
         *
         * @param \DateTime|\DateTimeImmutable $date
         */
        public function increment(\DateTimeInterface &$date, $invert = false, $parts = null): \Cron\FieldInterface
        {
        }
    }
}
namespace edoc\utils\Crypt {
    class Crypt
    {
        public function __construct(string $key)
        {
        }
        public function setKey(string $key): void
        {
        }
        /**
         * @param string $data
         * @return string
         * @throws \SodiumException
         */
        public function encrypt(string $data): string
        {
        }
        /**
         * @param string $encrypted
         * @return string|null
         * @throws \SodiumException
         */
        public function decrypt(string $encrypted): ?string
        {
        }
    }
}
namespace edoc\utils\Security {
    class Credentials
    {
        public static function GetInstance(): self
        {
        }
        public function setKey(string $key): void
        {
        }
        public static function create(string $value, ?string &$error = null): ?string
        {
        }
        public static function get(string $value, ?string &$error = null): ?string
        {
        }
    }
}
namespace edoc\utils\Uuid {
    class Uuid
    {
        /**
         * @throws \Exception
         */
        public static function Uuid4()
        {
        }
    }
}
namespace {
    /**
     * Short description
     *
     * Long description here...
     *
     * PHP version 7.x
     *
     * @category   CategoryName
     * @author     trproc
     * @copyright  2023 edoc solutions ag
     * @license    proprietary
     * @link       https://edoc.de
     */
    class CredentialsTest extends \PHPUnit\Framework\TestCase
    {
        public function testCreate(): void
        {
        }
    }
    /**
     * Short description
     *
     * Long description here...
     *
     * PHP version 7.x
     *
     * @category   CategoryName
     * @author     trproc
     * @copyright  2023 edoc solutions ag
     * @license    proprietary
     * @link       https://edoc.de
     */
    class CryptTest extends \PHPUnit\Framework\TestCase
    {
        function testEncryptAndDecrypt(): void
        {
        }
    }
    /**
     * Short description
     *
     * Long description here...
     *
     * PHP version 7.x
     *
     * @category   CategoryName
     * @author     trproc
     * @copyright  2022 edoc solutions ag
     * @license    proprietary
     * @link       https://edoc.de
     */
    class UuidTest extends \PHPUnit\Framework\TestCase
    {
        public function testGenearteUuid4(): void
        {
        }
    }
}
namespace Firebase\JWT {
    interface JWTExceptionWithPayloadInterface
    {
        /**
         * Get the payload that caused this exception.
         *
         * @return object
         */
        public function getPayload(): object;
        /**
         * Get the payload that caused this exception.
         *
         * @param object $payload
         * @return void
         */
        public function setPayload(object $payload): void;
    }
    class BeforeValidException extends \UnexpectedValueException implements \Firebase\JWT\JWTExceptionWithPayloadInterface
    {
        public function setPayload(object $payload): void
        {
        }
        public function getPayload(): object
        {
        }
    }
    /**
     * @implements ArrayAccess<string, Key>
     */
    class CachedKeySet implements \ArrayAccess
    {
        public function __construct(string $jwksUri, \Psr\Http\Client\ClientInterface $httpClient, \Psr\Http\Message\RequestFactoryInterface $httpFactory, \Psr\Cache\CacheItemPoolInterface $cache, ?int $expiresAfter = null, bool $rateLimit = false, ?string $defaultAlg = null)
        {
        }
        /**
         * @param string $keyId
         * @return Key
         */
        public function offsetGet($keyId): \Firebase\JWT\Key
        {
        }
        /**
         * @param string $keyId
         * @return bool
         */
        public function offsetExists($keyId): bool
        {
        }
        /**
         * @param string $offset
         * @param Key $value
         */
        public function offsetSet($offset, $value): void
        {
        }
        /**
         * @param string $offset
         */
        public function offsetUnset($offset): void
        {
        }
    }
    class ExpiredException extends \UnexpectedValueException implements \Firebase\JWT\JWTExceptionWithPayloadInterface
    {
        public function setPayload(object $payload): void
        {
        }
        public function getPayload(): object
        {
        }
    }
    /**
     * JSON Web Key implementation, based on this spec:
     * https://tools.ietf.org/html/draft-ietf-jose-json-web-key-41
     *
     * PHP version 5
     *
     * @category Authentication
     * @package  Authentication_JWT
     * @author   Bui Sy Nguyen <nguyenbs@gmail.com>
     * @license  http://opensource.org/licenses/BSD-3-Clause 3-clause BSD
     * @link     https://github.com/firebase/php-jwt
     */
    class JWK
    {
        /**
         * Parse a set of JWK keys
         *
         * @param array<mixed> $jwks The JSON Web Key Set as an associative array
         * @param string       $defaultAlg The algorithm for the Key object if "alg" is not set in the
         *                                 JSON Web Key Set
         *
         * @return array<string, Key> An associative array of key IDs (kid) to Key objects
         *
         * @throws InvalidArgumentException     Provided JWK Set is empty
         * @throws UnexpectedValueException     Provided JWK Set was invalid
         * @throws DomainException              OpenSSL failure
         *
         * @uses parseKey
         */
        public static function parseKeySet(array $jwks, ?string $defaultAlg = null): array
        {
        }
        /**
         * Parse a JWK key
         *
         * @param array<mixed> $jwk An individual JWK
         * @param string       $defaultAlg The algorithm for the Key object if "alg" is not set in the
         *                                 JSON Web Key Set
         *
         * @return Key The key object for the JWK
         *
         * @throws InvalidArgumentException     Provided JWK is empty
         * @throws UnexpectedValueException     Provided JWK was invalid
         * @throws DomainException              OpenSSL failure
         *
         * @uses createPemFromModulusAndExponent
         */
        public static function parseKey(array $jwk, ?string $defaultAlg = null): ?\Firebase\JWT\Key
        {
        }
    }
    /**
     * JSON Web Token implementation, based on this spec:
     * https://tools.ietf.org/html/rfc7519
     *
     * PHP version 5
     *
     * @category Authentication
     * @package  Authentication_JWT
     * @author   Neuman Vong <neuman@twilio.com>
     * @author   Anant Narayanan <anant@php.net>
     * @license  http://opensource.org/licenses/BSD-3-Clause 3-clause BSD
     * @link     https://github.com/firebase/php-jwt
     */
    class JWT
    {
        /**
         * When checking nbf, iat or expiration times,
         * we want to provide some extra leeway time to
         * account for clock skew.
         *
         * @var int
         */
        public static $leeway = 0;
        /**
         * Allow the current timestamp to be specified.
         * Useful for fixing a value within unit testing.
         * Will default to PHP time() value if null.
         *
         * @var ?int
         */
        public static $timestamp = null;
        /**
         * @var array<string, string[]>
         */
        public static $supported_algs = ['ES384' => ['openssl', 'SHA384'], 'ES256' => ['openssl', 'SHA256'], 'ES256K' => ['openssl', 'SHA256'], 'HS256' => ['hash_hmac', 'SHA256'], 'HS384' => ['hash_hmac', 'SHA384'], 'HS512' => ['hash_hmac', 'SHA512'], 'RS256' => ['openssl', 'SHA256'], 'RS384' => ['openssl', 'SHA384'], 'RS512' => ['openssl', 'SHA512'], 'EdDSA' => ['sodium_crypto', 'EdDSA']];
        /**
         * Decodes a JWT string into a PHP object.
         *
         * @param string                 $jwt            The JWT
         * @param Key|ArrayAccess<string,Key>|array<string,Key> $keyOrKeyArray  The Key or associative array of key IDs
         *                                                                      (kid) to Key objects.
         *                                                                      If the algorithm used is asymmetric, this is
         *                                                                      the public key.
         *                                                                      Each Key object contains an algorithm and
         *                                                                      matching key.
         *                                                                      Supported algorithms are 'ES384','ES256',
         *                                                                      'HS256', 'HS384', 'HS512', 'RS256', 'RS384'
         *                                                                      and 'RS512'.
         * @param stdClass               $headers                               Optional. Populates stdClass with headers.
         *
         * @return stdClass The JWT's payload as a PHP object
         *
         * @throws InvalidArgumentException     Provided key/key-array was empty or malformed
         * @throws DomainException              Provided JWT is malformed
         * @throws UnexpectedValueException     Provided JWT was invalid
         * @throws SignatureInvalidException    Provided JWT was invalid because the signature verification failed
         * @throws BeforeValidException         Provided JWT is trying to be used before it's eligible as defined by 'nbf'
         * @throws BeforeValidException         Provided JWT is trying to be used before it's been created as defined by 'iat'
         * @throws ExpiredException             Provided JWT has since expired, as defined by the 'exp' claim
         *
         * @uses jsonDecode
         * @uses urlsafeB64Decode
         */
        public static function decode(string $jwt, $keyOrKeyArray, ?\stdClass &$headers = null): \stdClass
        {
        }
        /**
         * Converts and signs a PHP array into a JWT string.
         *
         * @param array<mixed>          $payload PHP array
         * @param string|resource|OpenSSLAsymmetricKey|OpenSSLCertificate $key The secret key.
         * @param string                $alg     Supported algorithms are 'ES384','ES256', 'ES256K', 'HS256',
         *                                       'HS384', 'HS512', 'RS256', 'RS384', and 'RS512'
         * @param string                $keyId
         * @param array<string, string> $head    An array with header elements to attach
         *
         * @return string A signed JWT
         *
         * @uses jsonEncode
         * @uses urlsafeB64Encode
         */
        public static function encode(array $payload, $key, string $alg, ?string $keyId = null, ?array $head = null): string
        {
        }
        /**
         * Sign a string with a given key and algorithm.
         *
         * @param string $msg  The message to sign
         * @param string|resource|OpenSSLAsymmetricKey|OpenSSLCertificate  $key  The secret key.
         * @param string $alg  Supported algorithms are 'EdDSA', 'ES384', 'ES256', 'ES256K', 'HS256',
         *                    'HS384', 'HS512', 'RS256', 'RS384', and 'RS512'
         *
         * @return string An encrypted message
         *
         * @throws DomainException Unsupported algorithm or bad key was specified
         */
        public static function sign(string $msg, $key, string $alg): string
        {
        }
        /**
         * Decode a JSON string into a PHP object.
         *
         * @param string $input JSON string
         *
         * @return mixed The decoded JSON string
         *
         * @throws DomainException Provided string was invalid JSON
         */
        public static function jsonDecode(string $input)
        {
        }
        /**
         * Encode a PHP array into a JSON string.
         *
         * @param array<mixed> $input A PHP array
         *
         * @return string JSON representation of the PHP array
         *
         * @throws DomainException Provided object could not be encoded to valid JSON
         */
        public static function jsonEncode(array $input): string
        {
        }
        /**
         * Decode a string with URL-safe Base64.
         *
         * @param string $input A Base64 encoded string
         *
         * @return string A decoded string
         *
         * @throws InvalidArgumentException invalid base64 characters
         */
        public static function urlsafeB64Decode(string $input): string
        {
        }
        /**
         * Convert a string in the base64url (URL-safe Base64) encoding to standard base64.
         *
         * @param string $input A Base64 encoded string with URL-safe characters (-_ and no padding)
         *
         * @return string A Base64 encoded string with standard characters (+/) and padding (=), when
         * needed.
         *
         * @see https://www.rfc-editor.org/rfc/rfc4648
         */
        public static function convertBase64UrlToBase64(string $input): string
        {
        }
        /**
         * Encode a string with URL-safe Base64.
         *
         * @param string $input The string you want encoded
         *
         * @return string The base64 encode of what you passed in
         */
        public static function urlsafeB64Encode(string $input): string
        {
        }
        /**
         * @param string $left  The string of known length to compare against
         * @param string $right The user-supplied string
         * @return bool
         */
        public static function constantTimeEquals(string $left, string $right): bool
        {
        }
    }
    class Key
    {
        /**
         * @param string|resource|OpenSSLAsymmetricKey|OpenSSLCertificate $keyMaterial
         * @param string $algorithm
         */
        public function __construct(private $keyMaterial, private string $algorithm)
        {
        }
        /**
         * Return the algorithm valid for this key
         *
         * @return string
         */
        public function getAlgorithm(): string
        {
        }
        /**
         * @return string|resource|OpenSSLAsymmetricKey|OpenSSLCertificate
         */
        public function getKeyMaterial()
        {
        }
    }
    class SignatureInvalidException extends \UnexpectedValueException
    {
    }
}
namespace GuzzleHttp {
    interface BodySummarizerInterface
    {
        /**
         * Returns a summarized message body.
         */
        public function summarize(\Psr\Http\Message\MessageInterface $message): ?string;
    }
    final class BodySummarizer implements \GuzzleHttp\BodySummarizerInterface
    {
        public function __construct(?int $truncateAt = null)
        {
        }
        /**
         * Returns a summarized message body.
         */
        public function summarize(\Psr\Http\Message\MessageInterface $message): ?string
        {
        }
    }
    /**
     * Client interface for sending HTTP requests.
     */
    interface ClientInterface
    {
        /**
         * The Guzzle major version.
         */
        public const MAJOR_VERSION = 7;
        /**
         * Send an HTTP request.
         *
         * @param RequestInterface $request Request to send
         * @param array            $options Request options to apply to the given
         *                                  request and to the transfer.
         *
         * @throws GuzzleException
         */
        public function send(\Psr\Http\Message\RequestInterface $request, array $options = []): \Psr\Http\Message\ResponseInterface;
        /**
         * Asynchronously send an HTTP request.
         *
         * @param RequestInterface $request Request to send
         * @param array            $options Request options to apply to the given
         *                                  request and to the transfer.
         */
        public function sendAsync(\Psr\Http\Message\RequestInterface $request, array $options = []): \GuzzleHttp\Promise\PromiseInterface;
        /**
         * Create and send an HTTP request.
         *
         * Use an absolute path to override the base path of the client, or a
         * relative path to append to the base path of the client. The URL can
         * contain the query string as well.
         *
         * @param string              $method  HTTP method.
         * @param string|UriInterface $uri     URI object or string.
         * @param array               $options Request options to apply.
         *
         * @throws GuzzleException
         */
        public function request(string $method, $uri, array $options = []): \Psr\Http\Message\ResponseInterface;
        /**
         * Create and send an asynchronous HTTP request.
         *
         * Use an absolute path to override the base path of the client, or a
         * relative path to append to the base path of the client. The URL can
         * contain the query string as well. Use an array to provide a URL
         * template and additional variables to use in the URL template expansion.
         *
         * @param string              $method  HTTP method
         * @param string|UriInterface $uri     URI object or string.
         * @param array               $options Request options to apply.
         */
        public function requestAsync(string $method, $uri, array $options = []): \GuzzleHttp\Promise\PromiseInterface;
        /**
         * Get a client configuration option.
         *
         * These options include default request options of the client, a "handler"
         * (if utilized by the concrete client), and a "base_uri" if utilized by
         * the concrete client.
         *
         * @param string|null $option The config option to retrieve.
         *
         * @return mixed
         *
         * @deprecated ClientInterface::getConfig will be removed in guzzlehttp/guzzle:8.0.
         */
        public function getConfig(?string $option = null);
    }
}
namespace Psr\Http\Client {
    interface ClientInterface
    {
        /**
         * Sends a PSR-7 request and returns a PSR-7 response.
         *
         * @param RequestInterface $request
         *
         * @return ResponseInterface
         *
         * @throws \Psr\Http\Client\ClientExceptionInterface If an error happens while processing the request.
         */
        public function sendRequest(\Psr\Http\Message\RequestInterface $request): \Psr\Http\Message\ResponseInterface;
    }
}
namespace GuzzleHttp {
    /**
     * Client interface for sending HTTP requests.
     */
    trait ClientTrait
    {
        /**
         * Create and send an HTTP request.
         *
         * Use an absolute path to override the base path of the client, or a
         * relative path to append to the base path of the client. The URL can
         * contain the query string as well.
         *
         * @param string              $method  HTTP method.
         * @param string|UriInterface $uri     URI object or string.
         * @param array               $options Request options to apply.
         *
         * @throws GuzzleException
         */
        abstract public function request(string $method, $uri, array $options = []): \Psr\Http\Message\ResponseInterface;
        /**
         * Create and send an HTTP GET request.
         *
         * Use an absolute path to override the base path of the client, or a
         * relative path to append to the base path of the client. The URL can
         * contain the query string as well.
         *
         * @param string|UriInterface $uri     URI object or string.
         * @param array               $options Request options to apply.
         *
         * @throws GuzzleException
         */
        public function get($uri, array $options = []): \Psr\Http\Message\ResponseInterface
        {
        }
        /**
         * Create and send an HTTP HEAD request.
         *
         * Use an absolute path to override the base path of the client, or a
         * relative path to append to the base path of the client. The URL can
         * contain the query string as well.
         *
         * @param string|UriInterface $uri     URI object or string.
         * @param array               $options Request options to apply.
         *
         * @throws GuzzleException
         */
        public function head($uri, array $options = []): \Psr\Http\Message\ResponseInterface
        {
        }
        /**
         * Create and send an HTTP PUT request.
         *
         * Use an absolute path to override the base path of the client, or a
         * relative path to append to the base path of the client. The URL can
         * contain the query string as well.
         *
         * @param string|UriInterface $uri     URI object or string.
         * @param array               $options Request options to apply.
         *
         * @throws GuzzleException
         */
        public function put($uri, array $options = []): \Psr\Http\Message\ResponseInterface
        {
        }
        /**
         * Create and send an HTTP POST request.
         *
         * Use an absolute path to override the base path of the client, or a
         * relative path to append to the base path of the client. The URL can
         * contain the query string as well.
         *
         * @param string|UriInterface $uri     URI object or string.
         * @param array               $options Request options to apply.
         *
         * @throws GuzzleException
         */
        public function post($uri, array $options = []): \Psr\Http\Message\ResponseInterface
        {
        }
        /**
         * Create and send an HTTP PATCH request.
         *
         * Use an absolute path to override the base path of the client, or a
         * relative path to append to the base path of the client. The URL can
         * contain the query string as well.
         *
         * @param string|UriInterface $uri     URI object or string.
         * @param array               $options Request options to apply.
         *
         * @throws GuzzleException
         */
        public function patch($uri, array $options = []): \Psr\Http\Message\ResponseInterface
        {
        }
        /**
         * Create and send an HTTP DELETE request.
         *
         * Use an absolute path to override the base path of the client, or a
         * relative path to append to the base path of the client. The URL can
         * contain the query string as well.
         *
         * @param string|UriInterface $uri     URI object or string.
         * @param array               $options Request options to apply.
         *
         * @throws GuzzleException
         */
        public function delete($uri, array $options = []): \Psr\Http\Message\ResponseInterface
        {
        }
        /**
         * Create and send an asynchronous HTTP request.
         *
         * Use an absolute path to override the base path of the client, or a
         * relative path to append to the base path of the client. The URL can
         * contain the query string as well. Use an array to provide a URL
         * template and additional variables to use in the URL template expansion.
         *
         * @param string              $method  HTTP method
         * @param string|UriInterface $uri     URI object or string.
         * @param array               $options Request options to apply.
         */
        abstract public function requestAsync(string $method, $uri, array $options = []): \GuzzleHttp\Promise\PromiseInterface;
        /**
         * Create and send an asynchronous HTTP GET request.
         *
         * Use an absolute path to override the base path of the client, or a
         * relative path to append to the base path of the client. The URL can
         * contain the query string as well. Use an array to provide a URL
         * template and additional variables to use in the URL template expansion.
         *
         * @param string|UriInterface $uri     URI object or string.
         * @param array               $options Request options to apply.
         */
        public function getAsync($uri, array $options = []): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * Create and send an asynchronous HTTP HEAD request.
         *
         * Use an absolute path to override the base path of the client, or a
         * relative path to append to the base path of the client. The URL can
         * contain the query string as well. Use an array to provide a URL
         * template and additional variables to use in the URL template expansion.
         *
         * @param string|UriInterface $uri     URI object or string.
         * @param array               $options Request options to apply.
         */
        public function headAsync($uri, array $options = []): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * Create and send an asynchronous HTTP PUT request.
         *
         * Use an absolute path to override the base path of the client, or a
         * relative path to append to the base path of the client. The URL can
         * contain the query string as well. Use an array to provide a URL
         * template and additional variables to use in the URL template expansion.
         *
         * @param string|UriInterface $uri     URI object or string.
         * @param array               $options Request options to apply.
         */
        public function putAsync($uri, array $options = []): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * Create and send an asynchronous HTTP POST request.
         *
         * Use an absolute path to override the base path of the client, or a
         * relative path to append to the base path of the client. The URL can
         * contain the query string as well. Use an array to provide a URL
         * template and additional variables to use in the URL template expansion.
         *
         * @param string|UriInterface $uri     URI object or string.
         * @param array               $options Request options to apply.
         */
        public function postAsync($uri, array $options = []): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * Create and send an asynchronous HTTP PATCH request.
         *
         * Use an absolute path to override the base path of the client, or a
         * relative path to append to the base path of the client. The URL can
         * contain the query string as well. Use an array to provide a URL
         * template and additional variables to use in the URL template expansion.
         *
         * @param string|UriInterface $uri     URI object or string.
         * @param array               $options Request options to apply.
         */
        public function patchAsync($uri, array $options = []): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * Create and send an asynchronous HTTP DELETE request.
         *
         * Use an absolute path to override the base path of the client, or a
         * relative path to append to the base path of the client. The URL can
         * contain the query string as well. Use an array to provide a URL
         * template and additional variables to use in the URL template expansion.
         *
         * @param string|UriInterface $uri     URI object or string.
         * @param array               $options Request options to apply.
         */
        public function deleteAsync($uri, array $options = []): \GuzzleHttp\Promise\PromiseInterface
        {
        }
    }
    /**
     * @final
     */
    class Client implements \GuzzleHttp\ClientInterface, \Psr\Http\Client\ClientInterface
    {
        use \GuzzleHttp\ClientTrait;
        /**
         * Clients accept an array of constructor parameters.
         *
         * Here's an example of creating a client using a base_uri and an array of
         * default request options to apply to each request:
         *
         *     $client = new Client([
         *         'base_uri'        => 'http://www.foo.com/1.0/',
         *         'timeout'         => 0,
         *         'allow_redirects' => false,
         *         'proxy'           => '192.168.16.1:10'
         *     ]);
         *
         * Client configuration settings include the following options:
         *
         * - handler: (callable) Function that transfers HTTP requests over the
         *   wire. The function is called with a Psr7\Http\Message\RequestInterface
         *   and array of transfer options, and must return a
         *   GuzzleHttp\Promise\PromiseInterface that is fulfilled with a
         *   Psr7\Http\Message\ResponseInterface on success.
         *   If no handler is provided, a default handler will be created
         *   that enables all of the request options below by attaching all of the
         *   default middleware to the handler.
         * - base_uri: (string|UriInterface) Base URI of the client that is merged
         *   into relative URIs. Can be a string or instance of UriInterface.
         * - **: any request option
         *
         * @param array $config Client configuration settings.
         *
         * @see RequestOptions for a list of available request options.
         */
        public function __construct(array $config = [])
        {
        }
        /**
         * @param string $method
         * @param array  $args
         *
         * @return PromiseInterface|ResponseInterface
         *
         * @deprecated Client::__call will be removed in guzzlehttp/guzzle:8.0.
         */
        public function __call($method, $args)
        {
        }
        /**
         * Asynchronously send an HTTP request.
         *
         * @param array $options Request options to apply to the given
         *                       request and to the transfer. See \GuzzleHttp\RequestOptions.
         */
        public function sendAsync(\Psr\Http\Message\RequestInterface $request, array $options = []): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * Send an HTTP request.
         *
         * @param array $options Request options to apply to the given
         *                       request and to the transfer. See \GuzzleHttp\RequestOptions.
         *
         * @throws GuzzleException
         */
        public function send(\Psr\Http\Message\RequestInterface $request, array $options = []): \Psr\Http\Message\ResponseInterface
        {
        }
        /**
         * The HttpClient PSR (PSR-18) specify this method.
         *
         * {@inheritDoc}
         */
        public function sendRequest(\Psr\Http\Message\RequestInterface $request): \Psr\Http\Message\ResponseInterface
        {
        }
        /**
         * Create and send an asynchronous HTTP request.
         *
         * Use an absolute path to override the base path of the client, or a
         * relative path to append to the base path of the client. The URL can
         * contain the query string as well. Use an array to provide a URL
         * template and additional variables to use in the URL template expansion.
         *
         * @param string              $method  HTTP method
         * @param string|UriInterface $uri     URI object or string.
         * @param array               $options Request options to apply. See \GuzzleHttp\RequestOptions.
         */
        public function requestAsync(string $method, $uri = '', array $options = []): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * Create and send an HTTP request.
         *
         * Use an absolute path to override the base path of the client, or a
         * relative path to append to the base path of the client. The URL can
         * contain the query string as well.
         *
         * @param string              $method  HTTP method.
         * @param string|UriInterface $uri     URI object or string.
         * @param array               $options Request options to apply. See \GuzzleHttp\RequestOptions.
         *
         * @throws GuzzleException
         */
        public function request(string $method, $uri = '', array $options = []): \Psr\Http\Message\ResponseInterface
        {
        }
        /**
         * Get a client configuration option.
         *
         * These options include default request options of the client, a "handler"
         * (if utilized by the concrete client), and a "base_uri" if utilized by
         * the concrete client.
         *
         * @param string|null $option The config option to retrieve.
         *
         * @return mixed
         *
         * @deprecated Client::getConfig will be removed in guzzlehttp/guzzle:8.0.
         */
        public function getConfig(?string $option = null)
        {
        }
    }
}
namespace GuzzleHttp\Cookie {
    /**
     * Stores HTTP cookies.
     *
     * It extracts cookies from HTTP requests, and returns them in HTTP responses.
     * CookieJarInterface instances automatically expire contained cookies when
     * necessary. Subclasses are also responsible for storing and retrieving
     * cookies from a file, database, etc.
     *
     * @see https://docs.python.org/2/library/cookielib.html Inspiration
     *
     * @extends \IteratorAggregate<SetCookie>
     */
    interface CookieJarInterface extends \Countable, \IteratorAggregate
    {
        /**
         * Create a request with added cookie headers.
         *
         * If no matching cookies are found in the cookie jar, then no Cookie
         * header is added to the request and the same request is returned.
         *
         * @param RequestInterface $request Request object to modify.
         *
         * @return RequestInterface returns the modified request.
         */
        public function withCookieHeader(\Psr\Http\Message\RequestInterface $request): \Psr\Http\Message\RequestInterface;
        /**
         * Extract cookies from an HTTP response and store them in the CookieJar.
         *
         * @param RequestInterface  $request  Request that was sent
         * @param ResponseInterface $response Response that was received
         */
        public function extractCookies(\Psr\Http\Message\RequestInterface $request, \Psr\Http\Message\ResponseInterface $response): void;
        /**
         * Sets a cookie in the cookie jar.
         *
         * @param SetCookie $cookie Cookie to set.
         *
         * @return bool Returns true on success or false on failure
         */
        public function setCookie(\GuzzleHttp\Cookie\SetCookie $cookie): bool;
        /**
         * Remove cookies currently held in the cookie jar.
         *
         * Invoking this method without arguments will empty the whole cookie jar.
         * If given a $domain argument only cookies belonging to that domain will
         * be removed. If given a $domain and $path argument, cookies belonging to
         * the specified path within that domain are removed. If given all three
         * arguments, then the cookie with the specified name, path and domain is
         * removed.
         *
         * @param string|null $domain Clears cookies matching a domain
         * @param string|null $path   Clears cookies matching a domain and path
         * @param string|null $name   Clears cookies matching a domain, path, and name
         */
        public function clear(?string $domain = null, ?string $path = null, ?string $name = null): void;
        /**
         * Discard all sessions cookies.
         *
         * Removes cookies that don't have an expire field or a have a discard
         * field set to true. To be called when the user agent shuts down according
         * to RFC 2965.
         */
        public function clearSessionCookies(): void;
        /**
         * Converts the cookie jar to an array.
         */
        public function toArray(): array;
    }
    /**
     * Cookie jar that stores cookies as an array
     */
    class CookieJar implements \GuzzleHttp\Cookie\CookieJarInterface
    {
        /**
         * @param bool  $strictMode  Set to true to throw exceptions when invalid
         *                           cookies are added to the cookie jar.
         * @param array $cookieArray Array of SetCookie objects or a hash of
         *                           arrays that can be used with the SetCookie
         *                           constructor
         */
        public function __construct(bool $strictMode = false, array $cookieArray = [])
        {
        }
        /**
         * Create a new Cookie jar from an associative array and domain.
         *
         * @param array  $cookies Cookies to create the jar from
         * @param string $domain  Domain to set the cookies to
         */
        public static function fromArray(array $cookies, string $domain): self
        {
        }
        /**
         * Evaluate if this cookie should be persisted to storage
         * that survives between requests.
         *
         * @param SetCookie $cookie              Being evaluated.
         * @param bool      $allowSessionCookies If we should persist session cookies
         */
        public static function shouldPersist(\GuzzleHttp\Cookie\SetCookie $cookie, bool $allowSessionCookies = false): bool
        {
        }
        /**
         * Finds and returns the cookie based on the name
         *
         * @param string $name cookie name to search for
         *
         * @return SetCookie|null cookie that was found or null if not found
         */
        public function getCookieByName(string $name): ?\GuzzleHttp\Cookie\SetCookie
        {
        }
        public function toArray(): array
        {
        }
        public function clear(?string $domain = null, ?string $path = null, ?string $name = null): void
        {
        }
        public function clearSessionCookies(): void
        {
        }
        public function setCookie(\GuzzleHttp\Cookie\SetCookie $cookie): bool
        {
        }
        public function count(): int
        {
        }
        /**
         * @return \ArrayIterator<int, SetCookie>
         */
        public function getIterator(): \ArrayIterator
        {
        }
        public function extractCookies(\Psr\Http\Message\RequestInterface $request, \Psr\Http\Message\ResponseInterface $response): void
        {
        }
        public function withCookieHeader(\Psr\Http\Message\RequestInterface $request): \Psr\Http\Message\RequestInterface
        {
        }
    }
    /**
     * Persists non-session cookies using a JSON formatted file
     */
    class FileCookieJar extends \GuzzleHttp\Cookie\CookieJar
    {
        /**
         * Create a new FileCookieJar object
         *
         * @param string $cookieFile          File to store the cookie data
         * @param bool   $storeSessionCookies Set to true to store session cookies
         *                                    in the cookie jar.
         *
         * @throws \RuntimeException if the file cannot be found or created
         */
        public function __construct(string $cookieFile, bool $storeSessionCookies = false)
        {
        }
        /**
         * Saves the file when shutting down
         */
        public function __destruct()
        {
        }
        /**
         * Saves the cookies to a file.
         *
         * @param string $filename File to save
         *
         * @throws \RuntimeException if the file cannot be found or created
         */
        public function save(string $filename): void
        {
        }
        /**
         * Load cookies from a JSON formatted file.
         *
         * Old cookies are kept unless overwritten by newly loaded ones.
         *
         * @param string $filename Cookie file to load.
         *
         * @throws \RuntimeException if the file cannot be loaded.
         */
        public function load(string $filename): void
        {
        }
    }
    /**
     * Persists cookies in the client session
     */
    class SessionCookieJar extends \GuzzleHttp\Cookie\CookieJar
    {
        /**
         * Create a new SessionCookieJar object
         *
         * @param string $sessionKey          Session key name to store the cookie
         *                                    data in session
         * @param bool   $storeSessionCookies Set to true to store session cookies
         *                                    in the cookie jar.
         */
        public function __construct(string $sessionKey, bool $storeSessionCookies = false)
        {
        }
        /**
         * Saves cookies to session when shutting down
         */
        public function __destruct()
        {
        }
        /**
         * Save cookies to the client session
         */
        public function save(): void
        {
        }
        /**
         * Load the contents of the client session into the data array
         */
        protected function load(): void
        {
        }
    }
    /**
     * Set-Cookie object
     */
    class SetCookie
    {
        /**
         * Create a new SetCookie object from a string.
         *
         * @param string $cookie Set-Cookie header string
         */
        public static function fromString(string $cookie): self
        {
        }
        /**
         * @param array $data Array of cookie data provided by a Cookie parser
         */
        public function __construct(array $data = [])
        {
        }
        public function __toString()
        {
        }
        public function toArray(): array
        {
        }
        /**
         * Get the cookie name.
         *
         * @return string
         */
        public function getName()
        {
        }
        /**
         * Set the cookie name.
         *
         * @param string $name Cookie name
         */
        public function setName($name): void
        {
        }
        /**
         * Get the cookie value.
         *
         * @return string|null
         */
        public function getValue()
        {
        }
        /**
         * Set the cookie value.
         *
         * @param string $value Cookie value
         */
        public function setValue($value): void
        {
        }
        /**
         * Get the domain.
         *
         * @return string|null
         */
        public function getDomain()
        {
        }
        /**
         * Set the domain of the cookie.
         *
         * @param string|null $domain
         */
        public function setDomain($domain): void
        {
        }
        /**
         * Get the path.
         *
         * @return string
         */
        public function getPath()
        {
        }
        /**
         * Set the path of the cookie.
         *
         * @param string $path Path of the cookie
         */
        public function setPath($path): void
        {
        }
        /**
         * Maximum lifetime of the cookie in seconds.
         *
         * @return int|null
         */
        public function getMaxAge()
        {
        }
        /**
         * Set the max-age of the cookie.
         *
         * @param int|null $maxAge Max age of the cookie in seconds
         */
        public function setMaxAge($maxAge): void
        {
        }
        /**
         * The UNIX timestamp when the cookie Expires.
         *
         * @return string|int|null
         */
        public function getExpires()
        {
        }
        /**
         * Set the unix timestamp for which the cookie will expire.
         *
         * @param int|string|null $timestamp Unix timestamp or any English textual datetime description.
         */
        public function setExpires($timestamp): void
        {
        }
        /**
         * Get whether or not this is a secure cookie.
         *
         * @return bool
         */
        public function getSecure()
        {
        }
        /**
         * Set whether or not the cookie is secure.
         *
         * @param bool $secure Set to true or false if secure
         */
        public function setSecure($secure): void
        {
        }
        /**
         * Get whether or not this is a session cookie.
         *
         * @return bool|null
         */
        public function getDiscard()
        {
        }
        /**
         * Set whether or not this is a session cookie.
         *
         * @param bool $discard Set to true or false if this is a session cookie
         */
        public function setDiscard($discard): void
        {
        }
        /**
         * Get whether or not this is an HTTP only cookie.
         *
         * @return bool
         */
        public function getHttpOnly()
        {
        }
        /**
         * Set whether or not this is an HTTP only cookie.
         *
         * @param bool $httpOnly Set to true or false if this is HTTP only
         */
        public function setHttpOnly($httpOnly): void
        {
        }
        /**
         * Check if the cookie matches a path value.
         *
         * A request-path path-matches a given cookie-path if at least one of
         * the following conditions holds:
         *
         * - The cookie-path and the request-path are identical.
         * - The cookie-path is a prefix of the request-path, and the last
         *   character of the cookie-path is %x2F ("/").
         * - The cookie-path is a prefix of the request-path, and the first
         *   character of the request-path that is not included in the cookie-
         *   path is a %x2F ("/") character.
         *
         * @param string $requestPath Path to check against
         */
        public function matchesPath(string $requestPath): bool
        {
        }
        /**
         * Check if the cookie matches a domain value.
         *
         * @param string $domain Domain to check against
         */
        public function matchesDomain(string $domain): bool
        {
        }
        /**
         * Check if the cookie is expired.
         */
        public function isExpired(): bool
        {
        }
        /**
         * Check if the cookie is valid according to RFC 6265.
         *
         * @return bool|string Returns true if valid or an error message if invalid
         */
        public function validate()
        {
        }
    }
}
namespace Psr\Http\Client {
    /**
     * Every HTTP client related exception MUST implement this interface.
     */
    interface ClientExceptionInterface extends \Throwable
    {
    }
    /**
     * Exception for when a request failed.
     *
     * Examples:
     *      - Request is invalid (e.g. method is missing)
     *      - Runtime request errors (e.g. the body stream is not seekable)
     */
    interface RequestExceptionInterface extends \Psr\Http\Client\ClientExceptionInterface
    {
        /**
         * Returns the request.
         *
         * The request object MAY be a different object from the one passed to ClientInterface::sendRequest()
         *
         * @return RequestInterface
         */
        public function getRequest(): \Psr\Http\Message\RequestInterface;
    }
}
namespace GuzzleHttp\Exception {
    interface GuzzleException extends \Psr\Http\Client\ClientExceptionInterface
    {
    }
    class TransferException extends \RuntimeException implements \GuzzleHttp\Exception\GuzzleException
    {
    }
    /**
     * HTTP Request exception
     */
    class RequestException extends \GuzzleHttp\Exception\TransferException implements \Psr\Http\Client\RequestExceptionInterface
    {
        public function __construct(string $message, \Psr\Http\Message\RequestInterface $request, ?\Psr\Http\Message\ResponseInterface $response = null, ?\Throwable $previous = null, array $handlerContext = [])
        {
        }
        /**
         * Wrap non-RequestExceptions with a RequestException
         */
        public static function wrapException(\Psr\Http\Message\RequestInterface $request, \Throwable $e): \GuzzleHttp\Exception\RequestException
        {
        }
        /**
         * Factory method to create a new exception with a normalized error message
         *
         * @param RequestInterface             $request        Request sent
         * @param ResponseInterface            $response       Response received
         * @param \Throwable|null              $previous       Previous exception
         * @param array                        $handlerContext Optional handler context
         * @param BodySummarizerInterface|null $bodySummarizer Optional body summarizer
         */
        public static function create(\Psr\Http\Message\RequestInterface $request, ?\Psr\Http\Message\ResponseInterface $response = null, ?\Throwable $previous = null, array $handlerContext = [], ?\GuzzleHttp\BodySummarizerInterface $bodySummarizer = null): self
        {
        }
        /**
         * Get the request that caused the exception
         */
        public function getRequest(): \Psr\Http\Message\RequestInterface
        {
        }
        /**
         * Get the associated response
         */
        public function getResponse(): ?\Psr\Http\Message\ResponseInterface
        {
        }
        /**
         * Check if a response was received
         */
        public function hasResponse(): bool
        {
        }
        /**
         * Get contextual information about the error from the underlying handler.
         *
         * The contents of this array will vary depending on which handler you are
         * using. It may also be just an empty array. Relying on this data will
         * couple you to a specific handler, but can give more debug information
         * when needed.
         */
        public function getHandlerContext(): array
        {
        }
    }
    /**
     * Exception when an HTTP error occurs (4xx or 5xx error)
     */
    class BadResponseException extends \GuzzleHttp\Exception\RequestException
    {
        public function __construct(string $message, \Psr\Http\Message\RequestInterface $request, \Psr\Http\Message\ResponseInterface $response, ?\Throwable $previous = null, array $handlerContext = [])
        {
        }
        /**
         * Current exception and the ones that extend it will always have a response.
         */
        public function hasResponse(): bool
        {
        }
        /**
         * This function narrows the return type from the parent class and does not allow it to be nullable.
         */
        public function getResponse(): \Psr\Http\Message\ResponseInterface
        {
        }
    }
    /**
     * Exception when a client error is encountered (4xx codes)
     */
    class ClientException extends \GuzzleHttp\Exception\BadResponseException
    {
    }
}
namespace Psr\Http\Client {
    /**
     * Thrown when the request cannot be completed because of network issues.
     *
     * There is no response object as this exception is thrown when no response has been received.
     *
     * Example: the target host name can not be resolved or the connection failed.
     */
    interface NetworkExceptionInterface extends \Psr\Http\Client\ClientExceptionInterface
    {
        /**
         * Returns the request.
         *
         * The request object MAY be a different object from the one passed to ClientInterface::sendRequest()
         *
         * @return RequestInterface
         */
        public function getRequest(): \Psr\Http\Message\RequestInterface;
    }
}
namespace GuzzleHttp\Exception {
    /**
     * Exception thrown when a connection cannot be established.
     *
     * Note that no response is present for a ConnectException
     */
    class ConnectException extends \GuzzleHttp\Exception\TransferException implements \Psr\Http\Client\NetworkExceptionInterface
    {
        public function __construct(string $message, \Psr\Http\Message\RequestInterface $request, ?\Throwable $previous = null, array $handlerContext = [])
        {
        }
        /**
         * Get the request that caused the exception
         */
        public function getRequest(): \Psr\Http\Message\RequestInterface
        {
        }
        /**
         * Get contextual information about the error from the underlying handler.
         *
         * The contents of this array will vary depending on which handler you are
         * using. It may also be just an empty array. Relying on this data will
         * couple you to a specific handler, but can give more debug information
         * when needed.
         */
        public function getHandlerContext(): array
        {
        }
    }
    final class InvalidArgumentException extends \InvalidArgumentException implements \GuzzleHttp\Exception\GuzzleException
    {
    }
    /**
     * Exception when a server error is encountered (5xx codes)
     */
    class ServerException extends \GuzzleHttp\Exception\BadResponseException
    {
    }
    class TooManyRedirectsException extends \GuzzleHttp\Exception\RequestException
    {
    }
}
namespace GuzzleHttp\Handler {
    interface CurlFactoryInterface
    {
        /**
         * Creates a cURL handle resource.
         *
         * @param RequestInterface $request Request
         * @param array            $options Transfer options
         *
         * @throws \RuntimeException when an option cannot be applied
         */
        public function create(\Psr\Http\Message\RequestInterface $request, array $options): \GuzzleHttp\Handler\EasyHandle;
        /**
         * Release an easy handle, allowing it to be reused or closed.
         *
         * This function must call unset on the easy handle's "handle" property.
         */
        public function release(\GuzzleHttp\Handler\EasyHandle $easy): void;
    }
    /**
     * Creates curl resources from a request
     *
     * @final
     */
    class CurlFactory implements \GuzzleHttp\Handler\CurlFactoryInterface
    {
        public const CURL_VERSION_STR = 'curl_version';
        /**
         * @deprecated
         */
        public const LOW_CURL_VERSION_NUMBER = '7.21.2';
        /**
         * @param int $maxHandles Maximum number of idle handles.
         */
        public function __construct(int $maxHandles)
        {
        }
        public function create(\Psr\Http\Message\RequestInterface $request, array $options): \GuzzleHttp\Handler\EasyHandle
        {
        }
        public function release(\GuzzleHttp\Handler\EasyHandle $easy): void
        {
        }
        /**
         * Completes a cURL transaction, either returning a response promise or a
         * rejected promise.
         *
         * @param callable(RequestInterface, array): PromiseInterface $handler
         * @param CurlFactoryInterface                                $factory Dictates how the handle is released
         */
        public static function finish(callable $handler, \GuzzleHttp\Handler\EasyHandle $easy, \GuzzleHttp\Handler\CurlFactoryInterface $factory): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        public function __destruct()
        {
        }
    }
    /**
     * HTTP handler that uses cURL easy handles as a transport layer.
     *
     * When using the CurlHandler, custom curl options can be specified as an
     * associative array of curl option constants mapping to values in the
     * **curl** key of the "client" key of the request.
     *
     * @final
     */
    class CurlHandler
    {
        /**
         * Accepts an associative array of options:
         *
         * - handle_factory: Optional curl factory used to create cURL handles.
         *
         * @param array{handle_factory?: ?CurlFactoryInterface} $options Array of options to use with the handler
         */
        public function __construct(array $options = [])
        {
        }
        public function __invoke(\Psr\Http\Message\RequestInterface $request, array $options): \GuzzleHttp\Promise\PromiseInterface
        {
        }
    }
    /**
     * Returns an asynchronous response using curl_multi_* functions.
     *
     * When using the CurlMultiHandler, custom curl options can be specified as an
     * associative array of curl option constants mapping to values in the
     * **curl** key of the provided request options.
     *
     * @final
     */
    class CurlMultiHandler
    {
        /**
         * This handler accepts the following options:
         *
         * - handle_factory: An optional factory  used to create curl handles
         * - select_timeout: Optional timeout (in seconds) to block before timing
         *   out while selecting curl handles. Defaults to 1 second.
         * - options: An associative array of CURLMOPT_* options and
         *   corresponding values for curl_multi_setopt()
         */
        public function __construct(array $options = [])
        {
        }
        /**
         * @param string $name
         *
         * @return resource|\CurlMultiHandle
         *
         * @throws \BadMethodCallException when another field as `_mh` will be gotten
         * @throws \RuntimeException       when curl can not initialize a multi handle
         */
        public function __get($name)
        {
        }
        public function __destruct()
        {
        }
        public function __invoke(\Psr\Http\Message\RequestInterface $request, array $options): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * Ticks the curl event loop.
         */
        public function tick(): void
        {
        }
        /**
         * Runs until all outstanding connections have completed.
         */
        public function execute(): void
        {
        }
    }
    /**
     * Represents a cURL easy handle and the data it populates.
     *
     * @internal
     */
    final class EasyHandle
    {
        /**
         * @var resource|\CurlHandle cURL resource
         */
        public $handle;
        /**
         * @var StreamInterface Where data is being written
         */
        public $sink;
        /**
         * @var array Received HTTP headers so far
         */
        public $headers = [];
        /**
         * @var ResponseInterface|null Received response (if any)
         */
        public $response;
        /**
         * @var RequestInterface Request being sent
         */
        public $request;
        /**
         * @var array Request options
         */
        public $options = [];
        /**
         * @var int cURL error number (if any)
         */
        public $errno = 0;
        /**
         * @var \Throwable|null Exception during on_headers (if any)
         */
        public $onHeadersException;
        /**
         * @var \Exception|null Exception during createResponse (if any)
         */
        public $createResponseException;
        /**
         * Attach a response to the easy handle based on the received headers.
         *
         * @throws \RuntimeException if no headers have been received or the first
         *                           header line is invalid.
         */
        public function createResponse(): void
        {
        }
        /**
         * @param string $name
         *
         * @return void
         *
         * @throws \BadMethodCallException
         */
        public function __get($name)
        {
        }
    }
    /**
     * @internal
     */
    final class HeaderProcessor
    {
        /**
         * Returns the HTTP version, status code, reason phrase, and headers.
         *
         * @param string[] $headers
         *
         * @return array{0:string, 1:int, 2:?string, 3:array}
         *
         * @throws \RuntimeException
         */
        public static function parseHeaders(array $headers): array
        {
        }
    }
    /**
     * Handler that returns responses or throw exceptions from a queue.
     *
     * @final
     */
    class MockHandler implements \Countable
    {
        /**
         * Creates a new MockHandler that uses the default handler stack list of
         * middlewares.
         *
         * @param array|null    $queue       Array of responses, callables, or exceptions.
         * @param callable|null $onFulfilled Callback to invoke when the return value is fulfilled.
         * @param callable|null $onRejected  Callback to invoke when the return value is rejected.
         */
        public static function createWithMiddleware(?array $queue = null, ?callable $onFulfilled = null, ?callable $onRejected = null): \GuzzleHttp\HandlerStack
        {
        }
        /**
         * The passed in value must be an array of
         * {@see ResponseInterface} objects, Exceptions,
         * callables, or Promises.
         *
         * @param array<int, mixed>|null $queue       The parameters to be passed to the append function, as an indexed array.
         * @param callable|null          $onFulfilled Callback to invoke when the return value is fulfilled.
         * @param callable|null          $onRejected  Callback to invoke when the return value is rejected.
         */
        public function __construct(?array $queue = null, ?callable $onFulfilled = null, ?callable $onRejected = null)
        {
        }
        public function __invoke(\Psr\Http\Message\RequestInterface $request, array $options): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * Adds one or more variadic requests, exceptions, callables, or promises
         * to the queue.
         *
         * @param mixed ...$values
         */
        public function append(...$values): void
        {
        }
        /**
         * Get the last received request.
         */
        public function getLastRequest(): ?\Psr\Http\Message\RequestInterface
        {
        }
        /**
         * Get the last received request options.
         */
        public function getLastOptions(): array
        {
        }
        /**
         * Returns the number of remaining items in the queue.
         */
        public function count(): int
        {
        }
        public function reset(): void
        {
        }
    }
    /**
     * Provides basic proxies for handlers.
     *
     * @final
     */
    class Proxy
    {
        /**
         * Sends synchronous requests to a specific handler while sending all other
         * requests to another handler.
         *
         * @param callable(\Psr\Http\Message\RequestInterface, array): \GuzzleHttp\Promise\PromiseInterface $default Handler used for normal responses
         * @param callable(\Psr\Http\Message\RequestInterface, array): \GuzzleHttp\Promise\PromiseInterface $sync    Handler used for synchronous responses.
         *
         * @return callable(\Psr\Http\Message\RequestInterface, array): \GuzzleHttp\Promise\PromiseInterface Returns the composed handler.
         */
        public static function wrapSync(callable $default, callable $sync): callable
        {
        }
        /**
         * Sends streaming requests to a streaming compatible handler while sending
         * all other requests to a default handler.
         *
         * This, for example, could be useful for taking advantage of the
         * performance benefits of curl while still supporting true streaming
         * through the StreamHandler.
         *
         * @param callable(\Psr\Http\Message\RequestInterface, array): \GuzzleHttp\Promise\PromiseInterface $default   Handler used for non-streaming responses
         * @param callable(\Psr\Http\Message\RequestInterface, array): \GuzzleHttp\Promise\PromiseInterface $streaming Handler used for streaming responses
         *
         * @return callable(\Psr\Http\Message\RequestInterface, array): \GuzzleHttp\Promise\PromiseInterface Returns the composed handler.
         */
        public static function wrapStreaming(callable $default, callable $streaming): callable
        {
        }
    }
    /**
     * HTTP handler that uses PHP's HTTP stream wrapper.
     *
     * @final
     */
    class StreamHandler
    {
        /**
         * Sends an HTTP request.
         *
         * @param RequestInterface $request Request to send.
         * @param array            $options Request transfer options.
         */
        public function __invoke(\Psr\Http\Message\RequestInterface $request, array $options): \GuzzleHttp\Promise\PromiseInterface
        {
        }
    }
}
namespace GuzzleHttp {
    /**
     * Creates a composed Guzzle handler function by stacking middlewares on top of
     * an HTTP handler function.
     *
     * @final
     */
    class HandlerStack
    {
        /**
         * Creates a default handler stack that can be used by clients.
         *
         * The returned handler will wrap the provided handler or use the most
         * appropriate default handler for your system. The returned HandlerStack has
         * support for cookies, redirects, HTTP error exceptions, and preparing a body
         * before sending.
         *
         * The returned handler stack can be passed to a client in the "handler"
         * option.
         *
         * @param (callable(RequestInterface, array): PromiseInterface)|null $handler HTTP handler function to use with the stack. If no
         *                                                                            handler is provided, the best handler for your
         *                                                                            system will be utilized.
         */
        public static function create(?callable $handler = null): self
        {
        }
        /**
         * @param (callable(RequestInterface, array): PromiseInterface)|null $handler Underlying HTTP handler.
         */
        public function __construct(?callable $handler = null)
        {
        }
        /**
         * Invokes the handler stack as a composed handler
         *
         * @return ResponseInterface|PromiseInterface
         */
        public function __invoke(\Psr\Http\Message\RequestInterface $request, array $options)
        {
        }
        /**
         * Dumps a string representation of the stack.
         *
         * @return string
         */
        public function __toString()
        {
        }
        /**
         * Set the HTTP handler that actually returns a promise.
         *
         * @param callable(RequestInterface, array): PromiseInterface $handler Accepts a request and array of options and
         *                                                                     returns a Promise.
         */
        public function setHandler(callable $handler): void
        {
        }
        /**
         * Returns true if the builder has a handler.
         */
        public function hasHandler(): bool
        {
        }
        /**
         * Unshift a middleware to the bottom of the stack.
         *
         * @param callable(callable): callable $middleware Middleware function
         * @param string                       $name       Name to register for this middleware.
         */
        public function unshift(callable $middleware, ?string $name = null): void
        {
        }
        /**
         * Push a middleware to the top of the stack.
         *
         * @param callable(callable): callable $middleware Middleware function
         * @param string                       $name       Name to register for this middleware.
         */
        public function push(callable $middleware, string $name = ''): void
        {
        }
        /**
         * Add a middleware before another middleware by name.
         *
         * @param string                       $findName   Middleware to find
         * @param callable(callable): callable $middleware Middleware function
         * @param string                       $withName   Name to register for this middleware.
         */
        public function before(string $findName, callable $middleware, string $withName = ''): void
        {
        }
        /**
         * Add a middleware after another middleware by name.
         *
         * @param string                       $findName   Middleware to find
         * @param callable(callable): callable $middleware Middleware function
         * @param string                       $withName   Name to register for this middleware.
         */
        public function after(string $findName, callable $middleware, string $withName = ''): void
        {
        }
        /**
         * Remove a middleware by instance or name from the stack.
         *
         * @param callable|string $remove Middleware to remove by instance or name.
         */
        public function remove($remove): void
        {
        }
        /**
         * Compose the middleware and handler into a single callable function.
         *
         * @return callable(RequestInterface, array): PromiseInterface
         */
        public function resolve(): callable
        {
        }
    }
    interface MessageFormatterInterface
    {
        /**
         * Returns a formatted message string.
         *
         * @param RequestInterface       $request  Request that was sent
         * @param ResponseInterface|null $response Response that was received
         * @param \Throwable|null        $error    Exception that was received
         */
        public function format(\Psr\Http\Message\RequestInterface $request, ?\Psr\Http\Message\ResponseInterface $response = null, ?\Throwable $error = null): string;
    }
    /**
     * Formats log messages using variable substitutions for requests, responses,
     * and other transactional data.
     *
     * The following variable substitutions are supported:
     *
     * - {request}:        Full HTTP request message
     * - {response}:       Full HTTP response message
     * - {ts}:             ISO 8601 date in GMT
     * - {date_iso_8601}   ISO 8601 date in GMT
     * - {date_common_log} Apache common log date using the configured timezone.
     * - {host}:           Host of the request
     * - {method}:         Method of the request
     * - {uri}:            URI of the request
     * - {version}:        Protocol version
     * - {target}:         Request target of the request (path + query + fragment)
     * - {hostname}:       Hostname of the machine that sent the request
     * - {code}:           Status code of the response (if available)
     * - {phrase}:         Reason phrase of the response  (if available)
     * - {error}:          Any error messages (if available)
     * - {req_header_*}:   Replace `*` with the lowercased name of a request header to add to the message
     * - {res_header_*}:   Replace `*` with the lowercased name of a response header to add to the message
     * - {req_headers}:    Request headers
     * - {res_headers}:    Response headers
     * - {req_body}:       Request body
     * - {res_body}:       Response body
     *
     * @final
     */
    class MessageFormatter implements \GuzzleHttp\MessageFormatterInterface
    {
        /**
         * Apache Common Log Format.
         *
         * @see https://httpd.apache.org/docs/2.4/logs.html#common
         *
         * @var string
         */
        public const CLF = '{hostname} {req_header_User-Agent} - [{date_common_log}] "{method} {target} HTTP/{version}" {code} {res_header_Content-Length}';
        public const DEBUG = ">>>>>>>>\n{request}\n<<<<<<<<\n{response}\n--------\n{error}";
        public const SHORT = '[{ts}] "{method} {target} HTTP/{version}" {code}';
        /**
         * @param string $template Log message template
         */
        public function __construct(?string $template = self::CLF)
        {
        }
        /**
         * Returns a formatted message string.
         *
         * @param RequestInterface       $request  Request that was sent
         * @param ResponseInterface|null $response Response that was received
         * @param \Throwable|null        $error    Exception that was received
         */
        public function format(\Psr\Http\Message\RequestInterface $request, ?\Psr\Http\Message\ResponseInterface $response = null, ?\Throwable $error = null): string
        {
        }
    }
    /**
     * Functions used to create and wrap handlers with handler middleware.
     */
    final class Middleware
    {
        /**
         * Middleware that adds cookies to requests.
         *
         * The options array must be set to a CookieJarInterface in order to use
         * cookies. This is typically handled for you by a client.
         *
         * @return callable Returns a function that accepts the next handler.
         */
        public static function cookies(): callable
        {
        }
        /**
         * Middleware that throws exceptions for 4xx or 5xx responses when the
         * "http_errors" request option is set to true.
         *
         * @param BodySummarizerInterface|null $bodySummarizer The body summarizer to use in exception messages.
         *
         * @return callable(callable): callable Returns a function that accepts the next handler.
         */
        public static function httpErrors(?\GuzzleHttp\BodySummarizerInterface $bodySummarizer = null): callable
        {
        }
        /**
         * Middleware that pushes history data to an ArrayAccess container.
         *
         * @param array|\ArrayAccess<int, array> $container Container to hold the history (by reference).
         *
         * @return callable(callable): callable Returns a function that accepts the next handler.
         *
         * @throws \InvalidArgumentException if container is not an array or ArrayAccess.
         */
        public static function history(&$container): callable
        {
        }
        /**
         * Middleware that invokes a callback before and after sending a request.
         *
         * The provided listener cannot modify or alter the response. It simply
         * "taps" into the chain to be notified before returning the promise. The
         * before listener accepts a request and options array, and the after
         * listener accepts a request, options array, and response promise.
         *
         * @param callable $before Function to invoke before forwarding the request.
         * @param callable $after  Function invoked after forwarding.
         *
         * @return callable Returns a function that accepts the next handler.
         */
        public static function tap(?callable $before = null, ?callable $after = null): callable
        {
        }
        /**
         * Middleware that handles request redirects.
         *
         * @return callable Returns a function that accepts the next handler.
         */
        public static function redirect(): callable
        {
        }
        /**
         * Middleware that retries requests based on the boolean result of
         * invoking the provided "decider" function.
         *
         * If no delay function is provided, a simple implementation of exponential
         * backoff will be utilized.
         *
         * @param callable $decider Function that accepts the number of retries,
         *                          a request, [response], and [exception] and
         *                          returns true if the request is to be retried.
         * @param callable $delay   Function that accepts the number of retries and
         *                          returns the number of milliseconds to delay.
         *
         * @return callable Returns a function that accepts the next handler.
         */
        public static function retry(callable $decider, ?callable $delay = null): callable
        {
        }
        /**
         * Middleware that logs requests, responses, and errors using a message
         * formatter.
         *
         * @phpstan-param \Psr\Log\LogLevel::* $logLevel  Level at which to log requests.
         *
         * @param LoggerInterface                            $logger    Logs messages.
         * @param MessageFormatterInterface|MessageFormatter $formatter Formatter used to create message strings.
         * @param string                                     $logLevel  Level at which to log requests.
         *
         * @return callable Returns a function that accepts the next handler.
         */
        public static function log(\Psr\Log\LoggerInterface $logger, $formatter, string $logLevel = 'info'): callable
        {
        }
        /**
         * This middleware adds a default content-type if possible, a default
         * content-length or transfer-encoding header, and the expect header.
         */
        public static function prepareBody(): callable
        {
        }
        /**
         * Middleware that applies a map function to the request before passing to
         * the next handler.
         *
         * @param callable $fn Function that accepts a RequestInterface and returns
         *                     a RequestInterface.
         */
        public static function mapRequest(callable $fn): callable
        {
        }
        /**
         * Middleware that applies a map function to the resolved promise's
         * response.
         *
         * @param callable $fn Function that accepts a ResponseInterface and
         *                     returns a ResponseInterface.
         */
        public static function mapResponse(callable $fn): callable
        {
        }
    }
}
namespace GuzzleHttp\Promise {
    /**
     * Interface used with classes that return a promise.
     */
    interface PromisorInterface
    {
        /**
         * Returns a promise.
         */
        public function promise(): \GuzzleHttp\Promise\PromiseInterface;
    }
}
namespace GuzzleHttp {
    /**
     * Sends an iterator of requests concurrently using a capped pool size.
     *
     * The pool will read from an iterator until it is cancelled or until the
     * iterator is consumed. When a request is yielded, the request is sent after
     * applying the "request_options" request options (if provided in the ctor).
     *
     * When a function is yielded by the iterator, the function is provided the
     * "request_options" array that should be merged on top of any existing
     * options, and the function MUST then return a wait-able promise.
     *
     * @final
     */
    class Pool implements \GuzzleHttp\Promise\PromisorInterface
    {
        /**
         * @param ClientInterface $client   Client used to send the requests.
         * @param array|\Iterator $requests Requests or functions that return
         *                                  requests to send concurrently.
         * @param array           $config   Associative array of options
         *                                  - concurrency: (int) Maximum number of requests to send concurrently
         *                                  - options: Array of request options to apply to each request.
         *                                  - fulfilled: (callable) Function to invoke when a request completes.
         *                                  - rejected: (callable) Function to invoke when a request is rejected.
         */
        public function __construct(\GuzzleHttp\ClientInterface $client, $requests, array $config = [])
        {
        }
        /**
         * Get promise
         */
        public function promise(): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * Sends multiple requests concurrently and returns an array of responses
         * and exceptions that uses the same ordering as the provided requests.
         *
         * IMPORTANT: This method keeps every request and response in memory, and
         * as such, is NOT recommended when sending a large number or an
         * indeterminate number of requests concurrently.
         *
         * @param ClientInterface $client   Client used to send the requests
         * @param array|\Iterator $requests Requests to send concurrently.
         * @param array           $options  Passes through the options available in
         *                                  {@see \GuzzleHttp\Pool::__construct}
         *
         * @return array Returns an array containing the response or an exception
         *               in the same order that the requests were sent.
         *
         * @throws \InvalidArgumentException if the event format is incorrect.
         */
        public static function batch(\GuzzleHttp\ClientInterface $client, $requests, array $options = []): array
        {
        }
    }
    /**
     * Prepares requests that contain a body, adding the Content-Length,
     * Content-Type, and Expect headers.
     *
     * @final
     */
    class PrepareBodyMiddleware
    {
        /**
         * @param callable(RequestInterface, array): PromiseInterface $nextHandler Next handler to invoke.
         */
        public function __construct(callable $nextHandler)
        {
        }
        public function __invoke(\Psr\Http\Message\RequestInterface $request, array $options): \GuzzleHttp\Promise\PromiseInterface
        {
        }
    }
    /**
     * Request redirect middleware.
     *
     * Apply this middleware like other middleware using
     * {@see \GuzzleHttp\Middleware::redirect()}.
     *
     * @final
     */
    class RedirectMiddleware
    {
        public const HISTORY_HEADER = 'X-Guzzle-Redirect-History';
        public const STATUS_HISTORY_HEADER = 'X-Guzzle-Redirect-Status-History';
        /**
         * @var array
         */
        public static $defaultSettings = ['max' => 5, 'protocols' => ['http', 'https'], 'strict' => false, 'referer' => false, 'track_redirects' => false];
        /**
         * @param callable(RequestInterface, array): PromiseInterface $nextHandler Next handler to invoke.
         */
        public function __construct(callable $nextHandler)
        {
        }
        public function __invoke(\Psr\Http\Message\RequestInterface $request, array $options): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * @return ResponseInterface|PromiseInterface
         */
        public function checkRedirect(\Psr\Http\Message\RequestInterface $request, array $options, \Psr\Http\Message\ResponseInterface $response)
        {
        }
        public function modifyRequest(\Psr\Http\Message\RequestInterface $request, array $options, \Psr\Http\Message\ResponseInterface $response): \Psr\Http\Message\RequestInterface
        {
        }
    }
    /**
     * This class contains a list of built-in Guzzle request options.
     *
     * @see https://docs.guzzlephp.org/en/latest/request-options.html
     */
    final class RequestOptions
    {
        /**
         * allow_redirects: (bool|array) Controls redirect behavior. Pass false
         * to disable redirects, pass true to enable redirects, pass an
         * associative to provide custom redirect settings. Defaults to "false".
         * This option only works if your handler has the RedirectMiddleware. When
         * passing an associative array, you can provide the following key value
         * pairs:
         *
         * - max: (int, default=5) maximum number of allowed redirects.
         * - strict: (bool, default=false) Set to true to use strict redirects
         *   meaning redirect POST requests with POST requests vs. doing what most
         *   browsers do which is redirect POST requests with GET requests
         * - referer: (bool, default=false) Set to true to enable the Referer
         *   header.
         * - protocols: (array, default=['http', 'https']) Allowed redirect
         *   protocols.
         * - on_redirect: (callable) PHP callable that is invoked when a redirect
         *   is encountered. The callable is invoked with the request, the redirect
         *   response that was received, and the effective URI. Any return value
         *   from the on_redirect function is ignored.
         */
        public const ALLOW_REDIRECTS = 'allow_redirects';
        /**
         * auth: (array) Pass an array of HTTP authentication parameters to use
         * with the request. The array must contain the username in index [0],
         * the password in index [1], and you can optionally provide a built-in
         * authentication type in index [2]. Pass null to disable authentication
         * for a request.
         */
        public const AUTH = 'auth';
        /**
         * body: (resource|string|null|int|float|StreamInterface|callable|\Iterator)
         * Body to send in the request.
         */
        public const BODY = 'body';
        /**
         * cert: (string|array) Set to a string to specify the path to a file
         * containing a PEM formatted SSL client side certificate. If a password
         * is required, then set cert to an array containing the path to the PEM
         * file in the first array element followed by the certificate password
         * in the second array element.
         */
        public const CERT = 'cert';
        /**
         * cookies: (bool|GuzzleHttp\Cookie\CookieJarInterface, default=false)
         * Specifies whether or not cookies are used in a request or what cookie
         * jar to use or what cookies to send. This option only works if your
         * handler has the `cookie` middleware. Valid values are `false` and
         * an instance of {@see Cookie\CookieJarInterface}.
         */
        public const COOKIES = 'cookies';
        /**
         * connect_timeout: (float, default=0) Float describing the number of
         * seconds to wait while trying to connect to a server. Use 0 to wait
         * 300 seconds (the default behavior).
         */
        public const CONNECT_TIMEOUT = 'connect_timeout';
        /**
         * crypto_method: (int) A value describing the minimum TLS protocol
         * version to use.
         *
         * This setting must be set to one of the
         * ``STREAM_CRYPTO_METHOD_TLS*_CLIENT`` constants. PHP 7.4 or higher is
         * required in order to use TLS 1.3, and cURL 7.34.0 or higher is required
         * in order to specify a crypto method, with cURL 7.52.0 or higher being
         * required to use TLS 1.3.
         */
        public const CRYPTO_METHOD = 'crypto_method';
        /**
         * debug: (bool|resource) Set to true or set to a PHP stream returned by
         * fopen()  enable debug output with the HTTP handler used to send a
         * request.
         */
        public const DEBUG = 'debug';
        /**
         * decode_content: (bool, default=true) Specify whether or not
         * Content-Encoding responses (gzip, deflate, etc.) are automatically
         * decoded.
         */
        public const DECODE_CONTENT = 'decode_content';
        /**
         * delay: (int) The amount of time to delay before sending in milliseconds.
         */
        public const DELAY = 'delay';
        /**
         * expect: (bool|integer) Controls the behavior of the
         * "Expect: 100-Continue" header.
         *
         * Set to `true` to enable the "Expect: 100-Continue" header for all
         * requests that sends a body. Set to `false` to disable the
         * "Expect: 100-Continue" header for all requests. Set to a number so that
         * the size of the payload must be greater than the number in order to send
         * the Expect header. Setting to a number will send the Expect header for
         * all requests in which the size of the payload cannot be determined or
         * where the body is not rewindable.
         *
         * By default, Guzzle will add the "Expect: 100-Continue" header when the
         * size of the body of a request is greater than 1 MB and a request is
         * using HTTP/1.1.
         */
        public const EXPECT = 'expect';
        /**
         * form_params: (array) Associative array of form field names to values
         * where each value is a string or array of strings. Sets the Content-Type
         * header to application/x-www-form-urlencoded when no Content-Type header
         * is already present.
         */
        public const FORM_PARAMS = 'form_params';
        /**
         * headers: (array) Associative array of HTTP headers. Each value MUST be
         * a string or array of strings.
         */
        public const HEADERS = 'headers';
        /**
         * http_errors: (bool, default=true) Set to false to disable exceptions
         * when a non- successful HTTP response is received. By default,
         * exceptions will be thrown for 4xx and 5xx responses. This option only
         * works if your handler has the `httpErrors` middleware.
         */
        public const HTTP_ERRORS = 'http_errors';
        /**
         * idn: (bool|int, default=true) A combination of IDNA_* constants for
         * idn_to_ascii() PHP's function (see "options" parameter). Set to false to
         * disable IDN support completely, or to true to use the default
         * configuration (IDNA_DEFAULT constant).
         */
        public const IDN_CONVERSION = 'idn_conversion';
        /**
         * json: (mixed) Adds JSON data to a request. The provided value is JSON
         * encoded and a Content-Type header of application/json will be added to
         * the request if no Content-Type header is already present.
         */
        public const JSON = 'json';
        /**
         * multipart: (array) Array of associative arrays, each containing a
         * required "name" key mapping to the form field, name, a required
         * "contents" key mapping to a StreamInterface|resource|string, an
         * optional "headers" associative array of custom headers, and an
         * optional "filename" key mapping to a string to send as the filename in
         * the part. If no "filename" key is present, then no "filename" attribute
         * will be added to the part.
         */
        public const MULTIPART = 'multipart';
        /**
         * on_headers: (callable) A callable that is invoked when the HTTP headers
         * of the response have been received but the body has not yet begun to
         * download.
         */
        public const ON_HEADERS = 'on_headers';
        /**
         * on_stats: (callable) allows you to get access to transfer statistics of
         * a request and access the lower level transfer details of the handler
         * associated with your client. ``on_stats`` is a callable that is invoked
         * when a handler has finished sending a request. The callback is invoked
         * with transfer statistics about the request, the response received, or
         * the error encountered. Included in the data is the total amount of time
         * taken to send the request.
         */
        public const ON_STATS = 'on_stats';
        /**
         * progress: (callable) Defines a function to invoke when transfer
         * progress is made. The function accepts the following positional
         * arguments: the total number of bytes expected to be downloaded, the
         * number of bytes downloaded so far, the number of bytes expected to be
         * uploaded, the number of bytes uploaded so far.
         */
        public const PROGRESS = 'progress';
        /**
         * proxy: (string|array) Pass a string to specify an HTTP proxy, or an
         * array to specify different proxies for different protocols (where the
         * key is the protocol and the value is a proxy string).
         */
        public const PROXY = 'proxy';
        /**
         * query: (array|string) Associative array of query string values to add
         * to the request. This option uses PHP's http_build_query() to create
         * the string representation. Pass a string value if you need more
         * control than what this method provides
         */
        public const QUERY = 'query';
        /**
         * sink: (resource|string|StreamInterface) Where the data of the
         * response is written to. Defaults to a PHP temp stream. Providing a
         * string will write data to a file by the given name.
         */
        public const SINK = 'sink';
        /**
         * synchronous: (bool) Set to true to inform HTTP handlers that you intend
         * on waiting on the response. This can be useful for optimizations. Note
         * that a promise is still returned if you are using one of the async
         * client methods.
         */
        public const SYNCHRONOUS = 'synchronous';
        /**
         * ssl_key: (array|string) Specify the path to a file containing a private
         * SSL key in PEM format. If a password is required, then set to an array
         * containing the path to the SSL key in the first array element followed
         * by the password required for the certificate in the second element.
         */
        public const SSL_KEY = 'ssl_key';
        /**
         * stream: Set to true to attempt to stream a response rather than
         * download it all up-front.
         */
        public const STREAM = 'stream';
        /**
         * verify: (bool|string, default=true) Describes the SSL certificate
         * verification behavior of a request. Set to true to enable SSL
         * certificate verification using the system CA bundle when available
         * (the default). Set to false to disable certificate verification (this
         * is insecure!). Set to a string to provide the path to a CA bundle on
         * disk to enable verification using a custom certificate.
         */
        public const VERIFY = 'verify';
        /**
         * timeout: (float, default=0) Float describing the timeout of the
         * request in seconds. Use 0 to wait indefinitely (the default behavior).
         */
        public const TIMEOUT = 'timeout';
        /**
         * read_timeout: (float, default=default_socket_timeout ini setting) Float describing
         * the body read timeout, for stream requests.
         */
        public const READ_TIMEOUT = 'read_timeout';
        /**
         * version: (float) Specifies the HTTP protocol version to attempt to use.
         */
        public const VERSION = 'version';
        /**
         * force_ip_resolve: (bool) Force client to use only ipv4 or ipv6 protocol
         */
        public const FORCE_IP_RESOLVE = 'force_ip_resolve';
    }
    /**
     * Middleware that retries requests based on the boolean result of
     * invoking the provided "decider" function.
     *
     * @final
     */
    class RetryMiddleware
    {
        /**
         * @param callable                                            $decider     Function that accepts the number of retries,
         *                                                                         a request, [response], and [exception] and
         *                                                                         returns true if the request is to be
         *                                                                         retried.
         * @param callable(RequestInterface, array): PromiseInterface $nextHandler Next handler to invoke.
         * @param (callable(int): int)|null                           $delay       Function that accepts the number of retries
         *                                                                         and returns the number of
         *                                                                         milliseconds to delay.
         */
        public function __construct(callable $decider, callable $nextHandler, ?callable $delay = null)
        {
        }
        /**
         * Default exponential backoff delay function.
         *
         * @return int milliseconds.
         */
        public static function exponentialDelay(int $retries): int
        {
        }
        public function __invoke(\Psr\Http\Message\RequestInterface $request, array $options): \GuzzleHttp\Promise\PromiseInterface
        {
        }
    }
    /**
     * Represents data at the point after it was transferred either successfully
     * or after a network error.
     */
    final class TransferStats
    {
        /**
         * @param RequestInterface       $request          Request that was sent.
         * @param ResponseInterface|null $response         Response received (if any)
         * @param float|null             $transferTime     Total handler transfer time.
         * @param mixed                  $handlerErrorData Handler error data.
         * @param array                  $handlerStats     Handler specific stats.
         */
        public function __construct(\Psr\Http\Message\RequestInterface $request, ?\Psr\Http\Message\ResponseInterface $response = null, ?float $transferTime = null, $handlerErrorData = null, array $handlerStats = [])
        {
        }
        public function getRequest(): \Psr\Http\Message\RequestInterface
        {
        }
        /**
         * Returns the response that was received (if any).
         */
        public function getResponse(): ?\Psr\Http\Message\ResponseInterface
        {
        }
        /**
         * Returns true if a response was received.
         */
        public function hasResponse(): bool
        {
        }
        /**
         * Gets handler specific error data.
         *
         * This might be an exception, a integer representing an error code, or
         * anything else. Relying on this value assumes that you know what handler
         * you are using.
         *
         * @return mixed
         */
        public function getHandlerErrorData()
        {
        }
        /**
         * Get the effective URI the request was sent to.
         */
        public function getEffectiveUri(): \Psr\Http\Message\UriInterface
        {
        }
        /**
         * Get the estimated time the request was being transferred by the handler.
         *
         * @return float|null Time in seconds.
         */
        public function getTransferTime(): ?float
        {
        }
        /**
         * Gets an array of all of the handler specific transfer data.
         */
        public function getHandlerStats(): array
        {
        }
        /**
         * Get a specific handler statistic from the handler by name.
         *
         * @param string $stat Handler specific transfer stat to retrieve.
         *
         * @return mixed|null
         */
        public function getHandlerStat(string $stat)
        {
        }
    }
    final class Utils
    {
        /**
         * Debug function used to describe the provided value type and class.
         *
         * @param mixed $input
         *
         * @return string Returns a string containing the type of the variable and
         *                if a class is provided, the class name.
         */
        public static function describeType($input): string
        {
        }
        /**
         * Parses an array of header lines into an associative array of headers.
         *
         * @param iterable $lines Header lines array of strings in the following
         *                        format: "Name: Value"
         */
        public static function headersFromLines(iterable $lines): array
        {
        }
        /**
         * Returns a debug stream based on the provided variable.
         *
         * @param mixed $value Optional value
         *
         * @return resource
         */
        public static function debugResource($value = null)
        {
        }
        /**
         * Chooses and creates a default handler to use based on the environment.
         *
         * The returned handler is not wrapped by any default middlewares.
         *
         * @return callable(\Psr\Http\Message\RequestInterface, array): \GuzzleHttp\Promise\PromiseInterface Returns the best handler for the given system.
         *
         * @throws \RuntimeException if no viable Handler is available.
         */
        public static function chooseHandler(): callable
        {
        }
        /**
         * Get the default User-Agent string to use with Guzzle.
         */
        public static function defaultUserAgent(): string
        {
        }
        /**
         * Returns the default cacert bundle for the current system.
         *
         * First, the openssl.cafile and curl.cainfo php.ini settings are checked.
         * If those settings are not configured, then the common locations for
         * bundles found on Red Hat, CentOS, Fedora, Ubuntu, Debian, FreeBSD, OS X
         * and Windows are checked. If any of these file locations are found on
         * disk, they will be utilized.
         *
         * Note: the result of this function is cached for subsequent calls.
         *
         * @throws \RuntimeException if no bundle can be found.
         *
         * @deprecated Utils::defaultCaBundle will be removed in guzzlehttp/guzzle:8.0. This method is not needed in PHP 5.6+.
         */
        public static function defaultCaBundle(): string
        {
        }
        /**
         * Creates an associative array of lowercase header names to the actual
         * header casing.
         */
        public static function normalizeHeaderKeys(array $headers): array
        {
        }
        /**
         * Returns true if the provided host matches any of the no proxy areas.
         *
         * This method will strip a port from the host if it is present. Each pattern
         * can be matched with an exact match (e.g., "foo.com" == "foo.com") or a
         * partial match: (e.g., "foo.com" == "baz.foo.com" and ".foo.com" ==
         * "baz.foo.com", but ".foo.com" != "foo.com").
         *
         * Areas are matched in the following cases:
         * 1. "*" (without quotes) always matches any hosts.
         * 2. An exact match.
         * 3. The area starts with "." and the area is the last part of the host. e.g.
         *    '.mit.edu' will match any host that ends with '.mit.edu'.
         *
         * @param string   $host         Host to check against the patterns.
         * @param string[] $noProxyArray An array of host patterns.
         *
         * @throws InvalidArgumentException
         */
        public static function isHostInNoProxy(string $host, array $noProxyArray): bool
        {
        }
        /**
         * Wrapper for json_decode that throws when an error occurs.
         *
         * @param string $json    JSON data to parse
         * @param bool   $assoc   When true, returned objects will be converted
         *                        into associative arrays.
         * @param int    $depth   User specified recursion depth.
         * @param int    $options Bitmask of JSON decode options.
         *
         * @return object|array|string|int|float|bool|null
         *
         * @throws InvalidArgumentException if the JSON cannot be decoded.
         *
         * @see https://www.php.net/manual/en/function.json-decode.php
         */
        public static function jsonDecode(string $json, bool $assoc = false, int $depth = 512, int $options = 0)
        {
        }
        /**
         * Wrapper for JSON encoding that throws when an error occurs.
         *
         * @param mixed $value   The value being encoded
         * @param int   $options JSON encode option bitmask
         * @param int   $depth   Set the maximum depth. Must be greater than zero.
         *
         * @throws InvalidArgumentException if the JSON cannot be encoded.
         *
         * @see https://www.php.net/manual/en/function.json-encode.php
         */
        public static function jsonEncode($value, int $options = 0, int $depth = 512): string
        {
        }
        /**
         * Wrapper for the hrtime() or microtime() functions
         * (depending on the PHP version, one of the two is used)
         *
         * @return float UNIX timestamp
         *
         * @internal
         */
        public static function currentTime(): float
        {
        }
        /**
         * @throws InvalidArgumentException
         *
         * @internal
         */
        public static function idnUriConvert(\Psr\Http\Message\UriInterface $uri, int $options = 0): \Psr\Http\Message\UriInterface
        {
        }
        /**
         * @internal
         */
        public static function getenv(string $name): ?string
        {
        }
    }
}
namespace GuzzleHttp\Promise {
    /**
     * A special exception that is thrown when waiting on a rejected promise.
     *
     * The reason value is available via the getReason() method.
     */
    class RejectionException extends \RuntimeException
    {
        /**
         * @param mixed       $reason      Rejection reason.
         * @param string|null $description Optional description.
         */
        public function __construct($reason, ?string $description = null)
        {
        }
        /**
         * Returns the rejection reason.
         *
         * @return mixed
         */
        public function getReason()
        {
        }
    }
    /**
     * Exception thrown when too many errors occur in the some() or any() methods.
     */
    class AggregateException extends \GuzzleHttp\Promise\RejectionException
    {
        public function __construct(string $msg, array $reasons)
        {
        }
    }
    /**
     * Exception that is set as the reason for a promise that has been cancelled.
     */
    class CancellationException extends \GuzzleHttp\Promise\RejectionException
    {
    }
    /**
     * A promise represents the eventual result of an asynchronous operation.
     *
     * The primary way of interacting with a promise is through its then method,
     * which registers callbacks to receive either a promise’s eventual value or
     * the reason why the promise cannot be fulfilled.
     *
     * @see https://promisesaplus.com/
     */
    interface PromiseInterface
    {
        public const PENDING = 'pending';
        public const FULFILLED = 'fulfilled';
        public const REJECTED = 'rejected';
        /**
         * Appends fulfillment and rejection handlers to the promise, and returns
         * a new promise resolving to the return value of the called handler.
         *
         * @param callable $onFulfilled Invoked when the promise fulfills.
         * @param callable $onRejected  Invoked when the promise is rejected.
         */
        public function then(?callable $onFulfilled = null, ?callable $onRejected = null): \GuzzleHttp\Promise\PromiseInterface;
        /**
         * Appends a rejection handler callback to the promise, and returns a new
         * promise resolving to the return value of the callback if it is called,
         * or to its original fulfillment value if the promise is instead
         * fulfilled.
         *
         * @param callable $onRejected Invoked when the promise is rejected.
         */
        public function otherwise(callable $onRejected): \GuzzleHttp\Promise\PromiseInterface;
        /**
         * Get the state of the promise ("pending", "rejected", or "fulfilled").
         *
         * The three states can be checked against the constants defined on
         * PromiseInterface: PENDING, FULFILLED, and REJECTED.
         */
        public function getState(): string;
        /**
         * Resolve the promise with the given value.
         *
         * @param mixed $value
         *
         * @throws \RuntimeException if the promise is already resolved.
         */
        public function resolve($value): void;
        /**
         * Reject the promise with the given reason.
         *
         * @param mixed $reason
         *
         * @throws \RuntimeException if the promise is already resolved.
         */
        public function reject($reason): void;
        /**
         * Cancels the promise if possible.
         *
         * @see https://github.com/promises-aplus/cancellation-spec/issues/7
         */
        public function cancel(): void;
        /**
         * Waits until the promise completes if possible.
         *
         * Pass $unwrap as true to unwrap the result of the promise, either
         * returning the resolved value or throwing the rejected exception.
         *
         * If the promise cannot be waited on, then the promise will be rejected.
         *
         * @return mixed
         *
         * @throws \LogicException if the promise has no wait function or if the
         *                         promise does not settle after waiting.
         */
        public function wait(bool $unwrap = true);
    }
    /**
     * Creates a promise that is resolved using a generator that yields values or
     * promises (somewhat similar to C#'s async keyword).
     *
     * When called, the Coroutine::of method will start an instance of the generator
     * and returns a promise that is fulfilled with its final yielded value.
     *
     * Control is returned back to the generator when the yielded promise settles.
     * This can lead to less verbose code when doing lots of sequential async calls
     * with minimal processing in between.
     *
     *     use GuzzleHttp\Promise;
     *
     *     function createPromise($value) {
     *         return new Promise\FulfilledPromise($value);
     *     }
     *
     *     $promise = Promise\Coroutine::of(function () {
     *         $value = (yield createPromise('a'));
     *         try {
     *             $value = (yield createPromise($value . 'b'));
     *         } catch (\Throwable $e) {
     *             // The promise was rejected.
     *         }
     *         yield $value . 'c';
     *     });
     *
     *     // Outputs "abc"
     *     $promise->then(function ($v) { echo $v; });
     *
     * @param callable $generatorFn Generator function to wrap into a promise.
     *
     * @return Promise
     *
     * @see https://github.com/petkaantonov/bluebird/blob/master/API.md#generators inspiration
     */
    final class Coroutine implements \GuzzleHttp\Promise\PromiseInterface
    {
        public function __construct(callable $generatorFn)
        {
        }
        /**
         * Create a new coroutine.
         */
        public static function of(callable $generatorFn): self
        {
        }
        public function then(?callable $onFulfilled = null, ?callable $onRejected = null): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        public function otherwise(callable $onRejected): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        public function wait(bool $unwrap = true)
        {
        }
        public function getState(): string
        {
        }
        public function resolve($value): void
        {
        }
        public function reject($reason): void
        {
        }
        public function cancel(): void
        {
        }
        /**
         * @internal
         */
        public function _handleSuccess($value): void
        {
        }
        /**
         * @internal
         */
        public function _handleFailure($reason): void
        {
        }
    }
    final class Create
    {
        /**
         * Creates a promise for a value if the value is not a promise.
         *
         * @param mixed $value Promise or value.
         */
        public static function promiseFor($value): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * Creates a rejected promise for a reason if the reason is not a promise.
         * If the provided reason is a promise, then it is returned as-is.
         *
         * @param mixed $reason Promise or reason.
         */
        public static function rejectionFor($reason): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * Create an exception for a rejected promise value.
         *
         * @param mixed $reason
         */
        public static function exceptionFor($reason): \Throwable
        {
        }
        /**
         * Returns an iterator for the given value.
         *
         * @param mixed $value
         */
        public static function iterFor($value): \Iterator
        {
        }
    }
    final class Each
    {
        /**
         * Given an iterator that yields promises or values, returns a promise that
         * is fulfilled with a null value when the iterator has been consumed or
         * the aggregate promise has been fulfilled or rejected.
         *
         * $onFulfilled is a function that accepts the fulfilled value, iterator
         * index, and the aggregate promise. The callback can invoke any necessary
         * side effects and choose to resolve or reject the aggregate if needed.
         *
         * $onRejected is a function that accepts the rejection reason, iterator
         * index, and the aggregate promise. The callback can invoke any necessary
         * side effects and choose to resolve or reject the aggregate if needed.
         *
         * @param mixed $iterable Iterator or array to iterate over.
         */
        public static function of($iterable, ?callable $onFulfilled = null, ?callable $onRejected = null): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * Like of, but only allows a certain number of outstanding promises at any
         * given time.
         *
         * $concurrency may be an integer or a function that accepts the number of
         * pending promises and returns a numeric concurrency limit value to allow
         * for dynamic a concurrency size.
         *
         * @param mixed        $iterable
         * @param int|callable $concurrency
         */
        public static function ofLimit($iterable, $concurrency, ?callable $onFulfilled = null, ?callable $onRejected = null): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * Like limit, but ensures that no promise in the given $iterable argument
         * is rejected. If any promise is rejected, then the aggregate promise is
         * rejected with the encountered rejection.
         *
         * @param mixed        $iterable
         * @param int|callable $concurrency
         */
        public static function ofLimitAll($iterable, $concurrency, ?callable $onFulfilled = null): \GuzzleHttp\Promise\PromiseInterface
        {
        }
    }
    /**
     * Represents a promise that iterates over many promises and invokes
     * side-effect functions in the process.
     *
     * @final
     */
    class EachPromise implements \GuzzleHttp\Promise\PromisorInterface
    {
        /**
         * Configuration hash can include the following key value pairs:
         *
         * - fulfilled: (callable) Invoked when a promise fulfills. The function
         *   is invoked with three arguments: the fulfillment value, the index
         *   position from the iterable list of the promise, and the aggregate
         *   promise that manages all of the promises. The aggregate promise may
         *   be resolved from within the callback to short-circuit the promise.
         * - rejected: (callable) Invoked when a promise is rejected. The
         *   function is invoked with three arguments: the rejection reason, the
         *   index position from the iterable list of the promise, and the
         *   aggregate promise that manages all of the promises. The aggregate
         *   promise may be resolved from within the callback to short-circuit
         *   the promise.
         * - concurrency: (integer) Pass this configuration option to limit the
         *   allowed number of outstanding concurrently executing promises,
         *   creating a capped pool of promises. There is no limit by default.
         *
         * @param mixed $iterable Promises or values to iterate.
         * @param array $config   Configuration options
         */
        public function __construct($iterable, array $config = [])
        {
        }
        /** @psalm-suppress InvalidNullableReturnType */
        public function promise(): \GuzzleHttp\Promise\PromiseInterface
        {
        }
    }
    /**
     * A promise that has been fulfilled.
     *
     * Thenning off of this promise will invoke the onFulfilled callback
     * immediately and ignore other callbacks.
     *
     * @final
     */
    class FulfilledPromise implements \GuzzleHttp\Promise\PromiseInterface
    {
        /**
         * @param mixed $value
         */
        public function __construct($value)
        {
        }
        public function then(?callable $onFulfilled = null, ?callable $onRejected = null): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        public function otherwise(callable $onRejected): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        public function wait(bool $unwrap = true)
        {
        }
        public function getState(): string
        {
        }
        public function resolve($value): void
        {
        }
        public function reject($reason): void
        {
        }
        public function cancel(): void
        {
        }
    }
    final class Is
    {
        /**
         * Returns true if a promise is pending.
         */
        public static function pending(\GuzzleHttp\Promise\PromiseInterface $promise): bool
        {
        }
        /**
         * Returns true if a promise is fulfilled or rejected.
         */
        public static function settled(\GuzzleHttp\Promise\PromiseInterface $promise): bool
        {
        }
        /**
         * Returns true if a promise is fulfilled.
         */
        public static function fulfilled(\GuzzleHttp\Promise\PromiseInterface $promise): bool
        {
        }
        /**
         * Returns true if a promise is rejected.
         */
        public static function rejected(\GuzzleHttp\Promise\PromiseInterface $promise): bool
        {
        }
    }
    /**
     * Promises/A+ implementation that avoids recursion when possible.
     *
     * @see https://promisesaplus.com/
     *
     * @final
     */
    class Promise implements \GuzzleHttp\Promise\PromiseInterface
    {
        /**
         * @param callable $waitFn   Fn that when invoked resolves the promise.
         * @param callable $cancelFn Fn that when invoked cancels the promise.
         */
        public function __construct(?callable $waitFn = null, ?callable $cancelFn = null)
        {
        }
        public function then(?callable $onFulfilled = null, ?callable $onRejected = null): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        public function otherwise(callable $onRejected): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        public function wait(bool $unwrap = true)
        {
        }
        public function getState(): string
        {
        }
        public function cancel(): void
        {
        }
        public function resolve($value): void
        {
        }
        public function reject($reason): void
        {
        }
    }
    /**
     * A promise that has been rejected.
     *
     * Thenning off of this promise will invoke the onRejected callback
     * immediately and ignore other callbacks.
     *
     * @final
     */
    class RejectedPromise implements \GuzzleHttp\Promise\PromiseInterface
    {
        /**
         * @param mixed $reason
         */
        public function __construct($reason)
        {
        }
        public function then(?callable $onFulfilled = null, ?callable $onRejected = null): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        public function otherwise(callable $onRejected): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        public function wait(bool $unwrap = true)
        {
        }
        public function getState(): string
        {
        }
        public function resolve($value): void
        {
        }
        public function reject($reason): void
        {
        }
        public function cancel(): void
        {
        }
    }
    interface TaskQueueInterface
    {
        /**
         * Returns true if the queue is empty.
         */
        public function isEmpty(): bool;
        /**
         * Adds a task to the queue that will be executed the next time run is
         * called.
         */
        public function add(callable $task): void;
        /**
         * Execute all of the pending task in the queue.
         */
        public function run(): void;
    }
    /**
     * A task queue that executes tasks in a FIFO order.
     *
     * This task queue class is used to settle promises asynchronously and
     * maintains a constant stack size. You can use the task queue asynchronously
     * by calling the `run()` function of the global task queue in an event loop.
     *
     *     GuzzleHttp\Promise\Utils::queue()->run();
     *
     * @final
     */
    class TaskQueue implements \GuzzleHttp\Promise\TaskQueueInterface
    {
        public function __construct(bool $withShutdown = true)
        {
        }
        public function isEmpty(): bool
        {
        }
        public function add(callable $task): void
        {
        }
        public function run(): void
        {
        }
        /**
         * The task queue will be run and exhausted by default when the process
         * exits IFF the exit is not the result of a PHP E_ERROR error.
         *
         * You can disable running the automatic shutdown of the queue by calling
         * this function. If you disable the task queue shutdown process, then you
         * MUST either run the task queue (as a result of running your event loop
         * or manually using the run() method) or wait on each outstanding promise.
         *
         * Note: This shutdown will occur before any destructors are triggered.
         */
        public function disableShutdown(): void
        {
        }
    }
    final class Utils
    {
        /**
         * Get the global task queue used for promise resolution.
         *
         * This task queue MUST be run in an event loop in order for promises to be
         * settled asynchronously. It will be automatically run when synchronously
         * waiting on a promise.
         *
         * <code>
         * while ($eventLoop->isRunning()) {
         *     GuzzleHttp\Promise\Utils::queue()->run();
         * }
         * </code>
         *
         * @param TaskQueueInterface|null $assign Optionally specify a new queue instance.
         */
        public static function queue(?\GuzzleHttp\Promise\TaskQueueInterface $assign = null): \GuzzleHttp\Promise\TaskQueueInterface
        {
        }
        /**
         * Adds a function to run in the task queue when it is next `run()` and
         * returns a promise that is fulfilled or rejected with the result.
         *
         * @param callable $task Task function to run.
         */
        public static function task(callable $task): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * Synchronously waits on a promise to resolve and returns an inspection
         * state array.
         *
         * Returns a state associative array containing a "state" key mapping to a
         * valid promise state. If the state of the promise is "fulfilled", the
         * array will contain a "value" key mapping to the fulfilled value of the
         * promise. If the promise is rejected, the array will contain a "reason"
         * key mapping to the rejection reason of the promise.
         *
         * @param PromiseInterface $promise Promise or value.
         */
        public static function inspect(\GuzzleHttp\Promise\PromiseInterface $promise): array
        {
        }
        /**
         * Waits on all of the provided promises, but does not unwrap rejected
         * promises as thrown exception.
         *
         * Returns an array of inspection state arrays.
         *
         * @see inspect for the inspection state array format.
         *
         * @param PromiseInterface[] $promises Traversable of promises to wait upon.
         */
        public static function inspectAll($promises): array
        {
        }
        /**
         * Waits on all of the provided promises and returns the fulfilled values.
         *
         * Returns an array that contains the value of each promise (in the same
         * order the promises were provided). An exception is thrown if any of the
         * promises are rejected.
         *
         * @param iterable<PromiseInterface> $promises Iterable of PromiseInterface objects to wait on.
         *
         * @throws \Throwable on error
         */
        public static function unwrap($promises): array
        {
        }
        /**
         * Given an array of promises, return a promise that is fulfilled when all
         * the items in the array are fulfilled.
         *
         * The promise's fulfillment value is an array with fulfillment values at
         * respective positions to the original array. If any promise in the array
         * rejects, the returned promise is rejected with the rejection reason.
         *
         * @param mixed $promises  Promises or values.
         * @param bool  $recursive If true, resolves new promises that might have been added to the stack during its own resolution.
         */
        public static function all($promises, bool $recursive = false): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * Initiate a competitive race between multiple promises or values (values
         * will become immediately fulfilled promises).
         *
         * When count amount of promises have been fulfilled, the returned promise
         * is fulfilled with an array that contains the fulfillment values of the
         * winners in order of resolution.
         *
         * This promise is rejected with a {@see AggregateException} if the number
         * of fulfilled promises is less than the desired $count.
         *
         * @param int   $count    Total number of promises.
         * @param mixed $promises Promises or values.
         */
        public static function some(int $count, $promises): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * Like some(), with 1 as count. However, if the promise fulfills, the
         * fulfillment value is not an array of 1 but the value directly.
         *
         * @param mixed $promises Promises or values.
         */
        public static function any($promises): \GuzzleHttp\Promise\PromiseInterface
        {
        }
        /**
         * Returns a promise that is fulfilled when all of the provided promises have
         * been fulfilled or rejected.
         *
         * The returned promise is fulfilled with an array of inspection state arrays.
         *
         * @see inspect for the inspection state array format.
         *
         * @param mixed $promises Promises or values.
         */
        public static function settle($promises): \GuzzleHttp\Promise\PromiseInterface
        {
        }
    }
}
namespace Psr\Http\Message {
    /**
     * Describes a data stream.
     *
     * Typically, an instance will wrap a PHP stream; this interface provides
     * a wrapper around the most common operations, including serialization of
     * the entire stream to a string.
     */
    interface StreamInterface
    {
        /**
         * Reads all data from the stream into a string, from the beginning to end.
         *
         * This method MUST attempt to seek to the beginning of the stream before
         * reading data and read the stream until the end is reached.
         *
         * Warning: This could attempt to load a large amount of data into memory.
         *
         * This method MUST NOT raise an exception in order to conform with PHP's
         * string casting operations.
         *
         * @see http://php.net/manual/en/language.oop5.magic.php#object.tostring
         * @return string
         */
        public function __toString(): string;
        /**
         * Closes the stream and any underlying resources.
         *
         * @return void
         */
        public function close(): void;
        /**
         * Separates any underlying resources from the stream.
         *
         * After the stream has been detached, the stream is in an unusable state.
         *
         * @return resource|null Underlying PHP stream, if any
         */
        public function detach();
        /**
         * Get the size of the stream if known.
         *
         * @return int|null Returns the size in bytes if known, or null if unknown.
         */
        public function getSize(): ?int;
        /**
         * Returns the current position of the file read/write pointer
         *
         * @return int Position of the file pointer
         * @throws \RuntimeException on error.
         */
        public function tell(): int;
        /**
         * Returns true if the stream is at the end of the stream.
         *
         * @return bool
         */
        public function eof(): bool;
        /**
         * Returns whether or not the stream is seekable.
         *
         * @return bool
         */
        public function isSeekable(): bool;
        /**
         * Seek to a position in the stream.
         *
         * @link http://www.php.net/manual/en/function.fseek.php
         * @param int $offset Stream offset
         * @param int $whence Specifies how the cursor position will be calculated
         *     based on the seek offset. Valid values are identical to the built-in
         *     PHP $whence values for `fseek()`.  SEEK_SET: Set position equal to
         *     offset bytes SEEK_CUR: Set position to current location plus offset
         *     SEEK_END: Set position to end-of-stream plus offset.
         * @throws \RuntimeException on failure.
         */
        public function seek(int $offset, int $whence = SEEK_SET): void;
        /**
         * Seek to the beginning of the stream.
         *
         * If the stream is not seekable, this method will raise an exception;
         * otherwise, it will perform a seek(0).
         *
         * @see seek()
         * @link http://www.php.net/manual/en/function.fseek.php
         * @throws \RuntimeException on failure.
         */
        public function rewind(): void;
        /**
         * Returns whether or not the stream is writable.
         *
         * @return bool
         */
        public function isWritable(): bool;
        /**
         * Write data to the stream.
         *
         * @param string $string The string that is to be written.
         * @return int Returns the number of bytes written to the stream.
         * @throws \RuntimeException on failure.
         */
        public function write(string $string): int;
        /**
         * Returns whether or not the stream is readable.
         *
         * @return bool
         */
        public function isReadable(): bool;
        /**
         * Read data from the stream.
         *
         * @param int $length Read up to $length bytes from the object and return
         *     them. Fewer than $length bytes may be returned if underlying stream
         *     call returns fewer bytes.
         * @return string Returns the data read from the stream, or an empty string
         *     if no bytes are available.
         * @throws \RuntimeException if an error occurs.
         */
        public function read(int $length): string;
        /**
         * Returns the remaining contents in a string
         *
         * @return string
         * @throws \RuntimeException if unable to read or an error occurs while
         *     reading.
         */
        public function getContents(): string;
        /**
         * Get stream metadata as an associative array or retrieve a specific key.
         *
         * The keys returned are identical to the keys returned from PHP's
         * stream_get_meta_data() function.
         *
         * @link http://php.net/manual/en/function.stream-get-meta-data.php
         * @param string|null $key Specific metadata to retrieve.
         * @return array|mixed|null Returns an associative array if no key is
         *     provided. Returns a specific key value if a key is provided and the
         *     value is found, or null if the key is not found.
         */
        public function getMetadata(?string $key = null);
    }
}
namespace GuzzleHttp\Psr7 {
    /**
     * Reads from multiple streams, one after the other.
     *
     * This is a read-only stream decorator.
     */
    final class AppendStream implements \Psr\Http\Message\StreamInterface
    {
        /**
         * @param StreamInterface[] $streams Streams to decorate. Each stream must
         *                                   be readable.
         */
        public function __construct(array $streams = [])
        {
        }
        public function __toString(): string
        {
        }
        /**
         * Add a stream to the AppendStream
         *
         * @param StreamInterface $stream Stream to append. Must be readable.
         *
         * @throws \InvalidArgumentException if the stream is not readable
         */
        public function addStream(\Psr\Http\Message\StreamInterface $stream): void
        {
        }
        public function getContents(): string
        {
        }
        /**
         * Closes each attached stream.
         */
        public function close(): void
        {
        }
        /**
         * Detaches each attached stream.
         *
         * Returns null as it's not clear which underlying stream resource to return.
         */
        public function detach()
        {
        }
        public function tell(): int
        {
        }
        /**
         * Tries to calculate the size by adding the size of each stream.
         *
         * If any of the streams do not return a valid number, then the size of the
         * append stream cannot be determined and null is returned.
         */
        public function getSize(): ?int
        {
        }
        public function eof(): bool
        {
        }
        public function rewind(): void
        {
        }
        /**
         * Attempts to seek to the given position. Only supports SEEK_SET.
         */
        public function seek($offset, $whence = SEEK_SET): void
        {
        }
        /**
         * Reads from all of the appended streams until the length is met or EOF.
         */
        public function read($length): string
        {
        }
        public function isReadable(): bool
        {
        }
        public function isWritable(): bool
        {
        }
        public function isSeekable(): bool
        {
        }
        public function write($string): int
        {
        }
        /**
         * @return mixed
         */
        public function getMetadata($key = null)
        {
        }
    }
    /**
     * Provides a buffer stream that can be written to to fill a buffer, and read
     * from to remove bytes from the buffer.
     *
     * This stream returns a "hwm" metadata value that tells upstream consumers
     * what the configured high water mark of the stream is, or the maximum
     * preferred size of the buffer.
     */
    final class BufferStream implements \Psr\Http\Message\StreamInterface
    {
        /**
         * @param int $hwm High water mark, representing the preferred maximum
         *                 buffer size. If the size of the buffer exceeds the high
         *                 water mark, then calls to write will continue to succeed
         *                 but will return 0 to inform writers to slow down
         *                 until the buffer has been drained by reading from it.
         */
        public function __construct(int $hwm = 16384)
        {
        }
        public function __toString(): string
        {
        }
        public function getContents(): string
        {
        }
        public function close(): void
        {
        }
        public function detach()
        {
        }
        public function getSize(): ?int
        {
        }
        public function isReadable(): bool
        {
        }
        public function isWritable(): bool
        {
        }
        public function isSeekable(): bool
        {
        }
        public function rewind(): void
        {
        }
        public function seek($offset, $whence = SEEK_SET): void
        {
        }
        public function eof(): bool
        {
        }
        public function tell(): int
        {
        }
        /**
         * Reads data from the buffer.
         */
        public function read($length): string
        {
        }
        /**
         * Writes data to the buffer.
         */
        public function write($string): int
        {
        }
        /**
         * @return mixed
         */
        public function getMetadata($key = null)
        {
        }
    }
    /**
     * Stream decorator trait
     *
     * @property StreamInterface $stream
     */
    trait StreamDecoratorTrait
    {
        /**
         * @param StreamInterface $stream Stream to decorate
         */
        public function __construct(\Psr\Http\Message\StreamInterface $stream)
        {
        }
        /**
         * Magic method used to create a new stream if streams are not added in
         * the constructor of a decorator (e.g., LazyOpenStream).
         *
         * @return StreamInterface
         */
        public function __get(string $name)
        {
        }
        public function __toString(): string
        {
        }
        public function getContents(): string
        {
        }
        /**
         * Allow decorators to implement custom methods
         *
         * @return mixed
         */
        public function __call(string $method, array $args)
        {
        }
        public function close(): void
        {
        }
        /**
         * @return mixed
         */
        public function getMetadata($key = null)
        {
        }
        public function detach()
        {
        }
        public function getSize(): ?int
        {
        }
        public function eof(): bool
        {
        }
        public function tell(): int
        {
        }
        public function isReadable(): bool
        {
        }
        public function isWritable(): bool
        {
        }
        public function isSeekable(): bool
        {
        }
        public function rewind(): void
        {
        }
        public function seek($offset, $whence = SEEK_SET): void
        {
        }
        public function read($length): string
        {
        }
        public function write($string): int
        {
        }
        /**
         * Implement in subclasses to dynamically create streams when requested.
         *
         * @throws \BadMethodCallException
         */
        protected function createStream(): \Psr\Http\Message\StreamInterface
        {
        }
    }
    /**
     * Stream decorator that can cache previously read bytes from a sequentially
     * read stream.
     */
    final class CachingStream implements \Psr\Http\Message\StreamInterface
    {
        use \GuzzleHttp\Psr7\StreamDecoratorTrait;
        /**
         * We will treat the buffer object as the body of the stream
         *
         * @param StreamInterface $stream Stream to cache. The cursor is assumed to be at the beginning of the stream.
         * @param StreamInterface $target Optionally specify where data is cached
         */
        public function __construct(\Psr\Http\Message\StreamInterface $stream, ?\Psr\Http\Message\StreamInterface $target = null)
        {
        }
        public function getSize(): ?int
        {
        }
        public function rewind(): void
        {
        }
        public function seek($offset, $whence = SEEK_SET): void
        {
        }
        public function read($length): string
        {
        }
        public function write($string): int
        {
        }
        public function eof(): bool
        {
        }
        /**
         * Close both the remote stream and buffer stream
         */
        public function close(): void
        {
        }
    }
    /**
     * Stream decorator that begins dropping data once the size of the underlying
     * stream becomes too full.
     */
    final class DroppingStream implements \Psr\Http\Message\StreamInterface
    {
        use \GuzzleHttp\Psr7\StreamDecoratorTrait;
        /**
         * @param StreamInterface $stream    Underlying stream to decorate.
         * @param int             $maxLength Maximum size before dropping data.
         */
        public function __construct(\Psr\Http\Message\StreamInterface $stream, int $maxLength)
        {
        }
        public function write($string): int
        {
        }
    }
}
namespace GuzzleHttp\Psr7\Exception {
    /**
     * Exception thrown if a URI cannot be parsed because it's malformed.
     */
    class MalformedUriException extends \InvalidArgumentException
    {
    }
}
namespace GuzzleHttp\Psr7 {
    /**
     * Compose stream implementations based on a hash of functions.
     *
     * Allows for easy testing and extension of a provided stream without needing
     * to create a concrete class for a simple extension point.
     */
    #[\AllowDynamicProperties]
    final class FnStream implements \Psr\Http\Message\StreamInterface
    {
        /**
         * @param array<string, callable> $methods Hash of method name to a callable.
         */
        public function __construct(array $methods)
        {
        }
        /**
         * Lazily determine which methods are not implemented.
         *
         * @throws \BadMethodCallException
         */
        public function __get(string $name): void
        {
        }
        /**
         * The close method is called on the underlying stream only if possible.
         */
        public function __destruct()
        {
        }
        /**
         * An unserialize would allow the __destruct to run when the unserialized value goes out of scope.
         *
         * @throws \LogicException
         */
        public function __wakeup(): void
        {
        }
        /**
         * Adds custom functionality to an underlying stream by intercepting
         * specific method calls.
         *
         * @param StreamInterface         $stream  Stream to decorate
         * @param array<string, callable> $methods Hash of method name to a closure
         *
         * @return FnStream
         */
        public static function decorate(\Psr\Http\Message\StreamInterface $stream, array $methods)
        {
        }
        public function __toString(): string
        {
        }
        public function close(): void
        {
        }
        public function detach()
        {
        }
        public function getSize(): ?int
        {
        }
        public function tell(): int
        {
        }
        public function eof(): bool
        {
        }
        public function isSeekable(): bool
        {
        }
        public function rewind(): void
        {
        }
        public function seek($offset, $whence = SEEK_SET): void
        {
        }
        public function isWritable(): bool
        {
        }
        public function write($string): int
        {
        }
        public function isReadable(): bool
        {
        }
        public function read($length): string
        {
        }
        public function getContents(): string
        {
        }
        /**
         * @return mixed
         */
        public function getMetadata($key = null)
        {
        }
    }
    final class Header
    {
        /**
         * Parse an array of header values containing ";" separated data into an
         * array of associative arrays representing the header key value pair data
         * of the header. When a parameter does not contain a value, but just
         * contains a key, this function will inject a key with a '' string value.
         *
         * @param string|array $header Header to parse into components.
         */
        public static function parse($header): array
        {
        }
        /**
         * Converts an array of header values that may contain comma separated
         * headers into an array of headers with no comma separated values.
         *
         * @param string|array $header Header to normalize.
         *
         * @deprecated Use self::splitList() instead.
         */
        public static function normalize($header): array
        {
        }
        /**
         * Splits a HTTP header defined to contain a comma-separated list into
         * each individual value. Empty values will be removed.
         *
         * Example headers include 'accept', 'cache-control' and 'if-none-match'.
         *
         * This method must not be used to parse headers that are not defined as
         * a list, such as 'user-agent' or 'set-cookie'.
         *
         * @param string|string[] $values Header value as returned by MessageInterface::getHeader()
         *
         * @return string[]
         */
        public static function splitList($values): array
        {
        }
    }
}
namespace Psr\Http\Message {
    interface RequestFactoryInterface
    {
        /**
         * Create a new request.
         *
         * @param string $method The HTTP method associated with the request.
         * @param UriInterface|string $uri The URI associated with the request. If
         *     the value is a string, the factory MUST create a UriInterface
         *     instance based on it.
         *
         * @return RequestInterface
         */
        public function createRequest(string $method, $uri): \Psr\Http\Message\RequestInterface;
    }
    interface ResponseFactoryInterface
    {
        /**
         * Create a new response.
         *
         * @param int $code HTTP status code; defaults to 200
         * @param string $reasonPhrase Reason phrase to associate with status code
         *     in generated response; if none is provided implementations MAY use
         *     the defaults as suggested in the HTTP specification.
         *
         * @return ResponseInterface
         */
        public function createResponse(int $code = 200, string $reasonPhrase = ''): \Psr\Http\Message\ResponseInterface;
    }
    interface ServerRequestFactoryInterface
    {
        /**
         * Create a new server request.
         *
         * Note that server-params are taken precisely as given - no parsing/processing
         * of the given values is performed, and, in particular, no attempt is made to
         * determine the HTTP method or URI, which must be provided explicitly.
         *
         * @param string $method The HTTP method associated with the request.
         * @param UriInterface|string $uri The URI associated with the request. If
         *     the value is a string, the factory MUST create a UriInterface
         *     instance based on it.
         * @param array $serverParams Array of SAPI parameters with which to seed
         *     the generated request instance.
         *
         * @return ServerRequestInterface
         */
        public function createServerRequest(string $method, $uri, array $serverParams = []): \Psr\Http\Message\ServerRequestInterface;
    }
    interface StreamFactoryInterface
    {
        /**
         * Create a new stream from a string.
         *
         * The stream SHOULD be created with a temporary resource.
         *
         * @param string $content String content with which to populate the stream.
         *
         * @return StreamInterface
         */
        public function createStream(string $content = ''): \Psr\Http\Message\StreamInterface;
        /**
         * Create a stream from an existing file.
         *
         * The file MUST be opened using the given mode, which may be any mode
         * supported by the `fopen` function.
         *
         * The `$filename` MAY be any string supported by `fopen()`.
         *
         * @param string $filename Filename or stream URI to use as basis of stream.
         * @param string $mode Mode with which to open the underlying filename/stream.
         *
         * @return StreamInterface
         * @throws \RuntimeException If the file cannot be opened.
         * @throws \InvalidArgumentException If the mode is invalid.
         */
        public function createStreamFromFile(string $filename, string $mode = 'r'): \Psr\Http\Message\StreamInterface;
        /**
         * Create a new stream from an existing resource.
         *
         * The stream MUST be readable and may be writable.
         *
         * @param resource $resource PHP resource to use as basis of stream.
         *
         * @return StreamInterface
         */
        public function createStreamFromResource($resource): \Psr\Http\Message\StreamInterface;
    }
    interface UploadedFileFactoryInterface
    {
        /**
         * Create a new uploaded file.
         *
         * If a size is not provided it will be determined by checking the size of
         * the file.
         *
         * @see http://php.net/manual/features.file-upload.post-method.php
         * @see http://php.net/manual/features.file-upload.errors.php
         *
         * @param StreamInterface $stream Underlying stream representing the
         *     uploaded file content.
         * @param int|null $size in bytes
         * @param int $error PHP file upload error
         * @param string|null $clientFilename Filename as provided by the client, if any.
         * @param string|null $clientMediaType Media type as provided by the client, if any.
         *
         * @return UploadedFileInterface
         *
         * @throws \InvalidArgumentException If the file resource is not readable.
         */
        public function createUploadedFile(\Psr\Http\Message\StreamInterface $stream, ?int $size = null, int $error = \UPLOAD_ERR_OK, ?string $clientFilename = null, ?string $clientMediaType = null): \Psr\Http\Message\UploadedFileInterface;
    }
    interface UriFactoryInterface
    {
        /**
         * Create a new URI.
         *
         * @param string $uri
         *
         * @return UriInterface
         *
         * @throws \InvalidArgumentException If the given URI cannot be parsed.
         */
        public function createUri(string $uri = ''): \Psr\Http\Message\UriInterface;
    }
}
namespace GuzzleHttp\Psr7 {
    /**
     * Implements all of the PSR-17 interfaces.
     *
     * Note: in consuming code it is recommended to require the implemented interfaces
     * and inject the instance of this class multiple times.
     */
    final class HttpFactory implements \Psr\Http\Message\RequestFactoryInterface, \Psr\Http\Message\ResponseFactoryInterface, \Psr\Http\Message\ServerRequestFactoryInterface, \Psr\Http\Message\StreamFactoryInterface, \Psr\Http\Message\UploadedFileFactoryInterface, \Psr\Http\Message\UriFactoryInterface
    {
        public function createUploadedFile(\Psr\Http\Message\StreamInterface $stream, ?int $size = null, int $error = \UPLOAD_ERR_OK, ?string $clientFilename = null, ?string $clientMediaType = null): \Psr\Http\Message\UploadedFileInterface
        {
        }
        public function createStream(string $content = ''): \Psr\Http\Message\StreamInterface
        {
        }
        public function createStreamFromFile(string $file, string $mode = 'r'): \Psr\Http\Message\StreamInterface
        {
        }
        public function createStreamFromResource($resource): \Psr\Http\Message\StreamInterface
        {
        }
        public function createServerRequest(string $method, $uri, array $serverParams = []): \Psr\Http\Message\ServerRequestInterface
        {
        }
        public function createResponse(int $code = 200, string $reasonPhrase = ''): \Psr\Http\Message\ResponseInterface
        {
        }
        public function createRequest(string $method, $uri): \Psr\Http\Message\RequestInterface
        {
        }
        public function createUri(string $uri = ''): \Psr\Http\Message\UriInterface
        {
        }
    }
    /**
     * Uses PHP's zlib.inflate filter to inflate zlib (HTTP deflate, RFC1950) or gzipped (RFC1952) content.
     *
     * This stream decorator converts the provided stream to a PHP stream resource,
     * then appends the zlib.inflate filter. The stream is then converted back
     * to a Guzzle stream resource to be used as a Guzzle stream.
     *
     * @see https://datatracker.ietf.org/doc/html/rfc1950
     * @see https://datatracker.ietf.org/doc/html/rfc1952
     * @see https://www.php.net/manual/en/filters.compression.php
     */
    final class InflateStream implements \Psr\Http\Message\StreamInterface
    {
        use \GuzzleHttp\Psr7\StreamDecoratorTrait;
        public function __construct(\Psr\Http\Message\StreamInterface $stream)
        {
        }
    }
    /**
     * Lazily reads or writes to a file that is opened only after an IO operation
     * take place on the stream.
     */
    final class LazyOpenStream implements \Psr\Http\Message\StreamInterface
    {
        use \GuzzleHttp\Psr7\StreamDecoratorTrait;
        /**
         * @param string $filename File to lazily open
         * @param string $mode     fopen mode to use when opening the stream
         */
        public function __construct(string $filename, string $mode)
        {
        }
    }
    /**
     * Decorator used to return only a subset of a stream.
     */
    final class LimitStream implements \Psr\Http\Message\StreamInterface
    {
        use \GuzzleHttp\Psr7\StreamDecoratorTrait;
        /**
         * @param StreamInterface $stream Stream to wrap
         * @param int             $limit  Total number of bytes to allow to be read
         *                                from the stream. Pass -1 for no limit.
         * @param int             $offset Position to seek to before reading (only
         *                                works on seekable streams).
         */
        public function __construct(\Psr\Http\Message\StreamInterface $stream, int $limit = -1, int $offset = 0)
        {
        }
        public function eof(): bool
        {
        }
        /**
         * Returns the size of the limited subset of data
         */
        public function getSize(): ?int
        {
        }
        /**
         * Allow for a bounded seek on the read limited stream
         */
        public function seek($offset, $whence = SEEK_SET): void
        {
        }
        /**
         * Give a relative tell()
         */
        public function tell(): int
        {
        }
        /**
         * Set the offset to start limiting from
         *
         * @param int $offset Offset to seek to and begin byte limiting from
         *
         * @throws \RuntimeException if the stream cannot be seeked.
         */
        public function setOffset(int $offset): void
        {
        }
        /**
         * Set the limit of bytes that the decorator allows to be read from the
         * stream.
         *
         * @param int $limit Number of bytes to allow to be read from the stream.
         *                   Use -1 for no limit.
         */
        public function setLimit(int $limit): void
        {
        }
        public function read($length): string
        {
        }
    }
    final class Message
    {
        /**
         * Returns the string representation of an HTTP message.
         *
         * @param MessageInterface $message Message to convert to a string.
         */
        public static function toString(\Psr\Http\Message\MessageInterface $message): string
        {
        }
        /**
         * Get a short summary of the message body.
         *
         * Will return `null` if the response is not printable.
         *
         * @param MessageInterface $message    The message to get the body summary
         * @param int              $truncateAt The maximum allowed size of the summary
         */
        public static function bodySummary(\Psr\Http\Message\MessageInterface $message, int $truncateAt = 120): ?string
        {
        }
        /**
         * Attempts to rewind a message body and throws an exception on failure.
         *
         * The body of the message will only be rewound if a call to `tell()`
         * returns a value other than `0`.
         *
         * @param MessageInterface $message Message to rewind
         *
         * @throws \RuntimeException
         */
        public static function rewindBody(\Psr\Http\Message\MessageInterface $message): void
        {
        }
        /**
         * Parses an HTTP message into an associative array.
         *
         * The array contains the "start-line" key containing the start line of
         * the message, "headers" key containing an associative array of header
         * array values, and a "body" key containing the body of the message.
         *
         * @param string $message HTTP request or response to parse.
         */
        public static function parseMessage(string $message): array
        {
        }
        /**
         * Constructs a URI for an HTTP request message.
         *
         * @param string $path    Path from the start-line
         * @param array  $headers Array of headers (each value an array).
         */
        public static function parseRequestUri(string $path, array $headers): string
        {
        }
        /**
         * Parses a request message string into a request object.
         *
         * @param string $message Request message string.
         */
        public static function parseRequest(string $message): \Psr\Http\Message\RequestInterface
        {
        }
        /**
         * Parses a response message string into a response object.
         *
         * @param string $message Response message string.
         */
        public static function parseResponse(string $message): \Psr\Http\Message\ResponseInterface
        {
        }
    }
    /**
     * Trait implementing functionality common to requests and responses.
     */
    trait MessageTrait
    {
        /** @var string[][] Map of all registered headers, as original name => array of values */
        private $headers = [];
        /** @var string[] Map of lowercase header name => original name at registration */
        private $headerNames = [];
        /** @var string */
        private $protocol = '1.1';
        /** @var StreamInterface|null */
        private $stream;
        public function getProtocolVersion(): string
        {
        }
        public function withProtocolVersion($version): \Psr\Http\Message\MessageInterface
        {
        }
        public function getHeaders(): array
        {
        }
        public function hasHeader($header): bool
        {
        }
        public function getHeader($header): array
        {
        }
        public function getHeaderLine($header): string
        {
        }
        public function withHeader($header, $value): \Psr\Http\Message\MessageInterface
        {
        }
        public function withAddedHeader($header, $value): \Psr\Http\Message\MessageInterface
        {
        }
        public function withoutHeader($header): \Psr\Http\Message\MessageInterface
        {
        }
        public function getBody(): \Psr\Http\Message\StreamInterface
        {
        }
        public function withBody(\Psr\Http\Message\StreamInterface $body): \Psr\Http\Message\MessageInterface
        {
        }
        /**
         * @param (string|string[])[] $headers
         */
        private function setHeaders(array $headers): void
        {
        }
        /**
         * @param mixed $value
         *
         * @return string[]
         */
        private function normalizeHeaderValue($value): array
        {
        }
        /**
         * Trims whitespace from the header values.
         *
         * Spaces and tabs ought to be excluded by parsers when extracting the field value from a header field.
         *
         * header-field = field-name ":" OWS field-value OWS
         * OWS          = *( SP / HTAB )
         *
         * @param mixed[] $values Header values
         *
         * @return string[] Trimmed header values
         *
         * @see https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.4
         */
        private function trimAndValidateHeaderValues(array $values): array
        {
        }
        /**
         * @see https://datatracker.ietf.org/doc/html/rfc7230#section-3.2
         *
         * @param mixed $header
         */
        private function assertHeader($header): void
        {
        }
        /**
         * @see https://datatracker.ietf.org/doc/html/rfc7230#section-3.2
         *
         * field-value    = *( field-content / obs-fold )
         * field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
         * field-vchar    = VCHAR / obs-text
         * VCHAR          = %x21-7E
         * obs-text       = %x80-FF
         * obs-fold       = CRLF 1*( SP / HTAB )
         */
        private function assertValue(string $value): void
        {
        }
    }
    final class MimeType
    {
        /**
         * Determines the mimetype of a file by looking at its extension.
         *
         * @see https://raw.githubusercontent.com/jshttp/mime-db/master/db.json
         */
        public static function fromFilename(string $filename): ?string
        {
        }
        /**
         * Maps a file extensions to a mimetype.
         *
         * @see https://raw.githubusercontent.com/jshttp/mime-db/master/db.json
         */
        public static function fromExtension(string $extension): ?string
        {
        }
    }
    /**
     * Stream that when read returns bytes for a streaming multipart or
     * multipart/form-data stream.
     */
    final class MultipartStream implements \Psr\Http\Message\StreamInterface
    {
        use \GuzzleHttp\Psr7\StreamDecoratorTrait;
        /**
         * @param array  $elements Array of associative arrays, each containing a
         *                         required "name" key mapping to the form field,
         *                         name, a required "contents" key mapping to a
         *                         StreamInterface/resource/string, an optional
         *                         "headers" associative array of custom headers,
         *                         and an optional "filename" key mapping to a
         *                         string to send as the filename in the part.
         * @param string $boundary You can optionally provide a specific boundary
         *
         * @throws \InvalidArgumentException
         */
        public function __construct(array $elements = [], ?string $boundary = null)
        {
        }
        public function getBoundary(): string
        {
        }
        public function isWritable(): bool
        {
        }
    }
    /**
     * Stream decorator that prevents a stream from being seeked.
     */
    final class NoSeekStream implements \Psr\Http\Message\StreamInterface
    {
        use \GuzzleHttp\Psr7\StreamDecoratorTrait;
        public function seek($offset, $whence = SEEK_SET): void
        {
        }
        public function isSeekable(): bool
        {
        }
    }
    /**
     * Provides a read only stream that pumps data from a PHP callable.
     *
     * When invoking the provided callable, the PumpStream will pass the amount of
     * data requested to read to the callable. The callable can choose to ignore
     * this value and return fewer or more bytes than requested. Any extra data
     * returned by the provided callable is buffered internally until drained using
     * the read() function of the PumpStream. The provided callable MUST return
     * false when there is no more data to read.
     */
    final class PumpStream implements \Psr\Http\Message\StreamInterface
    {
        /**
         * @param callable(int): (string|false|null)  $source  Source of the stream data. The callable MAY
         *                                                     accept an integer argument used to control the
         *                                                     amount of data to return. The callable MUST
         *                                                     return a string when called, or false|null on error
         *                                                     or EOF.
         * @param array{size?: int, metadata?: array} $options Stream options:
         *                                                     - metadata: Hash of metadata to use with stream.
         *                                                     - size: Size of the stream, if known.
         */
        public function __construct(callable $source, array $options = [])
        {
        }
        public function __toString(): string
        {
        }
        public function close(): void
        {
        }
        public function detach()
        {
        }
        public function getSize(): ?int
        {
        }
        public function tell(): int
        {
        }
        public function eof(): bool
        {
        }
        public function isSeekable(): bool
        {
        }
        public function rewind(): void
        {
        }
        public function seek($offset, $whence = SEEK_SET): void
        {
        }
        public function isWritable(): bool
        {
        }
        public function write($string): int
        {
        }
        public function isReadable(): bool
        {
        }
        public function read($length): string
        {
        }
        public function getContents(): string
        {
        }
        /**
         * @return mixed
         */
        public function getMetadata($key = null)
        {
        }
    }
    final class Query
    {
        /**
         * Parse a query string into an associative array.
         *
         * If multiple values are found for the same key, the value of that key
         * value pair will become an array. This function does not parse nested
         * PHP style arrays into an associative array (e.g., `foo[a]=1&foo[b]=2`
         * will be parsed into `['foo[a]' => '1', 'foo[b]' => '2'])`.
         *
         * @param string   $str         Query string to parse
         * @param int|bool $urlEncoding How the query string is encoded
         */
        public static function parse(string $str, $urlEncoding = true): array
        {
        }
        /**
         * Build a query string from an array of key value pairs.
         *
         * This function can use the return value of `parse()` to build a query
         * string. This function does not modify the provided keys when an array is
         * encountered (like `http_build_query()` would).
         *
         * @param array     $params           Query string parameters.
         * @param int|false $encoding         Set to false to not encode,
         *                                    PHP_QUERY_RFC3986 to encode using
         *                                    RFC3986, or PHP_QUERY_RFC1738 to
         *                                    encode using RFC1738.
         * @param bool      $treatBoolsAsInts Set to true to encode as 0/1, and
         *                                    false as false/true.
         */
        public static function build(array $params, $encoding = PHP_QUERY_RFC3986, bool $treatBoolsAsInts = true): string
        {
        }
    }
}
namespace Psr\Http\Message {
    /**
     * HTTP messages consist of requests from a client to a server and responses
     * from a server to a client. This interface defines the methods common to
     * each.
     *
     * Messages are considered immutable; all methods that might change state MUST
     * be implemented such that they retain the internal state of the current
     * message and return an instance that contains the changed state.
     *
     * @link http://www.ietf.org/rfc/rfc7230.txt
     * @link http://www.ietf.org/rfc/rfc7231.txt
     */
    interface MessageInterface
    {
        /**
         * Retrieves the HTTP protocol version as a string.
         *
         * The string MUST contain only the HTTP version number (e.g., "1.1", "1.0").
         *
         * @return string HTTP protocol version.
         */
        public function getProtocolVersion(): string;
        /**
         * Return an instance with the specified HTTP protocol version.
         *
         * The version string MUST contain only the HTTP version number (e.g.,
         * "1.1", "1.0").
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * new protocol version.
         *
         * @param string $version HTTP protocol version
         * @return static
         */
        public function withProtocolVersion(string $version): \Psr\Http\Message\MessageInterface;
        /**
         * Retrieves all message header values.
         *
         * The keys represent the header name as it will be sent over the wire, and
         * each value is an array of strings associated with the header.
         *
         *     // Represent the headers as a string
         *     foreach ($message->getHeaders() as $name => $values) {
         *         echo $name . ": " . implode(", ", $values);
         *     }
         *
         *     // Emit headers iteratively:
         *     foreach ($message->getHeaders() as $name => $values) {
         *         foreach ($values as $value) {
         *             header(sprintf('%s: %s', $name, $value), false);
         *         }
         *     }
         *
         * While header names are not case-sensitive, getHeaders() will preserve the
         * exact case in which headers were originally specified.
         *
         * @return string[][] Returns an associative array of the message's headers. Each
         *     key MUST be a header name, and each value MUST be an array of strings
         *     for that header.
         */
        public function getHeaders(): array;
        /**
         * Checks if a header exists by the given case-insensitive name.
         *
         * @param string $name Case-insensitive header field name.
         * @return bool Returns true if any header names match the given header
         *     name using a case-insensitive string comparison. Returns false if
         *     no matching header name is found in the message.
         */
        public function hasHeader(string $name): bool;
        /**
         * Retrieves a message header value by the given case-insensitive name.
         *
         * This method returns an array of all the header values of the given
         * case-insensitive header name.
         *
         * If the header does not appear in the message, this method MUST return an
         * empty array.
         *
         * @param string $name Case-insensitive header field name.
         * @return string[] An array of string values as provided for the given
         *    header. If the header does not appear in the message, this method MUST
         *    return an empty array.
         */
        public function getHeader(string $name): array;
        /**
         * Retrieves a comma-separated string of the values for a single header.
         *
         * This method returns all of the header values of the given
         * case-insensitive header name as a string concatenated together using
         * a comma.
         *
         * NOTE: Not all header values may be appropriately represented using
         * comma concatenation. For such headers, use getHeader() instead
         * and supply your own delimiter when concatenating.
         *
         * If the header does not appear in the message, this method MUST return
         * an empty string.
         *
         * @param string $name Case-insensitive header field name.
         * @return string A string of values as provided for the given header
         *    concatenated together using a comma. If the header does not appear in
         *    the message, this method MUST return an empty string.
         */
        public function getHeaderLine(string $name): string;
        /**
         * Return an instance with the provided value replacing the specified header.
         *
         * While header names are case-insensitive, the casing of the header will
         * be preserved by this function, and returned from getHeaders().
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * new and/or updated header and value.
         *
         * @param string $name Case-insensitive header field name.
         * @param string|string[] $value Header value(s).
         * @return static
         * @throws \InvalidArgumentException for invalid header names or values.
         */
        public function withHeader(string $name, $value): \Psr\Http\Message\MessageInterface;
        /**
         * Return an instance with the specified header appended with the given value.
         *
         * Existing values for the specified header will be maintained. The new
         * value(s) will be appended to the existing list. If the header did not
         * exist previously, it will be added.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * new header and/or value.
         *
         * @param string $name Case-insensitive header field name to add.
         * @param string|string[] $value Header value(s).
         * @return static
         * @throws \InvalidArgumentException for invalid header names or values.
         */
        public function withAddedHeader(string $name, $value): \Psr\Http\Message\MessageInterface;
        /**
         * Return an instance without the specified header.
         *
         * Header resolution MUST be done without case-sensitivity.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that removes
         * the named header.
         *
         * @param string $name Case-insensitive header field name to remove.
         * @return static
         */
        public function withoutHeader(string $name): \Psr\Http\Message\MessageInterface;
        /**
         * Gets the body of the message.
         *
         * @return StreamInterface Returns the body as a stream.
         */
        public function getBody(): \Psr\Http\Message\StreamInterface;
        /**
         * Return an instance with the specified message body.
         *
         * The body MUST be a StreamInterface object.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return a new instance that has the
         * new body stream.
         *
         * @param StreamInterface $body Body.
         * @return static
         * @throws \InvalidArgumentException When the body is not valid.
         */
        public function withBody(\Psr\Http\Message\StreamInterface $body): \Psr\Http\Message\MessageInterface;
    }
    /**
     * Representation of an outgoing, client-side request.
     *
     * Per the HTTP specification, this interface includes properties for
     * each of the following:
     *
     * - Protocol version
     * - HTTP method
     * - URI
     * - Headers
     * - Message body
     *
     * During construction, implementations MUST attempt to set the Host header from
     * a provided URI if no Host header is provided.
     *
     * Requests are considered immutable; all methods that might change state MUST
     * be implemented such that they retain the internal state of the current
     * message and return an instance that contains the changed state.
     */
    interface RequestInterface extends \Psr\Http\Message\MessageInterface
    {
        /**
         * Retrieves the message's request target.
         *
         * Retrieves the message's request-target either as it will appear (for
         * clients), as it appeared at request (for servers), or as it was
         * specified for the instance (see withRequestTarget()).
         *
         * In most cases, this will be the origin-form of the composed URI,
         * unless a value was provided to the concrete implementation (see
         * withRequestTarget() below).
         *
         * If no URI is available, and no request-target has been specifically
         * provided, this method MUST return the string "/".
         *
         * @return string
         */
        public function getRequestTarget(): string;
        /**
         * Return an instance with the specific request-target.
         *
         * If the request needs a non-origin-form request-target — e.g., for
         * specifying an absolute-form, authority-form, or asterisk-form —
         * this method may be used to create an instance with the specified
         * request-target, verbatim.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * changed request target.
         *
         * @link http://tools.ietf.org/html/rfc7230#section-5.3 (for the various
         *     request-target forms allowed in request messages)
         * @param string $requestTarget
         * @return static
         */
        public function withRequestTarget(string $requestTarget): \Psr\Http\Message\RequestInterface;
        /**
         * Retrieves the HTTP method of the request.
         *
         * @return string Returns the request method.
         */
        public function getMethod(): string;
        /**
         * Return an instance with the provided HTTP method.
         *
         * While HTTP method names are typically all uppercase characters, HTTP
         * method names are case-sensitive and thus implementations SHOULD NOT
         * modify the given string.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * changed request method.
         *
         * @param string $method Case-sensitive method.
         * @return static
         * @throws \InvalidArgumentException for invalid HTTP methods.
         */
        public function withMethod(string $method): \Psr\Http\Message\RequestInterface;
        /**
         * Retrieves the URI instance.
         *
         * This method MUST return a UriInterface instance.
         *
         * @link http://tools.ietf.org/html/rfc3986#section-4.3
         * @return UriInterface Returns a UriInterface instance
         *     representing the URI of the request.
         */
        public function getUri(): \Psr\Http\Message\UriInterface;
        /**
         * Returns an instance with the provided URI.
         *
         * This method MUST update the Host header of the returned request by
         * default if the URI contains a host component. If the URI does not
         * contain a host component, any pre-existing Host header MUST be carried
         * over to the returned request.
         *
         * You can opt-in to preserving the original state of the Host header by
         * setting `$preserveHost` to `true`. When `$preserveHost` is set to
         * `true`, this method interacts with the Host header in the following ways:
         *
         * - If the Host header is missing or empty, and the new URI contains
         *   a host component, this method MUST update the Host header in the returned
         *   request.
         * - If the Host header is missing or empty, and the new URI does not contain a
         *   host component, this method MUST NOT update the Host header in the returned
         *   request.
         * - If a Host header is present and non-empty, this method MUST NOT update
         *   the Host header in the returned request.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * new UriInterface instance.
         *
         * @link http://tools.ietf.org/html/rfc3986#section-4.3
         * @param UriInterface $uri New request URI to use.
         * @param bool $preserveHost Preserve the original state of the Host header.
         * @return static
         */
        public function withUri(\Psr\Http\Message\UriInterface $uri, bool $preserveHost = false): \Psr\Http\Message\RequestInterface;
    }
}
namespace GuzzleHttp\Psr7 {
    /**
     * PSR-7 request implementation.
     */
    class Request implements \Psr\Http\Message\RequestInterface
    {
        use \GuzzleHttp\Psr7\MessageTrait;
        /**
         * @param string                               $method  HTTP method
         * @param string|UriInterface                  $uri     URI
         * @param (string|string[])[]                  $headers Request headers
         * @param string|resource|StreamInterface|null $body    Request body
         * @param string                               $version Protocol version
         */
        public function __construct(string $method, $uri, array $headers = [], $body = null, string $version = '1.1')
        {
        }
        public function getRequestTarget(): string
        {
        }
        public function withRequestTarget($requestTarget): \Psr\Http\Message\RequestInterface
        {
        }
        public function getMethod(): string
        {
        }
        public function withMethod($method): \Psr\Http\Message\RequestInterface
        {
        }
        public function getUri(): \Psr\Http\Message\UriInterface
        {
        }
        public function withUri(\Psr\Http\Message\UriInterface $uri, $preserveHost = false): \Psr\Http\Message\RequestInterface
        {
        }
    }
}
namespace Psr\Http\Message {
    /**
     * Representation of an outgoing, server-side response.
     *
     * Per the HTTP specification, this interface includes properties for
     * each of the following:
     *
     * - Protocol version
     * - Status code and reason phrase
     * - Headers
     * - Message body
     *
     * Responses are considered immutable; all methods that might change state MUST
     * be implemented such that they retain the internal state of the current
     * message and return an instance that contains the changed state.
     */
    interface ResponseInterface extends \Psr\Http\Message\MessageInterface
    {
        /**
         * Gets the response status code.
         *
         * The status code is a 3-digit integer result code of the server's attempt
         * to understand and satisfy the request.
         *
         * @return int Status code.
         */
        public function getStatusCode(): int;
        /**
         * Return an instance with the specified status code and, optionally, reason phrase.
         *
         * If no reason phrase is specified, implementations MAY choose to default
         * to the RFC 7231 or IANA recommended reason phrase for the response's
         * status code.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * updated status and reason phrase.
         *
         * @link http://tools.ietf.org/html/rfc7231#section-6
         * @link http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
         * @param int $code The 3-digit integer result code to set.
         * @param string $reasonPhrase The reason phrase to use with the
         *     provided status code; if none is provided, implementations MAY
         *     use the defaults as suggested in the HTTP specification.
         * @return static
         * @throws \InvalidArgumentException For invalid status code arguments.
         */
        public function withStatus(int $code, string $reasonPhrase = ''): \Psr\Http\Message\ResponseInterface;
        /**
         * Gets the response reason phrase associated with the status code.
         *
         * Because a reason phrase is not a required element in a response
         * status line, the reason phrase value MAY be null. Implementations MAY
         * choose to return the default RFC 7231 recommended reason phrase (or those
         * listed in the IANA HTTP Status Code Registry) for the response's
         * status code.
         *
         * @link http://tools.ietf.org/html/rfc7231#section-6
         * @link http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
         * @return string Reason phrase; must return an empty string if none present.
         */
        public function getReasonPhrase(): string;
    }
}
namespace GuzzleHttp\Psr7 {
    /**
     * PSR-7 response implementation.
     */
    class Response implements \Psr\Http\Message\ResponseInterface
    {
        use \GuzzleHttp\Psr7\MessageTrait;
        /**
         * @param int                                  $status  Status code
         * @param (string|string[])[]                  $headers Response headers
         * @param string|resource|StreamInterface|null $body    Response body
         * @param string                               $version Protocol version
         * @param string|null                          $reason  Reason phrase (when empty a default will be used based on the status code)
         */
        public function __construct(int $status = 200, array $headers = [], $body = null, string $version = '1.1', ?string $reason = null)
        {
        }
        public function getStatusCode(): int
        {
        }
        public function getReasonPhrase(): string
        {
        }
        public function withStatus($code, $reasonPhrase = ''): \Psr\Http\Message\ResponseInterface
        {
        }
    }
    /**
     * @internal
     */
    final class Rfc7230
    {
        /**
         * Header related regular expressions (based on amphp/http package)
         *
         * Note: header delimiter (\r\n) is modified to \r?\n to accept line feed only delimiters for BC reasons.
         *
         * @see https://github.com/amphp/http/blob/v1.0.1/src/Rfc7230.php#L12-L15
         *
         * @license https://github.com/amphp/http/blob/v1.0.1/LICENSE
         */
        public const HEADER_REGEX = "(^([^()<>@,;:\\\"/[\\]?={}\x01- ]++):[ \t]*+((?:[ \t]*+[!-~\x80-\xff]++)*+)[ \t]*+\r?\n)m";
        public const HEADER_FOLD_REGEX = "(\r?\n[ \t]++)";
    }
}
namespace Psr\Http\Message {
    /**
     * Representation of an incoming, server-side HTTP request.
     *
     * Per the HTTP specification, this interface includes properties for
     * each of the following:
     *
     * - Protocol version
     * - HTTP method
     * - URI
     * - Headers
     * - Message body
     *
     * Additionally, it encapsulates all data as it has arrived to the
     * application from the CGI and/or PHP environment, including:
     *
     * - The values represented in $_SERVER.
     * - Any cookies provided (generally via $_COOKIE)
     * - Query string arguments (generally via $_GET, or as parsed via parse_str())
     * - Upload files, if any (as represented by $_FILES)
     * - Deserialized body parameters (generally from $_POST)
     *
     * $_SERVER values MUST be treated as immutable, as they represent application
     * state at the time of request; as such, no methods are provided to allow
     * modification of those values. The other values provide such methods, as they
     * can be restored from $_SERVER or the request body, and may need treatment
     * during the application (e.g., body parameters may be deserialized based on
     * content type).
     *
     * Additionally, this interface recognizes the utility of introspecting a
     * request to derive and match additional parameters (e.g., via URI path
     * matching, decrypting cookie values, deserializing non-form-encoded body
     * content, matching authorization headers to users, etc). These parameters
     * are stored in an "attributes" property.
     *
     * Requests are considered immutable; all methods that might change state MUST
     * be implemented such that they retain the internal state of the current
     * message and return an instance that contains the changed state.
     */
    interface ServerRequestInterface extends \Psr\Http\Message\RequestInterface
    {
        /**
         * Retrieve server parameters.
         *
         * Retrieves data related to the incoming request environment,
         * typically derived from PHP's $_SERVER superglobal. The data IS NOT
         * REQUIRED to originate from $_SERVER.
         *
         * @return array
         */
        public function getServerParams(): array;
        /**
         * Retrieve cookies.
         *
         * Retrieves cookies sent by the client to the server.
         *
         * The data MUST be compatible with the structure of the $_COOKIE
         * superglobal.
         *
         * @return array
         */
        public function getCookieParams(): array;
        /**
         * Return an instance with the specified cookies.
         *
         * The data IS NOT REQUIRED to come from the $_COOKIE superglobal, but MUST
         * be compatible with the structure of $_COOKIE. Typically, this data will
         * be injected at instantiation.
         *
         * This method MUST NOT update the related Cookie header of the request
         * instance, nor related values in the server params.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * updated cookie values.
         *
         * @param array $cookies Array of key/value pairs representing cookies.
         * @return static
         */
        public function withCookieParams(array $cookies): \Psr\Http\Message\ServerRequestInterface;
        /**
         * Retrieve query string arguments.
         *
         * Retrieves the deserialized query string arguments, if any.
         *
         * Note: the query params might not be in sync with the URI or server
         * params. If you need to ensure you are only getting the original
         * values, you may need to parse the query string from `getUri()->getQuery()`
         * or from the `QUERY_STRING` server param.
         *
         * @return array
         */
        public function getQueryParams(): array;
        /**
         * Return an instance with the specified query string arguments.
         *
         * These values SHOULD remain immutable over the course of the incoming
         * request. They MAY be injected during instantiation, such as from PHP's
         * $_GET superglobal, or MAY be derived from some other value such as the
         * URI. In cases where the arguments are parsed from the URI, the data
         * MUST be compatible with what PHP's parse_str() would return for
         * purposes of how duplicate query parameters are handled, and how nested
         * sets are handled.
         *
         * Setting query string arguments MUST NOT change the URI stored by the
         * request, nor the values in the server params.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * updated query string arguments.
         *
         * @param array $query Array of query string arguments, typically from
         *     $_GET.
         * @return static
         */
        public function withQueryParams(array $query): \Psr\Http\Message\ServerRequestInterface;
        /**
         * Retrieve normalized file upload data.
         *
         * This method returns upload metadata in a normalized tree, with each leaf
         * an instance of Psr\Http\Message\UploadedFileInterface.
         *
         * These values MAY be prepared from $_FILES or the message body during
         * instantiation, or MAY be injected via withUploadedFiles().
         *
         * @return array An array tree of UploadedFileInterface instances; an empty
         *     array MUST be returned if no data is present.
         */
        public function getUploadedFiles(): array;
        /**
         * Create a new instance with the specified uploaded files.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * updated body parameters.
         *
         * @param array $uploadedFiles An array tree of UploadedFileInterface instances.
         * @return static
         * @throws \InvalidArgumentException if an invalid structure is provided.
         */
        public function withUploadedFiles(array $uploadedFiles): \Psr\Http\Message\ServerRequestInterface;
        /**
         * Retrieve any parameters provided in the request body.
         *
         * If the request Content-Type is either application/x-www-form-urlencoded
         * or multipart/form-data, and the request method is POST, this method MUST
         * return the contents of $_POST.
         *
         * Otherwise, this method may return any results of deserializing
         * the request body content; as parsing returns structured content, the
         * potential types MUST be arrays or objects only. A null value indicates
         * the absence of body content.
         *
         * @return null|array|object The deserialized body parameters, if any.
         *     These will typically be an array or object.
         */
        public function getParsedBody();
        /**
         * Return an instance with the specified body parameters.
         *
         * These MAY be injected during instantiation.
         *
         * If the request Content-Type is either application/x-www-form-urlencoded
         * or multipart/form-data, and the request method is POST, use this method
         * ONLY to inject the contents of $_POST.
         *
         * The data IS NOT REQUIRED to come from $_POST, but MUST be the results of
         * deserializing the request body content. Deserialization/parsing returns
         * structured data, and, as such, this method ONLY accepts arrays or objects,
         * or a null value if nothing was available to parse.
         *
         * As an example, if content negotiation determines that the request data
         * is a JSON payload, this method could be used to create a request
         * instance with the deserialized parameters.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * updated body parameters.
         *
         * @param null|array|object $data The deserialized body data. This will
         *     typically be in an array or object.
         * @return static
         * @throws \InvalidArgumentException if an unsupported argument type is
         *     provided.
         */
        public function withParsedBody($data): \Psr\Http\Message\ServerRequestInterface;
        /**
         * Retrieve attributes derived from the request.
         *
         * The request "attributes" may be used to allow injection of any
         * parameters derived from the request: e.g., the results of path
         * match operations; the results of decrypting cookies; the results of
         * deserializing non-form-encoded message bodies; etc. Attributes
         * will be application and request specific, and CAN be mutable.
         *
         * @return array Attributes derived from the request.
         */
        public function getAttributes(): array;
        /**
         * Retrieve a single derived request attribute.
         *
         * Retrieves a single derived request attribute as described in
         * getAttributes(). If the attribute has not been previously set, returns
         * the default value as provided.
         *
         * This method obviates the need for a hasAttribute() method, as it allows
         * specifying a default value to return if the attribute is not found.
         *
         * @see getAttributes()
         * @param string $name The attribute name.
         * @param mixed $default Default value to return if the attribute does not exist.
         * @return mixed
         */
        public function getAttribute(string $name, $default = null);
        /**
         * Return an instance with the specified derived request attribute.
         *
         * This method allows setting a single derived request attribute as
         * described in getAttributes().
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * updated attribute.
         *
         * @see getAttributes()
         * @param string $name The attribute name.
         * @param mixed $value The value of the attribute.
         * @return static
         */
        public function withAttribute(string $name, $value): \Psr\Http\Message\ServerRequestInterface;
        /**
         * Return an instance that removes the specified derived request attribute.
         *
         * This method allows removing a single derived request attribute as
         * described in getAttributes().
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that removes
         * the attribute.
         *
         * @see getAttributes()
         * @param string $name The attribute name.
         * @return static
         */
        public function withoutAttribute(string $name): \Psr\Http\Message\ServerRequestInterface;
    }
}
namespace GuzzleHttp\Psr7 {
    /**
     * Server-side HTTP request
     *
     * Extends the Request definition to add methods for accessing incoming data,
     * specifically server parameters, cookies, matched path parameters, query
     * string arguments, body parameters, and upload file information.
     *
     * "Attributes" are discovered via decomposing the request (and usually
     * specifically the URI path), and typically will be injected by the application.
     *
     * Requests are considered immutable; all methods that might change state are
     * implemented such that they retain the internal state of the current
     * message and return a new instance that contains the changed state.
     */
    class ServerRequest extends \GuzzleHttp\Psr7\Request implements \Psr\Http\Message\ServerRequestInterface
    {
        /**
         * @param string                               $method       HTTP method
         * @param string|UriInterface                  $uri          URI
         * @param (string|string[])[]                  $headers      Request headers
         * @param string|resource|StreamInterface|null $body         Request body
         * @param string                               $version      Protocol version
         * @param array                                $serverParams Typically the $_SERVER superglobal
         */
        public function __construct(string $method, $uri, array $headers = [], $body = null, string $version = '1.1', array $serverParams = [])
        {
        }
        /**
         * Return an UploadedFile instance array.
         *
         * @param array $files An array which respect $_FILES structure
         *
         * @throws InvalidArgumentException for unrecognized values
         */
        public static function normalizeFiles(array $files): array
        {
        }
        /**
         * Return a ServerRequest populated with superglobals:
         * $_GET
         * $_POST
         * $_COOKIE
         * $_FILES
         * $_SERVER
         */
        public static function fromGlobals(): \Psr\Http\Message\ServerRequestInterface
        {
        }
        /**
         * Get a Uri populated with values from $_SERVER.
         */
        public static function getUriFromGlobals(): \Psr\Http\Message\UriInterface
        {
        }
        public function getServerParams(): array
        {
        }
        public function getUploadedFiles(): array
        {
        }
        public function withUploadedFiles(array $uploadedFiles): \Psr\Http\Message\ServerRequestInterface
        {
        }
        public function getCookieParams(): array
        {
        }
        public function withCookieParams(array $cookies): \Psr\Http\Message\ServerRequestInterface
        {
        }
        public function getQueryParams(): array
        {
        }
        public function withQueryParams(array $query): \Psr\Http\Message\ServerRequestInterface
        {
        }
        /**
         * @return array|object|null
         */
        public function getParsedBody()
        {
        }
        public function withParsedBody($data): \Psr\Http\Message\ServerRequestInterface
        {
        }
        public function getAttributes(): array
        {
        }
        /**
         * @return mixed
         */
        public function getAttribute($attribute, $default = null)
        {
        }
        public function withAttribute($attribute, $value): \Psr\Http\Message\ServerRequestInterface
        {
        }
        public function withoutAttribute($attribute): \Psr\Http\Message\ServerRequestInterface
        {
        }
    }
    /**
     * PHP stream implementation.
     */
    class Stream implements \Psr\Http\Message\StreamInterface
    {
        /**
         * This constructor accepts an associative array of options.
         *
         * - size: (int) If a read stream would otherwise have an indeterminate
         *   size, but the size is known due to foreknowledge, then you can
         *   provide that size, in bytes.
         * - metadata: (array) Any additional metadata to return when the metadata
         *   of the stream is accessed.
         *
         * @param resource                            $stream  Stream resource to wrap.
         * @param array{size?: int, metadata?: array} $options Associative array of options.
         *
         * @throws \InvalidArgumentException if the stream is not a stream resource
         */
        public function __construct($stream, array $options = [])
        {
        }
        /**
         * Closes the stream when the destructed
         */
        public function __destruct()
        {
        }
        public function __toString(): string
        {
        }
        public function getContents(): string
        {
        }
        public function close(): void
        {
        }
        public function detach()
        {
        }
        public function getSize(): ?int
        {
        }
        public function isReadable(): bool
        {
        }
        public function isWritable(): bool
        {
        }
        public function isSeekable(): bool
        {
        }
        public function eof(): bool
        {
        }
        public function tell(): int
        {
        }
        public function rewind(): void
        {
        }
        public function seek($offset, $whence = SEEK_SET): void
        {
        }
        public function read($length): string
        {
        }
        public function write($string): int
        {
        }
        /**
         * @return mixed
         */
        public function getMetadata($key = null)
        {
        }
    }
    /**
     * Converts Guzzle streams into PHP stream resources.
     *
     * @see https://www.php.net/streamwrapper
     */
    final class StreamWrapper
    {
        /** @var resource */
        public $context;
        /**
         * Returns a resource representing the stream.
         *
         * @param StreamInterface $stream The stream to get a resource for
         *
         * @return resource
         *
         * @throws \InvalidArgumentException if stream is not readable or writable
         */
        public static function getResource(\Psr\Http\Message\StreamInterface $stream)
        {
        }
        /**
         * Creates a stream context that can be used to open a stream as a php stream resource.
         *
         * @return resource
         */
        public static function createStreamContext(\Psr\Http\Message\StreamInterface $stream)
        {
        }
        /**
         * Registers the stream wrapper if needed
         */
        public static function register(): void
        {
        }
        public function stream_open(string $path, string $mode, int $options, ?string &$opened_path = null): bool
        {
        }
        public function stream_read(int $count): string
        {
        }
        public function stream_write(string $data): int
        {
        }
        public function stream_tell(): int
        {
        }
        public function stream_eof(): bool
        {
        }
        public function stream_seek(int $offset, int $whence): bool
        {
        }
        /**
         * @return resource|false
         */
        public function stream_cast(int $cast_as)
        {
        }
        /**
         * @return array{
         *   dev: int,
         *   ino: int,
         *   mode: int,
         *   nlink: int,
         *   uid: int,
         *   gid: int,
         *   rdev: int,
         *   size: int,
         *   atime: int,
         *   mtime: int,
         *   ctime: int,
         *   blksize: int,
         *   blocks: int
         * }|false
         */
        public function stream_stat()
        {
        }
        /**
         * @return array{
         *   dev: int,
         *   ino: int,
         *   mode: int,
         *   nlink: int,
         *   uid: int,
         *   gid: int,
         *   rdev: int,
         *   size: int,
         *   atime: int,
         *   mtime: int,
         *   ctime: int,
         *   blksize: int,
         *   blocks: int
         * }
         */
        public function url_stat(string $path, int $flags): array
        {
        }
    }
}
namespace Psr\Http\Message {
    /**
     * Value object representing a file uploaded through an HTTP request.
     *
     * Instances of this interface are considered immutable; all methods that
     * might change state MUST be implemented such that they retain the internal
     * state of the current instance and return an instance that contains the
     * changed state.
     */
    interface UploadedFileInterface
    {
        /**
         * Retrieve a stream representing the uploaded file.
         *
         * This method MUST return a StreamInterface instance, representing the
         * uploaded file. The purpose of this method is to allow utilizing native PHP
         * stream functionality to manipulate the file upload, such as
         * stream_copy_to_stream() (though the result will need to be decorated in a
         * native PHP stream wrapper to work with such functions).
         *
         * If the moveTo() method has been called previously, this method MUST raise
         * an exception.
         *
         * @return StreamInterface Stream representation of the uploaded file.
         * @throws \RuntimeException in cases when no stream is available or can be
         *     created.
         */
        public function getStream(): \Psr\Http\Message\StreamInterface;
        /**
         * Move the uploaded file to a new location.
         *
         * Use this method as an alternative to move_uploaded_file(). This method is
         * guaranteed to work in both SAPI and non-SAPI environments.
         * Implementations must determine which environment they are in, and use the
         * appropriate method (move_uploaded_file(), rename(), or a stream
         * operation) to perform the operation.
         *
         * $targetPath may be an absolute path, or a relative path. If it is a
         * relative path, resolution should be the same as used by PHP's rename()
         * function.
         *
         * The original file or stream MUST be removed on completion.
         *
         * If this method is called more than once, any subsequent calls MUST raise
         * an exception.
         *
         * When used in an SAPI environment where $_FILES is populated, when writing
         * files via moveTo(), is_uploaded_file() and move_uploaded_file() SHOULD be
         * used to ensure permissions and upload status are verified correctly.
         *
         * If you wish to move to a stream, use getStream(), as SAPI operations
         * cannot guarantee writing to stream destinations.
         *
         * @see http://php.net/is_uploaded_file
         * @see http://php.net/move_uploaded_file
         * @param string $targetPath Path to which to move the uploaded file.
         * @throws \InvalidArgumentException if the $targetPath specified is invalid.
         * @throws \RuntimeException on any error during the move operation, or on
         *     the second or subsequent call to the method.
         */
        public function moveTo(string $targetPath): void;
        /**
         * Retrieve the file size.
         *
         * Implementations SHOULD return the value stored in the "size" key of
         * the file in the $_FILES array if available, as PHP calculates this based
         * on the actual size transmitted.
         *
         * @return int|null The file size in bytes or null if unknown.
         */
        public function getSize(): ?int;
        /**
         * Retrieve the error associated with the uploaded file.
         *
         * The return value MUST be one of PHP's UPLOAD_ERR_XXX constants.
         *
         * If the file was uploaded successfully, this method MUST return
         * UPLOAD_ERR_OK.
         *
         * Implementations SHOULD return the value stored in the "error" key of
         * the file in the $_FILES array.
         *
         * @see http://php.net/manual/en/features.file-upload.errors.php
         * @return int One of PHP's UPLOAD_ERR_XXX constants.
         */
        public function getError(): int;
        /**
         * Retrieve the filename sent by the client.
         *
         * Do not trust the value returned by this method. A client could send
         * a malicious filename with the intention to corrupt or hack your
         * application.
         *
         * Implementations SHOULD return the value stored in the "name" key of
         * the file in the $_FILES array.
         *
         * @return string|null The filename sent by the client or null if none
         *     was provided.
         */
        public function getClientFilename(): ?string;
        /**
         * Retrieve the media type sent by the client.
         *
         * Do not trust the value returned by this method. A client could send
         * a malicious media type with the intention to corrupt or hack your
         * application.
         *
         * Implementations SHOULD return the value stored in the "type" key of
         * the file in the $_FILES array.
         *
         * @return string|null The media type sent by the client or null if none
         *     was provided.
         */
        public function getClientMediaType(): ?string;
    }
}
namespace GuzzleHttp\Psr7 {
    class UploadedFile implements \Psr\Http\Message\UploadedFileInterface
    {
        /**
         * @param StreamInterface|string|resource $streamOrFile
         */
        public function __construct($streamOrFile, ?int $size, int $errorStatus, ?string $clientFilename = null, ?string $clientMediaType = null)
        {
        }
        public function isMoved(): bool
        {
        }
        public function getStream(): \Psr\Http\Message\StreamInterface
        {
        }
        public function moveTo($targetPath): void
        {
        }
        public function getSize(): ?int
        {
        }
        public function getError(): int
        {
        }
        public function getClientFilename(): ?string
        {
        }
        public function getClientMediaType(): ?string
        {
        }
    }
}
namespace Psr\Http\Message {
    /**
     * Value object representing a URI.
     *
     * This interface is meant to represent URIs according to RFC 3986 and to
     * provide methods for most common operations. Additional functionality for
     * working with URIs can be provided on top of the interface or externally.
     * Its primary use is for HTTP requests, but may also be used in other
     * contexts.
     *
     * Instances of this interface are considered immutable; all methods that
     * might change state MUST be implemented such that they retain the internal
     * state of the current instance and return an instance that contains the
     * changed state.
     *
     * Typically the Host header will be also be present in the request message.
     * For server-side requests, the scheme will typically be discoverable in the
     * server parameters.
     *
     * @link http://tools.ietf.org/html/rfc3986 (the URI specification)
     */
    interface UriInterface
    {
        /**
         * Retrieve the scheme component of the URI.
         *
         * If no scheme is present, this method MUST return an empty string.
         *
         * The value returned MUST be normalized to lowercase, per RFC 3986
         * Section 3.1.
         *
         * The trailing ":" character is not part of the scheme and MUST NOT be
         * added.
         *
         * @see https://tools.ietf.org/html/rfc3986#section-3.1
         * @return string The URI scheme.
         */
        public function getScheme(): string;
        /**
         * Retrieve the authority component of the URI.
         *
         * If no authority information is present, this method MUST return an empty
         * string.
         *
         * The authority syntax of the URI is:
         *
         * <pre>
         * [user-info@]host[:port]
         * </pre>
         *
         * If the port component is not set or is the standard port for the current
         * scheme, it SHOULD NOT be included.
         *
         * @see https://tools.ietf.org/html/rfc3986#section-3.2
         * @return string The URI authority, in "[user-info@]host[:port]" format.
         */
        public function getAuthority(): string;
        /**
         * Retrieve the user information component of the URI.
         *
         * If no user information is present, this method MUST return an empty
         * string.
         *
         * If a user is present in the URI, this will return that value;
         * additionally, if the password is also present, it will be appended to the
         * user value, with a colon (":") separating the values.
         *
         * The trailing "@" character is not part of the user information and MUST
         * NOT be added.
         *
         * @return string The URI user information, in "username[:password]" format.
         */
        public function getUserInfo(): string;
        /**
         * Retrieve the host component of the URI.
         *
         * If no host is present, this method MUST return an empty string.
         *
         * The value returned MUST be normalized to lowercase, per RFC 3986
         * Section 3.2.2.
         *
         * @see http://tools.ietf.org/html/rfc3986#section-3.2.2
         * @return string The URI host.
         */
        public function getHost(): string;
        /**
         * Retrieve the port component of the URI.
         *
         * If a port is present, and it is non-standard for the current scheme,
         * this method MUST return it as an integer. If the port is the standard port
         * used with the current scheme, this method SHOULD return null.
         *
         * If no port is present, and no scheme is present, this method MUST return
         * a null value.
         *
         * If no port is present, but a scheme is present, this method MAY return
         * the standard port for that scheme, but SHOULD return null.
         *
         * @return null|int The URI port.
         */
        public function getPort(): ?int;
        /**
         * Retrieve the path component of the URI.
         *
         * The path can either be empty or absolute (starting with a slash) or
         * rootless (not starting with a slash). Implementations MUST support all
         * three syntaxes.
         *
         * Normally, the empty path "" and absolute path "/" are considered equal as
         * defined in RFC 7230 Section 2.7.3. But this method MUST NOT automatically
         * do this normalization because in contexts with a trimmed base path, e.g.
         * the front controller, this difference becomes significant. It's the task
         * of the user to handle both "" and "/".
         *
         * The value returned MUST be percent-encoded, but MUST NOT double-encode
         * any characters. To determine what characters to encode, please refer to
         * RFC 3986, Sections 2 and 3.3.
         *
         * As an example, if the value should include a slash ("/") not intended as
         * delimiter between path segments, that value MUST be passed in encoded
         * form (e.g., "%2F") to the instance.
         *
         * @see https://tools.ietf.org/html/rfc3986#section-2
         * @see https://tools.ietf.org/html/rfc3986#section-3.3
         * @return string The URI path.
         */
        public function getPath(): string;
        /**
         * Retrieve the query string of the URI.
         *
         * If no query string is present, this method MUST return an empty string.
         *
         * The leading "?" character is not part of the query and MUST NOT be
         * added.
         *
         * The value returned MUST be percent-encoded, but MUST NOT double-encode
         * any characters. To determine what characters to encode, please refer to
         * RFC 3986, Sections 2 and 3.4.
         *
         * As an example, if a value in a key/value pair of the query string should
         * include an ampersand ("&") not intended as a delimiter between values,
         * that value MUST be passed in encoded form (e.g., "%26") to the instance.
         *
         * @see https://tools.ietf.org/html/rfc3986#section-2
         * @see https://tools.ietf.org/html/rfc3986#section-3.4
         * @return string The URI query string.
         */
        public function getQuery(): string;
        /**
         * Retrieve the fragment component of the URI.
         *
         * If no fragment is present, this method MUST return an empty string.
         *
         * The leading "#" character is not part of the fragment and MUST NOT be
         * added.
         *
         * The value returned MUST be percent-encoded, but MUST NOT double-encode
         * any characters. To determine what characters to encode, please refer to
         * RFC 3986, Sections 2 and 3.5.
         *
         * @see https://tools.ietf.org/html/rfc3986#section-2
         * @see https://tools.ietf.org/html/rfc3986#section-3.5
         * @return string The URI fragment.
         */
        public function getFragment(): string;
        /**
         * Return an instance with the specified scheme.
         *
         * This method MUST retain the state of the current instance, and return
         * an instance that contains the specified scheme.
         *
         * Implementations MUST support the schemes "http" and "https" case
         * insensitively, and MAY accommodate other schemes if required.
         *
         * An empty scheme is equivalent to removing the scheme.
         *
         * @param string $scheme The scheme to use with the new instance.
         * @return static A new instance with the specified scheme.
         * @throws \InvalidArgumentException for invalid or unsupported schemes.
         */
        public function withScheme(string $scheme): \Psr\Http\Message\UriInterface;
        /**
         * Return an instance with the specified user information.
         *
         * This method MUST retain the state of the current instance, and return
         * an instance that contains the specified user information.
         *
         * Password is optional, but the user information MUST include the
         * user; an empty string for the user is equivalent to removing user
         * information.
         *
         * @param string $user The user name to use for authority.
         * @param null|string $password The password associated with $user.
         * @return static A new instance with the specified user information.
         */
        public function withUserInfo(string $user, ?string $password = null): \Psr\Http\Message\UriInterface;
        /**
         * Return an instance with the specified host.
         *
         * This method MUST retain the state of the current instance, and return
         * an instance that contains the specified host.
         *
         * An empty host value is equivalent to removing the host.
         *
         * @param string $host The hostname to use with the new instance.
         * @return static A new instance with the specified host.
         * @throws \InvalidArgumentException for invalid hostnames.
         */
        public function withHost(string $host): \Psr\Http\Message\UriInterface;
        /**
         * Return an instance with the specified port.
         *
         * This method MUST retain the state of the current instance, and return
         * an instance that contains the specified port.
         *
         * Implementations MUST raise an exception for ports outside the
         * established TCP and UDP port ranges.
         *
         * A null value provided for the port is equivalent to removing the port
         * information.
         *
         * @param null|int $port The port to use with the new instance; a null value
         *     removes the port information.
         * @return static A new instance with the specified port.
         * @throws \InvalidArgumentException for invalid ports.
         */
        public function withPort(?int $port): \Psr\Http\Message\UriInterface;
        /**
         * Return an instance with the specified path.
         *
         * This method MUST retain the state of the current instance, and return
         * an instance that contains the specified path.
         *
         * The path can either be empty or absolute (starting with a slash) or
         * rootless (not starting with a slash). Implementations MUST support all
         * three syntaxes.
         *
         * If the path is intended to be domain-relative rather than path relative then
         * it must begin with a slash ("/"). Paths not starting with a slash ("/")
         * are assumed to be relative to some base path known to the application or
         * consumer.
         *
         * Users can provide both encoded and decoded path characters.
         * Implementations ensure the correct encoding as outlined in getPath().
         *
         * @param string $path The path to use with the new instance.
         * @return static A new instance with the specified path.
         * @throws \InvalidArgumentException for invalid paths.
         */
        public function withPath(string $path): \Psr\Http\Message\UriInterface;
        /**
         * Return an instance with the specified query string.
         *
         * This method MUST retain the state of the current instance, and return
         * an instance that contains the specified query string.
         *
         * Users can provide both encoded and decoded query characters.
         * Implementations ensure the correct encoding as outlined in getQuery().
         *
         * An empty query string value is equivalent to removing the query string.
         *
         * @param string $query The query string to use with the new instance.
         * @return static A new instance with the specified query string.
         * @throws \InvalidArgumentException for invalid query strings.
         */
        public function withQuery(string $query): \Psr\Http\Message\UriInterface;
        /**
         * Return an instance with the specified URI fragment.
         *
         * This method MUST retain the state of the current instance, and return
         * an instance that contains the specified URI fragment.
         *
         * Users can provide both encoded and decoded fragment characters.
         * Implementations ensure the correct encoding as outlined in getFragment().
         *
         * An empty fragment value is equivalent to removing the fragment.
         *
         * @param string $fragment The fragment to use with the new instance.
         * @return static A new instance with the specified fragment.
         */
        public function withFragment(string $fragment): \Psr\Http\Message\UriInterface;
        /**
         * Return the string representation as a URI reference.
         *
         * Depending on which components of the URI are present, the resulting
         * string is either a full URI or relative reference according to RFC 3986,
         * Section 4.1. The method concatenates the various components of the URI,
         * using the appropriate delimiters:
         *
         * - If a scheme is present, it MUST be suffixed by ":".
         * - If an authority is present, it MUST be prefixed by "//".
         * - The path can be concatenated without delimiters. But there are two
         *   cases where the path has to be adjusted to make the URI reference
         *   valid as PHP does not allow to throw an exception in __toString():
         *     - If the path is rootless and an authority is present, the path MUST
         *       be prefixed by "/".
         *     - If the path is starting with more than one "/" and no authority is
         *       present, the starting slashes MUST be reduced to one.
         * - If a query is present, it MUST be prefixed by "?".
         * - If a fragment is present, it MUST be prefixed by "#".
         *
         * @see http://tools.ietf.org/html/rfc3986#section-4.1
         * @return string
         */
        public function __toString(): string;
    }
}
namespace GuzzleHttp\Psr7 {
    /**
     * PSR-7 URI implementation.
     *
     * @author Michael Dowling
     * @author Tobias Schultze
     * @author Matthew Weier O'Phinney
     */
    class Uri implements \Psr\Http\Message\UriInterface, \JsonSerializable
    {
        public function __construct(string $uri = '')
        {
        }
        public function __toString(): string
        {
        }
        /**
         * Composes a URI reference string from its various components.
         *
         * Usually this method does not need to be called manually but instead is used indirectly via
         * `Psr\Http\Message\UriInterface::__toString`.
         *
         * PSR-7 UriInterface treats an empty component the same as a missing component as
         * getQuery(), getFragment() etc. always return a string. This explains the slight
         * difference to RFC 3986 Section 5.3.
         *
         * Another adjustment is that the authority separator is added even when the authority is missing/empty
         * for the "file" scheme. This is because PHP stream functions like `file_get_contents` only work with
         * `file:///myfile` but not with `file:/myfile` although they are equivalent according to RFC 3986. But
         * `file:///` is the more common syntax for the file scheme anyway (Chrome for example redirects to
         * that format).
         *
         * @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.3
         */
        public static function composeComponents(?string $scheme, ?string $authority, string $path, ?string $query, ?string $fragment): string
        {
        }
        /**
         * Whether the URI has the default port of the current scheme.
         *
         * `Psr\Http\Message\UriInterface::getPort` may return null or the standard port. This method can be used
         * independently of the implementation.
         */
        public static function isDefaultPort(\Psr\Http\Message\UriInterface $uri): bool
        {
        }
        /**
         * Whether the URI is absolute, i.e. it has a scheme.
         *
         * An instance of UriInterface can either be an absolute URI or a relative reference. This method returns true
         * if it is the former. An absolute URI has a scheme. A relative reference is used to express a URI relative
         * to another URI, the base URI. Relative references can be divided into several forms:
         * - network-path references, e.g. '//example.com/path'
         * - absolute-path references, e.g. '/path'
         * - relative-path references, e.g. 'subpath'
         *
         * @see Uri::isNetworkPathReference
         * @see Uri::isAbsolutePathReference
         * @see Uri::isRelativePathReference
         * @see https://datatracker.ietf.org/doc/html/rfc3986#section-4
         */
        public static function isAbsolute(\Psr\Http\Message\UriInterface $uri): bool
        {
        }
        /**
         * Whether the URI is a network-path reference.
         *
         * A relative reference that begins with two slash characters is termed an network-path reference.
         *
         * @see https://datatracker.ietf.org/doc/html/rfc3986#section-4.2
         */
        public static function isNetworkPathReference(\Psr\Http\Message\UriInterface $uri): bool
        {
        }
        /**
         * Whether the URI is a absolute-path reference.
         *
         * A relative reference that begins with a single slash character is termed an absolute-path reference.
         *
         * @see https://datatracker.ietf.org/doc/html/rfc3986#section-4.2
         */
        public static function isAbsolutePathReference(\Psr\Http\Message\UriInterface $uri): bool
        {
        }
        /**
         * Whether the URI is a relative-path reference.
         *
         * A relative reference that does not begin with a slash character is termed a relative-path reference.
         *
         * @see https://datatracker.ietf.org/doc/html/rfc3986#section-4.2
         */
        public static function isRelativePathReference(\Psr\Http\Message\UriInterface $uri): bool
        {
        }
        /**
         * Whether the URI is a same-document reference.
         *
         * A same-document reference refers to a URI that is, aside from its fragment
         * component, identical to the base URI. When no base URI is given, only an empty
         * URI reference (apart from its fragment) is considered a same-document reference.
         *
         * @param UriInterface      $uri  The URI to check
         * @param UriInterface|null $base An optional base URI to compare against
         *
         * @see https://datatracker.ietf.org/doc/html/rfc3986#section-4.4
         */
        public static function isSameDocumentReference(\Psr\Http\Message\UriInterface $uri, ?\Psr\Http\Message\UriInterface $base = null): bool
        {
        }
        /**
         * Creates a new URI with a specific query string value removed.
         *
         * Any existing query string values that exactly match the provided key are
         * removed.
         *
         * @param UriInterface $uri URI to use as a base.
         * @param string       $key Query string key to remove.
         */
        public static function withoutQueryValue(\Psr\Http\Message\UriInterface $uri, string $key): \Psr\Http\Message\UriInterface
        {
        }
        /**
         * Creates a new URI with a specific query string value.
         *
         * Any existing query string values that exactly match the provided key are
         * removed and replaced with the given key value pair.
         *
         * A value of null will set the query string key without a value, e.g. "key"
         * instead of "key=value".
         *
         * @param UriInterface $uri   URI to use as a base.
         * @param string       $key   Key to set.
         * @param string|null  $value Value to set
         */
        public static function withQueryValue(\Psr\Http\Message\UriInterface $uri, string $key, ?string $value): \Psr\Http\Message\UriInterface
        {
        }
        /**
         * Creates a new URI with multiple specific query string values.
         *
         * It has the same behavior as withQueryValue() but for an associative array of key => value.
         *
         * @param UriInterface    $uri           URI to use as a base.
         * @param (string|null)[] $keyValueArray Associative array of key and values
         */
        public static function withQueryValues(\Psr\Http\Message\UriInterface $uri, array $keyValueArray): \Psr\Http\Message\UriInterface
        {
        }
        /**
         * Creates a URI from a hash of `parse_url` components.
         *
         * @see https://www.php.net/manual/en/function.parse-url.php
         *
         * @throws MalformedUriException If the components do not form a valid URI.
         */
        public static function fromParts(array $parts): \Psr\Http\Message\UriInterface
        {
        }
        public function getScheme(): string
        {
        }
        public function getAuthority(): string
        {
        }
        public function getUserInfo(): string
        {
        }
        public function getHost(): string
        {
        }
        public function getPort(): ?int
        {
        }
        public function getPath(): string
        {
        }
        public function getQuery(): string
        {
        }
        public function getFragment(): string
        {
        }
        public function withScheme($scheme): \Psr\Http\Message\UriInterface
        {
        }
        public function withUserInfo($user, $password = null): \Psr\Http\Message\UriInterface
        {
        }
        public function withHost($host): \Psr\Http\Message\UriInterface
        {
        }
        public function withPort($port): \Psr\Http\Message\UriInterface
        {
        }
        public function withPath($path): \Psr\Http\Message\UriInterface
        {
        }
        public function withQuery($query): \Psr\Http\Message\UriInterface
        {
        }
        public function withFragment($fragment): \Psr\Http\Message\UriInterface
        {
        }
        public function jsonSerialize(): string
        {
        }
    }
    /**
     * Provides methods to determine if a modified URL should be considered cross-origin.
     *
     * @author Graham Campbell
     */
    final class UriComparator
    {
        /**
         * Determines if a modified URL should be considered cross-origin with
         * respect to an original URL.
         */
        public static function isCrossOrigin(\Psr\Http\Message\UriInterface $original, \Psr\Http\Message\UriInterface $modified): bool
        {
        }
    }
    /**
     * Provides methods to normalize and compare URIs.
     *
     * @author Tobias Schultze
     *
     * @see https://datatracker.ietf.org/doc/html/rfc3986#section-6
     */
    final class UriNormalizer
    {
        /**
         * Default normalizations which only include the ones that preserve semantics.
         */
        public const PRESERVING_NORMALIZATIONS = self::CAPITALIZE_PERCENT_ENCODING | self::DECODE_UNRESERVED_CHARACTERS | self::CONVERT_EMPTY_PATH | self::REMOVE_DEFAULT_HOST | self::REMOVE_DEFAULT_PORT | self::REMOVE_DOT_SEGMENTS;
        /**
         * All letters within a percent-encoding triplet (e.g., "%3A") are case-insensitive, and should be capitalized.
         *
         * Example: http://example.org/a%c2%b1b → http://example.org/a%C2%B1b
         */
        public const CAPITALIZE_PERCENT_ENCODING = 1;
        /**
         * Decodes percent-encoded octets of unreserved characters.
         *
         * For consistency, percent-encoded octets in the ranges of ALPHA (%41–%5A and %61–%7A), DIGIT (%30–%39),
         * hyphen (%2D), period (%2E), underscore (%5F), or tilde (%7E) should not be created by URI producers and,
         * when found in a URI, should be decoded to their corresponding unreserved characters by URI normalizers.
         *
         * Example: http://example.org/%7Eusern%61me/ → http://example.org/~username/
         */
        public const DECODE_UNRESERVED_CHARACTERS = 2;
        /**
         * Converts the empty path to "/" for http and https URIs.
         *
         * Example: http://example.org → http://example.org/
         */
        public const CONVERT_EMPTY_PATH = 4;
        /**
         * Removes the default host of the given URI scheme from the URI.
         *
         * Only the "file" scheme defines the default host "localhost".
         * All of `file:/myfile`, `file:///myfile`, and `file://localhost/myfile`
         * are equivalent according to RFC 3986. The first format is not accepted
         * by PHPs stream functions and thus already normalized implicitly to the
         * second format in the Uri class. See `GuzzleHttp\Psr7\Uri::composeComponents`.
         *
         * Example: file://localhost/myfile → file:///myfile
         */
        public const REMOVE_DEFAULT_HOST = 8;
        /**
         * Removes the default port of the given URI scheme from the URI.
         *
         * Example: http://example.org:80/ → http://example.org/
         */
        public const REMOVE_DEFAULT_PORT = 16;
        /**
         * Removes unnecessary dot-segments.
         *
         * Dot-segments in relative-path references are not removed as it would
         * change the semantics of the URI reference.
         *
         * Example: http://example.org/../a/b/../c/./d.html → http://example.org/a/c/d.html
         */
        public const REMOVE_DOT_SEGMENTS = 32;
        /**
         * Paths which include two or more adjacent slashes are converted to one.
         *
         * Webservers usually ignore duplicate slashes and treat those URIs equivalent.
         * But in theory those URIs do not need to be equivalent. So this normalization
         * may change the semantics. Encoded slashes (%2F) are not removed.
         *
         * Example: http://example.org//foo///bar.html → http://example.org/foo/bar.html
         */
        public const REMOVE_DUPLICATE_SLASHES = 64;
        /**
         * Sort query parameters with their values in alphabetical order.
         *
         * However, the order of parameters in a URI may be significant (this is not defined by the standard).
         * So this normalization is not safe and may change the semantics of the URI.
         *
         * Example: ?lang=en&article=fred → ?article=fred&lang=en
         *
         * Note: The sorting is neither locale nor Unicode aware (the URI query does not get decoded at all) as the
         * purpose is to be able to compare URIs in a reproducible way, not to have the params sorted perfectly.
         */
        public const SORT_QUERY_PARAMETERS = 128;
        /**
         * Returns a normalized URI.
         *
         * The scheme and host component are already normalized to lowercase per PSR-7 UriInterface.
         * This methods adds additional normalizations that can be configured with the $flags parameter.
         *
         * PSR-7 UriInterface cannot distinguish between an empty component and a missing component as
         * getQuery(), getFragment() etc. always return a string. This means the URIs "/?#" and "/" are
         * treated equivalent which is not necessarily true according to RFC 3986. But that difference
         * is highly uncommon in reality. So this potential normalization is implied in PSR-7 as well.
         *
         * @param UriInterface $uri   The URI to normalize
         * @param int          $flags A bitmask of normalizations to apply, see constants
         *
         * @see https://datatracker.ietf.org/doc/html/rfc3986#section-6.2
         */
        public static function normalize(\Psr\Http\Message\UriInterface $uri, int $flags = self::PRESERVING_NORMALIZATIONS): \Psr\Http\Message\UriInterface
        {
        }
        /**
         * Whether two URIs can be considered equivalent.
         *
         * Both URIs are normalized automatically before comparison with the given $normalizations bitmask. The method also
         * accepts relative URI references and returns true when they are equivalent. This of course assumes they will be
         * resolved against the same base URI. If this is not the case, determination of equivalence or difference of
         * relative references does not mean anything.
         *
         * @param UriInterface $uri1           An URI to compare
         * @param UriInterface $uri2           An URI to compare
         * @param int          $normalizations A bitmask of normalizations to apply, see constants
         *
         * @see https://datatracker.ietf.org/doc/html/rfc3986#section-6.1
         */
        public static function isEquivalent(\Psr\Http\Message\UriInterface $uri1, \Psr\Http\Message\UriInterface $uri2, int $normalizations = self::PRESERVING_NORMALIZATIONS): bool
        {
        }
    }
    /**
     * Resolves a URI reference in the context of a base URI and the opposite way.
     *
     * @author Tobias Schultze
     *
     * @see https://datatracker.ietf.org/doc/html/rfc3986#section-5
     */
    final class UriResolver
    {
        /**
         * Removes dot segments from a path and returns the new path.
         *
         * @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4
         */
        public static function removeDotSegments(string $path): string
        {
        }
        /**
         * Converts the relative URI into a new URI that is resolved against the base URI.
         *
         * @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2
         */
        public static function resolve(\Psr\Http\Message\UriInterface $base, \Psr\Http\Message\UriInterface $rel): \Psr\Http\Message\UriInterface
        {
        }
        /**
         * Returns the target URI as a relative reference from the base URI.
         *
         * This method is the counterpart to resolve():
         *
         *    (string) $target === (string) UriResolver::resolve($base, UriResolver::relativize($base, $target))
         *
         * One use-case is to use the current request URI as base URI and then generate relative links in your documents
         * to reduce the document size or offer self-contained downloadable document archives.
         *
         *    $base = new Uri('http://example.com/a/b/');
         *    echo UriResolver::relativize($base, new Uri('http://example.com/a/b/c'));  // prints 'c'.
         *    echo UriResolver::relativize($base, new Uri('http://example.com/a/x/y'));  // prints '../x/y'.
         *    echo UriResolver::relativize($base, new Uri('http://example.com/a/b/?q')); // prints '?q'.
         *    echo UriResolver::relativize($base, new Uri('http://example.org/a/b/'));   // prints '//example.org/a/b/'.
         *
         * This method also accepts a target that is already relative and will try to relativize it further. Only a
         * relative-path reference will be returned as-is.
         *
         *    echo UriResolver::relativize($base, new Uri('/a/b/c'));  // prints 'c' as well
         */
        public static function relativize(\Psr\Http\Message\UriInterface $base, \Psr\Http\Message\UriInterface $target): \Psr\Http\Message\UriInterface
        {
        }
    }
    final class Utils
    {
        /**
         * Remove the items given by the keys, case insensitively from the data.
         *
         * @param (string|int)[] $keys
         */
        public static function caselessRemove(array $keys, array $data): array
        {
        }
        /**
         * Copy the contents of a stream into another stream until the given number
         * of bytes have been read.
         *
         * @param StreamInterface $source Stream to read from
         * @param StreamInterface $dest   Stream to write to
         * @param int             $maxLen Maximum number of bytes to read. Pass -1
         *                                to read the entire stream.
         *
         * @throws \RuntimeException on error.
         */
        public static function copyToStream(\Psr\Http\Message\StreamInterface $source, \Psr\Http\Message\StreamInterface $dest, int $maxLen = -1): void
        {
        }
        /**
         * Copy the contents of a stream into a string until the given number of
         * bytes have been read.
         *
         * @param StreamInterface $stream Stream to read
         * @param int             $maxLen Maximum number of bytes to read. Pass -1
         *                                to read the entire stream.
         *
         * @throws \RuntimeException on error.
         */
        public static function copyToString(\Psr\Http\Message\StreamInterface $stream, int $maxLen = -1): string
        {
        }
        /**
         * Calculate a hash of a stream.
         *
         * This method reads the entire stream to calculate a rolling hash, based
         * on PHP's `hash_init` functions.
         *
         * @param StreamInterface $stream    Stream to calculate the hash for
         * @param string          $algo      Hash algorithm (e.g. md5, crc32, etc)
         * @param bool            $rawOutput Whether or not to use raw output
         *
         * @throws \RuntimeException on error.
         */
        public static function hash(\Psr\Http\Message\StreamInterface $stream, string $algo, bool $rawOutput = false): string
        {
        }
        /**
         * Clone and modify a request with the given changes.
         *
         * This method is useful for reducing the number of clones needed to mutate
         * a message.
         *
         * The changes can be one of:
         * - method: (string) Changes the HTTP method.
         * - set_headers: (array) Sets the given headers.
         * - remove_headers: (array) Remove the given headers.
         * - body: (mixed) Sets the given body.
         * - uri: (UriInterface) Set the URI.
         * - query: (string) Set the query string value of the URI.
         * - version: (string) Set the protocol version.
         *
         * @param RequestInterface $request Request to clone and modify.
         * @param array            $changes Changes to apply.
         */
        public static function modifyRequest(\Psr\Http\Message\RequestInterface $request, array $changes): \Psr\Http\Message\RequestInterface
        {
        }
        /**
         * Read a line from the stream up to the maximum allowed buffer length.
         *
         * @param StreamInterface $stream    Stream to read from
         * @param int|null        $maxLength Maximum buffer length
         */
        public static function readLine(\Psr\Http\Message\StreamInterface $stream, ?int $maxLength = null): string
        {
        }
        /**
         * Redact the password in the user info part of a URI.
         */
        public static function redactUserInfo(\Psr\Http\Message\UriInterface $uri): \Psr\Http\Message\UriInterface
        {
        }
        /**
         * Create a new stream based on the input type.
         *
         * Options is an associative array that can contain the following keys:
         * - metadata: Array of custom metadata.
         * - size: Size of the stream.
         *
         * This method accepts the following `$resource` types:
         * - `Psr\Http\Message\StreamInterface`: Returns the value as-is.
         * - `string`: Creates a stream object that uses the given string as the contents.
         * - `resource`: Creates a stream object that wraps the given PHP stream resource.
         * - `Iterator`: If the provided value implements `Iterator`, then a read-only
         *   stream object will be created that wraps the given iterable. Each time the
         *   stream is read from, data from the iterator will fill a buffer and will be
         *   continuously called until the buffer is equal to the requested read size.
         *   Subsequent read calls will first read from the buffer and then call `next`
         *   on the underlying iterator until it is exhausted.
         * - `object` with `__toString()`: If the object has the `__toString()` method,
         *   the object will be cast to a string and then a stream will be returned that
         *   uses the string value.
         * - `NULL`: When `null` is passed, an empty stream object is returned.
         * - `callable` When a callable is passed, a read-only stream object will be
         *   created that invokes the given callable. The callable is invoked with the
         *   number of suggested bytes to read. The callable can return any number of
         *   bytes, but MUST return `false` when there is no more data to return. The
         *   stream object that wraps the callable will invoke the callable until the
         *   number of requested bytes are available. Any additional bytes will be
         *   buffered and used in subsequent reads.
         *
         * @param resource|string|int|float|bool|StreamInterface|callable|\Iterator|null $resource Entity body data
         * @param array{size?: int, metadata?: array}                                    $options  Additional options
         *
         * @throws \InvalidArgumentException if the $resource arg is not valid.
         */
        public static function streamFor($resource = '', array $options = []): \Psr\Http\Message\StreamInterface
        {
        }
        /**
         * Safely opens a PHP stream resource using a filename.
         *
         * When fopen fails, PHP normally raises a warning. This function adds an
         * error handler that checks for errors and throws an exception instead.
         *
         * @param string $filename File to open
         * @param string $mode     Mode used to open the file
         *
         * @return resource
         *
         * @throws \RuntimeException if the file cannot be opened
         */
        public static function tryFopen(string $filename, string $mode)
        {
        }
        /**
         * Safely gets the contents of a given stream.
         *
         * When stream_get_contents fails, PHP normally raises a warning. This
         * function adds an error handler that checks for errors and throws an
         * exception instead.
         *
         * @param resource $stream
         *
         * @throws \RuntimeException if the stream cannot be read
         */
        public static function tryGetContents($stream): string
        {
        }
        /**
         * Returns a UriInterface for the given value.
         *
         * This function accepts a string or UriInterface and returns a
         * UriInterface for the given value. If the value is already a
         * UriInterface, it is returned as-is.
         *
         * @param string|UriInterface $uri
         *
         * @throws \InvalidArgumentException
         */
        public static function uriFor($uri): \Psr\Http\Message\UriInterface
        {
        }
    }
}
namespace hollodotme\FastCGI {
    class Client
    {
        public function __construct()
        {
        }
        /**
         * @param ConfiguresSocketConnection $connection
         * @param ProvidesRequestData        $request
         *
         * @return ProvidesResponseData
         * @throws Throwable
         * @throws TimedoutException
         * @throws WriteFailedException
         * @throws ConnectException
         */
        public function sendRequest(\hollodotme\FastCGI\Interfaces\ConfiguresSocketConnection $connection, \hollodotme\FastCGI\Interfaces\ProvidesRequestData $request): \hollodotme\FastCGI\Interfaces\ProvidesResponseData
        {
        }
        /**
         * @param ConfiguresSocketConnection $connection
         * @param ProvidesRequestData        $request
         *
         * @return int SocketId
         *
         * @throws TimedoutException
         * @throws WriteFailedException
         * @throws ConnectException
         */
        public function sendAsyncRequest(\hollodotme\FastCGI\Interfaces\ConfiguresSocketConnection $connection, \hollodotme\FastCGI\Interfaces\ProvidesRequestData $request): int
        {
        }
        /**
         * @param int      $socketId
         * @param int|null $timeoutMs
         *
         * @return ProvidesResponseData
         * @throws Throwable
         */
        public function readResponse(int $socketId, ?int $timeoutMs = null): \hollodotme\FastCGI\Interfaces\ProvidesResponseData
        {
        }
        /**
         * @param int      $socketId
         * @param int|null $timeoutMs
         *
         * @throws ReadFailedException
         */
        public function waitForResponse(int $socketId, ?int $timeoutMs = null): void
        {
        }
        /**
         * @param int|null $timeoutMs
         *
         * @throws ReadFailedException
         * @throws Throwable
         */
        public function waitForResponses(?int $timeoutMs = null): void
        {
        }
        /**
         * @return bool
         */
        public function hasUnhandledResponses(): bool
        {
        }
        /**
         * @param int $socketId
         *
         * @return bool
         * @throws ReadFailedException
         */
        public function hasResponse(int $socketId): bool
        {
        }
        /**
         * @return array<int>
         * @throws ReadFailedException
         */
        public function getSocketIdsHavingResponse(): array
        {
        }
        /**
         * @param int|null $timeoutMs
         * @param int      ...$socketIds
         *
         * @return Generator|ProvidesResponseData[]
         */
        public function readResponses(?int $timeoutMs = null, int ...$socketIds): \Generator
        {
        }
        /**
         * @param int|null $timeoutMs
         *
         * @return Generator|ProvidesResponseData[]
         * @throws ReadFailedException
         */
        public function readReadyResponses(?int $timeoutMs = null): \Generator
        {
        }
        /**
         * @param int      $socketId
         * @param int|null $timeoutMs
         *
         * @throws ReadFailedException
         */
        public function handleResponse(int $socketId, ?int $timeoutMs = null): void
        {
        }
        /**
         * @param int|null $timeoutMs
         * @param int      ...$socketIds
         *
         * @throws ReadFailedException
         */
        public function handleResponses(?int $timeoutMs = null, int ...$socketIds): void
        {
        }
        /**
         * @param int|null $timeoutMs
         *
         * @throws ReadFailedException
         */
        public function handleReadyResponses(?int $timeoutMs = null): void
        {
        }
    }
}
namespace hollodotme\FastCGI\Constants {
    /**
     * Class RequestMethod
     * @package hollodotme\FastCGI\Constants
     */
    abstract class RequestMethod
    {
        public const GET = 'GET';
        public const POST = 'POST';
        public const PUT = 'PUT';
        public const PATCH = 'PATCH';
        public const DELETE = 'DELETE';
    }
    /**
     * Class ServerProtocol
     * @package hollodotme\FastCGI\Constants
     */
    abstract class ServerProtocol
    {
        public const HTTP_1_0 = 'HTTP/1.0';
        public const HTTP_1_1 = 'HTTP/1.1';
    }
}
namespace hollodotme\FastCGI\Interfaces {
    /**
     * Class NameValuePairEncoder
     * @package hollodotme\FastCGI\Encoders
     */
    interface EncodesNameValuePair
    {
        /**
         * @param array<mixed, mixed> $pairs
         *
         * @return string
         */
        public function encodePairs(array $pairs): string;
        public function encodePair(string $name, string $value): string;
        /**
         * @param string $data
         * @param int    $length
         *
         * @return array<string, string>
         */
        public function decodePairs(string $data, int $length = -1): array;
    }
}
namespace hollodotme\FastCGI\Encoders {
    /**
     * Class NameValuePairEncoder
     * @package hollodotme\FastCGI\Encoders
     */
    final class NameValuePairEncoder implements \hollodotme\FastCGI\Interfaces\EncodesNameValuePair
    {
        /**
         * @param array<mixed, mixed> $pairs
         *
         * @return string
         */
        public function encodePairs(array $pairs): string
        {
        }
        public function encodePair(string $name, string $value): string
        {
        }
        /**
         * @param string $data
         * @param int    $length
         *
         * @return array<string, string>
         */
        public function decodePairs(string $data, int $length = -1): array
        {
        }
    }
}
namespace hollodotme\FastCGI\Interfaces {
    /**
     * Interface PacketEncoder
     * @package hollodotme\FastCGI\Encoders
     */
    interface EncodesPacket
    {
        public function encodePacket(int $type, string $content, int $requestId): string;
        /**
         * @param string $data
         *
         * @return array<string, int>
         */
        public function decodeHeader(string $data): array;
    }
}
namespace hollodotme\FastCGI\Encoders {
    /**
     * Class PacketEncoder
     * @package hollodotme\FastCGI\Encoders
     */
    final class PacketEncoder implements \hollodotme\FastCGI\Interfaces\EncodesPacket
    {
        public function encodePacket(int $type, string $content, int $requestId): string
        {
        }
        /**
         * @param string $data
         *
         * @return array<string, int>
         */
        public function decodeHeader(string $data): array
        {
        }
    }
}
namespace hollodotme\FastCGI\Exceptions {
    class FastCGIClientException extends \Exception
    {
    }
    class ConnectException extends \hollodotme\FastCGI\Exceptions\FastCGIClientException
    {
    }
    class ReadFailedException extends \hollodotme\FastCGI\Exceptions\FastCGIClientException
    {
    }
    class TimedoutException extends \hollodotme\FastCGI\Exceptions\FastCGIClientException
    {
    }
    class WriteFailedException extends \hollodotme\FastCGI\Exceptions\FastCGIClientException
    {
    }
}
namespace hollodotme\FastCGI\Interfaces {
    interface ComposesRequestContent
    {
        public function getContentType(): string;
        public function getContent(): string;
    }
    /**
     * Interface ConfiguresSocketConnection
     * @package hollodotme\FastCGI\Interfaces
     */
    interface ConfiguresSocketConnection
    {
        public function getSocketAddress(): string;
        public function getConnectTimeout(): int;
        public function getReadWriteTimeout(): int;
        public function equals(\hollodotme\FastCGI\Interfaces\ConfiguresSocketConnection $other): bool;
    }
    /**
     * Interface ProvidesRequestData
     * @package hollodotme\FastCGI\Interfaces
     */
    interface ProvidesRequestData
    {
        public function getGatewayInterface(): string;
        public function getRequestMethod(): string;
        public function getScriptFilename(): string;
        public function getServerSoftware(): string;
        public function getRemoteAddress(): string;
        public function getRemotePort(): int;
        public function getServerAddress(): string;
        public function getServerPort(): int;
        public function getServerName(): string;
        public function getServerProtocol(): string;
        public function getContentType(): string;
        public function getContentLength(): int;
        public function getContent(): string;
        /**
         * @return array<string, mixed>
         */
        public function getCustomVars(): array;
        /**
         * @return array<string, mixed>
         */
        public function getParams(): array;
        public function getRequestUri(): string;
        /**
         * @return array<callable>
         */
        public function getResponseCallbacks(): array;
        /**
         * @return array<callable>
         */
        public function getFailureCallbacks(): array;
        /**
         * @return array<callable>
         */
        public function getPassThroughCallbacks(): array;
    }
    /**
     * Interface ProvidesResponseData
     * @package hollodotme\FastCGI\Interfaces
     */
    interface ProvidesResponseData
    {
        /**
         * @return array<string, array<int,string>>
         */
        public function getHeaders(): array;
        /**
         * @param string $headerKey
         *
         * @return array<int, string>
         */
        public function getHeader(string $headerKey): array;
        public function getHeaderLine(string $headerKey): string;
        public function getBody(): string;
        public function getOutput(): string;
        public function getError(): string;
        public function getDuration(): float;
    }
}
namespace hollodotme\FastCGI\RequestContents {
    final class JsonData implements \hollodotme\FastCGI\Interfaces\ComposesRequestContent
    {
        /**
         * @param mixed $data
         * @param int   $options
         * @param int<1, max>   $depth
         */
        public function __construct($data, int $options = 0, int $depth = 512)
        {
        }
        public function getContentType(): string
        {
        }
        /**
         * @return string
         * @throws RuntimeException
         */
        public function getContent(): string
        {
        }
    }
    final class MultipartFormData implements \hollodotme\FastCGI\Interfaces\ComposesRequestContent
    {
        /**
         * @param array<string, string> $formData
         * @param array<string, string> $files
         *
         * @throws InvalidArgumentException
         */
        public function __construct(array $formData, array $files)
        {
        }
        /**
         * @param string $name
         * @param string $filePath
         *
         * @throws InvalidArgumentException
         */
        public function addFile(string $name, string $filePath): void
        {
        }
        public function getContentType(): string
        {
        }
        public function getContent(): string
        {
        }
    }
    final class UrlEncodedFormData implements \hollodotme\FastCGI\Interfaces\ComposesRequestContent
    {
        /**
         * @param array<string, mixed> $formData
         */
        public function __construct(array $formData)
        {
        }
        public function getContentType(): string
        {
        }
        public function getContent(): string
        {
        }
    }
}
namespace hollodotme\FastCGI\Requests {
    /**
     * Class AbstractRequest
     * @package hollodotme\FastCGI\Requests
     */
    abstract class AbstractRequest implements \hollodotme\FastCGI\Interfaces\ProvidesRequestData
    {
        public function __construct(string $scriptFilename, string $content)
        {
        }
        public function getServerSoftware(): string
        {
        }
        public function setServerSoftware(string $serverSoftware): void
        {
        }
        public function getRemoteAddress(): string
        {
        }
        public function setRemoteAddress(string $remoteAddress): void
        {
        }
        public function getRemotePort(): int
        {
        }
        public function setRemotePort(int $remotePort): void
        {
        }
        public function getServerAddress(): string
        {
        }
        public function setServerAddress(string $serverAddress): void
        {
        }
        public function getServerPort(): int
        {
        }
        public function setServerPort(int $serverPort): void
        {
        }
        public function getServerName(): string
        {
        }
        public function setServerName(string $serverName): void
        {
        }
        public function getServerProtocol(): string
        {
        }
        public function setServerProtocol(string $serverProtocol): void
        {
        }
        public function getContentType(): string
        {
        }
        public function setContentType(string $contentType): void
        {
        }
        public function getContent(): string
        {
        }
        public function setContent(string $content): void
        {
        }
        /**
         * @param string $key
         * @param mixed  $value
         */
        public function setCustomVar(string $key, $value): void
        {
        }
        /**
         * @param array<string, mixed> $vars
         */
        public function addCustomVars(array $vars): void
        {
        }
        public function resetCustomVars(): void
        {
        }
        /**
         * @return array<string, mixed>
         */
        public function getCustomVars(): array
        {
        }
        public function getGatewayInterface(): string
        {
        }
        public function getScriptFilename(): string
        {
        }
        public function getContentLength(): int
        {
        }
        /**
         * @return array<string, mixed>
         */
        public function getParams(): array
        {
        }
        public function getRequestUri(): string
        {
        }
        public function setRequestUri(string $requestUri): void
        {
        }
        /**
         * @return array<callable>
         */
        public function getResponseCallbacks(): array
        {
        }
        public function addResponseCallbacks(callable ...$callbacks): void
        {
        }
        /**
         * @return array<callable>
         */
        public function getFailureCallbacks(): array
        {
        }
        public function addFailureCallbacks(callable ...$callbacks): void
        {
        }
        /**
         * @return array<callable>
         */
        public function getPassThroughCallbacks(): array
        {
        }
        public function addPassThroughCallbacks(callable ...$callbacks): void
        {
        }
    }
    /**
     * Class DeleteRequest
     * @package hollodotme\FastCGI\Requests
     */
    class DeleteRequest extends \hollodotme\FastCGI\Requests\AbstractRequest
    {
        public static function newWithRequestContent(string $scriptFilename, \hollodotme\FastCGI\Interfaces\ComposesRequestContent $requestContent): \hollodotme\FastCGI\Requests\DeleteRequest
        {
        }
        public function getRequestMethod(): string
        {
        }
    }
    /**
     * Class GetRequest
     * @package hollodotme\FastCGI\Requests
     */
    class GetRequest extends \hollodotme\FastCGI\Requests\AbstractRequest
    {
        public static function newWithRequestContent(string $scriptFilename, \hollodotme\FastCGI\Interfaces\ComposesRequestContent $requestContent): \hollodotme\FastCGI\Requests\GetRequest
        {
        }
        public function getRequestMethod(): string
        {
        }
    }
    /**
     * Class PatchRequest
     * @package hollodotme\FastCGI\Requests
     */
    class PatchRequest extends \hollodotme\FastCGI\Requests\AbstractRequest
    {
        public static function newWithRequestContent(string $scriptFilename, \hollodotme\FastCGI\Interfaces\ComposesRequestContent $requestContent): \hollodotme\FastCGI\Requests\PatchRequest
        {
        }
        public function getRequestMethod(): string
        {
        }
    }
    /**
     * Class PostRequest
     * @package hollodotme\FastCGI\Requests
     */
    class PostRequest extends \hollodotme\FastCGI\Requests\AbstractRequest
    {
        public static function newWithRequestContent(string $scriptFilename, \hollodotme\FastCGI\Interfaces\ComposesRequestContent $requestContent): \hollodotme\FastCGI\Requests\PostRequest
        {
        }
        public function getRequestMethod(): string
        {
        }
    }
    /**
     * Class PutRequest
     * @package hollodotme\FastCGI\Requests
     */
    class PutRequest extends \hollodotme\FastCGI\Requests\AbstractRequest
    {
        public static function newWithRequestContent(string $scriptFilename, \hollodotme\FastCGI\Interfaces\ComposesRequestContent $requestContent): \hollodotme\FastCGI\Requests\PutRequest
        {
        }
        public function getRequestMethod(): string
        {
        }
    }
}
namespace hollodotme\FastCGI\Responses {
    /**
     * Class Response
     * @package hollodotme\FastCGI\Responses
     */
    class Response implements \hollodotme\FastCGI\Interfaces\ProvidesResponseData
    {
        public function __construct(string $output, string $error, float $duration)
        {
        }
        public function getHeader(string $headerKey): array
        {
        }
        public function getHeaderLine(string $headerKey): string
        {
        }
        public function getHeaders(): array
        {
        }
        public function getBody(): string
        {
        }
        public function getOutput(): string
        {
        }
        public function getError(): string
        {
        }
        public function getDuration(): float
        {
        }
    }
}
namespace hollodotme\FastCGI\SocketConnections {
    /**
     * Class Defaults
     * @package hollodotme\FastCGI\SocketConnections
     */
    abstract class Defaults
    {
        public const CONNECT_TIMEOUT = 5000;
        public const READ_WRITE_TIMEOUT = 5000;
    }
    class NetworkSocket implements \hollodotme\FastCGI\Interfaces\ConfiguresSocketConnection
    {
        public function __construct(string $host, int $port, int $connectTimeout = \hollodotme\FastCGI\SocketConnections\Defaults::CONNECT_TIMEOUT, int $readWriteTimeout = \hollodotme\FastCGI\SocketConnections\Defaults::READ_WRITE_TIMEOUT)
        {
        }
        public function getSocketAddress(): string
        {
        }
        public function getConnectTimeout(): int
        {
        }
        public function getReadWriteTimeout(): int
        {
        }
        public function equals(\hollodotme\FastCGI\Interfaces\ConfiguresSocketConnection $other): bool
        {
        }
    }
    /**
     * Class UnixDomainSocket
     * @package hollodotme\FastCGI\SocketConnections
     */
    class UnixDomainSocket implements \hollodotme\FastCGI\Interfaces\ConfiguresSocketConnection
    {
        public function __construct(string $socketPath, int $connectTimeout = \hollodotme\FastCGI\SocketConnections\Defaults::CONNECT_TIMEOUT, int $readWriteTimeout = \hollodotme\FastCGI\SocketConnections\Defaults::READ_WRITE_TIMEOUT)
        {
        }
        public function getSocketAddress(): string
        {
        }
        public function getConnectTimeout(): int
        {
        }
        public function getReadWriteTimeout(): int
        {
        }
        public function equals(\hollodotme\FastCGI\Interfaces\ConfiguresSocketConnection $other): bool
        {
        }
    }
}
namespace hollodotme\FastCGI\Sockets {
    final class Socket
    {
        public const STREAM_SELECT_USEC = 200000;
        /**
         * @param SocketId                   $socketId
         * @param ConfiguresSocketConnection $connection
         * @param EncodesPacket              $packetEncoder
         * @param EncodesNameValuePair       $nameValuePairEncoder
         *
         * @throws Exception
         */
        public function __construct(\hollodotme\FastCGI\Sockets\SocketId $socketId, \hollodotme\FastCGI\Interfaces\ConfiguresSocketConnection $connection, \hollodotme\FastCGI\Interfaces\EncodesPacket $packetEncoder, \hollodotme\FastCGI\Interfaces\EncodesNameValuePair $nameValuePairEncoder)
        {
        }
        public function getId(): int
        {
        }
        public function usesConnection(\hollodotme\FastCGI\Interfaces\ConfiguresSocketConnection $connection): bool
        {
        }
        public function hasResponse(): bool
        {
        }
        /**
         * @param ProvidesRequestData $request
         *
         * @throws ConnectException
         * @throws TimedoutException
         * @throws WriteFailedException
         */
        public function sendRequest(\hollodotme\FastCGI\Interfaces\ProvidesRequestData $request): void
        {
        }
        public function isIdle(): bool
        {
        }
        public function isUsable(): bool
        {
        }
        public function isBusy(): bool
        {
        }
        /**
         * @param int|null $timeoutMs
         *
         * @return ProvidesResponseData
         * @throws TimedoutException
         * @throws WriteFailedException
         * @throws ReadFailedException
         */
        public function fetchResponse(?int $timeoutMs = null): \hollodotme\FastCGI\Interfaces\ProvidesResponseData
        {
        }
        public function __destruct()
        {
        }
        public function notifyResponseCallbacks(\hollodotme\FastCGI\Interfaces\ProvidesResponseData $response): void
        {
        }
        public function notifyFailureCallbacks(\Throwable $throwable): void
        {
        }
        /**
         * @param array<int, resource> $resources
         */
        public function collectResource(array &$resources): void
        {
        }
    }
    final class SocketCollection implements \Countable
    {
        /**
         * @param ConfiguresSocketConnection $connection
         * @param EncodesPacket              $packetEncoder
         * @param EncodesNameValuePair       $nameValuePairEncoder
         *
         * @return Socket
         * @throws Exception
         * @throws WriteFailedException
         */
        public function new(\hollodotme\FastCGI\Interfaces\ConfiguresSocketConnection $connection, \hollodotme\FastCGI\Interfaces\EncodesPacket $packetEncoder, \hollodotme\FastCGI\Interfaces\EncodesNameValuePair $nameValuePairEncoder): \hollodotme\FastCGI\Sockets\Socket
        {
        }
        /**
         * @param int $socketId
         *
         * @return Socket
         * @throws ReadFailedException
         */
        public function getById(int $socketId): \hollodotme\FastCGI\Sockets\Socket
        {
        }
        /**
         * @param array<int, resource> $resources
         *
         * @return array<int>
         * @throws ReadFailedException
         */
        public function getSocketIdsByResources(array $resources): array
        {
        }
        /**
         * @param resource $resource
         *
         * @return Socket
         * @throws ReadFailedException
         */
        public function getByResource($resource): \hollodotme\FastCGI\Sockets\Socket
        {
        }
        public function remove(int $socketId): void
        {
        }
        public function getIdleSocket(\hollodotme\FastCGI\Interfaces\ConfiguresSocketConnection $connection): ?\hollodotme\FastCGI\Sockets\Socket
        {
        }
        public function hasBusySockets(): bool
        {
        }
        /**
         * @return array<int, resource>
         */
        public function collectResources(): array
        {
        }
        public function count(): int
        {
        }
        public function isEmpty(): bool
        {
        }
    }
    final class SocketId
    {
        /**
         * @return SocketId
         * @throws InvalidArgumentException
         * @throws Exception
         */
        public static function new(): self
        {
        }
        /**
         * @param int $id
         *
         * @return SocketId
         * @throws InvalidArgumentException
         */
        public static function fromInt(int $id): self
        {
        }
        public function getValue(): int
        {
        }
        public function equals(\hollodotme\FastCGI\Sockets\SocketId $other): bool
        {
        }
    }
}
namespace Http\Factory\Guzzle {
    class RequestFactory implements \Psr\Http\Message\RequestFactoryInterface
    {
        public function createRequest(string $method, $uri): \Psr\Http\Message\RequestInterface
        {
        }
    }
    class ResponseFactory implements \Psr\Http\Message\ResponseFactoryInterface
    {
        public function createResponse(int $code = 200, string $reasonPhrase = ''): \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class ServerRequestFactory implements \Psr\Http\Message\ServerRequestFactoryInterface
    {
        public function createServerRequest(string $method, $uri, array $serverParams = []): \Psr\Http\Message\ServerRequestInterface
        {
        }
    }
    class StreamFactory implements \Psr\Http\Message\StreamFactoryInterface
    {
        public function createStream(string $content = ''): \Psr\Http\Message\StreamInterface
        {
        }
        public function createStreamFromFile(string $file, string $mode = 'r'): \Psr\Http\Message\StreamInterface
        {
        }
        public function createStreamFromResource($resource): \Psr\Http\Message\StreamInterface
        {
        }
    }
    class UploadedFileFactory implements \Psr\Http\Message\UploadedFileFactoryInterface
    {
        public function createUploadedFile(\Psr\Http\Message\StreamInterface $stream, int $size = null, int $error = \UPLOAD_ERR_OK, string $clientFilename = null, string $clientMediaType = null): \Psr\Http\Message\UploadedFileInterface
        {
        }
    }
    class UriFactory implements \Psr\Http\Message\UriFactoryInterface
    {
        public function createUri(string $uri = ''): \Psr\Http\Message\UriInterface
        {
        }
    }
}
namespace Laminas\Diactoros {
    /**
     * Provides base functionality for request and response de/serialization
     * strategies, including functionality for retrieving a line at a time from
     * the message, splitting headers from the body, and serializing headers.
     */
    abstract class AbstractSerializer
    {
        public const CR = "\r";
        public const EOL = "\r\n";
        public const LF = "\n";
        /**
         * Retrieve a single line from the stream.
         *
         * Retrieves a line from the stream; a line is defined as a sequence of
         * characters ending in a CRLF sequence.
         *
         * @throws Exception\DeserializationException If the sequence contains a CR
         *     or LF in isolation, or ends in a CR.
         */
        protected static function getLine(\Psr\Http\Message\StreamInterface $stream): string
        {
        }
        /**
         * Split the stream into headers and body content.
         *
         * Returns an array containing two elements
         *
         * - The first is an array of headers
         * - The second is a StreamInterface containing the body content
         *
         * @throws Exception\DeserializationException For invalid headers.
         */
        protected static function splitStream(\Psr\Http\Message\StreamInterface $stream): array
        {
        }
        /**
         * Serialize headers to string values.
         *
         * @psalm-param array<string, string[]> $headers
         */
        protected static function serializeHeaders(array $headers): string
        {
        }
        /**
         * Filter a header name to wordcase
         *
         * @param string $header
         */
        protected static function filterHeader($header): string
        {
        }
    }
    /**
     * Implementation of PSR HTTP streams
     */
    class CallbackStream implements \Psr\Http\Message\StreamInterface, \Stringable
    {
        /** @var callable|null */
        protected $callback;
        /**
         * @throws Exception\InvalidArgumentException
         */
        public function __construct(callable $callback)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function __toString(): string
        {
        }
        /**
         * {@inheritdoc}
         */
        public function close(): void
        {
        }
        /**
         * {@inheritdoc}
         *
         * @return null|callable
         */
        public function detach(): ?callable
        {
        }
        /**
         * Attach a new callback to the instance.
         */
        public function attach(callable $callback): void
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getSize(): ?int
        {
        }
        /**
         * {@inheritdoc}
         */
        public function tell(): int
        {
        }
        /**
         * {@inheritdoc}
         */
        public function eof(): bool
        {
        }
        /**
         * {@inheritdoc}
         */
        public function isSeekable(): bool
        {
        }
        /**
         * {@inheritdoc}
         */
        public function seek(int $offset, int $whence = \SEEK_SET): void
        {
        }
        /**
         * {@inheritdoc}
         */
        public function rewind(): void
        {
        }
        /**
         * {@inheritdoc}
         */
        public function isWritable(): bool
        {
        }
        /**
         * {@inheritdoc}
         */
        public function write(string $string): int
        {
        }
        /**
         * {@inheritdoc}
         */
        public function isReadable(): bool
        {
        }
        /**
         * {@inheritdoc}
         */
        public function read(int $length): string
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getContents(): string
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getMetadata(?string $key = null)
        {
        }
    }
    class ConfigProvider
    {
        public const CONFIG_KEY = 'laminas-diactoros';
        public const X_FORWARDED = 'x-forwarded-request-filter';
        public const X_FORWARDED_TRUSTED_PROXIES = 'trusted-proxies';
        public const X_FORWARDED_TRUSTED_HEADERS = 'trusted-headers';
        /**
         * Retrieve configuration for laminas-diactoros.
         *
         * @return array
         */
        public function __invoke(): array
        {
        }
        /**
         * Returns the container dependencies.
         * Maps factory interfaces to factories.
         */
        public function getDependencies(): array
        {
        }
        public function getComponentConfig(): array
        {
        }
    }
}
namespace Laminas\Diactoros\Exception {
    /**
     * Marker interface for package-specific exceptions.
     */
    interface ExceptionInterface extends \Throwable
    {
    }
    class DeserializationException extends \UnexpectedValueException implements \Laminas\Diactoros\Exception\ExceptionInterface
    {
        public static function forInvalidHeader(): self
        {
        }
        public static function forInvalidHeaderContinuation(): self
        {
        }
        public static function forRequestFromArray(\Throwable $previous): self
        {
        }
        public static function forResponseFromArray(\Throwable $previous): self
        {
        }
        public static function forUnexpectedCarriageReturn(): self
        {
        }
        public static function forUnexpectedEndOfHeaders(): self
        {
        }
        public static function forUnexpectedLineFeed(): self
        {
        }
    }
    class InvalidArgumentException extends \InvalidArgumentException implements \Laminas\Diactoros\Exception\ExceptionInterface
    {
    }
    class RuntimeException extends \RuntimeException implements \Laminas\Diactoros\Exception\ExceptionInterface
    {
    }
    class InvalidForwardedHeaderNameException extends \Laminas\Diactoros\Exception\RuntimeException implements \Laminas\Diactoros\Exception\ExceptionInterface
    {
        public static function forHeader(mixed $name): self
        {
        }
    }
    class InvalidProxyAddressException extends \Laminas\Diactoros\Exception\RuntimeException implements \Laminas\Diactoros\Exception\ExceptionInterface
    {
        public static function forInvalidProxyArgument(mixed $proxy): self
        {
        }
        public static function forAddress(string $address): self
        {
        }
    }
    class InvalidStreamPointerPositionException extends \RuntimeException implements \Laminas\Diactoros\Exception\ExceptionInterface
    {
        /** {@inheritDoc} */
        public function __construct(string $message = 'Invalid pointer position', int $code = 0, ?\Throwable $previous = null)
        {
        }
    }
    class SerializationException extends \UnexpectedValueException implements \Laminas\Diactoros\Exception\ExceptionInterface
    {
        public static function forInvalidRequestLine(): self
        {
        }
        public static function forInvalidStatusLine(): self
        {
        }
    }
    class UnreadableStreamException extends \RuntimeException implements \Laminas\Diactoros\Exception\ExceptionInterface
    {
        public static function dueToConfiguration(): self
        {
        }
        public static function dueToMissingResource(): self
        {
        }
        public static function dueToPhpError(): self
        {
        }
        public static function forCallbackStream(): self
        {
        }
    }
    class UnrecognizedProtocolVersionException extends \UnexpectedValueException implements \Laminas\Diactoros\Exception\ExceptionInterface
    {
        public static function forVersion(string $version): self
        {
        }
    }
    class UnrewindableStreamException extends \RuntimeException implements \Laminas\Diactoros\Exception\ExceptionInterface
    {
        public static function forCallbackStream(): self
        {
        }
    }
    class UnseekableStreamException extends \RuntimeException implements \Laminas\Diactoros\Exception\ExceptionInterface
    {
        public static function dueToConfiguration(): self
        {
        }
        public static function dueToMissingResource(): self
        {
        }
        public static function dueToPhpError(): self
        {
        }
        public static function forCallbackStream(): self
        {
        }
    }
    class UntellableStreamException extends \RuntimeException implements \Laminas\Diactoros\Exception\ExceptionInterface
    {
        public static function dueToMissingResource(): self
        {
        }
        public static function dueToPhpError(): self
        {
        }
        public static function forCallbackStream(): self
        {
        }
    }
    class UnwritableStreamException extends \RuntimeException implements \Laminas\Diactoros\Exception\ExceptionInterface
    {
        public static function dueToConfiguration(): self
        {
        }
        public static function dueToMissingResource(): self
        {
        }
        public static function dueToPhpError(): self
        {
        }
        public static function forCallbackStream(): self
        {
        }
    }
    class UploadedFileAlreadyMovedException extends \RuntimeException implements \Laminas\Diactoros\Exception\ExceptionInterface
    {
        /** {@inheritDoc} */
        public function __construct(string $message = 'Cannot retrieve stream after it has already moved', int $code = 0, ?\Throwable $previous = null)
        {
        }
    }
    class UploadedFileErrorException extends \RuntimeException implements \Laminas\Diactoros\Exception\ExceptionInterface
    {
        public static function forUnmovableFile(): self
        {
        }
        public static function dueToStreamUploadError(string $error): self
        {
        }
        public static function dueToUnwritablePath(): self
        {
        }
        public static function dueToUnwritableTarget(string $targetDirectory): self
        {
        }
    }
}
namespace Laminas\Diactoros {
    /**
     * Provide security tools around HTTP headers to prevent common injection vectors.
     */
    final class HeaderSecurity
    {
        /**
         * Filter a header value
         *
         * Ensures CRLF header injection vectors are filtered.
         *
         * Per RFC 7230, only VISIBLE ASCII characters, spaces, and horizontal
         * tabs are allowed in values; header continuations MUST consist of
         * a single CRLF sequence followed by a space or horizontal tab.
         *
         * This method filters any values not allowed from the string, and is
         * lossy.
         *
         * @see http://en.wikipedia.org/wiki/HTTP_response_splitting
         */
        public static function filter(string $value): string
        {
        }
        /**
         * Validate a header value.
         *
         * Per RFC 7230, only VISIBLE ASCII characters, spaces, and horizontal
         * tabs are allowed in values; header continuations MUST consist of
         * a single CRLF sequence followed by a space or horizontal tab.
         *
         * @see http://en.wikipedia.org/wiki/HTTP_response_splitting
         *
         * @param string|int|float $value
         */
        public static function isValid($value): bool
        {
        }
        /**
         * Assert a header value is valid.
         *
         * @param mixed $value Value to be tested. This method asserts it is a string or number.
         * @throws Exception\InvalidArgumentException For invalid values.
         */
        public static function assertValid(mixed $value): void
        {
        }
        /**
         * Assert whether or not a header name is valid.
         *
         * @see http://tools.ietf.org/html/rfc7230#section-3.2
         *
         * @throws Exception\InvalidArgumentException
         */
        public static function assertValidName(mixed $name): void
        {
        }
    }
    /**
     * Trait implementing the various methods defined in MessageInterface.
     *
     * @see https://github.com/php-fig/http-message/tree/master/src/MessageInterface.php
     */
    trait MessageTrait
    {
        /**
         * List of all registered headers, as key => array of values.
         *
         * @var array
         * @psalm-var array<non-empty-string, list<string>>
         */
        protected $headers = [];
        /**
         * Map of normalized header name to original name used to register header.
         *
         * @var array
         * @psalm-var array<non-empty-string, non-empty-string>
         */
        protected $headerNames = [];
        /** @var string */
        private $protocol = '1.1';
        /** @var StreamInterface */
        private $stream;
        /**
         * Retrieves the HTTP protocol version as a string.
         *
         * The string MUST contain only the HTTP version number (e.g., "1.1", "1.0").
         *
         * @return string HTTP protocol version.
         */
        public function getProtocolVersion(): string
        {
        }
        /**
         * Return an instance with the specified HTTP protocol version.
         *
         * The version string MUST contain only the HTTP version number (e.g.,
         * "1.1", "1.0").
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * new protocol version.
         *
         * @param string $version HTTP protocol version
         * @return static
         */
        public function withProtocolVersion(string $version): \Psr\Http\Message\MessageInterface
        {
        }
        /**
         * Retrieves all message headers.
         *
         * The keys represent the header name as it will be sent over the wire, and
         * each value is an array of strings associated with the header.
         *
         *     // Represent the headers as a string
         *     foreach ($message->getHeaders() as $name => $values) {
         *         echo $name . ": " . implode(", ", $values);
         *     }
         *
         *     // Emit headers iteratively:
         *     foreach ($message->getHeaders() as $name => $values) {
         *         foreach ($values as $value) {
         *             header(sprintf('%s: %s', $name, $value), false);
         *         }
         *     }
         *
         * @return array Returns an associative array of the message's headers. Each
         *     key MUST be a header name, and each value MUST be an array of strings.
         * @psalm-return array<non-empty-string, list<string>>
         */
        public function getHeaders(): array
        {
        }
        /**
         * Checks if a header exists by the given case-insensitive name.
         *
         * @param string $header Case-insensitive header name.
         * @return bool Returns true if any header names match the given header
         *     name using a case-insensitive string comparison. Returns false if
         *     no matching header name is found in the message.
         */
        public function hasHeader(string $header): bool
        {
        }
        /**
         * Retrieves a message header value by the given case-insensitive name.
         *
         * This method returns an array of all the header values of the given
         * case-insensitive header name.
         *
         * If the header does not appear in the message, this method MUST return an
         * empty array.
         *
         * @param string $header Case-insensitive header field name.
         * @return string[] An array of string values as provided for the given
         *    header. If the header does not appear in the message, this method MUST
         *    return an empty array.
         */
        public function getHeader(string $header): array
        {
        }
        /**
         * Retrieves a comma-separated string of the values for a single header.
         *
         * This method returns all of the header values of the given
         * case-insensitive header name as a string concatenated together using
         * a comma.
         *
         * NOTE: Not all header values may be appropriately represented using
         * comma concatenation. For such headers, use getHeader() instead
         * and supply your own delimiter when concatenating.
         *
         * If the header does not appear in the message, this method MUST return
         * an empty string.
         *
         * @param string $name Case-insensitive header field name.
         * @return string A string of values as provided for the given header
         *    concatenated together using a comma. If the header does not appear in
         *    the message, this method MUST return an empty string.
         */
        public function getHeaderLine(string $name): string
        {
        }
        /**
         * Return an instance with the provided header, replacing any existing
         * values of any headers with the same case-insensitive name.
         *
         * While header names are case-insensitive, the casing of the header will
         * be preserved by this function, and returned from getHeaders().
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * new and/or updated header and value.
         *
         * @param string $name Case-insensitive header field name.
         * @param string|string[] $value Header value(s).
         * @return static
         * @throws Exception\InvalidArgumentException For invalid header names or values.
         */
        public function withHeader(string $name, $value): \Psr\Http\Message\MessageInterface
        {
        }
        /**
         * Return an instance with the specified header appended with the
         * given value.
         *
         * Existing values for the specified header will be maintained. The new
         * value(s) will be appended to the existing list. If the header did not
         * exist previously, it will be added.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * new header and/or value.
         *
         * @param string $name Case-insensitive header field name to add.
         * @param string|string[] $value Header value(s).
         * @return static
         * @throws Exception\InvalidArgumentException For invalid header names or values.
         */
        public function withAddedHeader(string $name, $value): \Psr\Http\Message\MessageInterface
        {
        }
        /**
         * Return an instance without the specified header.
         *
         * Header resolution MUST be done without case-sensitivity.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that removes
         * the named header.
         *
         * @param string $name Case-insensitive header field name to remove.
         * @return static
         */
        public function withoutHeader(string $name): \Psr\Http\Message\MessageInterface
        {
        }
        /**
         * Gets the body of the message.
         *
         * @return StreamInterface Returns the body as a stream.
         */
        public function getBody(): \Psr\Http\Message\StreamInterface
        {
        }
        /**
         * Return an instance with the specified message body.
         *
         * The body MUST be a StreamInterface object.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return a new instance that has the
         * new body stream.
         *
         * @param StreamInterface $body Body.
         * @return static
         * @throws Exception\InvalidArgumentException When the body is not valid.
         */
        public function withBody(\Psr\Http\Message\StreamInterface $body): \Psr\Http\Message\MessageInterface
        {
        }
        /** @param StreamInterface|string|resource $stream */
        private function getStream($stream, string $modeIfNotInstance): \Psr\Http\Message\StreamInterface
        {
        }
        /**
         * Filter a set of headers to ensure they are in the correct internal format.
         *
         * Used by message constructors to allow setting all initial headers at once.
         *
         * @param array $originalHeaders Headers to filter.
         */
        private function setHeaders(array $originalHeaders): void
        {
        }
        /**
         * Validate the HTTP protocol version
         *
         * @throws Exception\InvalidArgumentException On invalid HTTP protocol version.
         */
        private function validateProtocolVersion(string $version): void
        {
        }
        /** @return list<string> */
        private function filterHeaderValue(mixed $values): array
        {
        }
        /**
         * Ensure header name and values are valid.
         *
         * @param string $name
         * @throws Exception\InvalidArgumentException
         */
        private function assertHeader($name): void
        {
        }
    }
    class Module
    {
        public function getConfig(): array
        {
        }
    }
    /**
     * Wrapper for default Stream class, representing subpart (starting from given offset) of initial stream.
     * It can be used to avoid copying full stream, conserving memory.
     *
     * @see AbstractSerializer::splitStream()
     */
    final class RelativeStream implements \Psr\Http\Message\StreamInterface, \Stringable
    {
        public function __construct(private \Psr\Http\Message\StreamInterface $decoratedStream, ?int $offset)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function __toString(): string
        {
        }
        /**
         * {@inheritdoc}
         */
        public function close(): void
        {
        }
        /**
         * {@inheritdoc}
         */
        public function detach()
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getSize(): int
        {
        }
        /**
         * {@inheritdoc}
         */
        public function tell(): int
        {
        }
        /**
         * {@inheritdoc}
         */
        public function eof(): bool
        {
        }
        /**
         * {@inheritdoc}
         */
        public function isSeekable(): bool
        {
        }
        /**
         * {@inheritdoc}
         */
        public function seek(int $offset, int $whence = \SEEK_SET): void
        {
        }
        /**
         * {@inheritdoc}
         */
        public function rewind(): void
        {
        }
        /**
         * {@inheritdoc}
         */
        public function isWritable(): bool
        {
        }
        /**
         * {@inheritdoc}
         */
        public function write(string $string): int
        {
        }
        /**
         * {@inheritdoc}
         */
        public function isReadable(): bool
        {
        }
        /**
         * {@inheritdoc}
         */
        public function read(int $length): string
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getContents(): string
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getMetadata(?string $key = null)
        {
        }
    }
}
namespace Laminas\Diactoros\Request {
    /**
     * Serialize or deserialize request messages to/from arrays.
     *
     * This class provides functionality for serializing a RequestInterface instance
     * to an array, as well as the reverse operation of creating a Request instance
     * from an array representing a message.
     */
    final class ArraySerializer
    {
        /**
         * Serialize a request message to an array.
         *
         * @return array{
         *     method: string,
         *     request_target: string,
         *     uri: string,
         *     protocol_version: string,
         *     headers: array<array<string>>,
         *     body: string
         * }
         */
        public static function toArray(\Psr\Http\Message\RequestInterface $request): array
        {
        }
        /**
         * Deserialize a request array to a request instance.
         *
         * @throws Exception\DeserializationException When the response cannot be deserialized.
         */
        public static function fromArray(array $serializedRequest): \Laminas\Diactoros\Request
        {
        }
    }
    /**
     * Serialize (cast to string) or deserialize (cast string to Request) messages.
     *
     * This class provides functionality for serializing a RequestInterface instance
     * to a string, as well as the reverse operation of creating a Request instance
     * from a string/stream representing a message.
     */
    final class Serializer extends \Laminas\Diactoros\AbstractSerializer
    {
        /**
         * Deserialize a request string to a request instance.
         *
         * Internally, casts the message to a stream and invokes fromStream().
         *
         * @throws Exception\SerializationException When errors occur parsing the message.
         */
        public static function fromString(string $message): \Laminas\Diactoros\Request
        {
        }
        /**
         * Deserialize a request stream to a request instance.
         *
         * @throws Exception\InvalidArgumentException If the message stream is not readable or seekable.
         * @throws Exception\SerializationException If an invalid request line is detected.
         */
        public static function fromStream(\Psr\Http\Message\StreamInterface $stream): \Laminas\Diactoros\Request
        {
        }
        /**
         * Serialize a request message to a string.
         */
        public static function toString(\Psr\Http\Message\RequestInterface $request): string
        {
        }
    }
}
namespace Laminas\Diactoros {
    /**
     * Trait with common request behaviors.
     *
     * Server and client-side requests differ slightly in how the Host header is
     * handled; on client-side, it should be calculated on-the-fly from the
     * composed URI (if present), while on server-side, it will be calculated from
     * the environment. As such, this trait exists to provide the common code
     * between both client-side and server-side requests, and each can then
     * use the headers functionality required by their implementations.
     */
    trait RequestTrait
    {
        use \Laminas\Diactoros\MessageTrait;
        /** @var string */
        private $method = 'GET';
        /**
         * The request-target, if it has been provided or calculated.
         *
         * @var null|string
         */
        private $requestTarget;
        /** @var UriInterface */
        private $uri;
        /**
         * Initialize request state.
         *
         * Used by constructors.
         *
         * @param null|string|UriInterface $uri URI for the request, if any.
         * @param null|string $method HTTP method for the request, if any.
         * @param string|resource|StreamInterface $body Message body, if any.
         * @param array $headers Headers for the message, if any.
         * @throws Exception\InvalidArgumentException For any invalid value.
         */
        private function initialize($uri = null, ?string $method = null, $body = 'php://memory', array $headers = []): void
        {
        }
        /**
         * Create and return a URI instance.
         *
         * If `$uri` is a already a `UriInterface` instance, returns it.
         *
         * If `$uri` is a string, passes it to the `Uri` constructor to return an
         * instance.
         *
         * If `$uri is null, creates and returns an empty `Uri` instance.
         *
         * Otherwise, it raises an exception.
         *
         * @throws Exception\InvalidArgumentException
         */
        private function createUri(null|string|\Psr\Http\Message\UriInterface $uri): \Psr\Http\Message\UriInterface
        {
        }
        /**
         * Retrieves the message's request target.
         *
         * Retrieves the message's request-target either as it will appear (for
         * clients), as it appeared at request (for servers), or as it was
         * specified for the instance (see withRequestTarget()).
         *
         * In most cases, this will be the origin-form of the composed URI,
         * unless a value was provided to the concrete implementation (see
         * withRequestTarget() below).
         *
         * If no URI is available, and no request-target has been specifically
         * provided, this method MUST return the string "/".
         */
        public function getRequestTarget(): string
        {
        }
        /**
         * Create a new instance with a specific request-target.
         *
         * If the request needs a non-origin-form request-target — e.g., for
         * specifying an absolute-form, authority-form, or asterisk-form —
         * this method may be used to create an instance with the specified
         * request-target, verbatim.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return a new instance that has the
         * changed request target.
         *
         * @link http://tools.ietf.org/html/rfc7230#section-2.7 (for the various
         *     request-target forms allowed in request messages)
         *
         * @throws Exception\InvalidArgumentException If the request target is invalid.
         * @return static
         */
        public function withRequestTarget(string $requestTarget): \Psr\Http\Message\RequestInterface
        {
        }
        /**
         * Retrieves the HTTP method of the request.
         *
         * @return string Returns the request method.
         */
        public function getMethod(): string
        {
        }
        /**
         * Return an instance with the provided HTTP method.
         *
         * While HTTP method names are typically all uppercase characters, HTTP
         * method names are case-sensitive and thus implementations SHOULD NOT
         * modify the given string.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * changed request method.
         *
         * @param string $method Case-insensitive method.
         * @throws Exception\InvalidArgumentException For invalid HTTP methods.
         * @return static
         */
        public function withMethod(string $method): \Psr\Http\Message\RequestInterface
        {
        }
        /**
         * Retrieves the URI instance.
         *
         * This method MUST return a UriInterface instance.
         *
         * @link http://tools.ietf.org/html/rfc3986#section-4.3
         *
         * @return UriInterface Returns a UriInterface instance
         *     representing the URI of the request, if any.
         */
        public function getUri(): \Psr\Http\Message\UriInterface
        {
        }
        /**
         * Returns an instance with the provided URI.
         *
         * This method will update the Host header of the returned request by
         * default if the URI contains a host component. If the URI does not
         * contain a host component, any pre-existing Host header will be carried
         * over to the returned request.
         *
         * You can opt-in to preserving the original state of the Host header by
         * setting `$preserveHost` to `true`. When `$preserveHost` is set to
         * `true`, the returned request will not update the Host header of the
         * returned message -- even if the message contains no Host header. This
         * means that a call to `getHeader('Host')` on the original request MUST
         * equal the return value of a call to `getHeader('Host')` on the returned
         * request.
         *
         * This method MUST be implemented in such a way as to retain the
         * immutability of the message, and MUST return an instance that has the
         * new UriInterface instance.
         *
         * @link http://tools.ietf.org/html/rfc3986#section-4.3
         *
         * @param UriInterface $uri New request URI to use.
         * @param bool $preserveHost Preserve the original state of the Host header.
         * @return static
         */
        public function withUri(\Psr\Http\Message\UriInterface $uri, bool $preserveHost = false): \Psr\Http\Message\RequestInterface
        {
        }
        /**
         * Set and validate the HTTP method
         *
         * @throws Exception\InvalidArgumentException On invalid HTTP method.
         */
        private function setMethod(string $method): void
        {
        }
        /**
         * Retrieve the host from the URI instance
         */
        private function getHostFromUri(): string
        {
        }
    }
    /**
     * HTTP Request encapsulation
     *
     * Requests are considered immutable; all methods that might change state are
     * implemented such that they retain the internal state of the current
     * message and return a new instance that contains the changed state.
     */
    class Request implements \Psr\Http\Message\RequestInterface
    {
        use \Laminas\Diactoros\RequestTrait;
        /**
         * @param null|string|UriInterface $uri URI for the request, if any.
         * @param null|string $method HTTP method for the request, if any.
         * @param string|resource|StreamInterface $body Message body, if any.
         * @param array $headers Headers for the message, if any.
         * @throws Exception\InvalidArgumentException For any invalid value.
         */
        public function __construct($uri = null, ?string $method = null, $body = 'php://temp', array $headers = [])
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getHeaders(): array
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getHeader(string $name): array
        {
        }
    }
    class RequestFactory implements \Psr\Http\Message\RequestFactoryInterface
    {
        /**
         * {@inheritDoc}
         */
        public function createRequest(string $method, $uri): \Psr\Http\Message\RequestInterface
        {
        }
    }
}
namespace Laminas\Diactoros\Response {
    /**
     * Serialize or deserialize response messages to/from arrays.
     *
     * This class provides functionality for serializing a ResponseInterface instance
     * to an array, as well as the reverse operation of creating a Response instance
     * from an array representing a message.
     */
    final class ArraySerializer
    {
        /**
         * Serialize a response message to an array.
         *
         * @return array{
         *     status_code: int,
         *     reason_phrase: string,
         *     protocol_version: string,
         *     headers: array<array<string>>,
         *     body: string
         * }
         */
        public static function toArray(\Psr\Http\Message\ResponseInterface $response): array
        {
        }
        /**
         * Deserialize a response array to a response instance.
         *
         * @throws Exception\DeserializationException When cannot deserialize response.
         */
        public static function fromArray(array $serializedResponse): \Laminas\Diactoros\Response
        {
        }
    }
}
namespace Laminas\Diactoros {
    /**
     * HTTP response encapsulation.
     *
     * Responses are considered immutable; all methods that might change state are
     * implemented such that they retain the internal state of the current
     * message and return a new instance that contains the changed state.
     */
    class Response implements \Psr\Http\Message\ResponseInterface
    {
        use \Laminas\Diactoros\MessageTrait;
        public const MIN_STATUS_CODE_VALUE = 100;
        public const MAX_STATUS_CODE_VALUE = 599;
        /**
         * @param string|resource|StreamInterface $body Stream identifier and/or actual stream resource
         * @param int $status Status code for the response, if any.
         * @param array $headers Headers for the response, if any.
         * @throws Exception\InvalidArgumentException On any invalid element.
         */
        public function __construct($body = 'php://memory', int $status = 200, array $headers = [])
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getStatusCode(): int
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getReasonPhrase(): string
        {
        }
        /**
         * {@inheritdoc}
         */
        public function withStatus(int $code, string $reasonPhrase = ''): \Laminas\Diactoros\Response
        {
        }
    }
}
namespace Laminas\Diactoros\Response {
    /**
     * A class representing empty HTTP responses.
     */
    class EmptyResponse extends \Laminas\Diactoros\Response
    {
        /**
         * Create an empty response with the given status code.
         *
         * @param int $status Status code for the response, if any.
         * @param array $headers Headers for the response, if any.
         */
        public function __construct(int $status = 204, array $headers = [])
        {
        }
        /**
         * Create an empty response with the given headers.
         *
         * @param array $headers Headers for the response.
         */
        public static function withHeaders(array $headers): \Laminas\Diactoros\Response\EmptyResponse
        {
        }
    }
    trait InjectContentTypeTrait
    {
        /**
         * Inject the provided Content-Type, if none is already present.
         *
         * @return array Headers with injected Content-Type
         */
        private function injectContentType(string $contentType, array $headers): array
        {
        }
    }
    /**
     * HTML response.
     *
     * Allows creating a response by passing an HTML string to the constructor;
     * by default, sets a status code of 200 and sets the Content-Type header to
     * text/html.
     */
    class HtmlResponse extends \Laminas\Diactoros\Response
    {
        use \Laminas\Diactoros\Response\InjectContentTypeTrait;
        /**
         * Create an HTML response.
         *
         * Produces an HTML response with a Content-Type of text/html and a default
         * status of 200.
         *
         * @param string|StreamInterface $html HTML or stream for the message body.
         * @param int $status Integer status code for the response; 200 by default.
         * @param array $headers Array of headers to use at initialization.
         * @throws Exception\InvalidArgumentException If $html is neither a string or stream.
         */
        public function __construct($html, int $status = 200, array $headers = [])
        {
        }
    }
    /**
     * JSON response.
     *
     * Allows creating a response by passing data to the constructor; by default,
     * serializes the data to JSON, sets a status code of 200 and sets the
     * Content-Type header to application/json.
     */
    class JsonResponse extends \Laminas\Diactoros\Response
    {
        use \Laminas\Diactoros\Response\InjectContentTypeTrait;
        /**
         * Default flags for json_encode
         *
         * @const int
         */
        public const DEFAULT_JSON_FLAGS = \JSON_HEX_TAG | \JSON_HEX_APOS | \JSON_HEX_AMP | \JSON_HEX_QUOT | \JSON_UNESCAPED_SLASHES;
        /**
         * Create a JSON response with the given data.
         *
         * Default JSON encoding is performed with the following options, which
         * produces RFC4627-compliant JSON, capable of embedding into HTML.
         *
         * - JSON_HEX_TAG
         * - JSON_HEX_APOS
         * - JSON_HEX_AMP
         * - JSON_HEX_QUOT
         * - JSON_UNESCAPED_SLASHES
         *
         * @param mixed $data Data to convert to JSON.
         * @param int $status Integer status code for the response; 200 by default.
         * @param array $headers Array of headers to use at initialization.
         * @param int $encodingOptions JSON encoding options to use.
         * @throws Exception\InvalidArgumentException If unable to encode the $data to JSON.
         */
        public function __construct($data, int $status = 200, array $headers = [], private int $encodingOptions = self::DEFAULT_JSON_FLAGS)
        {
        }
        /**
         * @return mixed
         */
        public function getPayload()
        {
        }
        public function withPayload(mixed $data): \Laminas\Diactoros\Response\JsonResponse
        {
        }
        public function getEncodingOptions(): int
        {
        }
        public function withEncodingOptions(int $encodingOptions): \Laminas\Diactoros\Response\JsonResponse
        {
        }
    }
    /**
     * Produce a redirect response.
     */
    class RedirectResponse extends \Laminas\Diactoros\Response
    {
        /**
         * Create a redirect response.
         *
         * Produces a redirect response with a Location header and the given status
         * (302 by default).
         *
         * Note: this method overwrites the `location` $headers value.
         *
         * @param string|UriInterface $uri URI for the Location header.
         * @param int $status Integer status code for the redirect; 302 by default.
         * @param array $headers Array of headers to use at initialization.
         */
        public function __construct($uri, int $status = 302, array $headers = [])
        {
        }
    }
    final class Serializer extends \Laminas\Diactoros\AbstractSerializer
    {
        /**
         * Deserialize a response string to a response instance.
         *
         * @throws Exception\SerializationException When errors occur parsing the message.
         */
        public static function fromString(string $message): \Laminas\Diactoros\Response
        {
        }
        /**
         * Parse a response from a stream.
         *
         * @throws Exception\InvalidArgumentException When the stream is not readable.
         * @throws Exception\SerializationException When errors occur parsing the message.
         */
        public static function fromStream(\Psr\Http\Message\StreamInterface $stream): \Laminas\Diactoros\Response
        {
        }
        /**
         * Create a string representation of a response.
         */
        public static function toString(\Psr\Http\Message\ResponseInterface $response): string
        {
        }
    }
    /**
     * Plain text response.
     *
     * Allows creating a response by passing a string to the constructor;
     * by default, sets a status code of 200 and sets the Content-Type header to
     * text/plain.
     */
    class TextResponse extends \Laminas\Diactoros\Response
    {
        use \Laminas\Diactoros\Response\InjectContentTypeTrait;
        /**
         * Create a plain text response.
         *
         * Produces a text response with a Content-Type of text/plain and a default
         * status of 200.
         *
         * @param string|StreamInterface $text String or stream for the message body.
         * @param int $status Integer status code for the response; 200 by default.
         * @param array $headers Array of headers to use at initialization.
         * @throws Exception\InvalidArgumentException If $text is neither a string or stream.
         */
        public function __construct($text, int $status = 200, array $headers = [])
        {
        }
    }
    /**
     * XML response.
     *
     * Allows creating a response by passing an XML string to the constructor; by default,
     * sets a status code of 200 and sets the Content-Type header to application/xml.
     */
    class XmlResponse extends \Laminas\Diactoros\Response
    {
        use \Laminas\Diactoros\Response\InjectContentTypeTrait;
        /**
         * Create an XML response.
         *
         * Produces an XML response with a Content-Type of application/xml and a default
         * status of 200.
         *
         * @param string|StreamInterface $xml String or stream for the message body.
         * @param int $status Integer status code for the response; 200 by default.
         * @param array $headers Array of headers to use at initialization.
         * @throws Exception\InvalidArgumentException If $text is neither a string or stream.
         */
        public function __construct($xml, int $status = 200, array $headers = [])
        {
        }
    }
}
namespace Laminas\Diactoros {
    class ResponseFactory implements \Psr\Http\Message\ResponseFactoryInterface
    {
        /**
         * {@inheritDoc}
         */
        public function createResponse(int $code = 200, string $reasonPhrase = ''): \Psr\Http\Message\ResponseInterface
        {
        }
    }
    /**
     * Server-side HTTP request
     *
     * Extends the Request definition to add methods for accessing incoming data,
     * specifically server parameters, cookies, matched path parameters, query
     * string arguments, body parameters, and upload file information.
     *
     * "Attributes" are discovered via decomposing the request (and usually
     * specifically the URI path), and typically will be injected by the application.
     *
     * Requests are considered immutable; all methods that might change state are
     * implemented such that they retain the internal state of the current
     * message and return a new instance that contains the changed state.
     */
    class ServerRequest implements \Psr\Http\Message\ServerRequestInterface
    {
        use \Laminas\Diactoros\RequestTrait;
        /**
         * @param array $serverParams Server parameters, typically from $_SERVER
         * @param array $uploadedFiles Upload file information, a tree of UploadedFiles
         * @param null|string|UriInterface $uri URI for the request, if any.
         * @param null|string $method HTTP method for the request, if any.
         * @param string|resource|StreamInterface $body Message body, if any.
         * @param array $headers Headers for the message, if any.
         * @param array $cookieParams Cookies for the message, if any.
         * @param array $queryParams Query params for the message, if any.
         * @param null|array|object $parsedBody The deserialized body parameters, if any.
         * @param string $protocol HTTP protocol version.
         * @throws Exception\InvalidArgumentException For any invalid value.
         */
        public function __construct(private array $serverParams = [], array $uploadedFiles = [], null|string|\Psr\Http\Message\UriInterface $uri = null, ?string $method = null, $body = 'php://input', array $headers = [], private array $cookieParams = [], private array $queryParams = [], private $parsedBody = null, string $protocol = '1.1')
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getServerParams(): array
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getUploadedFiles(): array
        {
        }
        /**
         * {@inheritdoc}
         */
        public function withUploadedFiles(array $uploadedFiles): \Laminas\Diactoros\ServerRequest
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getCookieParams(): array
        {
        }
        /**
         * {@inheritdoc}
         */
        public function withCookieParams(array $cookies): \Laminas\Diactoros\ServerRequest
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getQueryParams(): array
        {
        }
        /**
         * {@inheritdoc}
         */
        public function withQueryParams(array $query): \Laminas\Diactoros\ServerRequest
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getParsedBody()
        {
        }
        /**
         * {@inheritdoc}
         */
        public function withParsedBody($data): \Laminas\Diactoros\ServerRequest
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getAttributes(): array
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getAttribute(string $name, $default = null)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function withAttribute(string $name, $value): \Laminas\Diactoros\ServerRequest
        {
        }
        /**
         * {@inheritdoc}
         */
        public function withoutAttribute(string $name): \Laminas\Diactoros\ServerRequest
        {
        }
    }
    /**
     * Class for marshaling a request object from the current PHP environment.
     */
    class ServerRequestFactory implements \Psr\Http\Message\ServerRequestFactoryInterface
    {
        /**
         * Create a request from the supplied superglobal values.
         *
         * If any argument is not supplied, the corresponding superglobal value will
         * be used.
         *
         * The ServerRequest created is then passed to the fromServer() method in
         * order to marshal the request URI and headers.
         *
         * @see fromServer()
         *
         * @param null|array $server $_SERVER superglobal
         * @param null|array $query $_GET superglobal
         * @param null|array $body $_POST superglobal
         * @param null|array $cookies $_COOKIE superglobal
         * @param null|array $files $_FILES superglobal
         * @param null|FilterServerRequestInterface $requestFilter If present, the
         *     generated request will be passed to this instance and the result
         *     returned by this method. When not present, a default instance of
         *     FilterUsingXForwardedHeaders is created, using the `trustReservedSubnets()`
         *     constructor.
         */
        public static function fromGlobals(?array $server = null, ?array $query = null, ?array $body = null, ?array $cookies = null, ?array $files = null, ?\Laminas\Diactoros\ServerRequestFilter\FilterServerRequestInterface $requestFilter = null): \Psr\Http\Message\ServerRequestInterface
        {
        }
        /**
         * {@inheritDoc}
         */
        public function createServerRequest(string $method, $uri, array $serverParams = []): \Psr\Http\Message\ServerRequestInterface
        {
        }
    }
}
namespace Laminas\Diactoros\ServerRequestFilter {
    /**
     * Filter/initialize a server request.
     *
     * Implementations of this interface will take an incoming request, and
     * decide if additional modifications are necessary. As examples:
     *
     * - Injecting a unique request identifier header.
     * - Using the X-Forwarded-* headers to rewrite the URI to reflect the original request.
     * - Using the Forwarded header to rewrite the URI to reflect the original request.
     *
     * This functionality is consumed by the ServerRequestFactory using the request
     * instance it generates, just prior to returning a request.
     */
    interface FilterServerRequestInterface
    {
        /**
         * Determine if a request needs further modification, and if so, return a
         * new instance reflecting those modifications.
         */
        public function __invoke(\Psr\Http\Message\ServerRequestInterface $request): \Psr\Http\Message\ServerRequestInterface;
    }
    final class DoNotFilter implements \Laminas\Diactoros\ServerRequestFilter\FilterServerRequestInterface
    {
        public function __invoke(\Psr\Http\Message\ServerRequestInterface $request): \Psr\Http\Message\ServerRequestInterface
        {
        }
    }
    /**
     * Modify the URI to reflect the X-Forwarded-* headers.
     *
     * If the request comes from a trusted proxy, this filter will analyze the
     * various X-Forwarded-* headers, if any, and if they are marked as trusted,
     * in order to return a new request that composes a URI instance that reflects
     * those headers.
     *
     * @psalm-immutable
    */
    final class FilterUsingXForwardedHeaders implements \Laminas\Diactoros\ServerRequestFilter\FilterServerRequestInterface
    {
        public const HEADER_HOST = 'X-FORWARDED-HOST';
        public const HEADER_PORT = 'X-FORWARDED-PORT';
        public const HEADER_PROTO = 'X-FORWARDED-PROTO';
        public function __invoke(\Psr\Http\Message\ServerRequestInterface $request): \Psr\Http\Message\ServerRequestInterface
        {
        }
        /**
         * Indicate which proxies and which X-Forwarded headers to trust.
         *
         * @param list<non-empty-string> $proxyCIDRList Each element may
         *     be an IP address or a subnet specified using CIDR notation; both IPv4
         *     and IPv6 are supported. The special string "*" will be translated to
         *     two entries, "0.0.0.0/0" and "::/0". An empty list indicates no
         *     proxies are trusted.
         * @param list<FilterUsingXForwardedHeaders::HEADER_*> $trustedHeaders If
         *     the list is empty, all X-Forwarded headers are trusted.
         * @throws InvalidProxyAddressException
         * @throws InvalidForwardedHeaderNameException
         */
        public static function trustProxies(array $proxyCIDRList, array $trustedHeaders = self::X_FORWARDED_HEADERS): self
        {
        }
        /**
         * Trust any X-FORWARDED-* headers from any address.
         *
         * This is functionally equivalent to calling `trustProxies(['*'])`.
         *
         * WARNING: Only do this if you know for certain that your application
         * sits behind a trusted proxy that cannot be spoofed. This should only
         * be the case if your server is not publicly addressable, and all requests
         * are routed via a reverse proxy (e.g., a load balancer, a server such as
         * Caddy, when using Traefik, etc.).
         */
        public static function trustAny(): self
        {
        }
        /**
         * Trust X-Forwarded headers from reserved subnetworks.
         *
         * This is functionally equivalent to calling `trustProxies()` where the
         * `$proxcyCIDRList` argument is a list with the following:
         *
         * - 10.0.0.0/8
         * - 127.0.0.0/8
         * - 172.16.0.0/12
         * - 192.168.0.0/16
         * - ::1/128 (IPv6 localhost)
         * - fc00::/7 (IPv6 private networks)
         * - fe80::/10 (IPv6 local-link addresses)
         *
         * @param list<FilterUsingXForwardedHeaders::HEADER_*> $trustedHeaders If
         *     the list is empty, all X-Forwarded headers are trusted.
         * @throws InvalidForwardedHeaderNameException
         */
        public static function trustReservedSubnets(array $trustedHeaders = self::X_FORWARDED_HEADERS): self
        {
        }
    }
    /** @internal */
    final class IPRange
    {
        /** @psalm-pure */
        public static function matches(string $ip, string $cidr): bool
        {
        }
        /** @psalm-pure */
        public static function matchesIPv4(string $ip, string $cidr): bool
        {
        }
        /** @psalm-pure */
        public static function matchesIPv6(string $ip, string $cidr): bool
        {
        }
    }
}
namespace Laminas\Diactoros {
    /**
     * Implementation of PSR HTTP streams
     */
    class Stream implements \Psr\Http\Message\StreamInterface, \Stringable
    {
        /** @var resource|null */
        protected $resource;
        /** @var string|object|resource|null */
        protected $stream;
        /**
         * @param string|object|resource $stream
         * @param string $mode Mode with which to open stream
         * @throws Exception\InvalidArgumentException
         */
        public function __construct($stream, string $mode = 'r')
        {
        }
        /**
         * {@inheritdoc}
         */
        public function __toString(): string
        {
        }
        /**
         * {@inheritdoc}
         */
        public function close(): void
        {
        }
        /**
         * {@inheritdoc}
         */
        public function detach()
        {
        }
        /**
         * Attach a new stream/resource to the instance.
         *
         * @param string|object|resource $resource
         * @throws Exception\InvalidArgumentException For stream identifier that cannot be cast to a resource.
         * @throws Exception\InvalidArgumentException For non-resource stream.
         */
        public function attach($resource, string $mode = 'r'): void
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getSize(): ?int
        {
        }
        /**
         * {@inheritdoc}
         */
        public function tell(): int
        {
        }
        /**
         * {@inheritdoc}
         */
        public function eof(): bool
        {
        }
        /**
         * {@inheritdoc}
         */
        public function isSeekable(): bool
        {
        }
        /**
         * {@inheritdoc}
         */
        public function seek(int $offset, int $whence = \SEEK_SET): void
        {
        }
        /**
         * {@inheritdoc}
         */
        public function rewind(): void
        {
        }
        /**
         * {@inheritdoc}
         */
        public function isWritable(): bool
        {
        }
        /**
         * {@inheritdoc}
         */
        public function write($string): int
        {
        }
        /**
         * {@inheritdoc}
         */
        public function isReadable(): bool
        {
        }
        /**
         * {@inheritdoc}
         */
        public function read(int $length): string
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getContents(): string
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getMetadata(?string $key = null)
        {
        }
    }
    class StreamFactory implements \Psr\Http\Message\StreamFactoryInterface
    {
        /**
         * {@inheritDoc}
         */
        public function createStream(string $content = ''): \Psr\Http\Message\StreamInterface
        {
        }
        /**
         * {@inheritDoc}
         */
        public function createStreamFromFile(string $filename, string $mode = 'r'): \Psr\Http\Message\StreamInterface
        {
        }
        /**
         * {@inheritDoc}
         */
        public function createStreamFromResource($resource): \Psr\Http\Message\StreamInterface
        {
        }
    }
    class UploadedFile implements \Psr\Http\Message\UploadedFileInterface
    {
        public const ERROR_MESSAGES = [\UPLOAD_ERR_OK => 'There is no error, the file uploaded with success', \UPLOAD_ERR_INI_SIZE => 'The uploaded file exceeds the upload_max_filesize directive in php.ini', \UPLOAD_ERR_FORM_SIZE => 'The uploaded file exceeds the MAX_FILE_SIZE directive that was ' . 'specified in the HTML form', \UPLOAD_ERR_PARTIAL => 'The uploaded file was only partially uploaded', \UPLOAD_ERR_NO_FILE => 'No file was uploaded', \UPLOAD_ERR_NO_TMP_DIR => 'Missing a temporary folder', \UPLOAD_ERR_CANT_WRITE => 'Failed to write file to disk', \UPLOAD_ERR_EXTENSION => 'A PHP extension stopped the file upload.'];
        /**
         * @param string|resource|StreamInterface $streamOrFile
         * @throws Exception\InvalidArgumentException
         */
        public function __construct($streamOrFile, private ?int $size, int $errorStatus, private ?string $clientFilename = null, private ?string $clientMediaType = null)
        {
        }
        /**
         * {@inheritdoc}
         *
         * @throws Exception\UploadedFileAlreadyMovedException If the upload was not successful.
         */
        public function getStream(): \Psr\Http\Message\StreamInterface
        {
        }
        /**
         * {@inheritdoc}
         *
         * @see http://php.net/is_uploaded_file
         * @see http://php.net/move_uploaded_file
         *
         * @param string $targetPath Path to which to move the uploaded file.
         * @throws Exception\UploadedFileErrorException If the upload was not successful.
         * @throws Exception\InvalidArgumentException If the $path specified is invalid.
         * @throws Exception\UploadedFileErrorException On any error during the
         *     move operation, or on the second or subsequent call to the method.
         */
        public function moveTo(string $targetPath): void
        {
        }
        /**
         * {@inheritdoc}
         *
         * @return int|null The file size in bytes or null if unknown.
         */
        public function getSize(): ?int
        {
        }
        /**
         * {@inheritdoc}
         *
         * @see http://php.net/manual/en/features.file-upload.errors.php
         *
         * @return int One of PHP's UPLOAD_ERR_XXX constants.
         */
        public function getError(): int
        {
        }
        /**
         * {@inheritdoc}
         *
         * @return string|null The filename sent by the client or null if none
         *     was provided.
         */
        public function getClientFilename(): ?string
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getClientMediaType(): ?string
        {
        }
    }
    class UploadedFileFactory implements \Psr\Http\Message\UploadedFileFactoryInterface
    {
        /**
         * {@inheritDoc}
         */
        public function createUploadedFile(\Psr\Http\Message\StreamInterface $stream, ?int $size = null, int $error = \UPLOAD_ERR_OK, ?string $clientFilename = null, ?string $clientMediaType = null): \Psr\Http\Message\UploadedFileInterface
        {
        }
    }
    /**
     * Implementation of Psr\Http\UriInterface.
     *
     * Provides a value object representing a URI for HTTP requests.
     *
     * Instances of this class  are considered immutable; all methods that
     * might change state are implemented such that they retain the internal
     * state of the current instance and return a new instance that contains the
     * changed state.
     *
     * @psalm-immutable
     */
    class Uri implements \Psr\Http\Message\UriInterface, \Stringable
    {
        /**
         * Sub-delimiters used in user info, query strings and fragments.
         *
         * @const string
         */
        public const CHAR_SUB_DELIMS = '!\$&\'\(\)\*\+,;=';
        /**
         * Unreserved characters used in user info, paths, query strings, and fragments.
         *
         * @const string
         */
        public const CHAR_UNRESERVED = 'a-zA-Z0-9_\-\.~\pL';
        /** @var int[] Array indexed by valid scheme names to their corresponding ports. */
        protected $allowedSchemes = ['http' => 80, 'https' => 443];
        public function __construct(string $uri = '')
        {
        }
        /**
         * Operations to perform on clone.
         *
         * Since cloning usually is for purposes of mutation, we reset the
         * $uriString property so it will be re-calculated.
         */
        public function __clone()
        {
        }
        /**
         * {@inheritdoc}
         */
        public function __toString(): string
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getScheme(): string
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getAuthority(): string
        {
        }
        /**
         * Retrieve the user-info part of the URI.
         *
         * This value is percent-encoded, per RFC 3986 Section 3.2.1.
         *
         * {@inheritdoc}
         */
        public function getUserInfo(): string
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getHost(): string
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getPort(): ?int
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getPath(): string
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getQuery(): string
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getFragment(): string
        {
        }
        /**
         * {@inheritdoc}
         */
        public function withScheme(string $scheme): \Psr\Http\Message\UriInterface
        {
        }
        // The following rule is buggy for parameters attributes
        // phpcs:disable SlevomatCodingStandard.TypeHints.ParameterTypeHintSpacing.NoSpaceBetweenTypeHintAndParameter
        /**
         * Create and return a new instance containing the provided user credentials.
         *
         * The value will be percent-encoded in the new instance, but with measures
         * taken to prevent double-encoding.
         *
         * {@inheritdoc}
         */
        public function withUserInfo(
            string $user,
            #[\SensitiveParameter]
            ?string $password = null
        ): \Psr\Http\Message\UriInterface
        {
        }
        // phpcs:enable SlevomatCodingStandard.TypeHints.ParameterTypeHintSpacing.NoSpaceBetweenTypeHintAndParameter
        /**
         * {@inheritdoc}
         */
        public function withHost(string $host): \Psr\Http\Message\UriInterface
        {
        }
        /**
         * {@inheritdoc}
         */
        public function withPort(?int $port): \Psr\Http\Message\UriInterface
        {
        }
        /**
         * {@inheritdoc}
         */
        public function withPath(string $path): \Psr\Http\Message\UriInterface
        {
        }
        /**
         * {@inheritdoc}
         */
        public function withQuery(string $query): \Psr\Http\Message\UriInterface
        {
        }
        /**
         * {@inheritdoc}
         */
        public function withFragment(string $fragment): \Psr\Http\Message\UriInterface
        {
        }
    }
    class UriFactory implements \Psr\Http\Message\UriFactoryInterface
    {
        /**
         * {@inheritDoc}
         */
        public function createUri(string $uri = ''): \Psr\Http\Message\UriInterface
        {
        }
        /**
         * Create a Uri instance based on the headers and $_SERVER data.
         *
         * @param array<non-empty-string, list<string>|int|float|string> $server SAPI parameters
         * @param array<string, string|list<string>> $headers
         */
        public static function createFromSapi(array $server, array $headers): \Laminas\Diactoros\Uri
        {
        }
        /**
         * @internal
         *
         * @return array{string, int|null} Array of two items, host and port, in that order (can be
         *     passed to a list() operation).
         * @psalm-mutation-free
         */
        public static function marshalHostAndPortFromHeader(string $host): array
        {
        }
    }
}
namespace Laminas\I18n {
    /**
     * @psalm-import-type ServiceManagerConfiguration from ServiceManager
     * @final
     */
    class ConfigProvider
    {
        /**
         * Return general-purpose laminas-i18n configuration.
         *
         * @return array{
         *     dependencies: ServiceManagerConfiguration,
         *     filters: ServiceManagerConfiguration,
         *     validators: ServiceManagerConfiguration,
         *     view_helpers: ServiceManagerConfiguration,
         *     locale: string|null,
         * }
         */
        public function __invoke()
        {
        }
        /**
         * Return application-level dependency configuration.
         *
         * @return ServiceManagerConfiguration
         */
        public function getDependencyConfig()
        {
        }
        /**
         * Return laminas-filter configuration.
         *
         * @return ServiceManagerConfiguration
         */
        public function getFilterConfig()
        {
        }
        /**
         * Return laminas-validator configuration.
         *
         * @return ServiceManagerConfiguration
         */
        public function getValidatorConfig()
        {
        }
        /**
         * Return laminas-view helper configuration.
         *
         * Obsoletes View\HelperConfig.
         *
         * @return ServiceManagerConfiguration
         */
        public function getViewHelperConfig()
        {
        }
    }
    /**
     * @psalm-immutable
     */
    final class CountryCode
    {
        /** @return non-empty-string */
        public function toString(): string
        {
        }
        public function equals(self $other): bool
        {
        }
        /**
         * Create a new ValueObject from an ISO 3166 Country Code
         * Country codes are 2 letter, uppercase strings representing a country identifier on planet earth. The given
         * value must also represent a country known by PHP’s intl extension.
         * Valid values include 'US', 'GB', 'ZA', 'FR' etc.
         *
         * @link https://en.wikipedia.org/wiki/List_of_ISO_3166_country_codes
         *
         * @param non-empty-string $code
         * @throws InvalidArgumentException An invalid string or an unknown country will cause an exception.
         * @psalm-pure
         */
        public static function fromString(string $code): self
        {
        }
        /**
         * Create a new value object from a locale string
         *
         * Given a well-formed locale, this method will extract the relevant country code and proxy to @link fromString
         * Valid values include: 'en_GB', 'en-GB', 'zh-Hans-CN'
         *
         * @param non-empty-string $locale
         * @throws InvalidArgumentException An unrecognizable locale will cause an exception.
         * @psalm-pure
         */
        public static function fromLocaleString(string $locale): self
        {
        }
        /**
         * Return a country code from either a string code or a locale string falling back to the system locale if null
         *
         * @link fromLocaleString
         * @link fromString
         *
         * @throws InvalidArgumentException When a non-empty string is provided that cannot be recognized,
         *                                  an exception will be thrown.
         */
        public static function detect(string|self|null $countryCodeOrLocale = null): self
        {
        }
        /**
         * Attempt to create a value object from either a country code or a locale string
         *
         * This method returns null if the input cannot be recognized as either a code or a locale.
         *
         * @link fromLocaleString
         * @link fromString
         *
         * @param non-empty-string $countryCodeOrLocale
         * @psalm-pure
         */
        public static function tryFromString(string $countryCodeOrLocale): ?self
        {
        }
    }
}
namespace Laminas\I18n\Exception {
    interface ExceptionInterface extends \Throwable
    {
    }
    class ExtensionNotLoadedException extends \DomainException implements \Laminas\I18n\Exception\ExceptionInterface
    {
    }
    /** @final */
    class InvalidArgumentException extends \InvalidArgumentException implements \Laminas\I18n\Exception\ExceptionInterface
    {
        /** @psalm-pure */
        public static function withInvalidCountryCode(string $received): self
        {
        }
        /** @psalm-pure */
        public static function withUnknownCountryCode(string $code): self
        {
        }
        /** @psalm-pure */
        public static function withUnrecognizableLocaleString(string $locale): self
        {
        }
        /** @psalm-pure */
        public static function withUndetectableCountryCode(string $localeOrCode): self
        {
        }
    }
    class OutOfBoundsException extends \OutOfBoundsException implements \Laminas\I18n\Exception\ExceptionInterface
    {
    }
    class RuntimeException extends \RuntimeException implements \Laminas\I18n\Exception\ExceptionInterface
    {
    }
    class ParseException extends \Laminas\I18n\Exception\RuntimeException implements \Laminas\I18n\Exception\ExceptionInterface
    {
    }
    class RangeException extends \RangeException implements \Laminas\I18n\Exception\ExceptionInterface
    {
    }
}
namespace Laminas\I18n\Filter {
    /**
     * @psalm-type Options = array{
     *     locale: string|null,
     *     ...
     * }
     * @template TOptions of Options
     * @extends AbstractFilter<TOptions>
     */
    abstract class AbstractLocale extends \Laminas\Filter\AbstractFilter
    {
        public function __construct()
        {
        }
        /**
         * Sets the locale option
         *
         * @param  string|null $locale
         * @return $this
         */
        public function setLocale($locale = null)
        {
        }
        /**
         * Returns the locale option
         *
         * @return string
         */
        public function getLocale()
        {
        }
    }
    /**
     * @psalm-type Options = array{
     *     locale: string|null,
     *     allow_white_space: bool,
     *     ...
     * }
     * @extends AbstractLocale<Options>
     */
    class Alnum extends \Laminas\I18n\Filter\AbstractLocale
    {
        /** @var Options */
        protected $options = ['locale' => null, 'allow_white_space' => false];
        /**
         * Sets default option values for this instance
         *
         * @param array|Traversable|bool|null $allowWhiteSpaceOrOptions
         * @param string|null $locale
         */
        public function __construct($allowWhiteSpaceOrOptions = null, $locale = null)
        {
        }
        /**
         * Sets the allowWhiteSpace option
         *
         * @param  bool $flag
         * @return $this
         */
        public function setAllowWhiteSpace($flag = true)
        {
        }
        /**
         * Whether white space is allowed
         *
         * @return bool
         */
        public function getAllowWhiteSpace()
        {
        }
        /**
         * Defined by Laminas\Filter\FilterInterface
         *
         * Returns $value as string with all non-alphanumeric characters removed
         *
         * @param mixed $value
         * @return string|list<string>|mixed
         */
        public function filter($value)
        {
        }
    }
    class Alpha extends \Laminas\I18n\Filter\Alnum
    {
        /**
         * Defined by Laminas\Filter\FilterInterface
         *
         * Returns the string $value, removing all but alphabetic characters
         *
         * @param mixed $value
         * @return ($value is scalar ? string : ($value is list<scalar> ? list<string> : mixed))
         */
        public function filter($value)
        {
        }
    }
    /**
     * @psalm-type Options = array{
     *    locale: string|null,
     *    style: int,
     *    type: NumberFormatter::TYPE_*,
     *    ...
     * }
     * @extends AbstractLocale<Options>
     */
    class NumberParse extends \Laminas\I18n\Filter\AbstractLocale
    {
        /** @var Options */
        protected $options = ['locale' => null, 'style' => \NumberFormatter::DEFAULT_STYLE, 'type' => \NumberFormatter::TYPE_DOUBLE];
        /** @var NumberFormatter|null */
        protected $formatter;
        /**
         * @param array|Traversable|string|null $localeOrOptions
         * @param int $style
         * @param int $type
         * @psalm-param NumberFormatter::TYPE_* $type
         */
        public function __construct($localeOrOptions = null, $style = \NumberFormatter::DEFAULT_STYLE, $type = \NumberFormatter::TYPE_DOUBLE)
        {
        }
        /**
         * @param  string|null $locale
         * @return $this
         */
        public function setLocale($locale = null)
        {
        }
        /**
         * @param  int $style
         * @return $this
         */
        public function setStyle($style)
        {
        }
        /**
         * @return int
         */
        public function getStyle()
        {
        }
        /**
         * @param int $type
         * @psalm-param NumberFormatter::TYPE_* $type
         * @return $this
         */
        public function setType($type)
        {
        }
        /**
         * @return NumberFormatter::TYPE_*
         */
        public function getType()
        {
        }
        /**
         * @return $this
         */
        public function setFormatter(\NumberFormatter $formatter)
        {
        }
        /**
         * @return NumberFormatter
         * @throws Exception\RuntimeException
         */
        public function getFormatter()
        {
        }
        /**
         * Defined by Laminas\Filter\FilterInterface
         *
         * @see    \Laminas\Filter\FilterInterface::filter()
         *
         * @param  mixed $value
         * @return mixed
         */
        public function filter($value)
        {
        }
    }
    class NumberFormat extends \Laminas\I18n\Filter\NumberParse
    {
        /**
         * Defined by Laminas\Filter\FilterInterface
         *
         * @see    \Laminas\Filter\FilterInterface::filter()
         *
         * @param  mixed $value
         * @return mixed
         */
        public function filter($value)
        {
        }
    }
}
namespace Laminas\I18n\Geography {
    /**
     * @extends IteratorAggregate<array-key, CountryCode>
     */
    interface CountryCodeListInterface extends \IteratorAggregate, \Countable
    {
    }
    final class DefaultCountryCodeList implements \Laminas\I18n\Geography\CountryCodeListInterface
    {
        public static function create(): self
        {
        }
        /** @return Traversable<array-key, CountryCode> */
        public function getIterator(): \Traversable
        {
        }
        /** @return positive-int */
        public function count(): int
        {
        }
        /** @return non-empty-list<CountryCode> */
        public function toArray(): array
        {
        }
    }
}
namespace Laminas\I18n {
    /**
     * @psalm-import-type ServiceManagerConfiguration from ServiceManager
     */
    class Module
    {
        /**
         * Return laminas-i18n configuration for laminas-mvc application.
         *
         * @return array{
         *     filters: ServiceManagerConfiguration,
         *     service_manager: ServiceManagerConfiguration,
         *     validators: ServiceManagerConfiguration,
         *     view_helpers: ServiceManagerConfiguration,
         * }
         */
        public function getConfig()
        {
        }
        /**
         * Register a specification for the TranslatorPluginManager with the ServiceListener.
         *
         * @param ModuleManager $moduleManager
         * @return void
         */
        public function init($moduleManager)
        {
        }
    }
}
namespace Laminas\I18n\Translator\Loader {
    /**
     * Gettext loader.
     */
    class Gettext extends \Laminas\I18n\Translator\Loader\AbstractFileLoader
    {
        /**
         * Current file pointer.
         *
         * @var resource
         */
        protected $file;
        /**
         * Whether the current file is little endian.
         *
         * @var bool
         */
        protected $littleEndian;
        /**
         * load(): defined by FileLoaderInterface.
         *
         * @see    FileLoaderInterface::load()
         *
         * @param  string $locale
         * @param  string $filename
         * @return TextDomain
         * @throws Exception\InvalidArgumentException
         */
        public function load($locale, $filename)
        {
        }
        /**
         * Read a single integer from the current file.
         *
         * @return int
         */
        protected function readInteger()
        {
        }
        /**
         * Read an integer from the current file.
         *
         * @param  int $num
         * @return int
         */
        protected function readIntegerList($num)
        {
        }
    }
    /**
     * PHP INI format loader.
     */
    class Ini extends \Laminas\I18n\Translator\Loader\AbstractFileLoader
    {
        /**
         * load(): defined by FileLoaderInterface.
         *
         * @see    FileLoaderInterface::load()
         *
         * @param  string $locale
         * @param  string $filename
         * @return TextDomain
         * @throws Exception\InvalidArgumentException
         */
        public function load($locale, $filename)
        {
        }
    }
    /**
     * PHP array loader.
     */
    class PhpArray extends \Laminas\I18n\Translator\Loader\AbstractFileLoader
    {
        /**
         * load(): defined by FileLoaderInterface.
         *
         * @see    FileLoaderInterface::load()
         *
         * @param  string $locale
         * @param  string $filename
         * @return TextDomain
         * @throws Exception\InvalidArgumentException
         */
        public function load($locale, $filename)
        {
        }
    }
    /**
     * Remote loader interface.
     */
    interface RemoteLoaderInterface
    {
        /**
         * Load translations from a remote source.
         *
         * @param  string $locale
         * @param  string $textDomain
         * @return TextDomain|null
         */
        public function load($locale, $textDomain);
    }
    /**
     * PHP Memory array loader.
     */
    class PhpMemoryArray implements \Laminas\I18n\Translator\Loader\RemoteLoaderInterface
    {
        /** @var array */
        protected $messages;
        /** @param array $messages */
        public function __construct($messages)
        {
        }
        /**
         * Load translations from a remote source.
         *
         * @param  string $locale
         * @param  string $textDomain
         * @return TextDomain
         * @throws Exception\InvalidArgumentException
         */
        public function load($locale, $textDomain)
        {
        }
    }
}
namespace Laminas\ServiceManager {
    /**
     * Interface for service locator
     */
    interface ServiceLocatorInterface extends \Psr\Container\ContainerInterface
    {
        /**
         * Build a service by its name, using optional options (such services are NEVER cached).
         *
         * @template T of object
         * @param  string|class-string<T> $name
         * @param  null|array<mixed>  $options
         * @return mixed
         * @psalm-return ($name is class-string<T> ? T : mixed)
         * @throws Exception\ServiceNotFoundException If no factory/abstract
         *     factory could be found to create the instance.
         * @throws Exception\ServiceNotCreatedException If factory/delegator fails
         *     to create the instance.
         * @throws ContainerExceptionInterface If any other error occurs.
         */
        public function build($name, ?array $options = null);
    }
    /**
     * Interface for a plugin manager
     *
     * A plugin manager is a specialized service locator used to create homogeneous objects
     *
     * @template InstanceType
     */
    interface PluginManagerInterface extends \Laminas\ServiceManager\ServiceLocatorInterface
    {
        /**
         * Validate an instance
         *
         * @return void
         * @throws InvalidServiceException If created instance does not respect the
         *     constraint on type imposed by the plugin manager.
         * @throws ContainerExceptionInterface If any other error occurs.
         * @psalm-assert InstanceType $instance
         */
        public function validate(mixed $instance);
    }
    /**
     * Service Manager.
     *
     * Default implementation of the ServiceLocatorInterface, providing capabilities
     * for object creation via:
     *
     * - factories
     * - abstract factories
     * - delegator factories
     * - lazy service factories (generated proxies)
     * - initializers (interface injection)
     *
     * It also provides the ability to inject specific service instances and to
     * define aliases.
     *
     * @see ConfigInterface
     *
     * @psalm-type AbstractFactoriesConfiguration = array<
     *      array-key,
     *      (class-string<Factory\AbstractFactoryInterface>|Factory\AbstractFactoryInterface)
     * >
     * @psalm-type DelegatorsConfiguration = array<
     *      string,
     *      array<
     *          array-key,
     *          (class-string<Factory\DelegatorFactoryInterface>|Factory\DelegatorFactoryInterface)
     *          |callable(ContainerInterface,string,callable():object,array<mixed>|null):object
     *      >
     * >
     * @psalm-type FactoriesConfiguration = array<
     *      string,
     *      (class-string<Factory\FactoryInterface>|Factory\FactoryInterface)
     *      |callable(ContainerInterface,?string,?array<mixed>|null):object
     * >
     * @psalm-type InitializersConfiguration = array<
     *      array-key,
     *      (class-string<Initializer\InitializerInterface>|Initializer\InitializerInterface)
     *      |callable(ContainerInterface,object):void
     * >
     * @psalm-type LazyServicesConfiguration = array{
     *      class_map?:array<string,class-string>,
     *      proxies_namespace?:non-empty-string,
     *      proxies_target_dir?:non-empty-string,
     *      write_proxy_files?:bool
     * }
     * @psalm-type ServiceManagerConfiguration = array{
     *     abstract_factories?: AbstractFactoriesConfiguration,
     *     aliases?: array<string,string>,
     *     delegators?: DelegatorsConfiguration,
     *     factories?: FactoriesConfiguration,
     *     initializers?: InitializersConfiguration,
     *     invokables?: array<string,string>,
     *     lazy_services?: LazyServicesConfiguration,
     *     services?: array<string,object|array<mixed>>,
     *     shared?:array<string,bool>,
     *     shared_by_default?:bool,
     *     ...
     * }
     */
    class ServiceManager implements \Laminas\ServiceManager\ServiceLocatorInterface
    {
        /** @var Factory\AbstractFactoryInterface[] */
        protected $abstractFactories = [];
        /**
         * A list of aliases
         *
         * Should map one alias to a service name, or another alias (aliases are recursively resolved)
         *
         * @var string[]
         */
        protected $aliases = [];
        /**
         * Whether or not changes may be made to this instance.
         *
         * @var bool
         */
        protected $allowOverride = false;
        /** @var ContainerInterface */
        protected $creationContext;
        /**
         * @var string[][]|Factory\DelegatorFactoryInterface[][]
         * @psalm-var DelegatorsConfiguration
         */
        protected $delegators = [];
        /**
         * A list of factories (either as string name or callable)
         *
         * @var string[]|callable[]
         * @psalm-var FactoriesConfiguration
         */
        protected $factories = [];
        /**
         * @var Initializer\InitializerInterface[]|callable[]
         * @psalm-var InitializersConfiguration
         */
        protected $initializers = [];
        /**
         * @var array
         * @psalm-var LazyServicesConfiguration
         */
        protected $lazyServices = [];
        /**
         * A list of already loaded services (this act as a local cache)
         *
         * @var array<string,array|object>
         */
        protected $services = [];
        /**
         * Enable/disable shared instances by service name.
         *
         * Example configuration:
         *
         * 'shared' => [
         *     MyService::class => true, // will be shared, even if "sharedByDefault" is false
         *     MyOtherService::class => false // won't be shared, even if "sharedByDefault" is true
         * ]
         *
         * @var array<string,bool>
         */
        protected $shared = [];
        /**
         * Should the services be shared by default?
         *
         * @var bool
         */
        protected $sharedByDefault = true;
        /**
         * Service manager was already configured?
         *
         * @var bool
         */
        protected $configured = false;
        /**
         * See {@see \Laminas\ServiceManager\ServiceManager::configure()} for details
         * on what $config accepts.
         *
         * @psalm-param ServiceManagerConfiguration $config
         */
        public function __construct(array $config = [])
        {
        }
        /**
         * Implemented for backwards compatibility with previous plugin managers only.
         *
         * Returns the creation context.
         *
         * @deprecated since 3.0.0. Factories using 3.0 should use the container
         *     instance passed to the factory instead.
         *
         * @return ContainerInterface
         */
        public function getServiceLocator()
        {
        }
        /** {@inheritDoc} */
        public function get($name)
        {
        }
        /** {@inheritDoc} */
        public function build($name, ?array $options = null)
        {
        }
        /**
         * {@inheritDoc}
         *
         * @param string|class-string $name
         * @return bool
         */
        public function has($name)
        {
        }
        /**
         * Indicate whether or not the instance is immutable.
         *
         * @param bool $flag
         */
        public function setAllowOverride($flag)
        {
        }
        /**
         * Retrieve the flag indicating immutability status.
         *
         * @return bool
         */
        public function getAllowOverride()
        {
        }
        /**
         * @psalm-param ServiceManagerConfiguration $config
         * @return self
         * @throws ContainerModificationsNotAllowedException If the allow
         *     override flag has been toggled off, and a service instance
         *     exists for a given service.
         */
        public function configure(array $config)
        {
        }
        /**
         * Add an alias.
         *
         * @param string $alias
         * @param string $target
         * @throws ContainerModificationsNotAllowedException If $alias already
         *     exists as a service and overrides are disallowed.
         */
        public function setAlias($alias, $target)
        {
        }
        /**
         * Add an invokable class mapping.
         *
         * @param string $name Service name
         * @param null|string $class Class to which to map; if omitted, $name is
         *     assumed.
         * @throws ContainerModificationsNotAllowedException If $name already
         *     exists as a service and overrides are disallowed.
         */
        public function setInvokableClass($name, $class = null)
        {
        }
        /**
         * Specify a factory for a given service name.
         *
         * @param string $name Service name
         * @param string|callable|Factory\FactoryInterface $factory  Factory to which to map.
         * phpcs:disable Generic.Files.LineLength.TooLong
         * @psalm-param class-string<Factory\FactoryInterface>|callable(ContainerInterface,string,array<mixed>|null):object|Factory\FactoryInterface $factory
         * phpcs:enable Generic.Files.LineLength.TooLong
         * @return void
         * @throws ContainerModificationsNotAllowedException If $name already
         *     exists as a service and overrides are disallowed.
         */
        public function setFactory($name, $factory)
        {
        }
        /**
         * Create a lazy service mapping to a class.
         *
         * @param string $name Service name to map
         * @param null|string $class Class to which to map; if not provided, $name
         *     will be used for the mapping.
         */
        public function mapLazyService($name, $class = null)
        {
        }
        /**
         * Add an abstract factory for resolving services.
         *
         * @param string|Factory\AbstractFactoryInterface $factory Abstract factory
         *     instance or class name.
         * @psalm-param class-string<Factory\AbstractFactoryInterface>|Factory\AbstractFactoryInterface $factory
         */
        public function addAbstractFactory($factory)
        {
        }
        /**
         * Add a delegator for a given service.
         *
         * @param string $name Service name
         * @param string|callable|Factory\DelegatorFactoryInterface $factory Delegator
         *     factory to assign.
         * @psalm-param class-string<Factory\DelegatorFactoryInterface>
         *     |callable(ContainerInterface,string,callable,array<mixed>|null) $factory
         */
        public function addDelegator($name, $factory)
        {
        }
        /**
         * Add an initializer.
         *
         * @param string|callable|Initializer\InitializerInterface $initializer
         * @psalm-param class-string<Initializer\InitializerInterface>
         *     |callable(ContainerInterface,mixed):void
         *     |Initializer\InitializerInterface $initializer
         */
        public function addInitializer($initializer)
        {
        }
        /**
         * Map a service.
         *
         * @param string $name Service name
         * @param array|object $service
         * @throws ContainerModificationsNotAllowedException If $name already
         *     exists as a service and overrides are disallowed.
         */
        public function setService($name, $service)
        {
        }
        /**
         * Add a service sharing rule.
         *
         * @param string $name Service name
         * @param bool $flag Whether or not the service should be shared.
         * @throws ContainerModificationsNotAllowedException If $name already
         *     exists as a service and overrides are disallowed.
         */
        public function setShared($name, $flag)
        {
        }
    }
    /**
     * Abstract plugin manager.
     *
     * Abstract PluginManagerInterface implementation providing:
     *
     * - creation context support. The constructor accepts the parent container
     *   instance, which is then used when creating instances.
     * - plugin validation. Implementations may define the `$instanceOf` property
     *   to indicate what class types constitute valid plugins, omitting the
     *   requirement to define the `validate()` method.
     *
     * The implementation extends `ServiceManager`, thus providing the same set
     * of capabilities as found in that implementation.
     *
     * @template InstanceType
     * @implements PluginManagerInterface<InstanceType>
     * @psalm-import-type ServiceManagerConfiguration from ServiceManager
     * @psalm-suppress PropertyNotSetInConstructor
     */
    abstract class AbstractPluginManager extends \Laminas\ServiceManager\ServiceManager implements \Laminas\ServiceManager\PluginManagerInterface
    {
        /**
         * Whether or not to auto-add a FQCN as an invokable if it exists.
         *
         * @var bool
         */
        protected $autoAddInvokableClass = true;
        /**
         * An object type that the created instance must be instanced of
         *
         * @var null|string
         * @psalm-var null|class-string<InstanceType>
         */
        protected $instanceOf;
        /**
         * Sets the provided $parentLocator as the creation context for all
         * factories; for $config, {@see \Laminas\ServiceManager\ServiceManager::configure()}
         * for details on its accepted structure.
         *
         * @param null|ConfigInterface|ContainerInterface $configInstanceOrParentLocator
         * @param array $config
         * @psalm-param ServiceManagerConfiguration $config
         */
        public function __construct($configInstanceOrParentLocator = null, array $config = [])
        {
        }
        /**
         * Override configure() to validate service instances.
         *
         * @param  array $config
         * @psalm-param ServiceManagerConfiguration $config
         * @return self
         * @throws InvalidServiceException If an instance passed in the `services` configuration is invalid for the
         *                                 plugin manager.
         * @throws ContainerModificationsNotAllowedException If the allow override flag has been toggled off, and a
         *                                                   service instanceexists for a given service.
         */
        public function configure(array $config)
        {
        }
        /**
         * Override setService for additional plugin validation.
         *
         * {@inheritDoc}
         *
         * @param string|class-string<InstanceType> $name
         * @param InstanceType $service
         */
        public function setService($name, $service)
        {
        }
        /**
         * @param class-string<InstanceType>|string $name Service name of plugin to retrieve.
         * @param null|array<mixed> $options Options to use when creating the instance.
         * @return mixed
         * @psalm-return ($name is class-string<InstanceType> ? InstanceType : mixed)
         * @throws Exception\ServiceNotFoundException If the manager does not have
         *     a service definition for the instance, and the service is not
         *     auto-invokable.
         * @throws InvalidServiceException If the plugin created is invalid for the
         *     plugin context.
         */
        public function get($name, ?array $options = null)
        {
        }
        /**
         * {@inheritDoc}
         *
         * @psalm-assert InstanceType $instance
         */
        public function validate(mixed $instance)
        {
        }
        /**
         * Implemented for backwards compatibility only.
         *
         * Returns the creation context.
         *
         * @deprecated since 3.0.0. The creation context should be passed during
         *     instantiation instead.
         *
         * @return void
         */
        public function setServiceLocator(\Psr\Container\ContainerInterface $container)
        {
        }
    }
}
namespace Laminas\I18n\Translator {
    /**
     * Plugin manager implementation for translation loaders.
     *
     * Enforces that loaders retrieved are either instances of
     * Loader\FileLoaderInterface or Loader\RemoteLoaderInterface. Additionally,
     * it registers a number of default loaders.
     *
     * If you are wanting to use the ability to load translation files from the
     * include_path, you will need to create a factory to override the defaults
     * defined in this class. A simple factory might look like:
     *
     * <code>
     * function ($translators) {
     *     $adapter = new Gettext();
     *     $adapter->setUseIncludePath(true);
     *     return $adapter;
     * }
     * </code>
     *
     * You may need to override the Translator service factory to make this happen
     * more easily. That can be done by extending it:
     *
     * <code>
     * use Laminas\I18n\Translator\TranslatorServiceFactory;
     * // or Laminas\Mvc\I18n\TranslatorServiceFactory
     * use Laminas\ServiceManager\ServiceLocatorInterface;
     *
     * class MyTranslatorServiceFactory extends TranslatorServiceFactory
     * {
     *     public function createService(ServiceLocatorInterface $services)
     *     {
     *         $translator = parent::createService($services);
     *         $translator->getLoaderPluginManager()->setFactory(...);
     *         return $translator;
     *     }
     * }
     * </code>
     *
     * You would then specify your custom factory in your service configuration.
     *
     * @template InstanceType of RemoteLoaderInterface|FileLoaderInterface
     * @extends AbstractPluginManager<InstanceType>
     */
    class LoaderPluginManager extends \Laminas\ServiceManager\AbstractPluginManager
    {
        /** @inheritDoc */
        protected $aliases = [
            'gettext' => \Laminas\I18n\Translator\Loader\Gettext::class,
            'getText' => \Laminas\I18n\Translator\Loader\Gettext::class,
            'GetText' => \Laminas\I18n\Translator\Loader\Gettext::class,
            'ini' => \Laminas\I18n\Translator\Loader\Ini::class,
            'phparray' => \Laminas\I18n\Translator\Loader\PhpArray::class,
            'phpArray' => \Laminas\I18n\Translator\Loader\PhpArray::class,
            'PhpArray' => \Laminas\I18n\Translator\Loader\PhpArray::class,
            // Legacy Zend Framework aliases
            'Zend\I18n\Translator\Loader\Gettext' => \Laminas\I18n\Translator\Loader\Gettext::class,
            'Zend\I18n\Translator\Loader\Ini' => \Laminas\I18n\Translator\Loader\Ini::class,
            'Zend\I18n\Translator\Loader\PhpArray' => \Laminas\I18n\Translator\Loader\PhpArray::class,
            // v2 normalized FQCNs
            'zendi18ntranslatorloadergettext' => \Laminas\I18n\Translator\Loader\Gettext::class,
            'zendi18ntranslatorloaderini' => \Laminas\I18n\Translator\Loader\Ini::class,
            'zendi18ntranslatorloaderphparray' => \Laminas\I18n\Translator\Loader\PhpArray::class,
        ];
        /** @inheritDoc */
        protected $factories = [
            \Laminas\I18n\Translator\Loader\Gettext::class => \Laminas\ServiceManager\Factory\InvokableFactory::class,
            \Laminas\I18n\Translator\Loader\Ini::class => \Laminas\ServiceManager\Factory\InvokableFactory::class,
            \Laminas\I18n\Translator\Loader\PhpArray::class => \Laminas\ServiceManager\Factory\InvokableFactory::class,
            // Legacy (v2) due to alias resolution; canonical form of resolved
            // alias is used to look up the factory, while the non-normalized
            // resolved alias is used as the requested name passed to the factory.
            'laminasi18ntranslatorloadergettext' => \Laminas\ServiceManager\Factory\InvokableFactory::class,
            'laminasi18ntranslatorloaderini' => \Laminas\ServiceManager\Factory\InvokableFactory::class,
            'laminasi18ntranslatorloaderphparray' => \Laminas\ServiceManager\Factory\InvokableFactory::class,
        ];
        /**
         * Validate the plugin.
         *
         * Checks that the filter loaded is an instance of
         * Loader\FileLoaderInterface or Loader\RemoteLoaderInterface.
         *
         * @param  mixed $plugin
         * @return void
         * @throws Exception\RuntimeException If invalid.
         * @psalm-assert InstanceType $plugin
         */
        public function validate($plugin)
        {
        }
        /**
         * Validate the plugin is of the expected type (v2).
         *
         * Proxies to `validate()`.
         *
         * @deprecated Since 2.16.0 - This component is no longer compatible with Service Manager v2.
         *             This method will be removed in version 3.0
         *
         * @param mixed $plugin
         * @throws Exception\RuntimeException
         * @psalm-assert InstanceType $plugin
         */
        public function validatePlugin($plugin)
        {
        }
    }
}
namespace Laminas\ServiceManager\Factory {
    /**
     * Interface for a factory
     *
     * A factory is an callable object that is able to create an object. It is
     * given the instance of the service locator, the requested name of the class
     * you want to create, and any additional options that could be used to
     * configure the instance state.
     */
    interface FactoryInterface
    {
        /**
         * Create an object
         *
         * @param  string             $requestedName
         * @param  null|array<mixed>  $options
         * @return object
         * @throws ServiceNotFoundException If unable to resolve the service.
         * @throws ServiceNotCreatedException If an exception is raised when creating a service.
         * @throws ContainerExceptionInterface If any other error occurs.
         */
        public function __invoke(\Psr\Container\ContainerInterface $container, $requestedName, ?array $options = null);
    }
}
namespace Laminas\ServiceManager {
    /**
     * Backwards-compatibility shim for FactoryInterface.
     *
     * Implementations should update to implement only Laminas\ServiceManager\Factory\FactoryInterface.
     *
     * If upgrading from v2, take the following steps:
     *
     * - rename the method `createService()` to `__invoke()`, and:
     *   - rename the `$serviceLocator` argument to `$container`, and change the
     *     typehint to `Psr\Container\ContainerInterface`
     *   - add the `$requestedName` as a second argument
     *   - add the optional `array $options = null` argument as a final argument
     * - create a `createService()` method as defined in this interface, and have it
     *   proxy to `__invoke()`.
     *
     * Once you have tested your code, you can then update your class to only implement
     * Laminas\ServiceManager\Factory\FactoryInterface, and remove the `createService()`
     * method.
     *
     * @deprecated Use Laminas\ServiceManager\Factory\FactoryInterface instead.
     */
    interface FactoryInterface extends \Laminas\ServiceManager\Factory\FactoryInterface
    {
        /**
         * Create service
         *
         * @return mixed
         */
        public function createService(\Laminas\ServiceManager\ServiceLocatorInterface $serviceLocator);
    }
}
namespace Laminas\I18n\Translator {
    /** @psalm-import-type ServiceManagerConfiguration from ServiceManager */
    class LoaderPluginManagerFactory implements \Laminas\ServiceManager\FactoryInterface
    {
        /**
         * laminas-servicemanager v2 options passed to factory.
         *
         * @deprecated Since 2.16.0 - This component is no longer compatible with Service Manager v2.
         *             This property will be removed in version 3.0
         *
         * @var array
         */
        protected $creationOptions = [];
        /**
         * Create and return a LoaderPluginManager.
         *
         * @param string $name
         * @param array<string, mixed>|null $options
         * @psalm-param ServiceManagerConfiguration|null $options
         * @return LoaderPluginManager
         */
        public function __invoke(\Psr\Container\ContainerInterface $container, $name, ?array $options = null)
        {
        }
        /**
         * laminas-servicemanager v2 factory to return LoaderPluginManager
         *
         * @deprecated Since 2.16.0 - This component is no longer compatible with Service Manager v2.
         *             This method will be removed in version 3.0
         *
         * @return LoaderPluginManager
         */
        public function createService(\Laminas\ServiceManager\ServiceLocatorInterface $container)
        {
        }
        /**
         * v2 support for instance creation options.
         *
         * @deprecated Since 2.16.0 - This component is no longer compatible with Service Manager v2.
         *             This method will be removed in version 3.0
         *
         * @param array $options
         * @return void
         */
        public function setCreationOptions(array $options)
        {
        }
    }
}
namespace Laminas\I18n\Translator\Plural {
    /**
     * Plural rule parser.
     *
     * This plural rule parser is implemented after the article "Top Down Operator
     * Precedence" described in <http://javascript.crockford.com/tdop/tdop.html>.
     */
    class Parser
    {
        /**
         * String to parse.
         *
         * @var string
         */
        protected $string;
        /**
         * Current lexer position in the string.
         *
         * @var int
         */
        protected $currentPos;
        /**
         * Current token.
         *
         * @var Symbol
         */
        protected $currentToken;
        /**
         * Table of symbols.
         *
         * @var Symbol[]
         */
        protected $symbolTable = [];
        /**
         * Create a new plural parser.
         */
        public function __construct()
        {
        }
        /**
         * Populate the symbol table.
         *
         * @return void
         */
        protected function populateSymbolTable()
        {
        }
        /**
         * Register a left infix symbol.
         *
         * @param  string  $id
         * @param  int $leftBindingPower
         * @return void
         */
        protected function registerLeftInfixSymbol($id, $leftBindingPower)
        {
        }
        /**
         * Register a right infix symbol.
         *
         * @param  string  $id
         * @param  int $leftBindingPower
         * @return void
         */
        protected function registerRightInfixSymbol($id, $leftBindingPower)
        {
        }
        /**
         * Register a prefix symbol.
         *
         * @param  string  $id
         * @param  int $leftBindingPower
         * @return void
         */
        protected function registerPrefixSymbol($id, $leftBindingPower)
        {
        }
        /**
         * Register a symbol.
         *
         * @param  string  $id
         * @param  int $leftBindingPower
         * @return Symbol
         */
        protected function registerSymbol($id, $leftBindingPower = 0)
        {
        }
        /**
         * Get a new symbol.
         *
         * @param string $id
         * @return Symbol
         */
        protected function getSymbol($id)
        {
        }
        /**
         * Parse a string.
         *
         * @param  string $string
         * @return Symbol
         */
        public function parse($string)
        {
        }
        /**
         * Parse an expression.
         *
         * @param  int $rightBindingPower
         * @return Symbol
         */
        public function expression($rightBindingPower = 0)
        {
        }
        /**
         * Advance the current token and optionally check the old token id.
         *
         * @param  string $id
         * @return void
         * @throws Exception\ParseException
         */
        public function advance($id = null)
        {
        }
        /**
         * Get the next token.
         *
         * @return Symbol
         * @throws Exception\ParseException
         */
        protected function getNextToken()
        {
        }
    }
    /**
     * Plural rule evaluator.
     */
    class Rule
    {
        /**
         * Parser instance.
         *
         * @var Parser
         */
        protected static $parser;
        /**
         * Abstract syntax tree.
         *
         * @var array
         */
        protected $ast;
        /**
         * Number of plurals in this rule.
         *
         * @var int
         */
        protected $numPlurals;
        /**
         * Create a new plural rule.
         *
         * @param int   $numPlurals
         * @param array $ast
         */
        protected function __construct($numPlurals, array $ast)
        {
        }
        /**
         * Evaluate a number and return the plural index.
         *
         * @param  int $number
         * @return int
         * @throws Exception\RangeException
         */
        public function evaluate($number)
        {
        }
        /**
         * Get number of possible plural forms.
         *
         * @return int
         */
        public function getNumPlurals()
        {
        }
        /**
         * Evaluate a part of an ast.
         *
         * @param  array $ast
         * @param  int   $number
         * @return int
         * @throws Exception\ParseException
         */
        protected function evaluateAstPart(array $ast, $number)
        {
        }
        /**
         * Create a new rule from a string.
         *
         * @param  string $string
         * @throws Exception\ParseException
         * @return Rule
         */
        public static function fromString($string)
        {
        }
        /**
         * Create an AST from a tree.
         *
         * Theoretically we could just use the given Symbol, but that one is not
         * so easy to serialize and also takes up more memory.
         *
         * @return array
         */
        protected static function createAst(\Laminas\I18n\Translator\Plural\Symbol $symbol)
        {
        }
    }
    /**
     * Parser symbol.
     *
     * All properties in the symbol are defined as public for easier and faster
     * access from the applied closures. An exception are the closure properties
     * themselves, as they have to be accessed via the appropriate getter and
     * setter methods.
     */
    class Symbol
    {
        /**
         * Parser instance.
         *
         * @var Parser
         */
        public $parser;
        /**
         * Node or token type name.
         *
         * @var string
         */
        public $id;
        /**
         * Left binding power (precedence).
         *
         * @var int
         */
        public $leftBindingPower;
        /**
         * Getter for null denotation.
         *
         * @var callable
         */
        protected $nullDenotationGetter;
        /**
         * Getter for left denotation.
         *
         * @var callable
         */
        protected $leftDenotationGetter;
        /**
         * Value used by literals.
         *
         * @var mixed
         */
        public $value;
        /**
         * First node value.
         *
         * @var Symbol
         */
        public $first;
        /**
         * Second node value.
         *
         * @var Symbol
         */
        public $second;
        /**
         * Third node value.
         *
         * @var Symbol
         */
        public $third;
        /**
         * Create a new symbol.
         *
         * @param  string  $id
         * @param  int $leftBindingPower
         */
        public function __construct(\Laminas\I18n\Translator\Plural\Parser $parser, $id, $leftBindingPower)
        {
        }
        /**
         * Set the null denotation getter.
         *
         * @return $this
         */
        public function setNullDenotationGetter(\Closure $getter)
        {
        }
        /**
         * Set the left denotation getter.
         *
         * @return $this
         */
        public function setLeftDenotationGetter(\Closure $getter)
        {
        }
        /**
         * Get null denotation.
         *
         * @throws Exception\ParseException
         * @return Symbol
         */
        public function getNullDenotation()
        {
        }
        /**
         * Get left denotation.
         *
         * @param  Symbol $left
         * @throws Exception\ParseException
         * @return Symbol
         */
        public function getLeftDenotation($left)
        {
        }
    }
}
namespace Laminas\I18n\Translator {
    /**
     * Text domain.
     *
     * @template TKey of array-key
     * @template TValue
     * @extends ArrayObject<TKey, TValue>
     */
    class TextDomain extends \ArrayObject
    {
        /**
         * Plural rule.
         *
         * @var PluralRule|null
         */
        protected $pluralRule;
        /**
         * Default plural rule shared between instances.
         *
         * @var PluralRule|null
         */
        protected static $defaultPluralRule;
        /**
         * Set the plural rule
         *
         * @return $this
         */
        public function setPluralRule(\Laminas\I18n\Translator\Plural\Rule $rule)
        {
        }
        /**
         * Get the plural rule.
         *
         * @param  bool $fallbackToDefaultRule
         * @return PluralRule|null
         */
        public function getPluralRule($fallbackToDefaultRule = true)
        {
        }
        /**
         * Checks whether the text domain has a plural rule.
         *
         * @return bool
         */
        public function hasPluralRule()
        {
        }
        /**
         * Returns a shared default plural rule.
         *
         * @return PluralRule
         */
        public static function getDefaultPluralRule()
        {
        }
        /**
         * Merge another text domain with the current one.
         *
         * The plural rule of both text domains must be compatible for a successful
         * merge. We are only validating the number of plural forms though, as the
         * same rule could be made up with different expression.
         *
         * @return $this
         * @throws Exception\RuntimeException
         * @template TNewKey of array-key
         * @template TNewValue
         * @param self<TNewKey, TNewValue> $textDomain
         * @psalm-self-out self<TKey|TNewKey, TValue|TNewValue>
         */
        public function merge(\Laminas\I18n\Translator\TextDomain $textDomain)
        {
        }
    }
    interface TranslatorAwareInterface
    {
        /**
         * Sets translator to use in helper
         *
         * @param  TranslatorInterface|null $translator Default is null, which sets no translator.
         * @param  string|null              $textDomain Default is null, which skips setTranslatorTextDomain
         * @return $this
         */
        public function setTranslator(?\Laminas\I18n\Translator\TranslatorInterface $translator = null, $textDomain = null);
        /**
         * Returns translator used in object
         *
         * @return TranslatorInterface|null
         */
        public function getTranslator();
        /**
         * Checks if the object has a translator
         *
         * @return bool
         */
        public function hasTranslator();
        /**
         * Sets whether translator is enabled and should be used
         *
         * @param  bool $enabled [optional] whether translator should be used.
         *                       Default is true.
         * @return $this
         */
        public function setTranslatorEnabled($enabled = true);
        /**
         * Returns whether translator is enabled and should be used
         *
         * @return bool
         */
        public function isTranslatorEnabled();
        /**
         * Set translation text domain
         *
         * @param  string $textDomain
         * @return $this
         */
        public function setTranslatorTextDomain($textDomain = 'default');
        /**
         * Return the translation text domain
         *
         * @return string
         */
        public function getTranslatorTextDomain();
    }
    trait TranslatorAwareTrait
    {
        /** @var TranslatorInterface|null */
        protected $translator;
        /** @var bool */
        protected $translatorEnabled = true;
        /** @var string */
        protected $translatorTextDomain = 'default';
        /**
         * Sets translator to use in helper
         *
         * @param string|null              $textDomain
         * @return $this
         */
        public function setTranslator(?\Laminas\I18n\Translator\TranslatorInterface $translator = null, $textDomain = null)
        {
        }
        /**
         * Returns translator used in object
         *
         * @return TranslatorInterface|null
         */
        public function getTranslator()
        {
        }
        /**
         * Checks if the object has a translator
         *
         * @return bool
         */
        public function hasTranslator()
        {
        }
        /**
         * Sets whether translator is enabled and should be used
         *
         * @param bool $enabled
         * @return $this
         */
        public function setTranslatorEnabled($enabled = true)
        {
        }
        /**
         * Returns whether translator is enabled and should be used
         *
         * @return bool
         */
        public function isTranslatorEnabled()
        {
        }
        /**
         * Set translation text domain
         *
         * @param string $textDomain
         * @return $this
         */
        public function setTranslatorTextDomain($textDomain = 'default')
        {
        }
        /**
         * Return the translation text domain
         *
         * @return string
         */
        public function getTranslatorTextDomain()
        {
        }
    }
    /**
     * Translator.
     */
    class TranslatorServiceFactory implements \Laminas\ServiceManager\FactoryInterface
    {
        /**
         * Create a Translator instance.
         *
         * @param string $requestedName
         * @param null|array $options
         * @return Translator
         */
        public function __invoke(\Psr\Container\ContainerInterface $container, $requestedName, ?array $options = null)
        {
        }
        /**
         * laminas-servicemanager v2 factory for creating Translator instance.
         *
         * @deprecated Since 2.16.0 - This component is no longer compatible with Service Manager v2.
         *             This method will be removed in version 3.0
         *
         * Proxies to `__invoke()`.
         *
         * @return Translator
         */
        public function createService(\Laminas\ServiceManager\ServiceLocatorInterface $serviceLocator)
        {
        }
    }
}
namespace Laminas\I18n\Validator {
    /** @final */
    class Alnum extends \Laminas\Validator\AbstractValidator
    {
        public const INVALID = 'alnumInvalid';
        public const NOT_ALNUM = 'notAlnum';
        public const STRING_EMPTY = 'alnumStringEmpty';
        /**
         * Alphanumeric filter used for validation
         *
         * @var AlnumFilter|null
         */
        protected static $filter;
        /**
         * Validation failure message template definitions
         *
         * @var array<string, string>
         */
        protected $messageTemplates = [self::INVALID => 'Invalid type given. String, integer or float expected', self::NOT_ALNUM => 'The input contains characters which are non alphabetic and no digits', self::STRING_EMPTY => 'The input is an empty string'];
        /**
         * Options for this validator
         *
         * @var array<string, mixed>
         */
        protected $options = ['allowWhiteSpace' => false];
        /**
         * Sets default option values for this instance
         *
         * @param array{allowWhiteSpace: bool}|bool $allowWhiteSpace
         */
        public function __construct($allowWhiteSpace = false)
        {
        }
        /**
         * Returns the allowWhiteSpace option
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0
         *
         * @return bool
         */
        public function getAllowWhiteSpace()
        {
        }
        /**
         * Sets the allowWhiteSpace option
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0. Provide options to the constructor instead.
         *
         * @param bool $allowWhiteSpace
         * @return $this
         */
        public function setAllowWhiteSpace($allowWhiteSpace)
        {
        }
        /**
         * Returns true if and only if $value contains only alphabetic and digit characters
         *
         * @param mixed $value
         * @return bool
         */
        public function isValid($value)
        {
        }
    }
    /** @final */
    class Alpha extends \Laminas\I18n\Validator\Alnum
    {
        public const INVALID = 'alphaInvalid';
        public const NOT_ALPHA = 'notAlpha';
        public const STRING_EMPTY = 'alphaStringEmpty';
        /**
         * Alphabetic filter used for validation
         *
         * @var AlphaFilter|null
         */
        protected static $filter;
        /**
         * Validation failure message template definitions
         *
         * @var array<string, string>
         */
        protected $messageTemplates = [self::INVALID => 'Invalid type given. String expected', self::NOT_ALPHA => 'The input contains non alphabetic characters', self::STRING_EMPTY => 'The input is an empty string'];
        /**
         * Options for this validator
         *
         * @var array<string, mixed>
         */
        protected $options = ['allowWhiteSpace' => false];
        /**
         * Returns true if and only if $value contains only alphabetic characters
         *
         * @param mixed $value
         * @return bool
         */
        public function isValid($value)
        {
        }
    }
    final class CountryCode extends \Laminas\Validator\AbstractValidator
    {
        public const NOT_STRING = 'notString';
        public const EMPTY_STRING = 'emptyString';
        public const INVALID = 'invalid';
        public function isValid(mixed $value): bool
        {
        }
    }
    /** @final */
    class DateTime extends \Laminas\Validator\AbstractValidator
    {
        public const INVALID = 'datetimeInvalid';
        public const INVALID_DATETIME = 'datetimeInvalidDateTime';
        /**
         * Validation failure message template definitions
         *
         * @var array<string, string>
         */
        protected $messageTemplates = [self::INVALID => 'Invalid type given. String expected', self::INVALID_DATETIME => 'The input does not appear to be a valid datetime'];
        /**
         * Optional locale
         *
         * @var string|null
         */
        protected $locale;
        /** @var int|null */
        protected $dateType;
        /** @var int|null */
        protected $timeType;
        /**
         * Optional timezone
         *
         * @var string|null
         */
        protected $timezone;
        /** @var string|null */
        protected $pattern;
        /** @var int|null */
        protected $calendar;
        /** @var IntlDateFormatter|null */
        protected $formatter;
        /**
         * Is the formatter invalidated
         * Invalidation occurs when immutable properties are changed
         *
         * @var bool
         */
        protected $invalidateFormatter = false;
        /**
         * Constructor for the Date validator
         *
         * @param iterable<string, mixed> $options
         */
        public function __construct($options = [])
        {
        }
        /**
         * Sets the calendar to be used by the IntlDateFormatter
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0. Provide options to the constructor instead.
         *
         * @param int|null $calendar
         * @return $this
         */
        public function setCalendar($calendar)
        {
        }
        /**
         * Returns the calendar to by the IntlDateFormatter
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0
         *
         * @return int|null
         */
        public function getCalendar()
        {
        }
        /**
         * Sets the date format to be used by the IntlDateFormatter
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0. Provide options to the constructor instead.
         *
         * @param int|null $dateType
         * @return $this
         */
        public function setDateType($dateType)
        {
        }
        /**
         * Returns the date format used by the IntlDateFormatter
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0
         *
         * @return int|null
         */
        public function getDateType()
        {
        }
        /**
         * Sets the pattern to be used by the IntlDateFormatter
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0. Provide options to the constructor instead.
         *
         * @param string|null $pattern
         * @return $this
         */
        public function setPattern($pattern)
        {
        }
        /**
         * Returns the pattern used by the IntlDateFormatter
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0
         *
         * @return string|null
         */
        public function getPattern()
        {
        }
        /**
         * Sets the time format to be used by the IntlDateFormatter
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0. Provide options to the constructor instead.
         *
         * @param int|null $timeType
         * @return $this
         */
        public function setTimeType($timeType)
        {
        }
        /**
         * Returns the time format used by the IntlDateFormatter
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0
         *
         * @return int|null
         */
        public function getTimeType()
        {
        }
        /**
         * Sets the timezone to be used by the IntlDateFormatter
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0. Provide options to the constructor instead.
         *
         * @param string|null $timezone
         * @return $this
         */
        public function setTimezone($timezone)
        {
        }
        /**
         * Returns the timezone used by the IntlDateFormatter or the system default if none given
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0
         *
         * @return string|null
         */
        public function getTimezone()
        {
        }
        /**
         * Sets the locale to be used by the IntlDateFormatter
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0. Provide options to the constructor instead.
         *
         * @param string|null $locale
         * @return $this
         */
        public function setLocale($locale)
        {
        }
        /**
         * Returns the locale used by the IntlDateFormatter or the system default if none given
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0
         *
         * @return string|null
         */
        public function getLocale()
        {
        }
        /**
         * Returns true if and only if $value is a floating-point value
         *
         * @param  string $value
         * @return bool
         * @throws ValidatorException\InvalidArgumentException
         */
        public function isValid($value)
        {
        }
        /**
         * Returns a non lenient configured IntlDateFormatter
         *
         * @return IntlDateFormatter
         */
        protected function getIntlDateFormatter()
        {
        }
    }
    /** @final */
    class IsFloat extends \Laminas\Validator\AbstractValidator
    {
        public const INVALID = 'floatInvalid';
        public const NOT_FLOAT = 'notFloat';
        /**
         * Validation failure message template definitions
         *
         * @var array<string, string>
         */
        protected $messageTemplates = [self::INVALID => 'Invalid type given. String, integer or float expected', self::NOT_FLOAT => 'The input does not appear to be a float'];
        /**
         * Optional locale
         *
         * @var string|null
         */
        protected $locale;
        /**
         * UTF-8 compatible wrapper for string functions
         *
         * @var StringWrapperInterface
         */
        protected $wrapper;
        /**
         * Constructor for the integer validator
         *
         * @param iterable<string, mixed> $options
         */
        public function __construct($options = [])
        {
        }
        /**
         * Returns the set locale
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0
         *
         * @return string
         */
        public function getLocale()
        {
        }
        /**
         * Sets the locale to use
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0. Provide options to the constructor instead.
         *
         * @param string|null $locale
         * @return $this
         */
        public function setLocale($locale)
        {
        }
        /**
         * Returns true if and only if $value is a floating-point value. Uses the formal definition of a float as described
         * in the PHP manual: {@link https://www.php.net/float}
         *
         * @param mixed $value
         * @return bool
         * @throws Exception\InvalidArgumentException
         */
        public function isValid($value)
        {
        }
    }
    /** @final */
    class IsInt extends \Laminas\Validator\AbstractValidator
    {
        public const INVALID = 'intInvalid';
        public const NOT_INT = 'notInt';
        public const NOT_INT_STRICT = 'notIntStrict';
        /**
         * Validation failure message template definitions
         *
         * @var array<string, string>
         */
        protected $messageTemplates = [self::INVALID => 'Invalid type given. String or integer expected', self::NOT_INT => 'The input does not appear to be an integer', self::NOT_INT_STRICT => 'The input is not strictly an integer'];
        /**
         * Optional locale
         *
         * @var string|null
         */
        protected $locale;
        /**
         * Data type is not enforced by default, so the string '123' is considered an integer.
         * Setting strict to true will enforce the integer data type.
         *
         * @var bool
         */
        protected $strict = false;
        /**
         * Constructor for the integer validator
         *
         * @param iterable<string, mixed> $options
         */
        public function __construct($options = [])
        {
        }
        /**
         * Returns the set locale
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0
         *
         * @return string|null
         */
        public function getLocale()
        {
        }
        /**
         * Sets the locale to use
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0. Provide options to the constructor instead.
         *
         * @param string|null $locale
         * @return $this
         */
        public function setLocale($locale)
        {
        }
        /**
         * Returns the strict option
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0
         *
         * @return bool
         */
        public function getStrict()
        {
        }
        /**
         * Sets the strict option mode
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0. Provide options to the constructor instead.
         *
         * @param bool $strict
         * @return $this
         * @throws Exception\InvalidArgumentException
         */
        public function setStrict($strict)
        {
        }
        /**
         * Returns true if and only if $value is a valid integer
         *
         * @param mixed $value
         * @return bool
         * @throws Exception\InvalidArgumentException
         */
        public function isValid($value)
        {
        }
    }
    /**
     * @deprecated This class is deprecated and will be removed in v3.0.0
     *             Use Laminas\I18n\PhoneNumber\Validator\PhoneNumber instead:
     *             https://github.com/laminas/laminas-i18n-phone-number
     */
    class PhoneNumber extends \Laminas\Validator\AbstractValidator
    {
        public const NO_MATCH = 'phoneNumberNoMatch';
        public const UNSUPPORTED = 'phoneNumberUnsupported';
        public const INVALID = 'phoneNumberInvalid';
        /**
         * Validation failure message template definitions
         *
         * @var string[]
         */
        protected $messageTemplates = [self::NO_MATCH => 'The input does not match a phone number format', self::UNSUPPORTED => 'The country provided is currently unsupported', self::INVALID => 'Invalid type given. String expected'];
        /**
         * Phone Number Patterns
         *
         * @link http://code.google.com/p/libphonenumber/source/browse/trunk/resources/PhoneNumberMetadata.xml
         *
         * @var array
         */
        protected static $phone = [];
        /**
         * ISO 3611 Country Code
         *
         * @var string
         */
        protected $country;
        /**
         * Allow Possible Matches
         *
         * @var bool
         */
        protected $allowPossible = false;
        /**
         * Allowed Types
         *
         * @var string[]
         */
        protected $allowedTypes = ['general', 'fixed', 'tollfree', 'personal', 'mobile', 'voip', 'uan'];
        /**
         * Constructor for the PhoneNumber validator
         *
         * Options
         * - country | string | field or value
         * - allowed_types | array | array of allowed types
         * - allow_possible | boolean | allow possible matches aka non-strict
         *
         * @param iterable<string, mixed> $options
         */
        public function __construct($options = [])
        {
        }
        /**
         * Allowed Types
         *
         * @param  string[]|null $types
         * @return $this|string[]
         */
        public function allowedTypes(?array $types = null)
        {
        }
        /**
         * Allow Possible
         *
         * @param  bool|null $possible
         * @return $this|bool
         */
        public function allowPossible($possible = null)
        {
        }
        /**
         * Get Country
         *
         * @return string
         */
        public function getCountry()
        {
        }
        /**
         * Set Country
         *
         * @param  string $country
         * @return $this
         */
        public function setCountry($country)
        {
        }
        /**
         * Load Pattern
         *
         * @param  string        $code
         * @return array{code: string, patterns: array<string, array<string, string>>}|false
         */
        protected function loadPattern($code)
        {
        }
        /**
         * Returns true if and only if $value matches phone number format
         *
         * @param mixed $value
         * @param array|null $context
         * @return bool
         */
        public function isValid($value = null, $context = null)
        {
        }
    }
    /** @final */
    class PostCode extends \Laminas\Validator\AbstractValidator
    {
        public const INVALID = 'postcodeInvalid';
        public const NO_MATCH = 'postcodeNoMatch';
        public const SERVICE = 'postcodeService';
        public const SERVICEFAILURE = 'postcodeServiceFailure';
        /**
         * Validation failure message template definitions
         *
         * @var array<string, string>
         */
        protected $messageTemplates = [self::INVALID => 'Invalid type given. String or integer expected', self::NO_MATCH => 'The input does not appear to be a postal code', self::SERVICE => 'The input does not appear to be a postal code', self::SERVICEFAILURE => 'An exception has been raised while validating the input'];
        /**
         * Optional Locale to use
         *
         * @var string|null
         */
        protected $locale;
        /**
         * Optional Manual postal code format
         *
         * @var string|null
         */
        protected $format;
        /**
         * Optional Service callback for additional validation
         *
         * @var mixed|null
         */
        protected $service;
        // @codingStandardsIgnoreStart
        /**
         * Postal Code regexes by territory
         *
         * @var array
         */
        protected static $postCodeRegex = ['GB' => 'GIR[ ]?0AA|^((AB|AL|B|BA|BB|BD|BH|BL|BN|BR|BS|BT|CA|CB|CF|CH|CM|CO|CR|CT|CV|CW|DA|DD|DE|DG|DH|DL|DN|DT|DY|E|EC|EH|EN|EX|FK|FY|G|GL|GY|GU|HA|HD|HG|HP|HR|HS|HU|HX|IG|IM|IP|IV|JE|KA|KT|KW|KY|L|LA|LD|LE|LL|LN|LS|LU|M|ME|MK|ML|N|NE|NG|NN|NP|NR|NW|OL|OX|PA|PE|PH|PL|PO|PR|RG|RH|RM|S|SA|SE|SG|SK|SL|SM|SN|SO|SP|SR|SS|ST|SW|SY|TA|TD|TF|TN|TQ|TR|TS|TW|UB|W|WA|WC|WD|WF|WN|WR|WS|WV|YO|ZE)(\d[\dA-Z]?[ ]?\d[ABD-HJLN-UW-Z]{2}))$|^BFPO[ ]?\d{1,4}', 'JE' => 'JE\d[\dA-Z]?[ ]?\d[ABD-HJLN-UW-Z]{2}', 'GG' => 'GY\d[\dA-Z]?[ ]?\d[ABD-HJLN-UW-Z]{2}', 'IM' => 'IM\d[\dA-Z]?[ ]?\d[ABD-HJLN-UW-Z]{2}', 'US' => '\d{5}([ \-]\d{4})?', 'CA' => '[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][ ]?\d[ABCEGHJ-NPRSTV-Z]\d', 'DE' => '\d{5}', 'JP' => '\d{3}-\d{4}', 'FR' => '(?!(0{2})|(9(6|9))[ ]?\d{3})(\d{2}[ ]?\d{3})', 'AU' => '\d{4}', 'IT' => '\d{5}', 'CH' => '\d{4}', 'AT' => '\d{4}', 'ES' => '\d{5}', 'NL' => '\d{4}[ ]?[A-Z]{2}', 'BE' => '\d{4}', 'DK' => '\d{4}', 'SE' => '\d{3}[ ]?\d{2}', 'NO' => '(?!0000)\d{4}', 'BR' => '\d{5}[\-]?\d{3}', 'PT' => '\d{4}([\-]\d{3})?', 'FI' => '\d{5}', 'AX' => '22\d{3}', 'KR' => '\d{3}[\-]\d{3}', 'CN' => '\d{6}', 'TW' => '\d{3}(\d{2})?', 'SG' => '\d{6}', 'DZ' => '\d{5}', 'AD' => 'AD\d{3}', 'AR' => '([A-HJ-NP-Z])?\d{4}([A-Z]{3})?', 'AM' => '(37)?\d{4}', 'AZ' => '\d{4}', 'BH' => '((1[0-2]|[2-9])\d{2})?', 'BD' => '\d{4}', 'BB' => '(BB\d{5})?', 'BY' => '\d{6}', 'BM' => '[A-Z]{2}[ ]?[A-Z0-9]{2}', 'BA' => '\d{5}', 'IO' => 'BBND 1ZZ', 'BN' => '[A-Z]{2}[ ]?\d{4}', 'BG' => '\d{4}', 'KH' => '\d{5}', 'CV' => '\d{4}', 'CL' => '\d{7}', 'CR' => '\d{4,5}|\d{3}-\d{4}', 'HR' => '\d{5}', 'CY' => '\d{4}', 'CZ' => '\d{3}[ ]?\d{2}', 'DO' => '\d{5}', 'EC' => '([A-Z]\d{4}[A-Z]|(?:[A-Z]{2})?\d{6})?', 'EG' => '\d{5}', 'EE' => '\d{5}', 'FO' => '\d{3}', 'GE' => '\d{4}', 'GR' => '\d{3}[ ]?\d{2}', 'GL' => '39\d{2}', 'GT' => '\d{5}', 'HT' => '\d{4}', 'HN' => '(?:\d{5})?', 'HU' => '\d{4}', 'IS' => '\d{3}', 'IN' => '\d{6}', 'ID' => '\d{5}', 'IE' => '[\dA-Z]{3} ?[\dA-Z]{4}', 'IL' => '\d{5}', 'JO' => '\d{5}', 'KZ' => '\d{6}', 'KE' => '\d{5}', 'KW' => '\d{5}', 'LA' => '\d{5}', 'LV' => '(LV-)?\d{4}', 'LB' => '(\d{4}([ ]?\d{4})?)?', 'LI' => '(948[5-9])|(949[0-8])', 'LT' => '\d{5}', 'LU' => '\d{4}', 'MK' => '\d{4}', 'MY' => '\d{5}', 'MV' => '\d{5}', 'MT' => '[A-Z]{3}[ ]?\d{2,4}', 'MU' => '\d{5}', 'MX' => '\d{5}', 'MD' => '\d{4}', 'MC' => '980\d{2}', 'MA' => '\d{5}', 'NP' => '\d{5}', 'NZ' => '\d{4}', 'NI' => '((\d{4}-)?\d{3}-\d{3}(-\d{1})?)?', 'NG' => '(\d{6})?', 'OM' => '(PC )?\d{3}', 'PK' => '\d{5}', 'PY' => '\d{4}', 'PH' => '\d{4}', 'PL' => '\d{2}-\d{3}', 'PR' => '00[679]\d{2}([ \-]\d{4})?', 'RO' => '\d{6}', 'RU' => '\d{6}', 'SM' => '4789\d', 'SA' => '\d{5}', 'SN' => '\d{5}', 'SK' => '\d{3}[ ]?\d{2}', 'SI' => '\d{4}', 'ZA' => '\d{4}', 'LK' => '\d{5}', 'TJ' => '\d{6}', 'TH' => '\d{5}', 'TN' => '\d{4}', 'TR' => '\d{5}', 'TM' => '\d{6}', 'UA' => '\d{5}', 'UY' => '\d{5}', 'UZ' => '\d{6}', 'VA' => '00120', 'VE' => '\d{4}', 'ZM' => '\d{5}', 'AS' => '96799', 'CC' => '6799', 'CK' => '\d{4}', 'RS' => '\d{5}', 'ME' => '8\d{4}', 'CS' => '\d{5}', 'YU' => '\d{5}', 'CX' => '6798', 'ET' => '\d{4}', 'FK' => 'FIQQ 1ZZ', 'NF' => '2899', 'FM' => '(9694[1-4])([ \-]\d{4})?', 'GF' => '9[78]3\d{2}', 'GN' => '\d{3}', 'GP' => '9[78][01]\d{2}', 'GS' => 'SIQQ 1ZZ', 'GU' => '969[123]\d([ \-]\d{4})?', 'GW' => '\d{4}', 'HM' => '\d{4}', 'IQ' => '\d{5}', 'KG' => '\d{6}', 'LR' => '\d{4}', 'LS' => '\d{3}', 'MG' => '\d{3}', 'MH' => '969[67]\d([ \-]\d{4})?', 'MN' => '\d{6}', 'MP' => '9695[012]([ \-]\d{4})?', 'MQ' => '9[78]2\d{2}', 'NC' => '988\d{2}', 'NE' => '\d{4}', 'VI' => '008(([0-4]\d)|(5[01]))([ \-]\d{4})?', 'PF' => '987\d{2}', 'PG' => '\d{3}', 'PM' => '9[78]5\d{2}', 'PN' => 'PCRN 1ZZ', 'PW' => '96940', 'RE' => '9[78]4\d{2}', 'SH' => '(ASCN|STHL) 1ZZ', 'SJ' => '\d{4}', 'SO' => '\d{5}', 'SZ' => '[HLMS]\d{3}', 'TC' => 'TKCA 1ZZ', 'WF' => '986\d{2}', 'YT' => '976\d{2}', 'VN' => '\d{6}', 'VC' => 'VC\d{4}'];
        // @codingStandardsIgnoreEnd
        /**
         * Constructor for the PostCode validator
         *
         * Accepts a string locale and/or "format".
         *
         * @param iterable<string, mixed> $options
         */
        public function __construct($options = [])
        {
        }
        /**
         * Returns the set locale
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0
         *
         * @return string|null The set locale
         */
        public function getLocale()
        {
        }
        /**
         * Sets the locale to use
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0. Provide options to the constructor instead.
         *
         * @param string|null $locale
         * @return $this
         */
        public function setLocale($locale)
        {
        }
        /**
         * Returns the set postal code format
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0
         *
         * @return string|null
         */
        public function getFormat()
        {
        }
        /**
         * Sets a self defined postal format as regex
         *
         * @deprecated Since 2.28.0 - This method will be removed in 3.0. Provide options to the constructor instead.
         *
         * @param string|null $format
         * @return $this
         */
        public function setFormat($format)
        {
        }
        /**
         * Returns the actual set service
         *
         * @deprecated since 2.12.0, this method will be removed in version 3.0.0 of this component.
         *             Additional validations should be done via a validation chain.
         *
         * @return mixed|null
         */
        public function getService()
        {
        }
        /**
         * Sets a new callback for service validation
         *
         * @deprecated since 2.12.0, this method will be removed in version 3.0.0 of this component.
         *             Additional validations should be done via a validation chain.
         *
         * @param mixed|null $service
         * @return $this
         */
        public function setService($service)
        {
        }
        /**
         * Returns true if and only if $value is a valid postalcode
         *
         * @param mixed $value
         * @return bool
         * @throws Exception\InvalidArgumentException
         */
        public function isValid($value)
        {
        }
    }
}
namespace Laminas\I18n\View\Helper {
    abstract class AbstractTranslatorHelper extends \Laminas\View\Helper\AbstractHelper implements \Laminas\I18n\Translator\TranslatorAwareInterface
    {
        use \Laminas\View\Helper\DeprecatedAbstractHelperHierarchyTrait;
        /**
         * Translator (optional)
         *
         * @var Translator|null
         */
        protected $translator;
        /**
         * Translator text domain (optional)
         *
         * @var string
         */
        protected $translatorTextDomain = 'default';
        /**
         * Whether translator should be used
         *
         * @var bool
         */
        protected $translatorEnabled = true;
        /**
         * Sets translator to use in helper
         *
         * @param  Translator|null $translator Default is null, which sets no translator.
         * @param  string|null     $textDomain Default is null, which skips setTranslatorTextDomain
         * @return $this
         */
        public function setTranslator(?\Laminas\I18n\Translator\TranslatorInterface $translator = null, $textDomain = null)
        {
        }
        /**
         * Returns translator used in helper
         *
         * @return Translator|null
         */
        public function getTranslator()
        {
        }
        /**
         * Checks if the helper has a translator
         *
         * @return bool
         */
        public function hasTranslator()
        {
        }
        /**
         * Sets whether translator is enabled and should be used
         *
         * @param  bool $enabled
         * @return $this
         */
        public function setTranslatorEnabled($enabled = true)
        {
        }
        /**
         * Returns whether translator is enabled and should be used
         *
         * @return bool
         */
        public function isTranslatorEnabled()
        {
        }
        /**
         * Set translation text domain
         *
         * @param  string $textDomain
         * @return $this
         */
        public function setTranslatorTextDomain($textDomain = 'default')
        {
        }
        /**
         * Return the translation text domain
         *
         * @return string
         */
        public function getTranslatorTextDomain()
        {
        }
    }
}
namespace Laminas\I18n\View\Helper\Container {
    final class CountryCodeDataListFactory
    {
        public function __invoke(\Psr\Container\ContainerInterface $container): \Laminas\I18n\View\Helper\CountryCodeDataList
        {
        }
    }
}
namespace Laminas\I18n\View\Helper {
    /**
     * A View Helper that outputs an HTML datalist of all the ISO-3166 countries
     */
    final class CountryCodeDataList
    {
        public function __construct(private \Laminas\I18n\Geography\CountryCodeListInterface $codeList, private \Laminas\Escaper\Escaper $escaper, private string $defaultLocale)
        {
        }
        /**
         * @param string|null $locale Must be a valid locale string - used to format the names of the countries
         * @param array<string, scalar> $dataListAttributes An array of HTML attributes applied to the datalist element
         */
        public function __invoke(?string $locale = null, array $dataListAttributes = []): string
        {
        }
    }
    /**
     * View helper for formatting currency.
     */
    class CurrencyFormat extends \Laminas\View\Helper\AbstractHelper
    {
        use \Laminas\View\Helper\DeprecatedAbstractHelperHierarchyTrait;
        /**
         * The 3-letter ISO 4217 currency code indicating the currency to use
         *
         * @var string
         */
        protected $currencyCode;
        /**
         * Formatter instances
         *
         * @var array<string, NumberFormatter>
         */
        protected $formatters = [];
        /**
         * Locale to use instead of the default
         *
         * @var string
         */
        protected $locale;
        /**
         * Currency pattern
         *
         * @var string
         */
        protected $currencyPattern;
        /**
         * If set to true, the currency will be returned with two decimals
         *
         * @var bool
         */
        protected $showDecimals = true;
        /**
         * Special condition to be checked due to ICU bug:
         * http://bugs.icu-project.org/trac/ticket/10997
         *
         * @var bool
         */
        protected $correctionNeeded = false;
        /**
         * Format a number
         *
         * @param  float       $number
         * @param  string|null $currencyCode
         * @param  bool|null   $showDecimals
         * @param  string|null $locale
         * @param  string|null $pattern
         * @return string
         */
        public function __invoke($number, $currencyCode = null, $showDecimals = null, $locale = null, $pattern = null)
        {
        }
        /**
         * Format a number
         *
         * @param  float  $number
         * @param  string $currencyCode
         * @param  bool   $showDecimals
         * @param  string $locale
         * @param  string $pattern
         * @return string
         */
        protected function formatCurrency($number, $currencyCode, $showDecimals, $locale, $pattern)
        {
        }
        /**
         * The 3-letter ISO 4217 currency code indicating the currency to use
         *
         * @param  string $currencyCode
         * @return $this
         */
        public function setCurrencyCode($currencyCode)
        {
        }
        /**
         * Get the 3-letter ISO 4217 currency code indicating the currency to use
         *
         * @return string
         */
        public function getCurrencyCode()
        {
        }
        /**
         * Set the currency pattern
         *
         * @param  string $currencyPattern
         * @return $this
         */
        public function setCurrencyPattern($currencyPattern)
        {
        }
        /**
         * Get the currency pattern
         *
         * @return string
         */
        public function getCurrencyPattern()
        {
        }
        /**
         * Set locale to use instead of the default
         *
         * @param  string $locale
         * @return $this
         */
        public function setLocale($locale)
        {
        }
        /**
         * Get the locale to use
         *
         * @return string
         */
        public function getLocale()
        {
        }
        /**
         * Set if the view helper should show two decimals
         *
         * @param  bool $showDecimals
         * @return $this
         */
        public function setShouldShowDecimals($showDecimals)
        {
        }
        /**
         * Get if the view helper should show two decimals
         *
         * @return bool
         */
        public function shouldShowDecimals()
        {
        }
    }
    /**
     * View helper for formatting dates.
     */
    class DateFormat extends \Laminas\View\Helper\AbstractHelper
    {
        use \Laminas\View\Helper\DeprecatedAbstractHelperHierarchyTrait;
        /**
         * Locale to use instead of the default
         *
         * @var string
         */
        protected $locale;
        /**
         * Timezone to use
         *
         * @var string
         */
        protected $timezone;
        /**
         * Formatter instances
         *
         * @var array<string, IntlDateFormatter>
         */
        protected $formatters = [];
        /**
         * Format a date
         *
         * @param  DateTimeInterface|IntlCalendar|int|array $date
         * @param  int                                      $dateType
         * @param  int                                      $timeType
         * @param  string|null                              $locale
         * @param  string|null                              $pattern
         * @return string
         */
        public function __invoke($date, $dateType = \IntlDateFormatter::NONE, $timeType = \IntlDateFormatter::NONE, $locale = null, $pattern = null)
        {
        }
        /**
         * Set locale to use instead of the default
         *
         * @param  string $locale
         * @return $this
         */
        public function setLocale($locale)
        {
        }
        /**
         * Get the locale to use
         *
         * @return string
         */
        public function getLocale()
        {
        }
        /**
         * Set timezone to use instead of the default
         *
         * @param  string $timezone
         * @return $this
         */
        public function setTimezone($timezone)
        {
        }
        /**
         * Get the timezone to use
         *
         * @return string
         */
        public function getTimezone()
        {
        }
    }
    /**
     * View helper for formatting dates.
     */
    class NumberFormat extends \Laminas\View\Helper\AbstractHelper
    {
        use \Laminas\View\Helper\DeprecatedAbstractHelperHierarchyTrait;
        /**
         * number of decimals to use.
         *
         * @var int
         */
        protected $decimals;
        /**
         * NumberFormat style to use
         *
         * @var int
         */
        protected $formatStyle;
        /**
         * NumberFormat type to use
         *
         * @var int
         */
        protected $formatType;
        /**
         * Formatter instances
         *
         * @var array<string, NumberFormatter>
         */
        protected $formatters = [];
        /**
         * Text attributes.
         *
         * @var array
         */
        protected $textAttributes = [];
        /**
         * Locale to use instead of the default
         *
         * @var string
         */
        protected $locale;
        /**
         * Format a number
         *
         * @param  int|float   $number
         * @param  int|null    $formatStyle
         * @param  int|null    $formatType
         * @param  string|null $locale
         * @param  int|null    $decimals
         * @param  array|null  $textAttributes
         * @return string
         */
        public function __invoke($number, $formatStyle = null, $formatType = null, $locale = null, $decimals = null, ?array $textAttributes = null)
        {
        }
        /**
         * Set format style to use instead of the default
         *
         * @param  int $formatStyle
         * @return $this
         */
        public function setFormatStyle($formatStyle)
        {
        }
        /**
         * Get the format style to use
         *
         * @return int
         */
        public function getFormatStyle()
        {
        }
        /**
         * Set format type to use instead of the default
         *
         * @param  int $formatType
         * @return $this
         */
        public function setFormatType($formatType)
        {
        }
        /**
         * Get the format type to use
         *
         * @return int
         */
        public function getFormatType()
        {
        }
        /**
         * Set number of decimals to use instead of the default.
         *
         * @param  int $decimals
         * @return $this
         */
        public function setDecimals($decimals)
        {
        }
        /**
         * Get number of decimals.
         *
         * @return int
         */
        public function getDecimals()
        {
        }
        /**
         * Set locale to use instead of the default.
         *
         * @param  string $locale
         * @return $this
         */
        public function setLocale($locale)
        {
        }
        /**
         * Get the locale to use
         *
         * @return string
         */
        public function getLocale()
        {
        }
        /**
         * @return array
         */
        public function getTextAttributes()
        {
        }
        /**
         * @param array $textAttributes
         * @return $this
         */
        public function setTextAttributes(array $textAttributes)
        {
        }
    }
    /**
     * Helper for rendering text based on a count number (like the I18n plural translation helper, but when translation
     * is not needed).
     *
     * Please note that we did not write any hard-coded rules for languages, as languages can evolve, we preferred to
     * let the developer define the rules himself, instead of potentially break applications if we change rules in the
     * future.
     *
     * However, you can find most of the up-to-date plural rules for most languages in those links:
     *      - http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
     *      - https://developer.mozilla.org/en-US/docs/Localization_and_Plurals
     */
    class Plural extends \Laminas\View\Helper\AbstractHelper
    {
        use \Laminas\View\Helper\DeprecatedAbstractHelperHierarchyTrait;
        /**
         * Plural rule to use
         *
         * @var PluralRule|null
         */
        protected $rule;
        /**
         * Given an array of strings, a number and, if wanted, an optional locale (the default one is used
         * otherwise), this picks the right string according to plural rules of the locale
         *
         * @param  array|string $strings
         * @param  int          $number
         * @throws Exception\InvalidArgumentException
         * @return string
         */
        public function __invoke($strings, $number)
        {
        }
        /**
         * Set the plural rule to use
         *
         * @param  PluralRule|string $pluralRule
         * @return $this
         */
        public function setPluralRule($pluralRule)
        {
        }
        /**
         * Get the plural rule to use
         *
         * @return PluralRule|null
         */
        public function getPluralRule()
        {
        }
    }
    /**
     * View helper for translating messages.
     */
    class Translate extends \Laminas\I18n\View\Helper\AbstractTranslatorHelper
    {
        /**
         * Translate a message
         *
         * @param  string      $message
         * @param  string|null $textDomain
         * @param  string|null $locale
         * @throws Exception\RuntimeException
         * @return string
         */
        public function __invoke($message, $textDomain = null, $locale = null)
        {
        }
    }
    /**
     * View helper for translating plural messages.
     */
    class TranslatePlural extends \Laminas\I18n\View\Helper\AbstractTranslatorHelper
    {
        /**
         * Translate a plural message
         *
         * @param  string      $singular
         * @param  string      $plural
         * @param  int         $number
         * @param  string|null $textDomain
         * @param  string|null $locale
         * @throws Exception\RuntimeException
         * @return string
         */
        public function __invoke($singular, $plural, $number, $textDomain = null, $locale = null)
        {
        }
    }
}
namespace Laminas\ServiceManager {
    /**
     * @deprecated Interface will be removed as of v4.0
     *
     * @see ContainerInterface
     * @see ArrayAccess
     *
     * @psalm-type AbstractFactoriesConfigurationType = array<
     *      array-key,
     *      (class-string<Factory\AbstractFactoryInterface>|Factory\AbstractFactoryInterface)
     * >
     * @psalm-type DelegatorsConfigurationType = array<
     *      string,
     *      array<
     *          array-key,
     *          (class-string<Factory\DelegatorFactoryInterface>|Factory\DelegatorFactoryInterface)
     *          |callable(ContainerInterface,string,callable():object,array<mixed>|null):object
     *      >
     * >
     * @psalm-type FactoriesConfigurationType = array<
     *      string,
     *      (class-string<Factory\FactoryInterface>|Factory\FactoryInterface)
     *      |callable(ContainerInterface,?string,?array<mixed>|null):object
     * >
     * @psalm-type InitializersConfigurationType = array<
     *      array-key,
     *      (class-string<Initializer\InitializerInterface>|Initializer\InitializerInterface)
     *      |callable(ContainerInterface,object):void
     * >
     * @psalm-type LazyServicesConfigurationType = array{
     *      class_map?:array<string,class-string>,
     *      proxies_namespace?:non-empty-string,
     *      proxies_target_dir?:non-empty-string,
     *      write_proxy_files?:bool
     * }
     * @psalm-type ServiceManagerConfigurationType = array{
     *     abstract_factories?: AbstractFactoriesConfigurationType,
     *     aliases?: array<string,string>,
     *     delegators?: DelegatorsConfigurationType,
     *     factories?: FactoriesConfigurationType,
     *     initializers?: InitializersConfigurationType,
     *     invokables?: array<string,string>,
     *     lazy_services?: LazyServicesConfigurationType,
     *     services?: array<string,object|array>,
     *     shared?:array<string,bool>,
     *     ...
     * }
     */
    interface ConfigInterface
    {
        /**
         * Configure a service manager.
         *
         * Implementations should pull configuration from somewhere (typically
         * local properties) and pass it to a ServiceManager's withConfig() method,
         * returning a new instance.
         *
         * @return ServiceManager
         */
        public function configureServiceManager(\Laminas\ServiceManager\ServiceManager $serviceManager);
        /**
         * Return configuration for a service manager instance as an array.
         *
         * Implementations MUST return an array compatible with ServiceManager::configure,
         * containing one or more of the following keys:
         *
         * - abstract_factories
         * - aliases
         * - delegators
         * - factories
         * - initializers
         * - invokables
         * - lazy_services
         * - services
         * - shared
         *
         * In other words, this should return configuration that can be used to instantiate
         * a service manager or plugin manager, or pass to its `withConfig()` method.
         *
         * @return array
         * @psalm-return ServiceManagerConfigurationType
         */
        public function toArray();
    }
}
namespace Laminas\I18n\View {
    /**
     * Service manager configuration for i18n view helpers.
     *
     * @deprecated since 2.7.0; replaced by ConfigProvider and Module class.
     */
    class HelperConfig implements \Laminas\ServiceManager\ConfigInterface
    {
        /**
         * Common aliases for helpers
         *
         * @var array
         */
        protected $aliases = [
            'currencyformat' => \Laminas\I18n\View\Helper\CurrencyFormat::class,
            'currencyFormat' => \Laminas\I18n\View\Helper\CurrencyFormat::class,
            'CurrencyFormat' => \Laminas\I18n\View\Helper\CurrencyFormat::class,
            'dateformat' => \Laminas\I18n\View\Helper\DateFormat::class,
            'dateFormat' => \Laminas\I18n\View\Helper\DateFormat::class,
            'DateFormat' => \Laminas\I18n\View\Helper\DateFormat::class,
            'numberformat' => \Laminas\I18n\View\Helper\NumberFormat::class,
            'numberFormat' => \Laminas\I18n\View\Helper\NumberFormat::class,
            'NumberFormat' => \Laminas\I18n\View\Helper\NumberFormat::class,
            'plural' => \Laminas\I18n\View\Helper\Plural::class,
            'Plural' => \Laminas\I18n\View\Helper\Plural::class,
            'translate' => \Laminas\I18n\View\Helper\Translate::class,
            'Translate' => \Laminas\I18n\View\Helper\Translate::class,
            'translateplural' => \Laminas\I18n\View\Helper\TranslatePlural::class,
            'translatePlural' => \Laminas\I18n\View\Helper\TranslatePlural::class,
            'TranslatePlural' => \Laminas\I18n\View\Helper\TranslatePlural::class,
            // Legacy Zend Framework aliases
            // @codingStandardsIgnoreStart
            \Zend\I18n\View\Helper\CurrencyFormat::class => \Laminas\I18n\View\Helper\CurrencyFormat::class,
            \Zend\I18n\View\Helper\DateFormat::class => \Laminas\I18n\View\Helper\DateFormat::class,
            \Zend\I18n\View\Helper\NumberFormat::class => \Laminas\I18n\View\Helper\NumberFormat::class,
            \Zend\I18n\View\Helper\Plural::class => \Laminas\I18n\View\Helper\Plural::class,
            \Zend\I18n\View\Helper\Translate::class => \Laminas\I18n\View\Helper\Translate::class,
            \Zend\I18n\View\Helper\TranslatePlural::class => \Laminas\I18n\View\Helper\TranslatePlural::class,
            // @codingStandardsIgnoreEnd
            // v2 normalized FQCNs
            'zendi18nviewhelpercurrencyformat' => \Laminas\I18n\View\Helper\CurrencyFormat::class,
            'zendi18nviewhelperdateformat' => \Laminas\I18n\View\Helper\DateFormat::class,
            'zendi18nviewhelpernumberformat' => \Laminas\I18n\View\Helper\NumberFormat::class,
            'zendi18nviewhelperplural' => \Laminas\I18n\View\Helper\Plural::class,
            'zendi18nviewhelpertranslate' => \Laminas\I18n\View\Helper\Translate::class,
            'zendi18nviewhelpertranslateplural' => \Laminas\I18n\View\Helper\TranslatePlural::class,
        ];
        /**
         * Factories for included helpers.
         *
         * @var array
         */
        protected $factories = [
            \Laminas\I18n\View\Helper\CurrencyFormat::class => \Laminas\ServiceManager\Factory\InvokableFactory::class,
            \Laminas\I18n\View\Helper\DateFormat::class => \Laminas\ServiceManager\Factory\InvokableFactory::class,
            \Laminas\I18n\View\Helper\NumberFormat::class => \Laminas\ServiceManager\Factory\InvokableFactory::class,
            \Laminas\I18n\View\Helper\Plural::class => \Laminas\ServiceManager\Factory\InvokableFactory::class,
            \Laminas\I18n\View\Helper\Translate::class => \Laminas\ServiceManager\Factory\InvokableFactory::class,
            \Laminas\I18n\View\Helper\TranslatePlural::class => \Laminas\ServiceManager\Factory\InvokableFactory::class,
            // Legacy (v2) due to alias resolution; canonical form of resolved
            // alias is used to look up the factory, while the non-normalized
            // resolved alias is used as the requested name passed to the factory.
            'laminasi18nviewhelpercurrencyformat' => \Laminas\ServiceManager\Factory\InvokableFactory::class,
            'laminasi18nviewhelperdateformat' => \Laminas\ServiceManager\Factory\InvokableFactory::class,
            'laminasi18nviewhelpernumberformat' => \Laminas\ServiceManager\Factory\InvokableFactory::class,
            'laminasi18nviewhelperplural' => \Laminas\ServiceManager\Factory\InvokableFactory::class,
            'laminasi18nviewhelpertranslate' => \Laminas\ServiceManager\Factory\InvokableFactory::class,
            'laminasi18nviewhelpertranslateplural' => \Laminas\ServiceManager\Factory\InvokableFactory::class,
        ];
        /**
         * Configure the provided service manager instance with the configuration
         * in this class.
         *
         * @return ServiceManager
         */
        public function configureServiceManager(\Laminas\ServiceManager\ServiceManager $serviceManager)
        {
        }
        /**
         * Cast configuration to an array.
         *
         * Provided for v3 compatibility
         *
         * @return array
         */
        public function toArray()
        {
        }
    }
    // @codingStandardsIgnoreStart
    /**
     * Helper trait for auto-completion of code in modern IDEs.
     *
     * The trait provides convenience methods for view helpers,
     * defined by the laminas-i18n component. It is designed to be used
     * for type-hinting $this variable inside laminas-view templates via doc blocks.
     *
     * The base class is PhpRenderer, followed by the helper trait from
     * the laminas-i18n component. However, multiple helper traits from different
     * Laminas components can be chained afterwards.
     *
     * @example @var \Laminas\View\Renderer\PhpRenderer|\Laminas\I18n\View\HelperTrait $this
     *
     * @method string countryCodeDataList(?string $locale = null, array $dataListAttributes = [])
     * @method string currencyFormat(float $number, string|null $currencyCode = null, bool|null $showDecimals = null, string|null $locale = null, string|null $pattern = null)
     * @method string dateFormat(\DateTimeInterface|\IntlCalendar|int|array $date, int $dateType = IntlDateFormatter::NONE, int $timeType = IntlDateFormatter::NONE, string|null $locale = null, string|null $pattern = null)
     * @method string numberFormat(int|float $number, int|null $formatStyle = null, int|null $formatType = null, string|null $locale = null, int|null $decimals = null, array|null $textAttributes = null)
     * @method string plural(array|string $strings, int $number)
     * @method string translate(string $message, string|null $textDomain = null, string|null $locale = null)
     * @method string translatePlural(string $singular, string $plural, int $number, string|null $textDomain = null, string|null $locale = null)
     */
    trait HelperTrait
    {
    }
}
namespace Laminas\ServiceManager\Factory {
    /**
     * Interface for an abstract factory.
     *
     * An abstract factory extends the factory interface, but also has an
     * additional "canCreate" method, which is called to check if the abstract
     * factory has the ability to create an instance for the given service. You
     * should limit the number of abstract factories to ensure good performance.
     * Starting from ServiceManager v3, remember that you can also attach multiple
     * names to the same factory, which reduces the need for abstract factories.
     */
    interface AbstractFactoryInterface extends \Laminas\ServiceManager\Factory\FactoryInterface
    {
        /**
         * Can the factory create an instance for the service?
         *
         * @param  string $requestedName
         * @return bool
         */
        public function canCreate(\Psr\Container\ContainerInterface $container, $requestedName);
    }
}
namespace Laminas\ServiceManager\AbstractFactory {
    final class ConfigAbstractFactory implements \Laminas\ServiceManager\Factory\AbstractFactoryInterface
    {
        /**
         * Factory can create the service if there is a key for it in the config
         *
         * {@inheritdoc}
         */
        public function canCreate(\Psr\Container\ContainerInterface $container, $requestedName)
        {
        }
        /** {@inheritDoc} */
        public function __invoke(\Psr\Container\ContainerInterface $container, $requestedName, ?array $options = null)
        {
        }
    }
    /**
     * Reflection-based factory.
     *
     * To ease development, this factory may be used for classes with
     * type-hinted arguments that resolve to services in the application
     * container; this allows omitting the step of writing a factory for
     * each controller.
     *
     * You may use it as either an abstract factory:
     *
     * <code>
     * 'service_manager' => [
     *     'abstract_factories' => [
     *         ReflectionBasedAbstractFactory::class,
     *     ],
     * ],
     * </code>
     *
     * Or as a factory, mapping a class name to it:
     *
     * <code>
     * 'service_manager' => [
     *     'factories' => [
     *         MyClassWithDependencies::class => ReflectionBasedAbstractFactory::class,
     *     ],
     * ],
     * </code>
     *
     * The latter approach is more explicit, and also more performant.
     *
     * The factory has the following constraints/features:
     *
     * - A parameter named `$config` typehinted as an array will receive the
     *   application "config" service (i.e., the merged configuration).
     * - Parameters type-hinted against array, but not named `$config` will
     *   be injected with an empty array.
     * - Scalar parameters will result in an exception being thrown, unless
     *   a default value is present; if the default is present, that will be used.
     * - If a service cannot be found for a given typehint, the factory will
     *   raise an exception detailing this.
     * - Some services provided by Laminas components do not have
     *   entries based on their class name (for historical reasons); the
     *   factory allows defining a map of these class/interface names to the
     *   corresponding service name to allow them to resolve.
     *
     * `$options` passed to the factory are ignored in all cases, as we cannot
     * make assumptions about which argument(s) they might replace.
     *
     * Based on the LazyControllerAbstractFactory from laminas-mvc.
     */
    class ReflectionBasedAbstractFactory implements \Laminas\ServiceManager\Factory\AbstractFactoryInterface
    {
        /**
         * Maps known classes/interfaces to the service that provides them; only
         * required for those services with no entry based on the class/interface
         * name.
         *
         * Extend the class if you wish to add to the list.
         *
         * Example:
         *
         * <code>
         * [
         *     \Laminas\Filter\FilterPluginManager::class       => 'FilterManager',
         *     \Laminas\Validator\ValidatorPluginManager::class => 'ValidatorManager',
         * ]
         * </code>
         *
         * @var string[]
         */
        protected $aliases = [];
        /**
         * Allows overriding the internal list of aliases. These should be of the
         * form `class name => well-known service name`; see the documentation for
         * the `$aliases` property for details on what is accepted.
         *
         * @param string[] $aliases
         */
        public function __construct(array $aliases = [])
        {
        }
        /**
         * {@inheritDoc}
         *
         * @return DispatchableInterface
         */
        public function __invoke(\Psr\Container\ContainerInterface $container, $requestedName, ?array $options = null)
        {
        }
        /** {@inheritDoc} */
        public function canCreate(\Psr\Container\ContainerInterface $container, $requestedName)
        {
        }
    }
}
namespace Laminas\ServiceManager {
    /**
     * Backwards-compatibility shim for AbstractFactoryInterface.
     *
     * Implementations should update to implement only Laminas\ServiceManager\Factory\AbstractFactoryInterface.
     *
     * If upgrading from v2, take the following steps:
     *
     * - rename the method `canCreateServiceWithName()` to `canCreate()`, and:
     *   - rename the `$serviceLocator` argument to `$container`, and change the
     *     typehint to `Psr\Container\ContainerInterface`
     *   - merge the `$name` and `$requestedName` arguments
     * - rename the method `createServiceWithName()` to `__invoke()`, and:
     *   - rename the `$serviceLocator` argument to `$container`, and change the
     *     typehint to `Psr\Container\ContainerInterface`
     *   - merge the `$name` and `$requestedName` arguments
     *   - add the optional `array $options = null` argument.
     * - create a `canCreateServiceWithName()` method as defined in this interface, and have it
     *   proxy to `canCreate()`, passing `$requestedName` as the second argument.
     * - create a `createServiceWithName()` method as defined in this interface, and have it
     *   proxy to `__invoke()`, passing `$requestedName` as the second argument.
     *
     * Once you have tested your code, you can then update your class to only implement
     * Laminas\ServiceManager\Factory\AbstractFactoryInterface, and remove the `canCreateServiceWithName()`
     * and `createServiceWithName()` methods.
     *
     * @deprecated Use Laminas\ServiceManager\Factory\AbstractFactoryInterface instead.
     */
    interface AbstractFactoryInterface extends \Laminas\ServiceManager\Factory\AbstractFactoryInterface
    {
        /**
         * Determine if we can create a service with name
         *
         * @param string $name
         * @param string $requestedName
         * @return bool
         */
        public function canCreateServiceWithName(\Laminas\ServiceManager\ServiceLocatorInterface $serviceLocator, $name, $requestedName);
        /**
         * Create service with name
         *
         * @param string $name
         * @param string $requestedName
         * @return mixed
         */
        public function createServiceWithName(\Laminas\ServiceManager\ServiceLocatorInterface $serviceLocator, $name, $requestedName);
    }
    /**
     * Object for defining configuration and configuring an existing service manager instance.
     *
     * In order to provide configuration merging capabilities, this class implements
     * the same functionality as `Laminas\Stdlib\ArrayUtils::merge()`. That routine
     * allows developers to specifically shape how values are merged:
     *
     * - A value which is an instance of `MergeRemoveKey` indicates the value should
     *   be removed during merge.
     * - A value that is an instance of `MergeReplaceKeyInterface` indicates that the
     *   value it contains should be used to replace any previous versions.
     *
     * These features are advanced, and not typically used. If you wish to use them,
     * you will need to require the laminas-stdlib package in your application.
     *
     * @deprecated Class will be removed as of v4.0
     *
     * @psalm-import-type ServiceManagerConfigurationType from ConfigInterface
     */
    class Config implements \Laminas\ServiceManager\ConfigInterface
    {
        /**
         * @var array<string,array>
         * @psalm-var ServiceManagerConfigurationType
         */
        protected $config = ['abstract_factories' => [], 'aliases' => [], 'delegators' => [], 'factories' => [], 'initializers' => [], 'invokables' => [], 'lazy_services' => [], 'services' => [], 'shared' => []];
        /**
         * @psalm-param ServiceManagerConfigurationType $config
         */
        public function __construct(array $config = [])
        {
        }
        /**
         * @inheritDoc
         */
        public function configureServiceManager(\Laminas\ServiceManager\ServiceManager $serviceManager)
        {
        }
        /**
         * @inheritDoc
         */
        public function toArray()
        {
        }
    }
}
namespace Laminas\ServiceManager\Factory {
    /**
     * Delegator factory interface.
     *
     * Defines the capabilities required by a delegator factory. Delegator
     * factories are used to either decorate a service instance, or to allow
     * decorating the instantiation of a service instance (for instance, to
     * provide optional dependencies via setters, etc.).
     */
    interface DelegatorFactoryInterface
    {
        /**
         * A factory that creates delegates of a given service
         *
         * @param  string                $name
         * @psalm-param callable():mixed $callback
         * @param  null|array<mixed>     $options
         * @return object
         * @throws ServiceNotFoundException If unable to resolve the service.
         * @throws ServiceNotCreatedException If an exception is raised when creating a service.
         * @throws ContainerExceptionInterface If any other error occurs.
         */
        public function __invoke(\Psr\Container\ContainerInterface $container, $name, callable $callback, ?array $options = null);
    }
}
namespace Laminas\ServiceManager {
    /**
     * Backwards-compatibility shim for DelegatorFactoryInterface.
     *
     * Implementations should update to implement only Laminas\ServiceManager\Factory\DelegatorFactoryInterface.
     *
     * If upgrading from v2, take the following steps:
     *
     * - rename the method `createDelegatorWithName()` to `__invoke()`, and:
     *   - rename the `$serviceLocator` argument to `$container`, and change the
     *     typehint to `Psr\Container\ContainerInterface`
     *   - merge the `$name` and `$requestedName` arguments
     *   - add the `callable` typehint to the `$callback` argument
     *   - add the optional `array $options = null` argument as a final argument
     * - create a `createDelegatorWithName()` method as defined in this interface, and have it
     *   proxy to `__invoke()`, passing `$requestedName` as the second argument.
     *
     * Once you have tested your code, you can then update your class to only implement
     * Laminas\ServiceManager\Factory\DelegatorFactoryInterface, and remove the `createDelegatorWithName()`
     * method.
     *
     * @deprecated Use Laminas\ServiceManager\Factory\DelegatorFactoryInterface instead.
     */
    interface DelegatorFactoryInterface extends \Laminas\ServiceManager\Factory\DelegatorFactoryInterface
    {
        /**
         * A factory that creates delegates of a given service
         *
         * @param ServiceLocatorInterface $serviceLocator the service locator which requested the service
         * @param string                  $name           the normalized service name
         * @param string                  $requestedName  the requested service name
         * @param callable                $callback       the callback that is responsible for creating the service
         * @return mixed
         */
        public function createDelegatorWithName(\Laminas\ServiceManager\ServiceLocatorInterface $serviceLocator, $name, $requestedName, $callback);
    }
}
namespace Laminas\ServiceManager\Exception {
    /**
     * Base exception for all Laminas\ServiceManager exceptions.
     */
    interface ExceptionInterface extends \Psr\Container\ContainerExceptionInterface
    {
    }
    class ContainerModificationsNotAllowedException extends \DomainException implements \Laminas\ServiceManager\Exception\ExceptionInterface
    {
        /**
         * @param string $service Name of service that already exists.
         */
        public static function fromExistingService(string $service): self
        {
        }
    }
    /**
     * @inheritDoc
     */
    class InvalidArgumentException extends \InvalidArgumentException implements \Laminas\ServiceManager\Exception\ExceptionInterface
    {
        public static function fromInvalidInitializer(mixed $initializer): self
        {
        }
        public static function fromInvalidAbstractFactory(mixed $abstractFactory): self
        {
        }
    }
    class CyclicAliasException extends \Laminas\ServiceManager\Exception\InvalidArgumentException
    {
        /**
         * @param string   $alias conflicting alias key
         * @param string[] $aliases map of referenced services, indexed by alias name (string)
         */
        public static function fromCyclicAlias(string $alias, array $aliases): self
        {
        }
        /**
         * @param string[] $aliases map of referenced services, indexed by alias name (string)
         * @return self
         */
        public static function fromAliasesMap(array $aliases)
        {
        }
    }
    /**
     * This exception is thrown by plugin managers when the created object does not match
     * the plugin manager's conditions
     */
    class InvalidServiceException extends \RuntimeException implements \Laminas\ServiceManager\Exception\ExceptionInterface
    {
    }
    /**
     * This exception is thrown when the service locator do not manage to create
     * the service (factory that has an error...)
     */
    class ServiceNotCreatedException extends \RuntimeException implements \Laminas\ServiceManager\Exception\ExceptionInterface
    {
    }
    /**
     * This exception is thrown when the service locator do not manage to find a
     * valid factory to create a service
     */
    class ServiceNotFoundException extends \InvalidArgumentException implements \Laminas\ServiceManager\Exception\ExceptionInterface, \Psr\Container\NotFoundExceptionInterface
    {
    }
}
namespace Laminas\ServiceManager\Factory {
    /**
     * Factory for instantiating classes with no dependencies or which accept a single array.
     *
     * The InvokableFactory can be used for any class that:
     *
     * - has no constructor arguments;
     * - accepts a single array of arguments via the constructor.
     *
     * It replaces the "invokables" and "invokable class" functionality of the v2
     * service manager.
     */
    final class InvokableFactory implements \Laminas\ServiceManager\Factory\FactoryInterface
    {
        /** {@inheritDoc} */
        public function __invoke(\Psr\Container\ContainerInterface $container, $requestedName, ?array $options = null)
        {
        }
    }
}
namespace Laminas\ServiceManager\Initializer {
    /**
     * Interface for an initializer
     *
     * An initializer can be registered to a service locator, and are run after an instance is created
     * to inject additional dependencies through setters
     */
    interface InitializerInterface
    {
        /**
         * Initialize the given instance
         *
         * @param  object             $instance
         * @return void
         */
        public function __invoke(\Psr\Container\ContainerInterface $container, $instance);
    }
}
namespace Laminas\ServiceManager {
    /**
     * Backwards-compatibility shim for InitializerInterface.
     *
     * Implementations should update to implement only Laminas\ServiceManager\Initializer\InitializerInterface.
     *
     * If upgrading from v2, take the following steps:
     *
     * - rename the method `initialize()` to `__invoke()`, and:
     *   - rename the `$serviceLocator` argument to `$container`, and change the
     *     typehint to `Psr\Container\ContainerInterface`
     *   - swap the order of the arguments (so that `$instance` comes second)
     * - create an `initialize()` method as defined in this interface, and have it
     *   proxy to `__invoke()`, passing the arguments in the new order.
     *
     * Once you have tested your code, you can then update your class to only implement
     * Laminas\ServiceManager\Initializer\InitializerInterface, and remove the `initialize()`
     * method.
     *
     * @deprecated Use Laminas\ServiceManager\Initializer\InitializerInterface instead.
     */
    interface InitializerInterface extends \Laminas\ServiceManager\Initializer\InitializerInterface
    {
        /**
         * Initialize
         *
         * @return mixed
         */
        public function initialize(mixed $instance, \Laminas\ServiceManager\ServiceLocatorInterface $serviceLocator);
    }
}
namespace Laminas\ServiceManager\Proxy {
    /**
     * Delegator factory responsible for instantiating lazy loading value holder proxies of
     * given services at runtime
     *
     * @link https://github.com/Ocramius/ProxyManager/blob/master/docs/lazy-loading-value-holder.md
     */
    final class LazyServiceFactory implements \Laminas\ServiceManager\Factory\DelegatorFactoryInterface
    {
        /**
         * @param array<string, class-string> $servicesMap A map of service names to
         *     class names of their respective classes
         */
        public function __construct(private \ProxyManager\Factory\LazyLoadingValueHolderFactory $proxyFactory, private array $servicesMap)
        {
        }
        /**
         * {@inheritDoc}
         *
         * @param string $name
         * @return VirtualProxyInterface
         */
        public function __invoke(\Psr\Container\ContainerInterface $container, $name, callable $callback, ?array $options = null)
        {
        }
    }
}
namespace Laminas\ServiceManager\Test {
    /**
     * Trait for testing plugin managers for v2-v3 compatibility
     *
     * To use this trait:
     *   * implement the `getPluginManager()` method to return your plugin manager
     *   * implement the `getV2InvalidPluginException()` method to return the class `validatePlugin()` throws under v2
     */
    trait CommonPluginManagerTrait
    {
        public function testInstanceOfMatches()
        {
        }
        public function testShareByDefaultAndSharedByDefault()
        {
        }
        public function testRegisteringInvalidElementRaisesException()
        {
        }
        public function testLoadingInvalidElementRaisesException()
        {
        }
        /**
         * @dataProvider aliasProvider
         * @param string $alias
         * @param string $expected
         */
        public function testPluginAliasesResolve($alias, $expected)
        {
        }
        /**
         * @return array
         */
        public static function aliasProvider(): array
        {
        }
        protected function getServiceNotFoundException(): string
        {
        }
        /**
         * Returns the plugin manager to test
         *
         * @return AbstractPluginManager
         */
        abstract protected static function getPluginManager();
        /**
         * Returns the FQCN of the exception thrown under v2 by `validatePlugin()`
         *
         * @return mixed
         */
        abstract protected function getV2InvalidPluginException();
        /**
         * Returns the value the instanceOf property has been set to
         *
         * @return string
         */
        abstract protected function getInstanceOf();
    }
}
namespace Laminas\ServiceManager\Tool {
    class ConfigDumper
    {
        public const CONFIG_TEMPLATE = <<<EOC
        <?php
        
        /**
         * This file generated by %s.
         * Generated %s
         */
        
        return %s;
        EOC;
        public function __construct(private ?\Psr\Container\ContainerInterface $container = null)
        {
        }
        /**
         * @param string $className
         * @param bool $ignoreUnresolved
         * @return array
         * @throws InvalidArgumentException For invalid $className.
         */
        public function createDependencyConfig(array $config, $className, $ignoreUnresolved = false)
        {
        }
        /**
         * @return array
         * @throws InvalidArgumentException If ConfigAbstractFactory configuration
         *     value is not an array.
         */
        public function createFactoryMappingsFromConfig(array $config)
        {
        }
        /**
         * @param string $className
         * @return array
         */
        public function createFactoryMappings(array $config, $className)
        {
        }
        /**
         * @return string
         */
        public function dumpConfigFile(array $config)
        {
        }
    }
    /**
     * @psalm-type HelpObject = object{
     *     command: string
     * }
     * @psalm-type ErrorObject = object{
     *     command: string,
     *     message: string
     * }
     * @psalm-type ArgumentObject = object{
     *     command: string,
     *     configFile: string,
     *     config: array<array-key, mixed>,
     *     class: string,
     *     ignoreUnresolved: bool
     * }
     */
    class ConfigDumperCommand
    {
        public const COMMAND_DUMP = 'dump';
        public const COMMAND_ERROR = 'error';
        public const COMMAND_HELP = 'help';
        public const DEFAULT_SCRIPT_NAME = self::class;
        public const HELP_TEMPLATE = <<<EOH
        <info>Usage:</info>
        
          %s [-h|--help|help] [-i|--ignore-unresolved] <configFile> <className>
        
        <info>Arguments:</info>
        
          <info>-h|--help|help</info>          This usage message
          <info>-i|--ignore-unresolved</info>  Ignore classes with unresolved direct dependencies.
          <info><configFile></info>            Path to a config file for which to generate
                                  configuration. If the file does not exist, it will
                                  be created. If it does exist, it must return an
                                  array, and the file will be updated with new
                                  configuration.
          <info><className></info>             Name of the class to reflect and for which to
                                  generate dependency configuration.
        
        Reads the provided configuration file (creating it if it does not exist),
        and injects it with ConfigAbstractFactory dependency configuration for
        the provided class name, writing the changes back to the file.
        EOH;
        /**
         * @param string $scriptName
         */
        public function __construct(private $scriptName = self::DEFAULT_SCRIPT_NAME, ?\Laminas\Stdlib\ConsoleHelper $helper = null)
        {
        }
        /**
         * @param array $args Argument list, minus script name
         * @return int Exit status
         */
        public function __invoke(array $args)
        {
        }
    }
    class FactoryCreator
    {
        public const FACTORY_TEMPLATE = <<<'EOT'
        <?php
        
        declare(strict_types=1);
        
        namespace %s;
        
        %s
        
        class %sFactory implements FactoryInterface
        {
            /**
             * @param ContainerInterface $container
             * @param string $requestedName
             * @param null|array $options
             * @return %s
             */
            public function __invoke(ContainerInterface $container, $requestedName, array $options = null)
            {
                return new %s(%s);
            }
        }
        
        EOT;
        /**
         * @param string $className
         * @return string
         */
        public function createFactory($className)
        {
        }
    }
    /**
     * @psalm-type ArgumentObject = object{command:string, class:null|string, message:null|string}
     */
    class FactoryCreatorCommand
    {
        public const COMMAND_DUMP = 'dump';
        public const COMMAND_ERROR = 'error';
        public const COMMAND_HELP = 'help';
        public const DEFAULT_SCRIPT_NAME = self::class;
        public const HELP_TEMPLATE = <<<EOH
        <info>Usage:</info>
        
          %s [-h|--help|help] <className>
        
        <info>Arguments:</info>
        
          <info>-h|--help|help</info>    This usage message
          <info><className></info>       Name of the class to reflect and for which to generate
                            a factory.
        
        Generates to STDOUT a factory for creating the specified class; this may then
        be added to your application, and configured as a factory for the class.
        EOH;
        /**
         * @param string $scriptName
         */
        public function __construct(private $scriptName = self::DEFAULT_SCRIPT_NAME, ?\Laminas\Stdlib\ConsoleHelper $helper = null)
        {
        }
        /**
         * @param array $args Argument list, minus script name
         * @return int Exit status
         */
        public function __invoke(array $args)
        {
        }
    }
}
namespace Laminas\Stdlib {
    /**
     * @template TKey of string
     * @template TValue
     */
    interface ParameterObjectInterface
    {
        /**
         * @param TKey $key
         * @param TValue|null $value
         * @return void
         */
        public function __set($key, mixed $value);
        /**
         * @param TKey $key
         * @return TValue
         */
        public function __get($key);
        /**
         * @param TKey $key
         * @return bool
         */
        public function __isset($key);
        /**
         * @param TKey $key
         * @return void
         */
        public function __unset($key);
    }
    /**
     * @template TValue
     * @implements ParameterObjectInterface<string, TValue>
     */
    abstract class AbstractOptions implements \Laminas\Stdlib\ParameterObjectInterface
    {
        // phpcs:disable PSR2.Classes.PropertyDeclaration.Underscore,WebimpressCodingStandard.NamingConventions.ValidVariableName.NotCamelCapsProperty
        /**
         * We use the __ prefix to avoid collisions with properties in
         * user-implementations.
         *
         * @var bool
         */
        protected $__strictMode__ = true;
        // phpcs:enable
        /**
         * Constructor
         *
         * @param  iterable<string, TValue>|AbstractOptions<TValue>|null $options
         */
        public function __construct($options = null)
        {
        }
        /**
         * Set one or more configuration properties
         *
         * @param  iterable<string, TValue>|AbstractOptions<TValue> $options
         * @throws Exception\InvalidArgumentException
         * @return AbstractOptions Provides fluent interface
         */
        public function setFromArray($options)
        {
        }
        /**
         * Cast to array
         *
         * @return array<string, TValue>
         */
        public function toArray()
        {
        }
        /**
         * Set a configuration property
         *
         * @see ParameterObject::__set()
         *
         * @param string $key
         * @param TValue|null $value
         * @throws Exception\BadMethodCallException
         * @return void
         */
        public function __set($key, $value)
        {
        }
        /**
         * Get a configuration property
         *
         * @see ParameterObject::__get()
         *
         * @param string $key
         * @throws Exception\BadMethodCallException
         * @return TValue
         */
        public function __get($key)
        {
        }
        /**
         * Test if a configuration property is null
         *
         * @see ParameterObject::__isset()
         *
         * @param string $key
         * @return bool
         */
        public function __isset($key)
        {
        }
        /**
         * Set a configuration property to NULL
         *
         * @see ParameterObject::__unset()
         *
         * @param string $key
         * @throws Exception\InvalidArgumentException
         * @return void
         */
        public function __unset($key)
        {
        }
    }
    /**
     * Custom framework ArrayObject implementation
     *
     * Extends version-specific "abstract" implementation.
     *
     * @template TKey of array-key
     * @template TValue
     * @template-implements IteratorAggregate<TKey, TValue>
     * @template-implements ArrayAccess<TKey, TValue>
     */
    #[\AllowDynamicProperties]
    class ArrayObject implements \IteratorAggregate, \ArrayAccess, \Serializable, \Countable
    {
        /**
         * Properties of the object have their normal functionality
         * when accessed as list (var_dump, foreach, etc.).
         */
        public const STD_PROP_LIST = 1;
        /**
         * Entries can be accessed as properties (read and write).
         */
        public const ARRAY_AS_PROPS = 2;
        /** @var array<TKey, TValue> */
        protected $storage;
        /** @var self::STD_PROP_LIST|self::ARRAY_AS_PROPS */
        protected $flag;
        /** @var class-string<Iterator> */
        protected $iteratorClass;
        /** @var list<string> */
        protected $protectedProperties;
        /**
         * @param array<TKey, TValue>|object               $input Object values must act like ArrayAccess
         * @param self::STD_PROP_LIST|self::ARRAY_AS_PROPS $flags
         * @param class-string<Iterator>                   $iteratorClass
         */
        public function __construct($input = [], $flags = self::STD_PROP_LIST, $iteratorClass = \ArrayIterator::class)
        {
        }
        /**
         * Returns whether the requested key exists
         *
         * @param TKey $key
         * @return bool
         */
        public function __isset(mixed $key)
        {
        }
        /**
         * Sets the value at the specified key to value
         *
         * @param TKey $key
         * @param TValue $value
         * @return void
         */
        public function __set(mixed $key, mixed $value)
        {
        }
        /**
         * Unsets the value at the specified key
         *
         * @param TKey $key
         * @return void
         */
        public function __unset(mixed $key)
        {
        }
        /**
         * Returns the value at the specified key by reference
         *
         * @param TKey $key
         * @return TValue|null
         */
        public function &__get(mixed $key)
        {
        }
        /**
         * Appends the value
         *
         * @param TValue $value
         * @return void
         */
        public function append(mixed $value)
        {
        }
        /**
         * Sort the entries by value
         *
         * @return void
         */
        public function asort()
        {
        }
        /**
         * Get the number of public properties in the ArrayObject
         *
         * @return positive-int|0
         */
        #[\ReturnTypeWillChange]
        public function count()
        {
        }
        /**
         * Exchange the array for another one.
         *
         * @param array<TKey, TValue>|ArrayObject<TKey, TValue>|ArrayIterator<TKey, TValue>|object $data
         * @return array<TKey, TValue>
         */
        public function exchangeArray($data)
        {
        }
        /**
         * Creates a copy of the ArrayObject.
         *
         * @return array<TKey, TValue>
         */
        public function getArrayCopy()
        {
        }
        /**
         * Gets the behavior flags.
         *
         * @return self::STD_PROP_LIST|self::ARRAY_AS_PROPS
         */
        public function getFlags()
        {
        }
        /**
         * Create a new iterator from an ArrayObject instance
         *
         * @return Iterator<TKey, TValue>
         */
        #[\ReturnTypeWillChange]
        public function getIterator()
        {
        }
        /**
         * Gets the iterator classname for the ArrayObject.
         *
         * @return class-string<Iterator>
         */
        public function getIteratorClass()
        {
        }
        /**
         * Sort the entries by key
         *
         * @return void
         */
        public function ksort()
        {
        }
        /**
         * Sort an array using a case insensitive "natural order" algorithm
         *
         * @return void
         */
        public function natcasesort()
        {
        }
        /**
         * Sort entries using a "natural order" algorithm
         *
         * @return void
         */
        public function natsort()
        {
        }
        /**
         * Returns whether the requested key exists
         *
         * @param TKey $key
         * @return bool
         */
        #[\ReturnTypeWillChange]
        public function offsetExists(mixed $key)
        {
        }
        /**
         * {@inheritDoc}
         *
         * @param TKey $key
         * @return TValue|null
         */
        #[\ReturnTypeWillChange]
        public function &offsetGet(mixed $key)
        {
        }
        /**
         * Sets the value at the specified key to value
         *
         * @param TKey $offset
         * @param TValue $value
         * @return void
         */
        #[\ReturnTypeWillChange]
        public function offsetSet(mixed $offset, mixed $value)
        {
        }
        /**
         * Unsets the value at the specified key
         *
         * @param TKey $offset
         * @return void
         */
        #[\ReturnTypeWillChange]
        public function offsetUnset(mixed $offset)
        {
        }
        /**
         * Serialize an ArrayObject
         *
         * @return string
         */
        public function serialize()
        {
        }
        /**
         * Magic method used for serializing of an instance.
         *
         * @return array<string, mixed>
         */
        public function __serialize()
        {
        }
        /**
         * Sets the behavior flags
         *
         * @param self::STD_PROP_LIST|self::ARRAY_AS_PROPS $flags
         * @return void
         */
        public function setFlags($flags)
        {
        }
        /**
         * Sets the iterator classname for the ArrayObject
         *
         * @param  class-string<Iterator> $class
         * @return void
         */
        public function setIteratorClass($class)
        {
        }
        /**
         * Sort the entries with a user-defined comparison function and maintain key association
         *
         * @param  callable(TValue, TValue): int $function
         * @return void
         */
        public function uasort($function)
        {
        }
        /**
         * Sort the entries by keys using a user-defined comparison function
         *
         * @param  callable(TKey, TKey): int $function
         * @return void
         */
        public function uksort($function)
        {
        }
        /**
         * Unserialize an ArrayObject
         *
         * @param  string $data
         * @return void
         */
        public function unserialize($data)
        {
        }
        /**
         * Magic method used to rebuild an instance.
         *
         * @param array $data Data array.
         * @return void
         */
        public function __unserialize($data)
        {
        }
    }
    interface ArraySerializableInterface
    {
        /**
         * Exchange internal values from provided array
         *
         * @return void
         */
        public function exchangeArray(array $array);
        /**
         * Return an array representation of the object
         *
         * @return array
         */
        public function getArrayCopy();
    }
    /**
     * ArrayObject that acts as a stack with regards to iteration
     *
     * @template TKey of array-key
     * @template TValue
     * @template-extends PhpArrayObject<TKey, TValue>
     */
    class ArrayStack extends \ArrayObject
    {
        /**
         * Retrieve iterator
         *
         * Retrieve an array copy of the object, reverse its order, and return an
         * ArrayIterator with that reversed array.
         *
         * @return ArrayIterator<TKey, TValue>
         */
        #[\ReturnTypeWillChange]
        public function getIterator()
        {
        }
    }
}
namespace Laminas\Stdlib\ArrayUtils {
    final class MergeRemoveKey
    {
    }
    /**
     * Marker interface: can be used to replace keys completely in {@see ArrayUtils::merge()} operations
     */
    interface MergeReplaceKeyInterface
    {
        /**
         * @return mixed
         */
        public function getData();
    }
    final class MergeReplaceKey implements \Laminas\Stdlib\ArrayUtils\MergeReplaceKeyInterface
    {
        public function __construct(protected mixed $data)
        {
        }
        /**
         * {@inheritDoc}
         */
        public function getData()
        {
        }
    }
}
namespace Laminas\Stdlib {
    /**
     * Utility class for testing and manipulation of PHP arrays.
     *
     * Declared abstract, as we have no need for instantiation.
     */
    abstract class ArrayUtils
    {
        /**
         * Compatibility Flag for ArrayUtils::filter
         *
         * @deprecated
         */
        public const ARRAY_FILTER_USE_BOTH = 1;
        /**
         * Compatibility Flag for ArrayUtils::filter
         *
         * @deprecated
         */
        public const ARRAY_FILTER_USE_KEY = 2;
        /**
         * Test whether an array contains one or more string keys
         *
         * @param  bool  $allowEmpty    Should an empty array() return true
         * @return bool
         */
        public static function hasStringKeys(mixed $value, $allowEmpty = false)
        {
        }
        /**
         * Test whether an array contains one or more integer keys
         *
         * @param  bool  $allowEmpty    Should an empty array() return true
         * @return bool
         */
        public static function hasIntegerKeys(mixed $value, $allowEmpty = false)
        {
        }
        /**
         * Test whether an array contains one or more numeric keys.
         *
         * A numeric key can be one of the following:
         * - an integer 1,
         * - a string with a number '20'
         * - a string with negative number: '-1000'
         * - a float: 2.2120, -78.150999
         * - a string with float:  '4000.99999', '-10.10'
         *
         * @param  bool  $allowEmpty    Should an empty array() return true
         * @return bool
         */
        public static function hasNumericKeys(mixed $value, $allowEmpty = false)
        {
        }
        /**
         * Test whether an array is a list
         *
         * A list is a collection of values assigned to continuous integer keys
         * starting at 0 and ending at count() - 1.
         *
         * For example:
         * <code>
         * $list = array('a', 'b', 'c', 'd');
         * $list = array(
         *     0 => 'foo',
         *     1 => 'bar',
         *     2 => array('foo' => 'baz'),
         * );
         * </code>
         *
         * @param  bool  $allowEmpty    Is an empty list a valid list?
         * @return bool
         */
        public static function isList(mixed $value, $allowEmpty = false)
        {
        }
        /**
         * Test whether an array is a hash table.
         *
         * An array is a hash table if:
         *
         * 1. Contains one or more non-integer keys, or
         * 2. Integer keys are non-continuous or misaligned (not starting with 0)
         *
         * For example:
         * <code>
         * $hash = array(
         *     'foo' => 15,
         *     'bar' => false,
         * );
         * $hash = array(
         *     1995  => 'Birth of PHP',
         *     2009  => 'PHP 5.3.0',
         *     2012  => 'PHP 5.4.0',
         * );
         * $hash = array(
         *     'formElement,
         *     'options' => array( 'debug' => true ),
         * );
         * </code>
         *
         * @param  bool  $allowEmpty    Is an empty array() a valid hash table?
         * @return bool
         */
        public static function isHashTable(mixed $value, $allowEmpty = false)
        {
        }
        /**
         * Checks if a value exists in an array.
         *
         * Due to "foo" == 0 === TRUE with in_array when strict = false, an option
         * has been added to prevent this. When $strict = 0/false, the most secure
         * non-strict check is implemented. if $strict = -1, the default in_array
         * non-strict behaviour is used.
         *
         * @deprecated This method will be removed in version 4.0 of this component
         *
         * @param int|bool $strict
         * @return bool
         */
        public static function inArray(mixed $needle, array $haystack, $strict = false)
        {
        }
        /**
         * Converts an iterator to an array. The $recursive flag, on by default,
         * hints whether or not you want to do so recursively.
         *
         * @template TKey
         * @template TValue
         * @param  iterable<TKey, TValue> $iterator  The array or Traversable object to convert
         * @param  bool                   $recursive Recursively check all nested structures
         * @throws Exception\InvalidArgumentException If $iterator is not an array or a Traversable object.
         * @return array<TKey, TValue>
         */
        public static function iteratorToArray($iterator, $recursive = true)
        {
        }
        /**
         * Merge two arrays together.
         *
         * If an integer key exists in both arrays and preserveNumericKeys is false, the value
         * from the second array will be appended to the first array. If both values are arrays, they
         * are merged together, else the value of the second array overwrites the one of the first array.
         *
         * @param  bool  $preserveNumericKeys
         * @return array
         */
        public static function merge(array $a, array $b, $preserveNumericKeys = false)
        {
        }
        /**
         * @deprecated Since 3.2.0; use the native array_filter methods
         *
         * @param callable $callback
         * @param null|int $flag
         * @return array
         * @throws Exception\InvalidArgumentException
         */
        public static function filter(array $data, $callback, $flag = null)
        {
        }
    }
    /**
     * Utilities for console tooling.
     *
     * Provides the following facilities:
     *
     * - Colorize strings using markup (e.g., `<info>message</info>`,
     *   `<error>message</error>`)
     * - Write output to a specified stream, optionally with colorization.
     * - Write a line of output to a specified stream, optionally with
     *   colorization, using the system EOL sequence..
     * - Write an error message to STDERR.
     *
     * Colorization will only occur when expected sequences are discovered, and
     * then, only if the console terminal allows it.
     *
     * Essentially, provides the bare minimum to allow you to provide messages to
     * the current console.
     */
    class ConsoleHelper
    {
        public const COLOR_GREEN = "\x1b[32m";
        public const COLOR_RED = "\x1b[31m";
        public const COLOR_RESET = "\x1b[0m";
        public const HIGHLIGHT_INFO = 'info';
        public const HIGHLIGHT_ERROR = 'error';
        /**
         * @param resource $resource
         */
        public function __construct($resource = \STDOUT)
        {
        }
        /**
         * Colorize a string for use with the terminal.
         *
         * Takes strings formatted as `<key>string</key>` and formats them per the
         * $highlightMap; if color support is disabled, simply removes the formatting
         * tags.
         *
         * @param string $string
         * @return string
         */
        public function colorize($string)
        {
        }
        /**
         * @param string $string
         * @param bool $colorize Whether or not to colorize the string
         * @param resource $resource Defaults to STDOUT
         * @return void
         */
        public function write($string, $colorize = true, $resource = \STDOUT)
        {
        }
        /**
         * @param string $string
         * @param bool $colorize Whether or not to colorize the line
         * @param resource $resource Defaults to STDOUT
         * @return void
         */
        public function writeLine($string, $colorize = true, $resource = \STDOUT)
        {
        }
        /**
         * Emit an error message.
         *
         * Wraps the message in `<error></error>`, and passes it to `writeLine()`,
         * using STDERR as the resource; emits an additional empty line when done,
         * also to STDERR.
         *
         * @param string $message
         * @return void
         */
        public function writeErrorMessage($message)
        {
        }
    }
    interface DispatchableInterface
    {
        /**
         * Dispatch a request
         *
         * @return Response|mixed
         */
        public function dispatch(\Laminas\Stdlib\RequestInterface $request, ?\Laminas\Stdlib\ResponseInterface $response = null);
    }
    /**
     * ErrorHandler that can be used to catch internal PHP errors
     * and convert to an ErrorException instance.
     */
    abstract class ErrorHandler
    {
        /**
         * Active stack
         *
         * @var list<ErrorException|null>
         */
        protected static $stack = [];
        /**
         * Check if this error handler is active
         *
         * @return bool
         */
        public static function started()
        {
        }
        /**
         * Get the current nested level
         *
         * @return int
         */
        public static function getNestedLevel()
        {
        }
        /**
         * Starting the error handler
         *
         * @param int $errorLevel
         * @return void
         */
        public static function start($errorLevel = \E_WARNING)
        {
        }
        /**
         * Stopping the error handler
         *
         * @param  bool $throw Throw the ErrorException if any
         * @return null|ErrorException
         * @throws ErrorException If an error has been caught and $throw is true.
         */
        public static function stop($throw = false)
        {
        }
        /**
         * Stop all active handler
         *
         * @return void
         */
        public static function clean()
        {
        }
        /**
         * Add an error to the stack
         *
         * @param int    $errno
         * @param string $errstr
         * @param string $errfile
         * @param int    $errline
         * @return void
         */
        public static function addError($errno, $errstr = '', $errfile = '', $errline = 0)
        {
        }
    }
}
namespace Laminas\Stdlib\Exception {
    /**
     * Exception marker interface
     */
    interface ExceptionInterface
    {
    }
    /**
     * Bad method call exception
     */
    class BadMethodCallException extends \BadMethodCallException implements \Laminas\Stdlib\Exception\ExceptionInterface
    {
    }
    /**
     * Domain exception
     */
    class DomainException extends \DomainException implements \Laminas\Stdlib\Exception\ExceptionInterface
    {
    }
    /**
     * Runtime exception
     */
    class RuntimeException extends \RuntimeException implements \Laminas\Stdlib\Exception\ExceptionInterface
    {
    }
    /**
     * Extension not loaded exception
     */
    class ExtensionNotLoadedException extends \Laminas\Stdlib\Exception\RuntimeException
    {
    }
    /**
     * Invalid Argument Exception
     */
    class InvalidArgumentException extends \InvalidArgumentException implements \Laminas\Stdlib\Exception\ExceptionInterface
    {
    }
    /**
     * Logic exception
     */
    class LogicException extends \LogicException implements \Laminas\Stdlib\Exception\ExceptionInterface
    {
    }
}
namespace Laminas\Stdlib {
    /**
     * This is an efficient implementation of an integer priority queue in PHP
     *
     * This class acts like a queue with insert() and extract(), removing the
     * elements from the queue and it also acts like an Iterator without removing
     * the elements. This behaviour can be used in mixed scenarios with high
     * performance boost.
     *
     * @template TValue of mixed
     * @template-implements Iterator<int, TValue>
     */
    class FastPriorityQueue implements \Iterator, \Countable, \Serializable
    {
        public const EXTR_DATA = \SplPriorityQueue::EXTR_DATA;
        public const EXTR_PRIORITY = \SplPriorityQueue::EXTR_PRIORITY;
        public const EXTR_BOTH = \SplPriorityQueue::EXTR_BOTH;
        /** @var self::EXTR_* */
        protected $extractFlag = self::EXTR_DATA;
        /**
         * Elements of the queue, divided by priorities
         *
         * @var array<int, list<TValue>>
         */
        protected $values = [];
        /**
         * Array of priorities
         *
         * @var array<int, int>
         */
        protected $priorities = [];
        /**
         * Array of priorities used for the iteration
         *
         * @var array
         */
        protected $subPriorities = [];
        /**
         * Max priority
         *
         * @var int|null
         */
        protected $maxPriority;
        /**
         * Total number of elements in the queue
         *
         * @var int
         */
        protected $count = 0;
        /**
         * Index of the current element in the queue
         *
         * @var int
         */
        protected $index = 0;
        /**
         * Sub index of the current element in the same priority level
         *
         * @var int
         */
        protected $subIndex = 0;
        public function __serialize(): array
        {
        }
        public function __unserialize(array $data): void
        {
        }
        /**
         * Insert an element in the queue with a specified priority
         *
         * @param TValue $value
         * @param int    $priority
         * @return void
         */
        public function insert(mixed $value, $priority)
        {
        }
        /**
         * Extract an element in the queue according to the priority and the
         * order of insertion
         *
         * @return TValue|int|array{data: TValue, priority: int}|false
         */
        public function extract()
        {
        }
        /**
         * Remove an item from the queue
         *
         * This is different than {@link extract()}; its purpose is to dequeue an
         * item.
         *
         * Note: this removes the first item matching the provided item found. If
         * the same item has been added multiple times, it will not remove other
         * instances.
         *
         * @return bool False if the item was not found, true otherwise.
         */
        public function remove(mixed $datum)
        {
        }
        /**
         * Get the total number of elements in the queue
         *
         * @return int
         */
        #[\ReturnTypeWillChange]
        public function count()
        {
        }
        /**
         * Get the current element in the queue
         *
         * @return TValue|int|array{data: TValue|false, priority: int|null}|false
         */
        #[\ReturnTypeWillChange]
        public function current()
        {
        }
        /**
         * Get the index of the current element in the queue
         *
         * @return int
         */
        #[\ReturnTypeWillChange]
        public function key()
        {
        }
        /**
         * Set the iterator pointer to the next element in the queue
         * removing the previous element
         *
         * @return void
         */
        protected function nextAndRemove()
        {
        }
        /**
         * Set the iterator pointer to the next element in the queue
         * without removing the previous element
         */
        #[\ReturnTypeWillChange]
        public function next()
        {
        }
        /**
         * Check if the current iterator is valid
         *
         * @return bool
         */
        #[\ReturnTypeWillChange]
        public function valid()
        {
        }
        /**
         * Rewind the current iterator
         */
        #[\ReturnTypeWillChange]
        public function rewind()
        {
        }
        /**
         * Serialize to an array
         *
         * Array will be priority => data pairs
         *
         * @return list<TValue|int|array{data: TValue, priority: int}>
         */
        public function toArray()
        {
        }
        /**
         * Serialize
         *
         * @return string
         */
        public function serialize()
        {
        }
        /**
         * Deserialize
         *
         * @param  string $data
         * @return void
         */
        public function unserialize($data)
        {
        }
        /**
         * Set the extract flag
         *
         * @param self::EXTR_* $flag
         * @return void
         */
        public function setExtractFlags($flag)
        {
        }
        /**
         * Check if the queue is empty
         *
         * @return bool
         */
        public function isEmpty()
        {
        }
        /**
         * Does the queue contain the given datum?
         *
         * @return bool
         */
        public function contains(mixed $datum)
        {
        }
        /**
         * Does the queue have an item with the given priority?
         *
         * @param  int $priority
         * @return bool
         */
        public function hasPriority($priority)
        {
        }
    }
    /**
     * Wrapper for glob with fallback if GLOB_BRACE is not available.
     */
    abstract class Glob
    {
        /**#@+
         * Glob constants.
         */
        public const GLOB_MARK = 0x1;
        public const GLOB_NOSORT = 0x2;
        public const GLOB_NOCHECK = 0x4;
        public const GLOB_NOESCAPE = 0x8;
        public const GLOB_BRACE = 0x10;
        public const GLOB_ONLYDIR = 0x20;
        public const GLOB_ERR = 0x40;
        /**#@-*/
        /**
         * Find pathnames matching a pattern.
         *
         * @see    http://docs.php.net/glob
         *
         * @param  string  $pattern
         * @param  int $flags
         * @param  bool $forceFallback
         * @return array
         * @throws Exception\RuntimeException
         */
        public static function glob($pattern, $flags = 0, $forceFallback = false)
        {
        }
        /**
         * Use the glob function provided by the system.
         *
         * @param  string  $pattern
         * @param  int     $flags
         * @return array
         * @throws Exception\RuntimeException
         */
        protected static function systemGlob($pattern, $flags)
        {
        }
        /**
         * Expand braces manually, then use the system glob.
         *
         * @param  string  $pattern
         * @param  int     $flags
         * @return array
         * @throws Exception\RuntimeException
         */
        protected static function fallbackGlob($pattern, $flags)
        {
        }
        /**
         * Find the end of the sub-pattern in a brace expression.
         *
         * @param  string  $pattern
         * @param  int $begin
         * @param  int $flags
         * @return int|null
         */
        protected static function nextBraceSub($pattern, $begin, $flags)
        {
        }
        /** @internal */
        public static function flagsIsEqualTo(int $flags, int $otherFlags): bool
        {
        }
    }
}
namespace Laminas\Stdlib\Guard {
    /**
     * Provide a guard method for array or Traversable data
     */
    trait ArrayOrTraversableGuardTrait
    {
        /**
         * Verifies that the data is an array or Traversable
         *
         * @param mixed  $data           the data to verify
         * @param string $dataName       the data name
         * @param string $exceptionClass FQCN for the exception
         * @return void
         * @throws Exception
         */
        protected function guardForArrayOrTraversable(mixed $data, $dataName = 'Argument', $exceptionClass = \Laminas\Stdlib\Exception\InvalidArgumentException::class)
        {
        }
    }
    /**
     * Provide a guard method against empty data
     */
    trait EmptyGuardTrait
    {
        /**
         * Verify that the data is not empty
         *
         * @param mixed  $data           the data to verify
         * @param string $dataName       the data name
         * @param string $exceptionClass FQCN for the exception
         * @return void
         * @throws Exception
         */
        protected function guardAgainstEmpty(mixed $data, $dataName = 'Argument', $exceptionClass = \Laminas\Stdlib\Exception\InvalidArgumentException::class)
        {
        }
    }
    /**
     * Provide a guard method against null data
     */
    trait NullGuardTrait
    {
        /**
         * Verify that the data is not null
         *
         * @param mixed  $data           the data to verify
         * @param string $dataName       the data name
         * @param string $exceptionClass FQCN for the exception
         * @return void
         * @throws Exception
         */
        protected function guardAgainstNull(mixed $data, $dataName = 'Argument', $exceptionClass = \Laminas\Stdlib\Exception\InvalidArgumentException::class)
        {
        }
    }
    /**
     * An aggregate for all guard traits
     */
    trait AllGuardsTrait
    {
        use \Laminas\Stdlib\Guard\ArrayOrTraversableGuardTrait;
        use \Laminas\Stdlib\Guard\EmptyGuardTrait;
        use \Laminas\Stdlib\Guard\NullGuardTrait;
    }
}
namespace Laminas\Stdlib {
    /**
     * Interface to allow objects to have initialization logic
     */
    interface InitializableInterface
    {
        /**
         * Init an object
         *
         * @return void
         */
        public function init();
    }
    /**
     * @deprecated Since 3.1.0; use the native JsonSerializable interface
     */
    interface JsonSerializable extends \JsonSerializable
    {
    }
    interface MessageInterface
    {
        /**
         * Set metadata
         *
         * @param string|int|array|Traversable $spec
         * @param  mixed $value
         */
        public function setMetadata($spec, $value = null);
        /**
         * Get metadata
         *
         * @param  null|string|int $key
         * @return mixed
         */
        public function getMetadata($key = null);
        /**
         * Set content
         *
         * @param  mixed $content
         * @return mixed
         */
        public function setContent($content);
        /**
         * Get content
         *
         * @return mixed
         */
        public function getContent();
    }
    class Message implements \Laminas\Stdlib\MessageInterface
    {
        /** @var array */
        protected $metadata = [];
        /** @var mixed */
        protected $content = '';
        /**
         * Set message metadata
         *
         * Non-destructive setting of message metadata; always adds to the metadata, never overwrites
         * the entire metadata container.
         *
         * @param  string|int|array|Traversable $spec
         * @param  mixed $value
         * @throws Exception\InvalidArgumentException
         * @return Message
         */
        public function setMetadata($spec, $value = null)
        {
        }
        /**
         * Retrieve all metadata or a single metadatum as specified by key
         *
         * @param  null|string|int $key
         * @param  null|mixed $default
         * @throws Exception\InvalidArgumentException
         * @return mixed
         */
        public function getMetadata($key = null, $default = null)
        {
        }
        /**
         * Set message content
         *
         * @param  mixed $value
         * @return Message
         */
        public function setContent($value)
        {
        }
        /**
         * Get message content
         *
         * @return mixed
         */
        public function getContent()
        {
        }
        /**
         * @return string
         */
        public function toString()
        {
        }
    }
    /**
     * Basically, an ArrayObject. You could simply define something like:
     *     class QueryParams extends ArrayObject implements Parameters {}
     * and have 90% of the functionality
     *
     * @template TKey
     * @template TValue
     * @template-extends ArrayAccess<TKey, TValue>
     * @template-extends Traversable<TKey, TValue>
     */
    interface ParametersInterface extends \ArrayAccess, \Countable, \Serializable, \Traversable
    {
        /**
         * Constructor
         *
         * @param array<TKey, TValue>|null $values
         */
        public function __construct(?array $values = null);
        /**
         * From array
         *
         * Allow deserialization from standard array
         *
         * @param array<TKey, TValue> $values
         * @return mixed
         */
        public function fromArray(array $values);
        /**
         * From string
         *
         * Allow deserialization from raw body; e.g., for PUT requests
         *
         * @param string $string
         * @return mixed
         */
        public function fromString($string);
        /**
         * To array
         *
         * Allow serialization back to standard array
         *
         * @return array<TKey, TValue>
         */
        public function toArray();
        /**
         * To string
         *
         * Allow serialization to query format; e.g., for PUT or POST requests
         *
         * @return string
         */
        public function toString();
        /**
         * @param TKey $name
         * @param TValue|null $default
         * @return mixed
         */
        public function get($name, $default = null);
        /**
         * @param TKey $name
         * @param TValue $value
         * @return ParametersInterface
         */
        public function set($name, $value);
    }
    /**
     * @template TKey of array-key
     * @template TValue
     * @template-extends PhpArrayObject<TKey, TValue>
     * @template-implements ParametersInterface<TKey, TValue>
     */
    class Parameters extends \ArrayObject implements \Laminas\Stdlib\ParametersInterface
    {
        /**
         * Constructor
         *
         * Enforces that we have an array, and enforces parameter access to array
         * elements.
         *
         * @param array<TKey, TValue>|null $values
         */
        public function __construct(?array $values = null)
        {
        }
        /**
         * Populate from native PHP array
         *
         * @param array<TKey, TValue> $values
         * @return void
         */
        public function fromArray(array $values)
        {
        }
        /**
         * Populate from query string
         *
         * @param  string $string
         * @return void
         */
        public function fromString($string)
        {
        }
        /**
         * Serialize to native PHP array
         *
         * @return array<TKey, TValue>
         */
        public function toArray()
        {
        }
        /**
         * Serialize to query string
         *
         * @return string
         */
        public function toString()
        {
        }
        /**
         * Retrieve by key
         *
         * Returns null if the key does not exist.
         *
         * @param  TKey $name
         * @return TValue|null
         */
        #[\ReturnTypeWillChange]
        public function offsetGet($name)
        {
        }
        /**
         * @template TDefault
         * @param TKey $name
         * @param TDefault $default optional default value
         * @return TValue|TDefault|null
         */
        public function get($name, $default = null)
        {
        }
        /**
         * @param TKey   $name
         * @param TValue $value
         * @return $this
         */
        public function set($name, $value)
        {
        }
    }
    /**
     * @template TKey of string
     * @template TValue of mixed
     * @template-implements Iterator<TKey, TValue>
     */
    class PriorityList implements \Iterator, \Countable
    {
        public const EXTR_DATA = 0x1;
        public const EXTR_PRIORITY = 0x2;
        public const EXTR_BOTH = 0x3;
        /**
         * Internal list of all items.
         *
         * @var array<TKey, array{data: TValue, priority: int, serial: positive-int|0}>
         */
        protected $items = [];
        /**
         * Serial assigned to items to preserve LIFO.
         *
         * @var positive-int|0
         */
        protected $serial = 0;
        // phpcs:disable WebimpressCodingStandard.NamingConventions.ValidVariableName.NotCamelCapsProperty
        /**
         * Serial order mode
         *
         * @var integer
         */
        protected $isLIFO = 1;
        // phpcs:enable
        /**
         * Internal counter to avoid usage of count().
         *
         * @var int
         */
        protected $count = 0;
        /**
         * Whether the list was already sorted.
         *
         * @var bool
         */
        protected $sorted = false;
        /**
         * Insert a new item.
         *
         * @param TKey   $name
         * @param TValue $value
         * @param int    $priority
         * @return void
         */
        public function insert($name, mixed $value, $priority = 0)
        {
        }
        /**
         * @param TKey   $name
         * @param int    $priority
         * @return $this
         * @throws Exception
         */
        public function setPriority($name, $priority)
        {
        }
        /**
         * Remove a item.
         *
         * @param  TKey $name
         * @return void
         */
        public function remove($name)
        {
        }
        /**
         * Remove all items.
         *
         * @return void
         */
        public function clear()
        {
        }
        /**
         * Get a item.
         *
         * @param  TKey $name
         * @return TValue|null
         */
        public function get($name)
        {
        }
        /**
         * Sort all items.
         *
         * @return void
         */
        protected function sort()
        {
        }
        /**
         * Compare the priority of two items.
         *
         * @param  array $item1,
         * @return int
         */
        protected function compare(array $item1, array $item2)
        {
        }
        /**
         * Get/Set serial order mode
         *
         * @param bool|null $flag
         * @return bool
         */
        public function isLIFO($flag = null)
        {
        }
        /**
         * {@inheritDoc}
         */
        #[\ReturnTypeWillChange]
        public function rewind()
        {
        }
        /**
         * {@inheritDoc}
         */
        #[\ReturnTypeWillChange]
        public function current()
        {
        }
        /**
         * {@inheritDoc}
         */
        #[\ReturnTypeWillChange]
        public function key()
        {
        }
        /**
         * {@inheritDoc}
         */
        #[\ReturnTypeWillChange]
        public function next()
        {
        }
        /**
         * {@inheritDoc}
         */
        #[\ReturnTypeWillChange]
        public function valid()
        {
        }
        /**
         * @return self
         */
        public function getIterator()
        {
        }
        /**
         * {@inheritDoc}
         */
        #[\ReturnTypeWillChange]
        public function count()
        {
        }
        /**
         * Return list as array
         *
         * @param int $flag
         * @return array
         */
        public function toArray($flag = self::EXTR_DATA)
        {
        }
    }
    /**
     * Re-usable, serializable priority queue implementation
     *
     * SplPriorityQueue acts as a heap; on iteration, each item is removed from the
     * queue. If you wish to re-use such a queue, you need to clone it first. This
     * makes for some interesting issues if you wish to delete items from the queue,
     * or, as already stated, iterate over it multiple times.
     *
     * This class aggregates items for the queue itself, but also composes an
     * "inner" iterator in the form of an SplPriorityQueue object for performing
     * the actual iteration.
     *
     * @template TValue
     * @template TPriority of int
     * @implements IteratorAggregate<array-key, TValue>
     */
    class PriorityQueue implements \Countable, \IteratorAggregate, \Serializable
    {
        public const EXTR_DATA = 0x1;
        public const EXTR_PRIORITY = 0x2;
        public const EXTR_BOTH = 0x3;
        /**
         * Inner queue class to use for iteration
         *
         * @var class-string<\SplPriorityQueue>
         */
        protected $queueClass = \Laminas\Stdlib\SplPriorityQueue::class;
        /**
         * Actual items aggregated in the priority queue. Each item is an array
         * with keys "data" and "priority".
         *
         * @var list<array{data: TValue, priority: TPriority}>
         */
        protected $items = [];
        /**
         * Inner queue object
         *
         * @var \SplPriorityQueue<TPriority, TValue>|null
         */
        protected $queue;
        /**
         * Insert an item into the queue
         *
         * Priority defaults to 1 (low priority) if none provided.
         *
         * @param  TValue    $data
         * @param  TPriority $priority
         * @return $this
         */
        public function insert($data, $priority = 1)
        {
        }
        /**
         * Remove an item from the queue
         *
         * This is different than {@link extract()}; its purpose is to dequeue an
         * item.
         *
         * This operation is potentially expensive, as it requires
         * re-initialization and re-population of the inner queue.
         *
         * Note: this removes the first item matching the provided item found. If
         * the same item has been added multiple times, it will not remove other
         * instances.
         *
         * @return bool False if the item was not found, true otherwise.
         */
        public function remove(mixed $datum)
        {
        }
        /**
         * Is the queue empty?
         *
         * @return bool
         */
        public function isEmpty()
        {
        }
        /**
         * How many items are in the queue?
         *
         * @return int
         */
        #[\ReturnTypeWillChange]
        public function count()
        {
        }
        /**
         * Peek at the top node in the queue, based on priority.
         *
         * @return TValue
         */
        public function top()
        {
        }
        /**
         * Extract a node from the inner queue and sift up
         *
         * @return TValue
         */
        public function extract()
        {
        }
        /**
         * Retrieve the inner iterator
         *
         * SplPriorityQueue acts as a heap, which typically implies that as items
         * are iterated, they are also removed. This does not work for situations
         * where the queue may be iterated multiple times. As such, this class
         * aggregates the values, and also injects an SplPriorityQueue. This method
         * retrieves the inner queue object, and clones it for purposes of
         * iteration.
         *
         * @return \SplPriorityQueue<TPriority, TValue>
         */
        #[\ReturnTypeWillChange]
        public function getIterator()
        {
        }
        /**
         * Serialize the data structure
         *
         * @return string
         */
        public function serialize()
        {
        }
        /**
         * Magic method used for serializing of an instance.
         *
         * @return list<array{data: TValue, priority: TPriority}>
         */
        public function __serialize()
        {
        }
        /**
         * Unserialize a string into a PriorityQueue object
         *
         * Serialization format is compatible with {@link SplPriorityQueue}
         *
         * @param  string $data
         * @return void
         */
        public function unserialize($data)
        {
        }
        /**
         * Magic method used to rebuild an instance.
         *
         * @param list<array{data: TValue, priority: TPriority}> $data Data array.
         * @return void
         */
        public function __unserialize($data)
        {
        }
        /**
         * Serialize to an array
         * By default, returns only the item data, and in the order registered (not
         * sorted). You may provide one of the EXTR_* flags as an argument, allowing
         * the ability to return priorities or both data and priority.
         *
         * @param  int $flag
         * @return array<array-key, mixed>
         * @psalm-return ($flag is self::EXTR_BOTH
         *                      ? list<array{data: TValue, priority: TPriority}>
         *                      : $flag is self::EXTR_PRIORITY
         *                          ? list<TPriority>
         *                          : list<TValue>
         *               )
         */
        public function toArray($flag = self::EXTR_DATA)
        {
        }
        /**
         * Specify the internal queue class
         *
         * Please see {@link getIterator()} for details on the necessity of an
         * internal queue class. The class provided should extend SplPriorityQueue.
         *
         * @param  class-string<\SplPriorityQueue> $class
         * @return $this
         */
        public function setInternalQueueClass($class)
        {
        }
        /**
         * Does the queue contain the given datum?
         *
         * @param  TValue $datum
         * @return bool
         */
        public function contains($datum)
        {
        }
        /**
         * Does the queue have an item with the given priority?
         *
         * @param  TPriority $priority
         * @return bool
         */
        public function hasPriority($priority)
        {
        }
        /**
         * Get the inner priority queue instance
         *
         * @throws Exception\DomainException
         * @return \SplPriorityQueue<TPriority, TValue>
         * @psalm-assert !null $this->queue
         */
        protected function getQueue()
        {
        }
        /**
         * Add support for deep cloning
         *
         * @return void
         */
        public function __clone()
        {
        }
    }
    interface RequestInterface extends \Laminas\Stdlib\MessageInterface
    {
    }
    class Request extends \Laminas\Stdlib\Message implements \Laminas\Stdlib\RequestInterface
    {
        // generic request implementation
    }
    interface ResponseInterface extends \Laminas\Stdlib\MessageInterface
    {
    }
    class Response extends \Laminas\Stdlib\Message implements \Laminas\Stdlib\ResponseInterface
    {
        // generic response implementation
    }
    /**
     * Serializable version of SplPriorityQueue
     *
     * Also, provides predictable heap order for datums added with the same priority
     * (i.e., they will be emitted in the same order they are enqueued).
     *
     * @template TValue
     * @template TPriority of int
     * @extends \SplPriorityQueue<TPriority, TValue>
     */
    class SplPriorityQueue extends \SplPriorityQueue implements \Serializable
    {
        /** @var int Seed used to ensure queue order for items of the same priority */
        protected $serial = \PHP_INT_MAX;
        /**
         * Insert a value with a given priority
         *
         * Utilizes {@var $serial} to ensure that values of equal priority are
         * emitted in the same order in which they are inserted.
         *
         * @param  TValue    $value
         * @param  TPriority $priority
         * @return void
         */
        #[\ReturnTypeWillChange]
        public function insert($value, $priority)
        {
        }
        /**
         * Serialize to an array
         *
         * Array will be priority => data pairs
         *
         * @return list<TValue>
         */
        public function toArray()
        {
        }
        /**
         * Serialize
         *
         * @return string
         */
        public function serialize()
        {
        }
        /**
         * Magic method used for serializing of an instance.
         *
         * @return array
         */
        public function __serialize()
        {
        }
        /**
         * Deserialize
         *
         * @param  string $data
         * @return void
         */
        public function unserialize($data)
        {
        }
        /**
         * Magic method used to rebuild an instance.
         *
         * @param array<array-key, mixed> $data Data array.
         * @return void
         */
        public function __unserialize($data)
        {
        }
    }
    /**
     * Serializable version of SplQueue
     *
     * @template TKey of array-key
     * @template TValue
     * @extends \SplQueue<TValue>
     */
    class SplQueue extends \SplQueue implements \Serializable
    {
        /**
         * Return an array representing the queue
         *
         * @return list<TValue>
         */
        public function toArray()
        {
        }
        /**
         * Serialize
         *
         * @return string
         */
        #[\ReturnTypeWillChange]
        public function serialize()
        {
        }
        /**
         * Magic method used for serializing of an instance.
         *
         * @return list<TValue>
         */
        #[\ReturnTypeWillChange]
        public function __serialize()
        {
        }
        /**
         * Unserialize
         *
         * @param  string $data
         * @return void
         */
        #[\ReturnTypeWillChange]
        public function unserialize($data)
        {
        }
        /**
         * Magic method used to rebuild an instance.
         *
         * @param array<array-key, TValue> $data Data array.
         * @return void
         */
        #[\ReturnTypeWillChange]
        public function __unserialize($data)
        {
        }
    }
    /**
     * Serializable version of SplStack
     *
     * @template TValue
     * @extends \SplStack<TValue>
     */
    class SplStack extends \SplStack implements \Serializable
    {
        /**
         * Serialize to an array representing the stack
         *
         * @return list<TValue>
         */
        public function toArray()
        {
        }
        /**
         * Serialize
         *
         * @return string
         */
        #[\ReturnTypeWillChange]
        public function serialize()
        {
        }
        /**
         * Magic method used for serializing of an instance.
         *
         * @return list<TValue>
         */
        #[\ReturnTypeWillChange]
        public function __serialize()
        {
        }
        /**
         * Unserialize
         *
         * @param  string $data
         * @return void
         */
        #[\ReturnTypeWillChange]
        public function unserialize($data)
        {
        }
        /**
         * Magic method used to rebuild an instance.
         *
         * @param array<array-key, TValue> $data Data array.
         * @return void
         */
        #[\ReturnTypeWillChange]
        public function __unserialize($data)
        {
        }
    }
    /**
     * Utility class for handling strings of different character encodings
     * using available PHP extensions.
     *
     * Declared abstract, as we have no need for instantiation.
     */
    abstract class StringUtils
    {
        /**
         * Ordered list of registered string wrapper instances
         *
         * @var list<class-string<StringWrapperInterface>>|null
         */
        protected static $wrapperRegistry;
        /**
         * A list of known single-byte character encodings (upper-case)
         *
         * @var string[]
         */
        protected static $singleByteEncodings = ['ASCII', '7BIT', '8BIT', 'ISO-8859-1', 'ISO-8859-2', 'ISO-8859-3', 'ISO-8859-4', 'ISO-8859-5', 'ISO-8859-6', 'ISO-8859-7', 'ISO-8859-8', 'ISO-8859-9', 'ISO-8859-10', 'ISO-8859-11', 'ISO-8859-13', 'ISO-8859-14', 'ISO-8859-15', 'ISO-8859-16', 'CP-1251', 'CP-1252'];
        /**
         * Is PCRE compiled with Unicode support?
         *
         * @var bool
         **/
        protected static $hasPcreUnicodeSupport;
        /**
         * Get registered wrapper classes
         *
         * @return string[]
         * @psalm-return list<class-string<StringWrapperInterface>>
         */
        public static function getRegisteredWrappers()
        {
        }
        /**
         * Register a string wrapper class
         *
         * @param class-string<StringWrapperInterface> $wrapper
         * @return void
         */
        public static function registerWrapper($wrapper)
        {
        }
        /**
         * Unregister a string wrapper class
         *
         * @param class-string<StringWrapperInterface> $wrapper
         * @return void
         */
        public static function unregisterWrapper($wrapper)
        {
        }
        /**
         * Reset all registered wrappers so the default wrappers will be used
         *
         * @return void
         */
        public static function resetRegisteredWrappers()
        {
        }
        /**
         * Get the first string wrapper supporting the given character encoding
         * and supports to convert into the given convert encoding.
         *
         * @param string      $encoding        Character encoding to support
         * @param string|null $convertEncoding OPTIONAL character encoding to convert in
         * @return StringWrapperInterface
         * @throws Exception\RuntimeException If no wrapper supports given character encodings.
         */
        public static function getWrapper($encoding = 'UTF-8', $convertEncoding = null)
        {
        }
        /**
         * Get a list of all known single-byte character encodings
         *
         * @return string[]
         */
        public static function getSingleByteEncodings()
        {
        }
        /**
         * Check if a given encoding is a known single-byte character encoding
         *
         * @param string $encoding
         * @return bool
         */
        public static function isSingleByteEncoding($encoding)
        {
        }
        /**
         * Check if a given string is valid UTF-8 encoded
         *
         * @param string $str
         * @return bool
         */
        public static function isValidUtf8($str)
        {
        }
        /**
         * Is PCRE compiled with Unicode support?
         *
         * @return bool
         */
        public static function hasPcreUnicodeSupport()
        {
        }
    }
}
namespace Laminas\Stdlib\StringWrapper {
    interface StringWrapperInterface
    {
        /**
         * Check if the given character encoding is supported by this wrapper
         * and the character encoding to convert to is also supported.
         *
         * @param string      $encoding
         * @param string|null $convertEncoding
         */
        public static function isSupported($encoding, $convertEncoding = null);
        /**
         * Get a list of supported character encodings
         *
         * @return string[]
         */
        public static function getSupportedEncodings();
        /**
         * Set character encoding working with and convert to
         *
         * @param string      $encoding         The character encoding to work with
         * @param string|null $convertEncoding  The character encoding to convert to
         * @return StringWrapperInterface
         */
        public function setEncoding($encoding, $convertEncoding = null);
        /**
         * Get the defined character encoding to work with (upper case)
         *
         * @return string|null
         */
        public function getEncoding();
        /**
         * Get the defined character encoding to convert to (upper case)
         *
         * @return string|null
         */
        public function getConvertEncoding();
        /**
         * Returns the length of the given string
         *
         * @param string $str
         * @return int|false
         */
        public function strlen($str);
        /**
         * Returns the portion of string specified by the start and length parameters
         *
         * @param string   $str
         * @param int      $offset
         * @param int|null $length
         * @return string|false
         */
        public function substr($str, $offset = 0, $length = null);
        /**
         * Find the position of the first occurrence of a substring in a string
         *
         * @param string $haystack
         * @param string $needle
         * @param int    $offset
         * @return int|false
         */
        public function strpos($haystack, $needle, $offset = 0);
        /**
         * Convert a string from defined encoding to the defined convert encoding
         *
         * @param string  $str
         * @param bool $reverse
         * @return string|false
         */
        public function convert($str, $reverse = false);
        /**
         * Wraps a string to a given number of characters
         *
         * @param  string  $str
         * @param  int $width
         * @param  string  $break
         * @param  bool $cut
         * @return string
         */
        public function wordWrap($str, $width = 75, $break = "\n", $cut = false);
        /**
         * Pad a string to a certain length with another string
         *
         * @param  string  $input
         * @param  int $padLength
         * @param  string  $padString
         * @param  int $padType
         * @return string
         */
        public function strPad($input, $padLength, $padString = ' ', $padType = \STR_PAD_RIGHT);
    }
    abstract class AbstractStringWrapper implements \Laminas\Stdlib\StringWrapper\StringWrapperInterface
    {
        /**
         * The character encoding working on
         *
         * @var string|null
         */
        protected $encoding = 'UTF-8';
        /**
         * An optionally character encoding to convert to
         *
         * @var string|null
         */
        protected $convertEncoding;
        /**
         * Check if the given character encoding is supported by this wrapper
         * and the character encoding to convert to is also supported.
         *
         * @param  string      $encoding
         * @param  string|null $convertEncoding
         * @return bool
         */
        public static function isSupported($encoding, $convertEncoding = null)
        {
        }
        /**
         * Set character encoding working with and convert to
         *
         * @param string      $encoding         The character encoding to work with
         * @param string|null $convertEncoding  The character encoding to convert to
         * @return StringWrapperInterface
         */
        public function setEncoding($encoding, $convertEncoding = null)
        {
        }
        /**
         * Get the defined character encoding to work with
         *
         * @return null|string
         * @throws Exception\LogicException If no encoding was defined.
         */
        public function getEncoding()
        {
        }
        /**
         * Get the defined character encoding to convert to
         *
         * @return string|null
         */
        public function getConvertEncoding()
        {
        }
        /**
         * Convert a string from defined character encoding to the defined convert encoding
         *
         * @param string  $str
         * @param bool $reverse
         * @return string|false
         */
        public function convert($str, $reverse = false)
        {
        }
        /**
         * Wraps a string to a given number of characters
         *
         * @param  string  $string
         * @param  int $width
         * @param  string  $break
         * @param  bool $cut
         * @return string|false
         */
        public function wordWrap($string, $width = 75, $break = "\n", $cut = false)
        {
        }
        /**
         * Pad a string to a certain length with another string
         *
         * @param  string  $input
         * @param  int $padLength
         * @param  string  $padString
         * @param  int $padType
         * @return string
         */
        public function strPad($input, $padLength, $padString = ' ', $padType = \STR_PAD_RIGHT)
        {
        }
    }
    class Iconv extends \Laminas\Stdlib\StringWrapper\AbstractStringWrapper
    {
        /**
         * List of supported character sets (upper case)
         *
         * @link http://www.gnu.org/software/libiconv/
         *
         * @var string[]
         */
        protected static $encodings = [
            // European languages
            'ASCII',
            'ISO-8859-1',
            'ISO-8859-2',
            'ISO-8859-3',
            'ISO-8859-4',
            'ISO-8859-5',
            'ISO-8859-7',
            'ISO-8859-9',
            'ISO-8859-10',
            'ISO-8859-13',
            'ISO-8859-14',
            'ISO-8859-15',
            'ISO-8859-16',
            'KOI8-R',
            'KOI8-U',
            'KOI8-RU',
            'CP1250',
            'CP1251',
            'CP1252',
            'CP1253',
            'CP1254',
            'CP1257',
            'CP850',
            'CP866',
            'CP1131',
            'MACROMAN',
            'MACCENTRALEUROPE',
            'MACICELAND',
            'MACCROATIAN',
            'MACROMANIA',
            'MACCYRILLIC',
            'MACUKRAINE',
            'MACGREEK',
            'MACTURKISH',
            'MACINTOSH',
            // Semitic languages
            'ISO-8859-6',
            'ISO-8859-8',
            'CP1255',
            'CP1256',
            'CP862',
            'MACHEBREW',
            'MACARABIC',
            // Japanese
            'EUC-JP',
            'SHIFT_JIS',
            'CP932',
            'ISO-2022-JP',
            'ISO-2022-JP-2',
            'ISO-2022-JP-1',
            // Chinese
            'EUC-CN',
            'HZ',
            'GBK',
            'CP936',
            'GB18030',
            'EUC-TW',
            'BIG5',
            'CP950',
            'BIG5-HKSCS',
            'BIG5-HKSCS:2004',
            'BIG5-HKSCS:2001',
            'BIG5-HKSCS:1999',
            'ISO-2022-CN',
            'ISO-2022-CN-EXT',
            // Korean
            'EUC-KR',
            'CP949',
            'ISO-2022-KR',
            'JOHAB',
            // Armenian
            'ARMSCII-8',
            // Georgian
            'GEORGIAN-ACADEMY',
            'GEORGIAN-PS',
            // Tajik
            'KOI8-T',
            // Kazakh
            'PT154',
            'RK1048',
            // Thai
            'ISO-8859-11',
            'TIS-620',
            'CP874',
            'MACTHAI',
            // Laotian
            'MULELAO-1',
            'CP1133',
            // Vietnamese
            'VISCII',
            'TCVN',
            'CP1258',
            // Platform specifics
            'HP-ROMAN8',
            'NEXTSTEP',
            // Full Unicode
            'UTF-8',
            'UCS-2',
            'UCS-2BE',
            'UCS-2LE',
            'UCS-4',
            'UCS-4BE',
            'UCS-4LE',
            'UTF-16',
            'UTF-16BE',
            'UTF-16LE',
            'UTF-32',
            'UTF-32BE',
            'UTF-32LE',
            'UTF-7',
            'C99',
            'JAVA',
            /* Commented out because that's internal encodings not existing in real world
                    // Full Unicode, in terms of uint16_t or uint32_t (with machine dependent endianness and alignment)
                    'UCS-2-INTERNAL',
                    'UCS-4-INTERNAL',
            
                    // Locale dependent, in terms of `char' or `wchar_t' (with machine dependent endianness and alignment,
                    // and with OS and locale dependent semantics)
                    'char',
                    'wchar_t',
                    '', // The empty encoding name is equivalent to "char": it denotes the locale dependent character encoding.
                    */
            // When configured with the option --enable-extra-encodings,
            // it also provides support for a few extra encodings:
            // European languages
            'CP437',
            'CP737',
            'CP775',
            'CP852',
            'CP853',
            'CP855',
            'CP857',
            'CP858',
            'CP860',
            'CP861',
            'CP863',
            'CP865',
            'CP869',
            'CP1125',
            // Semitic languages
            'CP864',
            // Japanese
            'EUC-JISX0213',
            'Shift_JISX0213',
            'ISO-2022-JP-3',
            // Chinese
            'BIG5-2003',
            // (experimental)
            // Turkmen
            'TDS565',
            // Platform specifics
            'ATARIST',
            'RISCOS-LATIN1',
        ];
        /**
         * Get a list of supported character encodings
         *
         * @return string[]
         */
        public static function getSupportedEncodings()
        {
        }
        /**
         * Constructor
         *
         * @throws Exception\ExtensionNotLoadedException
         */
        public function __construct()
        {
        }
        /**
         * Returns the length of the given string
         *
         * @param string $str
         * @return int|false
         */
        public function strlen($str)
        {
        }
        /**
         * Returns the portion of string specified by the start and length parameters
         *
         * @param string   $str
         * @param int      $offset
         * @param int|null $length
         * @return string|false
         */
        public function substr($str, $offset = 0, $length = null)
        {
        }
        /**
         * Find the position of the first occurrence of a substring in a string
         *
         * @param string $haystack
         * @param string $needle
         * @param int    $offset
         * @return int|false
         */
        public function strpos($haystack, $needle, $offset = 0)
        {
        }
        /**
         * Convert a string from defined encoding to the defined convert encoding
         *
         * @param string  $str
         * @param bool $reverse
         * @return string|false
         */
        public function convert($str, $reverse = false)
        {
        }
    }
    class Intl extends \Laminas\Stdlib\StringWrapper\AbstractStringWrapper
    {
        /**
         * List of supported character sets (upper case)
         *
         * @var string[]
         */
        protected static $encodings = ['UTF-8'];
        /**
         * Get a list of supported character encodings
         *
         * @return string[]
         */
        public static function getSupportedEncodings()
        {
        }
        /**
         * Constructor
         *
         * @throws Exception\ExtensionNotLoadedException
         */
        public function __construct()
        {
        }
        /**
         * Returns the length of the given string
         *
         * @param string $str
         * @return false|int
         */
        public function strlen($str)
        {
        }
        /**
         * Returns the portion of string specified by the start and length parameters
         *
         * @param string   $str
         * @param int      $offset
         * @param int|null $length
         * @return string|false
         */
        public function substr($str, $offset = 0, $length = null)
        {
        }
        /**
         * Find the position of the first occurrence of a substring in a string
         *
         * @param string $haystack
         * @param string $needle
         * @param int    $offset
         * @return int|false
         */
        public function strpos($haystack, $needle, $offset = 0)
        {
        }
    }
    class MbString extends \Laminas\Stdlib\StringWrapper\AbstractStringWrapper
    {
        /**
         * List of supported character sets (upper case)
         *
         * @link http://php.net/manual/mbstring.supported-encodings.php
         *
         * @var null|string[]
         */
        protected static $encodings;
        /**
         * Get a list of supported character encodings
         *
         * @return string[]
         */
        public static function getSupportedEncodings()
        {
        }
        /**
         * Constructor
         *
         * @throws Exception\ExtensionNotLoadedException
         */
        public function __construct()
        {
        }
        /**
         * Returns the length of the given string
         *
         * @param string $str
         * @return int|false
         */
        public function strlen($str)
        {
        }
        /**
         * Returns the portion of string specified by the start and length parameters
         *
         * @param string   $str
         * @param int      $offset
         * @param int|null $length
         * @return string|false
         */
        public function substr($str, $offset = 0, $length = null)
        {
        }
        /**
         * Find the position of the first occurrence of a substring in a string
         *
         * @param string $haystack
         * @param string $needle
         * @param int    $offset
         * @return int|false
         */
        public function strpos($haystack, $needle, $offset = 0)
        {
        }
        /**
         * Convert a string from defined encoding to the defined convert encoding
         *
         * @param string  $str
         * @param bool $reverse
         * @return string|false
         */
        public function convert($str, $reverse = false)
        {
        }
    }
    class Native extends \Laminas\Stdlib\StringWrapper\AbstractStringWrapper
    {
        /**
         * The character encoding working on
         * (overwritten to change default encoding)
         *
         * @var string
         */
        protected $encoding = 'ASCII';
        /**
         * Check if the given character encoding is supported by this wrapper
         * and the character encoding to convert to is also supported.
         *
         * @param  string      $encoding
         * @param  string|null $convertEncoding
         * @return bool
         */
        public static function isSupported($encoding, $convertEncoding = null)
        {
        }
        /**
         * Get a list of supported character encodings
         *
         * @return string[]
         */
        public static function getSupportedEncodings()
        {
        }
        /**
         * Set character encoding working with and convert to
         *
         * @param string      $encoding         The character encoding to work with
         * @param string|null $convertEncoding  The character encoding to convert to
         * @return StringWrapperInterface
         */
        public function setEncoding($encoding, $convertEncoding = null)
        {
        }
        /**
         * Returns the length of the given string
         *
         * @param string $str
         * @return int|false
         */
        public function strlen($str)
        {
        }
        /**
         * Returns the portion of string specified by the start and length parameters
         *
         * @param string   $str
         * @param int      $offset
         * @param int|null $length
         * @return string|false
         */
        public function substr($str, $offset = 0, $length = null)
        {
        }
        /**
         * Find the position of the first occurrence of a substring in a string
         *
         * @param string $haystack
         * @param string $needle
         * @param int    $offset
         * @return int|false
         */
        public function strpos($haystack, $needle, $offset = 0)
        {
        }
    }
}
namespace Laravel\SerializableClosure\Contracts {
    interface Serializable
    {
        /**
         * Resolve the closure with the given arguments.
         *
         * @return mixed
         */
        public function __invoke();
        /**
         * Gets the closure that got serialized/unserialized.
         *
         * @return \Closure
         */
        public function getClosure();
    }
    interface Signer
    {
        /**
         * Sign the given serializable.
         *
         * @param  string  $serializable
         * @return array
         */
        public function sign($serializable);
        /**
         * Verify the given signature.
         *
         * @param  array  $signature
         * @return bool
         */
        public function verify($signature);
    }
}
namespace Laravel\SerializableClosure\Exceptions {
    class InvalidSignatureException extends \Exception
    {
        /**
         * Create a new exception instance.
         *
         * @param  string  $message
         * @return void
         */
        public function __construct($message = 'Your serialized closure might have been modified or it\'s unsafe to be unserialized.')
        {
        }
    }
    class MissingSecretKeyException extends \Exception
    {
        /**
         * Create a new exception instance.
         *
         * @param  string  $message
         * @return void
         */
        public function __construct($message = 'No serializable closure secret key has been specified.')
        {
        }
    }
    class PhpVersionNotSupportedException extends \Exception
    {
        /**
         * Create a new exception instance.
         *
         * @param  string  $message
         * @return void
         */
        public function __construct($message = 'PHP 7.3 is not supported.')
        {
        }
    }
}
namespace Laravel\SerializableClosure {
    class SerializableClosure
    {
        /**
         * The closure's serializable.
         *
         * @var \Laravel\SerializableClosure\Contracts\Serializable
         */
        protected $serializable;
        /**
         * Creates a new serializable closure instance.
         *
         * @param  \Closure  $closure
         * @return void
         */
        public function __construct(\Closure $closure)
        {
        }
        /**
         * Resolve the closure with the given arguments.
         *
         * @return mixed
         */
        public function __invoke()
        {
        }
        /**
         * Gets the closure.
         *
         * @return \Closure
         */
        public function getClosure()
        {
        }
        /**
         * Create a new unsigned serializable closure instance.
         *
         * @param  Closure  $closure
         * @return \Laravel\SerializableClosure\UnsignedSerializableClosure
         */
        public static function unsigned(\Closure $closure)
        {
        }
        /**
         * Sets the serializable closure secret key.
         *
         * @param  string|null  $secret
         * @return void
         */
        public static function setSecretKey($secret)
        {
        }
        /**
         * Sets the serializable closure secret key.
         *
         * @param  \Closure|null  $transformer
         * @return void
         */
        public static function transformUseVariablesUsing($transformer)
        {
        }
        /**
         * Sets the serializable closure secret key.
         *
         * @param  \Closure|null  $resolver
         * @return void
         */
        public static function resolveUseVariablesUsing($resolver)
        {
        }
        /**
         * Get the serializable representation of the closure.
         *
         * @return array{serializable: \Laravel\SerializableClosure\Serializers\Signed|\Laravel\SerializableClosure\Contracts\Serializable}
         */
        public function __serialize()
        {
        }
        /**
         * Restore the closure after serialization.
         *
         * @param  array{serializable: \Laravel\SerializableClosure\Serializers\Signed|\Laravel\SerializableClosure\Contracts\Serializable}  $data
         * @return void
         *
         * @throws \Laravel\SerializableClosure\Exceptions\InvalidSignatureException
         */
        public function __unserialize($data)
        {
        }
    }
}
namespace Laravel\SerializableClosure\Serializers {
    class Native implements \Laravel\SerializableClosure\Contracts\Serializable
    {
        /**
         * Transform the use variables before serialization.
         *
         * @var \Closure|null
         */
        public static $transformUseVariables;
        /**
         * Resolve the use variables after unserialization.
         *
         * @var \Closure|null
         */
        public static $resolveUseVariables;
        /**
         * The closure to be serialized/unserialized.
         *
         * @var \Closure
         */
        protected $closure;
        /**
         * The closure's reflection.
         *
         * @var \Laravel\SerializableClosure\Support\ReflectionClosure|null
         */
        protected $reflector;
        /**
         * The closure's code.
         *
         * @var array|null
         */
        protected $code;
        /**
         * The closure's reference.
         *
         * @var string
         */
        protected $reference;
        /**
         * The closure's scope.
         *
         * @var \Laravel\SerializableClosure\Support\ClosureScope|null
         */
        protected $scope;
        /**
         * The "key" that marks an array as recursive.
         */
        const ARRAY_RECURSIVE_KEY = 'LARAVEL_SERIALIZABLE_RECURSIVE_KEY';
        /**
         * Creates a new serializable closure instance.
         *
         * @param  \Closure  $closure
         * @return void
         */
        public function __construct(\Closure $closure)
        {
        }
        /**
         * Resolve the closure with the given arguments.
         *
         * @return mixed
         */
        public function __invoke()
        {
        }
        /**
         * Gets the closure.
         *
         * @return \Closure
         */
        public function getClosure()
        {
        }
        /**
         * Get the serializable representation of the closure.
         *
         * @return array
         */
        public function __serialize()
        {
        }
        /**
         * Restore the closure after serialization.
         *
         * @param  array  $data
         * @return void
         */
        public function __unserialize($data)
        {
        }
        /**
         * Ensures the given closures are serializable.
         *
         * @param  mixed  $data
         * @param  \Laravel\SerializableClosure\Support\ClosureScope  $storage
         * @return void
         */
        public static function wrapClosures(&$data, $storage)
        {
        }
        /**
         * Gets the closure's reflector.
         *
         * @return \Laravel\SerializableClosure\Support\ReflectionClosure
         */
        public function getReflector()
        {
        }
        /**
         * Internal method used to map closure pointers.
         *
         * @param  mixed  $data
         * @return void
         */
        protected function mapPointers(&$data)
        {
        }
        /**
         * Internal method used to map closures by reference.
         *
         * @param  mixed  $data
         * @return void
         */
        protected function mapByReference(&$data)
        {
        }
        /**
         * Determine is virtual property.
         *
         * @param  \ReflectionProperty  $property
         * @return bool
         */
        protected function isVirtualProperty(\ReflectionProperty $property): bool
        {
        }
    }
    class Signed implements \Laravel\SerializableClosure\Contracts\Serializable
    {
        /**
         * The signer that will sign and verify the closure's signature.
         *
         * @var \Laravel\SerializableClosure\Contracts\Signer|null
         */
        public static $signer;
        /**
         * The closure to be serialized/unserialized.
         *
         * @var \Closure
         */
        protected $closure;
        /**
         * Creates a new serializable closure instance.
         *
         * @param  \Closure  $closure
         * @return void
         */
        public function __construct($closure)
        {
        }
        /**
         * Resolve the closure with the given arguments.
         *
         * @return mixed
         */
        public function __invoke()
        {
        }
        /**
         * Gets the closure.
         *
         * @return \Closure
         */
        public function getClosure()
        {
        }
        /**
         * Get the serializable representation of the closure.
         *
         * @return array
         */
        public function __serialize()
        {
        }
        /**
         * Restore the closure after serialization.
         *
         * @param  array{serializable: string, hash: string}  $signature
         * @return void
         *
         * @throws \Laravel\SerializableClosure\Exceptions\InvalidSignatureException
         */
        public function __unserialize($signature)
        {
        }
    }
}
namespace Laravel\SerializableClosure\Signers {
    class Hmac implements \Laravel\SerializableClosure\Contracts\Signer
    {
        /**
         * The secret key.
         *
         * @var string
         */
        protected $secret;
        /**
         * Creates a new signer instance.
         *
         * @param  string  $secret
         * @return void
         */
        public function __construct($secret)
        {
        }
        /**
         * Sign the given serializable.
         *
         * @param  string  $serialized
         * @return array
         */
        public function sign($serialized)
        {
        }
        /**
         * Verify the given signature.
         *
         * @param  array{serializable: string, hash: string}  $signature
         * @return bool
         */
        public function verify($signature)
        {
        }
    }
}
namespace Laravel\SerializableClosure\Support {
    class ClosureScope extends \SplObjectStorage
    {
        /**
         * The number of serializations in current scope.
         *
         * @var int
         */
        public $serializations = 0;
        /**
         * The number of closures that have to be serialized.
         *
         * @var int
         */
        public $toSerialize = 0;
    }
    #[\AllowDynamicProperties]
    class ClosureStream
    {
        /**
         * The stream protocol.
         *
         * @var string
         */
        const STREAM_PROTO = 'laravel-serializable-closure';
        /**
         * Checks if this stream is registered.
         *
         * @var bool
         */
        protected static $isRegistered = false;
        /**
         * The stream content.
         *
         * @var string
         */
        protected $content;
        /**
         * The stream content.
         *
         * @var int
         */
        protected $length;
        /**
         * The stream pointer.
         *
         * @var int
         */
        protected $pointer = 0;
        /**
         * Opens file or URL.
         *
         * @param  string  $path
         * @param  string  $mode
         * @param  string  $options
         * @param  string|null  $opened_path
         * @return bool
         */
        public function stream_open($path, $mode, $options, &$opened_path)
        {
        }
        /**
         * Read from stream.
         *
         * @param  int  $count
         * @return string
         */
        public function stream_read($count)
        {
        }
        /**
         * Tests for end-of-file on a file pointer.
         *
         * @return bool
         */
        public function stream_eof()
        {
        }
        /**
         * Change stream options.
         *
         * @param  int  $option
         * @param  int  $arg1
         * @param  int  $arg2
         * @return bool
         */
        public function stream_set_option($option, $arg1, $arg2)
        {
        }
        /**
         * Retrieve information about a file resource.
         *
         * @return array|bool
         */
        public function stream_stat()
        {
        }
        /**
         * Retrieve information about a file.
         *
         * @param  string  $path
         * @param  int  $flags
         * @return array|bool
         */
        public function url_stat($path, $flags)
        {
        }
        /**
         * Seeks to specific location in a stream.
         *
         * @param  int  $offset
         * @param  int  $whence
         * @return bool
         */
        public function stream_seek($offset, $whence = SEEK_SET)
        {
        }
        /**
         * Retrieve the current position of a stream.
         *
         * @return int
         */
        public function stream_tell()
        {
        }
        /**
         * Registers the stream.
         *
         * @return void
         */
        public static function register()
        {
        }
    }
    class ReflectionClosure extends \ReflectionFunction
    {
        protected $code;
        protected $tokens;
        protected $hashedName;
        protected $useVariables;
        protected $isStaticClosure;
        protected $isScopeRequired;
        protected $isBindingRequired;
        protected $isShortClosure;
        protected static $files = [];
        protected static $classes = [];
        protected static $functions = [];
        protected static $constants = [];
        protected static $structures = [];
        /**
         * Creates a new reflection closure instance.
         *
         * @param  \Closure  $closure
         * @param  string|null  $code
         * @return void
         */
        public function __construct(\Closure $closure, $code = null)
        {
        }
        /**
         * Checks if the closure is "static".
         *
         * @return bool
         */
        public function isStatic(): bool
        {
        }
        /**
         * Checks if the closure is a "short closure".
         *
         * @return bool
         */
        public function isShortClosure()
        {
        }
        /**
         * Get the closure's code.
         *
         * @return string
         */
        public function getCode()
        {
        }
        /**
         * Get PHP native built in types.
         *
         * @return array
         */
        protected static function getBuiltinTypes()
        {
        }
        /**
         * Gets the use variables by the closure.
         *
         * @return array
         */
        public function getUseVariables()
        {
        }
        /**
         * Checks if binding is required.
         *
         * @return bool
         */
        public function isBindingRequired()
        {
        }
        /**
         * Checks if access to the scope is required.
         *
         * @return bool
         */
        public function isScopeRequired()
        {
        }
        /**
         * The hash of the current file name.
         *
         * @return string
         */
        protected function getHashedFileName()
        {
        }
        /**
         * Get the file tokens.
         *
         * @return array
         */
        protected function getFileTokens()
        {
        }
        /**
         * Get the tokens.
         *
         * @return array
         */
        protected function getTokens()
        {
        }
        /**
         * Get the classes.
         *
         * @return array
         */
        protected function getClasses()
        {
        }
        /**
         * Get the functions.
         *
         * @return array
         */
        protected function getFunctions()
        {
        }
        /**
         * Gets the constants.
         *
         * @return array
         */
        protected function getConstants()
        {
        }
        /**
         * Get the structures.
         *
         * @return array
         */
        protected function getStructures()
        {
        }
        /**
         * Fetch the items.
         *
         * @return void.
         */
        protected function fetchItems()
        {
        }
        /**
         * Returns the namespace associated to the closure.
         *
         * @return string
         */
        protected function getClosureNamespaceName()
        {
        }
        /**
         * Parse the given token.
         *
         * @param  string  $token
         * @return array
         */
        protected function parseNameQualified($token)
        {
        }
    }
    class SelfReference
    {
        /**
         * The unique hash representing the object.
         *
         * @var string
         */
        public $hash;
        /**
         * Creates a new self reference instance.
         *
         * @param  string  $hash
         * @return void
         */
        public function __construct($hash)
        {
        }
    }
}
namespace Laravel\SerializableClosure {
    class UnsignedSerializableClosure
    {
        /**
         * The closure's serializable.
         *
         * @var \Laravel\SerializableClosure\Contracts\Serializable
         */
        protected $serializable;
        /**
         * Creates a new serializable closure instance.
         *
         * @param  \Closure  $closure
         * @return void
         */
        public function __construct(\Closure $closure)
        {
        }
        /**
         * Resolve the closure with the given arguments.
         *
         * @return mixed
         */
        public function __invoke()
        {
        }
        /**
         * Gets the closure.
         *
         * @return \Closure
         */
        public function getClosure()
        {
        }
        /**
         * Get the serializable representation of the closure.
         *
         * @return array{serializable: \Laravel\SerializableClosure\Contracts\Serializable}
         */
        public function __serialize()
        {
        }
        /**
         * Restore the closure after serialization.
         *
         * @param  array{serializable: \Laravel\SerializableClosure\Contracts\Serializable}  $data
         * @return void
         */
        public function __unserialize($data)
        {
        }
    }
}
namespace fXmlRpc {
    interface CallClientInterface
    {
        /**
         * Execute remote call
         *
         * @param string $method
         * @param array $arguments
         * @throws ExceptionInterface
         * @return mixed
         */
        public function call($method, array $arguments = []);
    }
    interface MulticallClientInterface
    {
        /**
         * Start sequence of multicall
         *
         * @return MulticallBuilderInterface
         */
        public function multicall();
    }
    interface ClientInterface extends \fXmlRpc\CallClientInterface, \fXmlRpc\MulticallClientInterface
    {
    }
    /**
     * Abstract base class for client decorators
     *
     * Extend this base class if you want to decorate functionality of the client
     */
    abstract class AbstractDecorator implements \fXmlRpc\ClientInterface
    {
        /** @var ClientInterface */
        protected $wrapped;
        /** {@inheritdoc} */
        public function __construct(\fXmlRpc\ClientInterface $wrapped)
        {
        }
        /** {@inheritdoc} */
        public function call($methodName, array $arguments = [])
        {
        }
        /** {@inheritdoc} */
        public function multicall()
        {
        }
    }
    final class Client implements \fXmlRpc\ClientInterface
    {
        /**
         * Create new client instance
         *
         * If no specific transport, parser or serializer is passed, default implementations
         * are used.
         *
         * @param string                         $uri
         * @param TransportInterface             $transport
         * @param Parser\ParserInterface         $parser
         * @param Serializer\SerializerInterface $serializer
         */
        public function __construct($uri = null, \fXmlRpc\Transport\TransportInterface $transport = null, \fXmlRpc\Parser\ParserInterface $parser = null, \fXmlRpc\Serializer\SerializerInterface $serializer = null)
        {
        }
        /**
         * Set the endpoint URI
         *
         * @param string $uri
         */
        public function setUri($uri)
        {
        }
        /**
         * Return endpoint URI
         *
         * @return string
         */
        public function getUri()
        {
        }
        /**
         * Prepend default parameters that should always be prepended
         *
         * @param array $params
         */
        public function prependParams(array $params)
        {
        }
        /**
         * Get default parameters that are always prepended
         *
         * @return array
         */
        public function getPrependParams()
        {
        }
        /**
         * Append default parameters that should always be prepended
         *
         * @param array $params
         */
        public function appendParams(array $params)
        {
        }
        /**
         * Get default parameters that are always appended
         *
         * @return array
         */
        public function getAppendParams()
        {
        }
        /** {@inheritdoc} */
        public function call($methodName, array $params = [])
        {
        }
        /** {@inheritdoc} */
        public function multicall()
        {
        }
    }
}
namespace fXmlRpc\CodeGenerator {
    final class XmlReaderParserBitmaskGenerator
    {
        public function __construct()
        {
        }
        public function generate()
        {
        }
    }
}
namespace fXmlRpc\Exception {
    interface ExceptionInterface extends \Throwable
    {
    }
    abstract class RuntimeException extends \RuntimeException implements \fXmlRpc\Exception\ExceptionInterface
    {
    }
    abstract class AbstractTransportException extends \fXmlRpc\Exception\RuntimeException
    {
    }
    final class FaultException extends \fXmlRpc\Exception\RuntimeException
    {
        public static function fault($response)
        {
        }
        public function getFaultString()
        {
        }
        public function getFaultCode()
        {
        }
    }
    final class HttpException extends \fXmlRpc\Exception\AbstractTransportException
    {
        public static function httpError($message, $statusCode, \Exception $previous = null)
        {
        }
    }
    final class InvalidArgumentException extends \InvalidArgumentException implements \fXmlRpc\Exception\ExceptionInterface
    {
        public static function expectedParameter($position, $expected, $actualValue)
        {
        }
    }
    final class MissingExtensionException extends \fXmlRpc\Exception\RuntimeException
    {
        public static function extensionMissing($extension)
        {
        }
    }
    final class ParserException extends \fXmlRpc\Exception\RuntimeException
    {
        public static function unexpectedTag($tagName, $elements, array $definedVariables, $depth, $xml)
        {
        }
        public static function notXml($string)
        {
        }
        public static function xmlrpcExtensionLibxmlParsehugeNotSupported()
        {
        }
    }
    final class SerializationException extends \fXmlRpc\Exception\RuntimeException
    {
        public static function invalidType($value)
        {
        }
    }
    final class TransportException extends \fXmlRpc\Exception\RuntimeException
    {
        public static function transportError($error)
        {
        }
    }
}
namespace fXmlRpc {
    interface ExtensionSupportInterface
    {
        const EXTENSION_NIL = 'nil';
        /**
         * Enables extension
         *
         * @param  string $extension
         * @return null
         */
        public function enableExtension($extension);
        /**
         * Disables extension
         *
         * @param  string $extension
         * @return null
         */
        public function disableExtension($extension);
        /**
         * Returns true if an extension is enabled
         *
         * @param  string  $extension
         * @return boolean
         */
        public function isExtensionEnabled($extension);
    }
    interface MulticallBuilderInterface
    {
        /**
         * Register a success handler applicable to all multicall responses
         *
         * @param callable $handler
         * @throws InvalidArgumentException
         * @return MulticallBuilderInterface
         */
        public function onSuccess(callable $handler);
        /**
         * Register a error handler applicable to all multicall responses
         *
         * @param callable $handler
         * @throws InvalidArgumentException
         * @return MulticallBuilderInterface
         */
        public function onError(callable $handler);
        /**
         * Add a call to the end of the multicall stack
         *
         * @param string $methodName
         * @param array $params
         * @param callable $onSuccess
         * @param callable $onError
         * @return MulticallBuilderInterface
         */
        public function addCall($methodName, array $params = [], callable $onSuccess = null, callable $onError = null);
        /**
         * Send the multicall request to the server
         *
         * @return array
         */
        public function execute();
    }
    final class MulticallBuilder implements \fXmlRpc\MulticallBuilderInterface
    {
        /** @param ClientInterface $client */
        public function __construct(\fXmlRpc\ClientInterface $client)
        {
        }
        /** {@inheritdoc} */
        public function addCall($methodName, array $params = [], callable $onSuccess = null, callable $onError = null)
        {
        }
        /** {@inheritdoc} */
        public function onSuccess(callable $onSuccess)
        {
        }
        /** {@inheritdoc} */
        public function onError(callable $onError)
        {
        }
        /** {@inheritdoc} */
        public function execute()
        {
        }
        /** @return ClientInterface */
        public function getClient()
        {
        }
    }
}
namespace fXmlRpc\Parser {
    /**
     * Parser to parse XML responses into its PHP representation
     */
    interface ParserInterface
    {
        /**
         * Parse XML string into PHP representation
         *
         * @param  string $xmlString
         * @throws FaultException
         * @return mixed
         */
        public function parse($xmlString);
    }
    final class BestParserDelegate implements \fXmlRpc\Parser\ParserInterface
    {
        public function __construct($validateResponse = true)
        {
        }
        public function parse($xmlString)
        {
        }
    }
    final class NativeParser implements \fXmlRpc\Parser\ParserInterface
    {
        const LIBXML_PARSEHUGE_THRESHOLD = 1024 * 1024 * 10;
        public function __construct($validateResponse = true)
        {
        }
        /**
         * @param string $xmlString
         * @return bool
         */
        public static function isBiggerThanParseLimit($xmlString)
        {
        }
        /** {@inheritdoc} */
        public function parse($xmlString)
        {
        }
    }
    /**
     * Class XmlChecker to check is correct XML
     * @author Piotr Olaszewski <piotroo89@gmail.com>
     */
    final class XmlChecker
    {
        /**
         * @param string $xml
         * @throws ParserException
         */
        public static function validXml($xml)
        {
        }
    }
    final class XmlReaderParser implements \fXmlRpc\Parser\ParserInterface
    {
        public function __construct($validateResponse = true)
        {
        }
        /** {@inheritdoc} */
        public function parse($xmlString)
        {
        }
    }
}
namespace fXmlRpc {
    class Proxy
    {
        /**
         * @param ClientInterface $client
         * @param string          $namespaceSeparator
         * @param string          $namespace
         */
        public function __construct(\fXmlRpc\ClientInterface $client, $namespaceSeparator = '.', $namespace = null)
        {
        }
        /**
         * Invokes remote command
         *
         * @param  string $method
         * @param  array  $parameters
         * @return mixed
         */
        public function __call($method, array $parameters)
        {
        }
        /**
         * Returns namespace specific Proxy instance
         *
         * @param  string $namespace
         * @return Proxy
         */
        public function __get($namespace)
        {
        }
        /**
         * Prepend namespace if set
         *
         * @param  string $string
         * @return string
         */
        protected function prependNamespace($string)
        {
        }
    }
}
namespace fXmlRpc\Serializer {
    /**
     * Serializer creates XML from native PHP types
     */
    interface SerializerInterface
    {
        /**
         * Serialize XML/RPC method name and params into XML representation
         *
         * @param  string $method
         * @param  array  $params
         * @return string
         */
        public function serialize($method, array $params = []);
    }
    final class NativeSerializer implements \fXmlRpc\Serializer\SerializerInterface
    {
        public function __construct()
        {
        }
        /** {@inheritdoc} */
        public function serialize($method, array $params = [])
        {
        }
    }
    final class XmlWriterSerializer implements \fXmlRpc\Serializer\SerializerInterface, \fXmlRpc\ExtensionSupportInterface
    {
        public function __construct()
        {
        }
        /** {@inheritdoc} */
        public function enableExtension($extension)
        {
        }
        /** {@inheritdoc} */
        public function disableExtension($extension)
        {
        }
        /** {@inheritdoc} */
        public function isExtensionEnabled($extension)
        {
        }
        /** {@inheritdoc} */
        public function serialize($methodName, array $params = [])
        {
        }
    }
}
namespace fXmlRpc\Timing {
    interface TimerInterface
    {
        /**
         * Records a timing information
         *
         * @param float  $callTime
         * @param string $method
         * @param array  $arguments
         * @return null
         */
        public function recordTiming($callTime, $method, array $arguments);
    }
    /**
     * Base class for timing bridges
     *
     * Base class for bridging between timing information and various logger
     * implementations.
     */
    abstract class AbstractTimerBridge implements \fXmlRpc\Timing\TimerInterface
    {
        /** @var object */
        protected $logger;
        /** @var array|integer */
        protected $level;
        /** @var string */
        protected $messageTemplate = 'fXmlRpc call took %01.10Fs';
        /**
         * Set log level
         *
         * @param mixed $level
         * @param mixed $default
         */
        protected function setLevel($level, $default)
        {
        }
        /**
         * Get log level by callTime
         *
         * @param  float $callTime
         * @return integer
         */
        protected function getLevel($callTime)
        {
        }
    }
    final class MonologTimerBridge extends \fXmlRpc\Timing\AbstractTimerBridge
    {
        /**
         * Create new monolog bridge
         *
         * Allows passing custom log level and message template (with sprintf() control characters) for log message
         * customization
         *
         * @param Logger     $logger
         * @param null|array $level
         * @param null       $messageTemplate
         */
        public function __construct(\Monolog\Logger $logger, $level = null, $messageTemplate = null)
        {
        }
        /** {@inheritdoc} */
        public function recordTiming($callTime, $method, array $arguments)
        {
        }
    }
    final class Psr3TimerBridge extends \fXmlRpc\Timing\AbstractTimerBridge
    {
        /**
         * Create new bridge or a PSR-3 compatible logger
         *
         * Allows passing custom log level and message template (with sprintf() control characters) for log message
         * customization
         *
         * @param LoggerInterface $logger
         * @param integer         $level
         * @param string          $messageTemplate
         */
        public function __construct(\Psr\Log\LoggerInterface $logger, $level = null, $messageTemplate = null)
        {
        }
        /** {@inheritdoc} */
        public function recordTiming($callTime, $method, array $arguments)
        {
        }
    }
    final class TimingDecorator extends \fXmlRpc\AbstractDecorator
    {
        /**
         * Create new client decorator to record timing information
         *
         * @param ClientInterface $wrapped
         * @param TimerInterface  $timer
         */
        public function __construct(\fXmlRpc\ClientInterface $wrapped, \fXmlRpc\Timing\TimerInterface $timer)
        {
        }
        /** {@inheritdoc} */
        public function call($methodName, array $arguments = [])
        {
        }
    }
    final class ZendFrameworkOneTimerBridge extends \fXmlRpc\Timing\AbstractTimerBridge
    {
        /**
         * Create new Zend_Log bridge
         *
         * Allows passing custom log level and message template (with sprintf() control characters) for log message
         * customization
         *
         * @param Log $logger
         * @param integer  $level
         * @param string   $messageTemplate
         */
        public function __construct(\Zend_Log $logger, $level = null, $messageTemplate = null)
        {
        }
        /** {@inheritdoc} */
        public function recordTiming($callTime, $method, array $arguments)
        {
        }
    }
    final class ZendFrameworkTwoTimerBridge extends \fXmlRpc\Timing\AbstractTimerBridge
    {
        /**
         * Create new Zend\Log\LoggerInterface bridge
         *
         * Allows passing custom log level and message template (with sprintf() control characters) for log message
         * customization
         *
         * @param LoggerInterface $logger
         * @param string          $method
         * @param string          $messageTemplate
         */
        public function __construct(\Zend\Log\LoggerInterface $logger, $method = null, $messageTemplate = null)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function recordTiming($callTime, $method, array $arguments)
        {
        }
    }
}
namespace fXmlRpc\Transport {
    /**
     * Transport interface
     *
     * This interface is implemented by transports to provide means to send
     * requests over the wire.
     */
    interface TransportInterface
    {
        /**
         * Send XML/RPC request over the wire and return the payload
         *
         * @param  string                     $endpoint
         * @param  string                     $payload
         * @throws AbstractTransportException If a transport error occurred
         * @return string
         */
        public function send($endpoint, $payload);
    }
    final class HttpAdapterTransport implements \fXmlRpc\Transport\TransportInterface
    {
        public function __construct(\Http\Message\MessageFactory $messageFactory, \Psr\Http\Client\ClientInterface $client)
        {
        }
        /** {@inheritdoc} */
        public function send($endpoint, $payload)
        {
        }
    }
    /**
     * Supports transport via any classes that implement the PSR-17 (Request Factory) and PSR-18 (HTTP Client) standards.
     */
    final class PsrTransport implements \fXmlRpc\Transport\TransportInterface
    {
        public function __construct(\Psr\Http\Message\RequestFactoryInterface $requestFactory, \Psr\Http\Client\ClientInterface $client)
        {
        }
        /** {@inheritdoc} */
        public function send($endpoint, $payload)
        {
        }
    }
    /**
     * Transport decorator which contains XML of the last request and response.
     *
     * @author Piotr Olaszewski <piotroo89 [%] gmail dot com>
     */
    class Recorder implements \fXmlRpc\Transport\TransportInterface
    {
        public function __construct(\fXmlRpc\Transport\TransportInterface $transport)
        {
        }
        /** {@inheritdoc} */
        public function send($endpoint, $payload)
        {
        }
        /**
         * Returns the XML sent in the last request.
         *
         * @return string|null
         */
        public function getLastRequest()
        {
        }
        /**
         * Returns the XML received in the last response.
         *
         * @return string|null
         */
        public function getLastResponse()
        {
        }
        /**
         * Returns exception when last request fail.
         *
         * @return Exception|null
         */
        public function getLastException()
        {
        }
    }
}
namespace fXmlRpc\Value {
    interface Base64Interface
    {
        /**
         * Get base64 value as base64 encoded string
         *
         * @return string
         */
        public function getEncoded();
        /**
         * Get base64 value as binary string
         *
         * @return string
         */
        public function getDecoded();
    }
    final class Base64 implements \fXmlRpc\Value\Base64Interface
    {
        /**
         * Return new base64 value object by encoded value
         *
         * @param  string $string
         * @return Base64
         */
        public static function serialize($string)
        {
        }
        /**
         * Return new base64 value by string
         *
         * @param  string $value
         * @return Base64
         */
        public static function deserialize($value)
        {
        }
        /** {@inheritdoc} */
        public function getEncoded()
        {
        }
        /** {@inheritdoc} */
        public function getDecoded()
        {
        }
    }
}
namespace Monolog\Attribute {
    /**
     * A reusable attribute to help configure a class or a method as a processor.
     *
     * Using it offers no guarantee: it needs to be leveraged by a Monolog third-party consumer.
     *
     * Using it with the Monolog library only has no effect at all: processors should still be turned into a callable if
     * needed and manually pushed to the loggers and to the processable handlers.
     */
    #[\Attribute(\Attribute::TARGET_CLASS | \Attribute::TARGET_METHOD | \Attribute::IS_REPEATABLE)]
    class AsMonologProcessor
    {
        /**
         * @param string|null $channel  The logging channel the processor should be pushed to.
         * @param string|null $handler  The handler the processor should be pushed to.
         * @param string|null $method   The method that processes the records (if the attribute is used at the class level).
         * @param int|null    $priority The priority of the processor so the order can be determined.
         */
        public function __construct(public readonly ?string $channel = null, public readonly ?string $handler = null, public readonly ?string $method = null, public readonly ?int $priority = null)
        {
        }
    }
    /**
     * A reusable attribute to help configure a class as expecting a given logger channel.
     *
     * Using it offers no guarantee: it needs to be leveraged by a Monolog third-party consumer.
     *
     * Using it with the Monolog library only has no effect at all: wiring the logger instance into
     * other classes is not managed by Monolog.
     */
    #[\Attribute(\Attribute::TARGET_CLASS)]
    final class WithMonologChannel
    {
        public function __construct(public readonly string $channel)
        {
        }
    }
}
namespace Monolog {
    /**
     * Overrides default json encoding of date time objects
     *
     * @author Menno Holtkamp
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    class JsonSerializableDateTimeImmutable extends \DateTimeImmutable implements \JsonSerializable
    {
        public function __construct(bool $useMicroseconds, ?\DateTimeZone $timezone = null)
        {
        }
        public function jsonSerialize(): string
        {
        }
        public function __toString(): string
        {
        }
    }
    /**
     * @deprecated Use \Monolog\JsonSerializableDateTimeImmutable instead.
     */
    class DateTimeImmutable extends \Monolog\JsonSerializableDateTimeImmutable
    {
    }
    /**
     * Monolog error handler
     *
     * A facility to enable logging of runtime errors, exceptions and fatal errors.
     *
     * Quick setup: <code>ErrorHandler::register($logger);</code>
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    class ErrorHandler
    {
        public function __construct(private \Psr\Log\LoggerInterface $logger)
        {
        }
        /**
         * Registers a new ErrorHandler for a given Logger
         *
         * By default it will handle errors, exceptions and fatal errors
         *
         * @param  array<int, LogLevel::*>|false          $errorLevelMap     an array of E_* constant to LogLevel::* constant mapping, or false to disable error handling
         * @param  array<class-string, LogLevel::*>|false $exceptionLevelMap an array of class name to LogLevel::* constant mapping, or false to disable exception handling
         * @param  LogLevel::*|null|false                 $fatalLevel        a LogLevel::* constant, null to use the default LogLevel::ALERT or false to disable fatal error handling
         * @return static
         */
        public static function register(\Psr\Log\LoggerInterface $logger, $errorLevelMap = [], $exceptionLevelMap = [], $fatalLevel = null): self
        {
        }
        /**
         * @param  array<class-string, LogLevel::*> $levelMap an array of class name to LogLevel::* constant mapping
         * @return $this
         */
        public function registerExceptionHandler(array $levelMap = [], bool $callPrevious = true): self
        {
        }
        /**
         * @param  array<int, LogLevel::*> $levelMap an array of E_* constant to LogLevel::* constant mapping
         * @return $this
         */
        public function registerErrorHandler(array $levelMap = [], bool $callPrevious = true, int $errorTypes = -1, bool $handleOnlyReportedErrors = true): self
        {
        }
        /**
         * @param  LogLevel::*|null $level              a LogLevel::* constant, null to use the default LogLevel::ALERT
         * @param  int              $reservedMemorySize Amount of KBs to reserve in memory so that it can be freed when handling fatal errors giving Monolog some room in memory to get its job done
         * @return $this
         */
        public function registerFatalHandler($level = null, int $reservedMemorySize = 20): self
        {
        }
        /**
         * @return array<class-string, LogLevel::*>
         */
        protected function defaultExceptionLevelMap(): array
        {
        }
        /**
         * @return array<int, LogLevel::*>
         */
        protected function defaultErrorLevelMap(): array
        {
        }
        /**
         * @private
         */
        public function handleFatalError(): void
        {
        }
    }
}
namespace Monolog\Formatter {
    /**
     * Interface for formatters
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    interface FormatterInterface
    {
        /**
         * Formats a log record.
         *
         * @param  LogRecord $record A record to format
         * @return mixed     The formatted record
         */
        public function format(\Monolog\LogRecord $record);
        /**
         * Formats a set of log records.
         *
         * @param  array<LogRecord> $records A set of records to format
         * @return mixed            The formatted set of records
         */
        public function formatBatch(array $records);
    }
    /**
     * Formats a log message according to the ChromePHP array format
     *
     * @author Christophe Coevoet <stof@notk.org>
     */
    class ChromePHPFormatter implements \Monolog\Formatter\FormatterInterface
    {
        /**
         * @inheritDoc
         */
        public function format(\Monolog\LogRecord $record)
        {
        }
        /**
         * @inheritDoc
         */
        public function formatBatch(array $records)
        {
        }
    }
    /**
     * Normalizes incoming records to remove objects/resources so it's easier to dump to various targets
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    class NormalizerFormatter implements \Monolog\Formatter\FormatterInterface
    {
        public const SIMPLE_DATE = "Y-m-d\\TH:i:sP";
        protected string $dateFormat;
        protected int $maxNormalizeDepth = 9;
        protected int $maxNormalizeItemCount = 1000;
        protected string $basePath = '';
        /**
         * @param string|null $dateFormat The format of the timestamp: one supported by DateTime::format
         */
        public function __construct(?string $dateFormat = null)
        {
        }
        /**
         * @inheritDoc
         */
        public function format(\Monolog\LogRecord $record)
        {
        }
        /**
         * Normalize an arbitrary value to a scalar|array|null
         *
         * @return null|scalar|array<mixed[]|scalar|null>
         */
        public function normalizeValue(mixed $data): mixed
        {
        }
        /**
         * @inheritDoc
         */
        public function formatBatch(array $records)
        {
        }
        public function getDateFormat(): string
        {
        }
        /**
         * @return $this
         */
        public function setDateFormat(string $dateFormat): self
        {
        }
        /**
         * The maximum number of normalization levels to go through
         */
        public function getMaxNormalizeDepth(): int
        {
        }
        /**
         * @return $this
         */
        public function setMaxNormalizeDepth(int $maxNormalizeDepth): self
        {
        }
        /**
         * The maximum number of items to normalize per level
         */
        public function getMaxNormalizeItemCount(): int
        {
        }
        /**
         * @return $this
         */
        public function setMaxNormalizeItemCount(int $maxNormalizeItemCount): self
        {
        }
        /**
         * Enables `json_encode` pretty print.
         *
         * @return $this
         */
        public function setJsonPrettyPrint(bool $enable): self
        {
        }
        /**
         * Setting a base path will hide the base path from exception and stack trace file names to shorten them
         * @return $this
         */
        public function setBasePath(string $path = ''): self
        {
        }
        /**
         * Provided as extension point
         *
         * Because normalize is called with sub-values of context data etc, normalizeRecord can be
         * extended when data needs to be appended on the record array but not to other normalized data.
         *
         * @return array<mixed[]|scalar|null>
         */
        protected function normalizeRecord(\Monolog\LogRecord $record): array
        {
        }
        /**
         * @return null|scalar|array<mixed[]|scalar|null>
         */
        protected function normalize(mixed $data, int $depth = 0): mixed
        {
        }
        /**
         * @return array<array-key, string|int|array<string|int|array<string>>>
         */
        protected function normalizeException(\Throwable $e, int $depth = 0)
        {
        }
        /**
         * Return the JSON representation of a value
         *
         * @param  mixed             $data
         * @throws \RuntimeException if encoding fails and errors are not ignored
         * @return string            if encoding fails and ignoreErrors is true 'null' is returned
         */
        protected function toJson($data, bool $ignoreErrors = false): string
        {
        }
        protected function formatDate(\DateTimeInterface $date): string
        {
        }
        /**
         * @return $this
         */
        public function addJsonEncodeOption(int $option): self
        {
        }
        /**
         * @return $this
         */
        public function removeJsonEncodeOption(int $option): self
        {
        }
    }
    /**
     * Format a log message into an Elastica Document
     *
     * @author Jelle Vink <jelle.vink@gmail.com>
     */
    class ElasticaFormatter extends \Monolog\Formatter\NormalizerFormatter
    {
        /**
         * @var string Elastic search index name
         */
        protected string $index;
        /**
         * @var string|null Elastic search document type
         */
        protected string|null $type;
        /**
         * @param string  $index Elastic Search index name
         * @param ?string $type  Elastic Search document type, deprecated as of Elastica 7
         */
        public function __construct(string $index, ?string $type)
        {
        }
        /**
         * @inheritDoc
         */
        public function format(\Monolog\LogRecord $record)
        {
        }
        public function getIndex(): string
        {
        }
        /**
         * @deprecated since Elastica 7 type has no effect
         */
        public function getType(): string
        {
        }
        /**
         * Convert a log message into an Elastica Document
         *
         * @param mixed[] $record
         */
        protected function getDocument(array $record): \Elastica\Document
        {
        }
    }
    /**
     * Format a log message into an Elasticsearch record
     *
     * @author Avtandil Kikabidze <akalongman@gmail.com>
     */
    class ElasticsearchFormatter extends \Monolog\Formatter\NormalizerFormatter
    {
        /**
         * @var string Elasticsearch index name
         */
        protected string $index;
        /**
         * @var string Elasticsearch record type
         */
        protected string $type;
        /**
         * @param string $index Elasticsearch index name
         * @param string $type  Elasticsearch record type
         */
        public function __construct(string $index, string $type)
        {
        }
        /**
         * @inheritDoc
         */
        public function format(\Monolog\LogRecord $record)
        {
        }
        /**
         * Getter index
         */
        public function getIndex(): string
        {
        }
        /**
         * Getter type
         */
        public function getType(): string
        {
        }
        /**
         * Convert a log message into an Elasticsearch record
         *
         * @param  mixed[] $record Log message
         * @return mixed[]
         */
        protected function getDocument(array $record): array
        {
        }
    }
    /**
     * formats the record to be used in the FlowdockHandler
     *
     * @author Dominik Liebler <liebler.dominik@gmail.com>
     * @deprecated Since 2.9.0 and 3.3.0, Flowdock was shutdown we will thus drop this handler in Monolog 4
     */
    class FlowdockFormatter implements \Monolog\Formatter\FormatterInterface
    {
        public function __construct(string $source, string $sourceEmail)
        {
        }
        /**
         * @inheritDoc
         *
         * @return mixed[]
         */
        public function format(\Monolog\LogRecord $record): array
        {
        }
        /**
         * @inheritDoc
         *
         * @return mixed[][]
         */
        public function formatBatch(array $records): array
        {
        }
        public function getShortMessage(string $message): string
        {
        }
    }
    /**
     * Class FluentdFormatter
     *
     * Serializes a log message to Fluentd unix socket protocol
     *
     * Fluentd config:
     *
     * <source>
     *  type unix
     *  path /var/run/td-agent/td-agent.sock
     * </source>
     *
     * Monolog setup:
     *
     * $logger = new Monolog\Logger('fluent.tag');
     * $fluentHandler = new Monolog\Handler\SocketHandler('unix:///var/run/td-agent/td-agent.sock');
     * $fluentHandler->setFormatter(new Monolog\Formatter\FluentdFormatter());
     * $logger->pushHandler($fluentHandler);
     *
     * @author Andrius Putna <fordnox@gmail.com>
     */
    class FluentdFormatter implements \Monolog\Formatter\FormatterInterface
    {
        /**
         * @var bool $levelTag should message level be a part of the fluentd tag
         */
        protected bool $levelTag = false;
        public function __construct(bool $levelTag = false)
        {
        }
        public function isUsingLevelsInTag(): bool
        {
        }
        public function format(\Monolog\LogRecord $record): string
        {
        }
        public function formatBatch(array $records): string
        {
        }
    }
    /**
     * Serializes a log message to GELF
     * @see http://docs.graylog.org/en/latest/pages/gelf.html
     *
     * @author Matt Lehner <mlehner@gmail.com>
     */
    class GelfMessageFormatter extends \Monolog\Formatter\NormalizerFormatter
    {
        protected const DEFAULT_MAX_LENGTH = 32766;
        /**
         * @var string the name of the system for the Gelf log message
         */
        protected string $systemName;
        /**
         * @var string a prefix for 'extra' fields from the Monolog record (optional)
         */
        protected string $extraPrefix;
        /**
         * @var string a prefix for 'context' fields from the Monolog record (optional)
         */
        protected string $contextPrefix;
        /**
         * @var int max length per field
         */
        protected int $maxLength;
        /**
         * @throws \RuntimeException
         */
        public function __construct(?string $systemName = null, ?string $extraPrefix = null, string $contextPrefix = 'ctxt_', ?int $maxLength = null)
        {
        }
        /**
         * @inheritDoc
         */
        public function format(\Monolog\LogRecord $record): \Gelf\Message
        {
        }
    }
    /**
     * Encodes whatever record data is passed to it as json
     *
     * This can be useful to log to databases or remote APIs
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    class JsonFormatter extends \Monolog\Formatter\NormalizerFormatter
    {
        public const BATCH_MODE_JSON = 1;
        public const BATCH_MODE_NEWLINES = 2;
        /** @var self::BATCH_MODE_* */
        protected int $batchMode;
        protected bool $appendNewline;
        protected bool $ignoreEmptyContextAndExtra;
        protected bool $includeStacktraces = false;
        /**
         * @param self::BATCH_MODE_* $batchMode
         */
        public function __construct(int $batchMode = self::BATCH_MODE_JSON, bool $appendNewline = true, bool $ignoreEmptyContextAndExtra = false, bool $includeStacktraces = false)
        {
        }
        /**
         * The batch mode option configures the formatting style for
         * multiple records. By default, multiple records will be
         * formatted as a JSON-encoded array. However, for
         * compatibility with some API endpoints, alternative styles
         * are available.
         */
        public function getBatchMode(): int
        {
        }
        /**
         * True if newlines are appended to every formatted record
         */
        public function isAppendingNewlines(): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function format(\Monolog\LogRecord $record): string
        {
        }
        /**
         * @inheritDoc
         */
        public function formatBatch(array $records): string
        {
        }
        /**
         * @return $this
         */
        public function includeStacktraces(bool $include = true): self
        {
        }
        /**
         * @return array<array<mixed>|bool|float|int|\stdClass|string|null>
         */
        protected function normalizeRecord(\Monolog\LogRecord $record): array
        {
        }
        /**
         * Return a JSON-encoded array of records.
         *
         * @phpstan-param LogRecord[] $records
         */
        protected function formatBatchJson(array $records): string
        {
        }
        /**
         * Use new lines to separate records instead of a
         * JSON-encoded array.
         *
         * @phpstan-param LogRecord[] $records
         */
        protected function formatBatchNewlines(array $records): string
        {
        }
        /**
         * Normalizes given $data.
         *
         * @return null|scalar|array<mixed[]|scalar|null|object>|object
         */
        protected function normalize(mixed $data, int $depth = 0): mixed
        {
        }
        /**
         * Normalizes given exception with or without its own stack trace based on
         * `includeStacktraces` property.
         *
         * @return array<array-key, string|int|array<string|int|array<string>>>
         */
        protected function normalizeException(\Throwable $e, int $depth = 0): array
        {
        }
    }
    /**
     * Encodes message information into JSON in a format compatible with Cloud logging.
     *
     * @see https://cloud.google.com/logging/docs/structured-logging
     * @see https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry
     *
     * @author Luís Cobucci <lcobucci@gmail.com>
     */
    class GoogleCloudLoggingFormatter extends \Monolog\Formatter\JsonFormatter
    {
        protected function normalizeRecord(\Monolog\LogRecord $record): array
        {
        }
    }
    /**
     * Formats incoming records into an HTML table
     *
     * This is especially useful for html email logging
     *
     * @author Tiago Brito <tlfbrito@gmail.com>
     */
    class HtmlFormatter extends \Monolog\Formatter\NormalizerFormatter
    {
        /**
         * Translates Monolog log levels to html color priorities.
         */
        protected function getLevelColor(\Monolog\Level $level): string
        {
        }
        /**
         * @param string|null $dateFormat The format of the timestamp: one supported by DateTime::format
         */
        public function __construct(?string $dateFormat = null)
        {
        }
        /**
         * Creates an HTML table row
         *
         * @param string $th       Row header content
         * @param string $td       Row standard cell content
         * @param bool   $escapeTd false if td content must not be html escaped
         */
        protected function addRow(string $th, string $td = ' ', bool $escapeTd = true): string
        {
        }
        /**
         * Create a HTML h1 tag
         *
         * @param string $title Text to be in the h1
         */
        protected function addTitle(string $title, \Monolog\Level $level): string
        {
        }
        /**
         * Formats a log record.
         *
         * @return string The formatted record
         */
        public function format(\Monolog\LogRecord $record): string
        {
        }
        /**
         * Formats a set of log records.
         *
         * @return string The formatted set of records
         */
        public function formatBatch(array $records): string
        {
        }
        /**
         * @param mixed $data
         */
        protected function convertToString($data): string
        {
        }
    }
    /**
     * Formats incoming records into a one-line string
     *
     * This is especially useful for logging to files
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     * @author Christophe Coevoet <stof@notk.org>
     */
    class LineFormatter extends \Monolog\Formatter\NormalizerFormatter
    {
        public const SIMPLE_FORMAT = "[%datetime%] %channel%.%level_name%: %message% %context% %extra%\n";
        protected string $format;
        protected bool $allowInlineLineBreaks;
        protected bool $ignoreEmptyContextAndExtra;
        protected bool $includeStacktraces;
        protected ?int $maxLevelNameLength = null;
        protected string $indentStacktraces = '';
        protected \Closure|null $stacktracesParser = null;
        protected string $basePath = '';
        /**
         * @param string|null $format                The format of the message
         * @param string|null $dateFormat            The format of the timestamp: one supported by DateTime::format
         * @param bool        $allowInlineLineBreaks Whether to allow inline line breaks in log entries
         */
        public function __construct(?string $format = null, ?string $dateFormat = null, bool $allowInlineLineBreaks = false, bool $ignoreEmptyContextAndExtra = false, bool $includeStacktraces = false)
        {
        }
        /**
         * Setting a base path will hide the base path from exception and stack trace file names to shorten them
         * @return $this
         */
        public function setBasePath(string $path = ''): self
        {
        }
        /**
         * @return $this
         */
        public function includeStacktraces(bool $include = true, ?\Closure $parser = null): self
        {
        }
        /**
         * Indent stack traces to separate them a bit from the main log record messages
         *
         * @param  string $indent The string used to indent, for example "    "
         * @return $this
         */
        public function indentStacktraces(string $indent): self
        {
        }
        /**
         * @return $this
         */
        public function allowInlineLineBreaks(bool $allow = true): self
        {
        }
        /**
         * @return $this
         */
        public function ignoreEmptyContextAndExtra(bool $ignore = true): self
        {
        }
        /**
         * Allows cutting the level name to get fixed-length levels like INF for INFO, ERR for ERROR if you set this to 3 for example
         *
         * @param  int|null $maxLevelNameLength Maximum characters for the level name. Set null for infinite length (default)
         * @return $this
         */
        public function setMaxLevelNameLength(?int $maxLevelNameLength = null): self
        {
        }
        /**
         * @inheritDoc
         */
        public function format(\Monolog\LogRecord $record): string
        {
        }
        public function formatBatch(array $records): string
        {
        }
        /**
         * @param mixed $value
         */
        public function stringify($value): string
        {
        }
        protected function normalizeException(\Throwable $e, int $depth = 0): string
        {
        }
        /**
         * @param mixed $data
         */
        protected function convertToString($data): string
        {
        }
        protected function replaceNewlines(string $str): string
        {
        }
    }
    /**
     * Encodes message information into JSON in a format compatible with Loggly.
     *
     * @author Adam Pancutt <adam@pancutt.com>
     */
    class LogglyFormatter extends \Monolog\Formatter\JsonFormatter
    {
        /**
         * Overrides the default batch mode to new lines for compatibility with the
         * Loggly bulk API.
         */
        public function __construct(int $batchMode = self::BATCH_MODE_NEWLINES, bool $appendNewline = false)
        {
        }
        /**
         * Appends the 'timestamp' parameter for indexing by Loggly.
         *
         * @see https://www.loggly.com/docs/automated-parsing/#json
         * @see \Monolog\Formatter\JsonFormatter::format()
         */
        protected function normalizeRecord(\Monolog\LogRecord $record): array
        {
        }
    }
    /**
     * Encodes message information into JSON in a format compatible with Logmatic.
     *
     * @author Julien Breux <julien.breux@gmail.com>
     */
    class LogmaticFormatter extends \Monolog\Formatter\JsonFormatter
    {
        protected const MARKERS = ["sourcecode", "php"];
        protected string $hostname = '';
        protected string $appName = '';
        /**
         * @return $this
         */
        public function setHostname(string $hostname): self
        {
        }
        /**
         * @return $this
         */
        public function setAppName(string $appName): self
        {
        }
        /**
         * Appends the 'hostname' and 'appname' parameter for indexing by Logmatic.
         *
         * @see http://doc.logmatic.io/docs/basics-to-send-data
         * @see \Monolog\Formatter\JsonFormatter::format()
         */
        public function normalizeRecord(\Monolog\LogRecord $record): array
        {
        }
    }
    /**
     * Serializes a log message to Logstash Event Format
     *
     * @see https://www.elastic.co/products/logstash
     * @see https://github.com/elastic/logstash/blob/master/logstash-core/src/main/java/org/logstash/Event.java
     *
     * @author Tim Mower <timothy.mower@gmail.com>
     */
    class LogstashFormatter extends \Monolog\Formatter\NormalizerFormatter
    {
        /**
         * @var string the name of the system for the Logstash log message, used to fill the @source field
         */
        protected string $systemName;
        /**
         * @var string an application name for the Logstash log message, used to fill the @type field
         */
        protected string $applicationName;
        /**
         * @var string the key for 'extra' fields from the Monolog record
         */
        protected string $extraKey;
        /**
         * @var string the key for 'context' fields from the Monolog record
         */
        protected string $contextKey;
        /**
         * @param string      $applicationName The application that sends the data, used as the "type" field of logstash
         * @param string|null $systemName      The system/machine name, used as the "source" field of logstash, defaults to the hostname of the machine
         * @param string      $extraKey        The key for extra keys inside logstash "fields", defaults to extra
         * @param string      $contextKey      The key for context keys inside logstash "fields", defaults to context
         */
        public function __construct(string $applicationName, ?string $systemName = null, string $extraKey = 'extra', string $contextKey = 'context')
        {
        }
        /**
         * @inheritDoc
         */
        public function format(\Monolog\LogRecord $record): string
        {
        }
    }
    /**
     * Formats a record for use with the MongoDBHandler.
     *
     * @author Florian Plattner <me@florianplattner.de>
     */
    class MongoDBFormatter implements \Monolog\Formatter\FormatterInterface
    {
        /**
         * @param int  $maxNestingLevel        0 means infinite nesting, the $record itself is level 1, $record->context is 2
         * @param bool $exceptionTraceAsString set to false to log exception traces as a sub documents instead of strings
         */
        public function __construct(int $maxNestingLevel = 3, bool $exceptionTraceAsString = true)
        {
        }
        /**
         * @inheritDoc
         *
         * @return mixed[]
         */
        public function format(\Monolog\LogRecord $record): array
        {
        }
        /**
         * @inheritDoc
         *
         * @return array<mixed[]>
         */
        public function formatBatch(array $records): array
        {
        }
        /**
         * @param  mixed[]        $array
         * @return mixed[]|string Array except when max nesting level is reached then a string "[...]"
         */
        protected function formatArray(array $array, int $nestingLevel = 0)
        {
        }
        /**
         * @param  mixed          $value
         * @return mixed[]|string
         */
        protected function formatObject($value, int $nestingLevel)
        {
        }
        /**
         * @return mixed[]|string
         */
        protected function formatException(\Throwable $exception, int $nestingLevel)
        {
        }
        protected function formatDate(\DateTimeInterface $value, int $nestingLevel): \MongoDB\BSON\UTCDateTime
        {
        }
    }
    /**
     * Formats data into an associative array of scalar (+ null) values.
     * Objects and arrays will be JSON encoded.
     *
     * @author Andrew Lawson <adlawson@gmail.com>
     */
    class ScalarFormatter extends \Monolog\Formatter\NormalizerFormatter
    {
        /**
         * @inheritDoc
         *
         * @phpstan-return array<string, scalar|null> $record
         */
        public function format(\Monolog\LogRecord $record): array
        {
        }
        protected function toScalar(mixed $value): string|int|float|bool|null
        {
        }
    }
    /**
     * Serializes a log message according to RFC 5424
     *
     * @author Dalibor Karlović <dalibor.karlovic@sigwin.hr>
     * @author Renat Gabdullin <renatobyj@gmail.com>
     */
    class SyslogFormatter extends \Monolog\Formatter\LineFormatter
    {
        public function __construct(private string $applicationName = self::NILVALUE)
        {
        }
        public function format(\Monolog\LogRecord $record): string
        {
        }
    }
    /**
     * Serializes a log message according to Wildfire's header requirements
     *
     * @author Eric Clemmons (@ericclemmons) <eric@uxdriven.com>
     * @author Christophe Coevoet <stof@notk.org>
     * @author Kirill chEbba Chebunin <iam@chebba.org>
     */
    class WildfireFormatter extends \Monolog\Formatter\NormalizerFormatter
    {
        /**
         * @param string|null $dateFormat The format of the timestamp: one supported by DateTime::format
         */
        public function __construct(?string $dateFormat = null)
        {
        }
        /**
         * @inheritDoc
         */
        public function format(\Monolog\LogRecord $record): string
        {
        }
        /**
         * @inheritDoc
         *
         * @phpstan-return never
         */
        public function formatBatch(array $records)
        {
        }
        /**
         * @inheritDoc
         *
         * @return null|scalar|array<mixed[]|scalar|null>|object
         */
        protected function normalize(mixed $data, int $depth = 0): mixed
        {
        }
    }
}
namespace Monolog\Handler {
    /**
     * Common syslog functionality
     */
    abstract class AbstractSyslogHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        protected int $facility;
        /**
         * List of valid log facility names.
         * @var array<string, int>
         */
        protected array $facilities = ['auth' => \LOG_AUTH, 'authpriv' => \LOG_AUTHPRIV, 'cron' => \LOG_CRON, 'daemon' => \LOG_DAEMON, 'kern' => \LOG_KERN, 'lpr' => \LOG_LPR, 'mail' => \LOG_MAIL, 'news' => \LOG_NEWS, 'syslog' => \LOG_SYSLOG, 'user' => \LOG_USER, 'uucp' => \LOG_UUCP];
        /**
         * Translates Monolog log levels to syslog log priorities.
         */
        protected function toSyslogPriority(\Monolog\Level $level): int
        {
        }
        /**
         * @param string|int $facility Either one of the names of the keys in $this->facilities, or a LOG_* facility constant
         */
        public function __construct(string|int $facility = \LOG_USER, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        /**
         * @inheritDoc
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    class AmqpHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        protected \AMQPExchange|\PhpAmqpLib\Channel\AMQPChannel $exchange;
        protected string $exchangeName;
        /**
         * @param AMQPExchange|AMQPChannel $exchange     AMQPExchange (php AMQP ext) or PHP AMQP lib channel, ready for use
         * @param string|null              $exchangeName Optional exchange name, for AMQPChannel (PhpAmqpLib) only
         */
        public function __construct(\AMQPExchange|\PhpAmqpLib\Channel\AMQPChannel $exchange, ?string $exchangeName = null, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        /**
         * @return array<string, mixed>
         */
        public function getExtraAttributes(): array
        {
        }
        /**
         * Configure extra attributes to pass to the AMQPExchange (if you are using the amqp extension)
         *
         * @param  array<string, mixed> $extraAttributes One of content_type, content_encoding,
         *                                               message_id, user_id, app_id, delivery_mode,
         *                                               priority, timestamp, expiration, type
         *                                               or reply_to, headers.
         * @return $this
         */
        public function setExtraAttributes(array $extraAttributes): self
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * @inheritDoc
         */
        public function handleBatch(array $records): void
        {
        }
        /**
         * Gets the routing key for the AMQP exchange
         */
        protected function getRoutingKey(\Monolog\LogRecord $record): string
        {
        }
        /**
         * @inheritDoc
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * Handler sending logs to browser's javascript console with no browser extension required
     *
     * @author Olivier Poitrey <rs@dailymotion.com>
     */
    class BrowserConsoleHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        protected static bool $initialized = false;
        /** @var LogRecord[] */
        protected static array $records = [];
        protected const FORMAT_HTML = 'html';
        protected const FORMAT_JS = 'js';
        protected const FORMAT_UNKNOWN = 'unknown';
        /**
         * @inheritDoc
         *
         * Formatted output may contain some formatting markers to be transferred to `console.log` using the %c format.
         *
         * Example of formatted string:
         *
         *     You can do [[blue text]]{color: blue} or [[green background]]{background-color: green; color: white}
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * Convert records to javascript console commands and send it to the browser.
         * This method is automatically called on PHP shutdown if output is HTML or Javascript.
         */
        public static function send(): void
        {
        }
        public function close(): void
        {
        }
        public function reset(): void
        {
        }
        /**
         * Forget all logged records
         */
        public static function resetStatic(): void
        {
        }
        /**
         * Wrapper for register_shutdown_function to allow overriding
         */
        protected function registerShutdownFunction(): void
        {
        }
        /**
         * Wrapper for echo to allow overriding
         */
        protected static function writeOutput(string $str): void
        {
        }
        /**
         * Checks the format of the response
         *
         * If Content-Type is set to application/javascript or text/javascript -> js
         * If Content-Type is set to text/html, or is unset -> html
         * If Content-Type is anything else -> unknown
         *
         * @return string One of 'js', 'html' or 'unknown'
         * @phpstan-return self::FORMAT_*
         */
        protected static function getResponseFormat(): string
        {
        }
        /**
         * @return string One of 'js', 'html' or 'unknown'
         * @phpstan-return self::FORMAT_*
         */
        protected static function getResponseFormatFromContentType(string $contentType): string
        {
        }
    }
    /**
     * Buffers all records until closing the handler and then pass them as batch.
     *
     * This is useful for a MailHandler to send only one mail per request instead of
     * sending one per log message.
     *
     * @author Christophe Coevoet <stof@notk.org>
     */
    class BufferHandler extends \Monolog\Handler\AbstractHandler implements \Monolog\Handler\ProcessableHandlerInterface, \Monolog\Handler\FormattableHandlerInterface
    {
        use \Monolog\Handler\ProcessableHandlerTrait;
        protected \Monolog\Handler\HandlerInterface $handler;
        protected int $bufferSize = 0;
        protected int $bufferLimit;
        protected bool $flushOnOverflow;
        /** @var LogRecord[] */
        protected array $buffer = [];
        protected bool $initialized = false;
        /**
         * @param HandlerInterface $handler         Handler.
         * @param int              $bufferLimit     How many entries should be buffered at most, beyond that the oldest items are removed from the buffer.
         * @param bool             $flushOnOverflow If true, the buffer is flushed when the max size has been reached, by default oldest entries are discarded
         */
        public function __construct(\Monolog\Handler\HandlerInterface $handler, int $bufferLimit = 0, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true, bool $flushOnOverflow = false)
        {
        }
        /**
         * @inheritDoc
         */
        public function handle(\Monolog\LogRecord $record): bool
        {
        }
        public function flush(): void
        {
        }
        public function __destruct()
        {
        }
        /**
         * @inheritDoc
         */
        public function close(): void
        {
        }
        /**
         * Clears the buffer without flushing any messages down to the wrapped handler.
         */
        public function clear(): void
        {
        }
        public function reset(): void
        {
        }
        /**
         * @inheritDoc
         */
        public function setFormatter(\Monolog\Formatter\FormatterInterface $formatter): \Monolog\Handler\HandlerInterface
        {
        }
        /**
         * @inheritDoc
         */
        public function getFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    trait WebRequestRecognizerTrait
    {
        /**
         * Checks if PHP's serving a web request
         */
        protected function isWebRequest(): bool
        {
        }
    }
    /**
     * Handler sending logs to the ChromePHP extension (http://www.chromephp.com/)
     *
     * This also works out of the box with Firefox 43+
     *
     * @author Christophe Coevoet <stof@notk.org>
     */
    class ChromePHPHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        use \Monolog\Handler\WebRequestRecognizerTrait;
        /**
         * Version of the extension
         */
        protected const VERSION = '4.0';
        /**
         * Header name
         */
        protected const HEADER_NAME = 'X-ChromeLogger-Data';
        /**
         * Regular expression to detect supported browsers (matches any Chrome, or Firefox 43+)
         */
        protected const USER_AGENT_REGEX = '{\b(?:Chrome/\d+(?:\.\d+)*|HeadlessChrome|Firefox/(?:4[3-9]|[5-9]\d|\d{3,})(?:\.\d)*)\b}';
        protected static bool $initialized = false;
        /**
         * Tracks whether we sent too much data
         *
         * Chrome limits the headers to 4KB, so when we sent 3KB we stop sending
         */
        protected static bool $overflowed = false;
        /** @var mixed[] */
        protected static array $json = ['version' => self::VERSION, 'columns' => ['label', 'log', 'backtrace', 'type'], 'rows' => []];
        protected static bool $sendHeaders = true;
        public function __construct(int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        /**
         * @inheritDoc
         */
        public function handleBatch(array $records): void
        {
        }
        /**
         * @inheritDoc
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
        /**
         * Creates & sends header for a record
         *
         * @see sendHeader()
         * @see send()
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * Sends the log header
         *
         * @see sendHeader()
         */
        protected function send(): void
        {
        }
        /**
         * Send header string to the client
         */
        protected function sendHeader(string $header, string $content): void
        {
        }
        /**
         * Verifies if the headers are accepted by the current user agent
         */
        protected function headersAccepted(): bool
        {
        }
    }
    /**
     * CouchDB handler
     *
     * @author Markus Bachmann <markus.bachmann@bachi.biz>
     * @phpstan-type Options array{
     *     host: string,
     *     port: int,
     *     dbname: string,
     *     username: string|null,
     *     password: string|null
     * }
     * @phpstan-type InputOptions array{
     *     host?: string,
     *     port?: int,
     *     dbname?: string,
     *     username?: string|null,
     *     password?: string|null
     * }
     */
    class CouchDBHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        /**
         * @param mixed[] $options
         *
         * @phpstan-param InputOptions $options
         */
        public function __construct(array $options = [], int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * @inheritDoc
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * Logs to Cube.
     *
     * @link https://github.com/square/cube/wiki
     * @author Wan Chen <kami@kamisama.me>
     * @deprecated Since 2.8.0 and 3.2.0, Cube appears abandoned and thus we will drop this handler in Monolog 4
     */
    class CubeHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        /**
         * Create a Cube handler
         *
         * @throws \UnexpectedValueException when given url is not a valid url.
         *                                   A valid url must consist of three parts : protocol://host:port
         *                                   Only valid protocols used by Cube are http and udp
         */
        public function __construct(string $url, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        /**
         * Establish a connection to an UDP socket
         *
         * @throws \LogicException           when unable to connect to the socket
         * @throws MissingExtensionException when there is no socket extension
         */
        protected function connectUdp(): void
        {
        }
        /**
         * Establish a connection to an http server
         *
         * @throws \LogicException           when unable to connect to the socket
         * @throws MissingExtensionException when no curl extension
         */
        protected function connectHttp(): void
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
    }
}
namespace Monolog\Handler\Curl {
    /**
     * This class is marked as internal and it is not under the BC promise of the package.
     *
     * @internal
     */
    final class Util
    {
        /**
         * Executes a CURL request with optional retries and exception on failure
         *
         * @param  CurlHandle  $ch curl handler
         * @return bool|string @see curl_exec
         */
        public static function execute(\CurlHandle $ch, int $retries = 5, bool $closeAfterDone = true)
        {
        }
    }
}
namespace Monolog\Handler {
    /**
     * Simple handler wrapper that deduplicates log records across multiple requests
     *
     * It also includes the BufferHandler functionality and will buffer
     * all messages until the end of the request or flush() is called.
     *
     * This works by storing all log records' messages above $deduplicationLevel
     * to the file specified by $deduplicationStore. When further logs come in at the end of the
     * request (or when flush() is called), all those above $deduplicationLevel are checked
     * against the existing stored logs. If they match and the timestamps in the stored log is
     * not older than $time seconds, the new log record is discarded. If no log record is new, the
     * whole data set is discarded.
     *
     * This is mainly useful in combination with Mail handlers or things like Slack or HipChat handlers
     * that send messages to people, to avoid spamming with the same message over and over in case of
     * a major component failure like a database server being down which makes all requests fail in the
     * same way.
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    class DeduplicationHandler extends \Monolog\Handler\BufferHandler
    {
        protected string $deduplicationStore;
        protected \Monolog\Level $deduplicationLevel;
        protected int $time;
        protected bool $gc = false;
        /**
         * @param HandlerInterface             $handler            Handler.
         * @param string|null                  $deduplicationStore The file/path where the deduplication log should be kept
         * @param int|string|Level|LogLevel::* $deduplicationLevel The minimum logging level for log records to be looked at for deduplication purposes
         * @param int                          $time               The period (in seconds) during which duplicate entries should be suppressed after a given log is sent through
         * @param bool                         $bubble             Whether the messages that are handled can bubble up the stack or not
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $deduplicationLevel
         */
        public function __construct(\Monolog\Handler\HandlerInterface $handler, ?string $deduplicationStore = null, int|string|\Monolog\Level $deduplicationLevel = \Monolog\Level::Error, int $time = 60, bool $bubble = true)
        {
        }
        public function flush(): void
        {
        }
        /**
         * If there is a store entry older than e.g. a day, this method should set `$this->gc` to `true` to trigger garbage collection.
         * @param string[] $store The deduplication store
         */
        protected function isDuplicate(array $store, \Monolog\LogRecord $record): bool
        {
        }
        /**
         * @return string The given record serialized as a single line of text
         */
        protected function buildDeduplicationStoreEntry(\Monolog\LogRecord $record): string
        {
        }
    }
    /**
     * CouchDB handler for Doctrine CouchDB ODM
     *
     * @author Markus Bachmann <markus.bachmann@bachi.biz>
     */
    class DoctrineCouchDBHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        public function __construct(\Doctrine\CouchDB\CouchDBClient $client, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * Amazon DynamoDB handler (http://aws.amazon.com/dynamodb/)
     *
     * @link https://github.com/aws/aws-sdk-php/
     * @author Andrew Lawson <adlawson@gmail.com>
     */
    class DynamoDbHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        public const DATE_FORMAT = 'Y-m-d\TH:i:s.uO';
        protected \Aws\DynamoDb\DynamoDbClient $client;
        protected string $table;
        protected \Aws\DynamoDb\Marshaler $marshaler;
        public function __construct(\Aws\DynamoDb\DynamoDbClient $client, string $table, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * @param  mixed[] $record
         * @return mixed[]
         */
        protected function filterEmptyFields(array $record): array
        {
        }
        /**
         * @inheritDoc
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * Elastic Search handler
     *
     * Usage example:
     *
     *    $client = new \Elastica\Client();
     *    $options = array(
     *        'index' => 'elastic_index_name',
     *        'type' => 'elastic_doc_type', Types have been removed in Elastica 7
     *    );
     *    $handler = new ElasticaHandler($client, $options);
     *    $log = new Logger('application');
     *    $log->pushHandler($handler);
     *
     * @author Jelle Vink <jelle.vink@gmail.com>
     * @phpstan-type Options array{
     *     index: string,
     *     type: string,
     *     ignore_error: bool
     * }
     * @phpstan-type InputOptions array{
     *     index?: string,
     *     type?: string,
     *     ignore_error?: bool
     * }
     */
    class ElasticaHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        protected \Elastica\Client $client;
        /**
         * @var mixed[] Handler config options
         * @phpstan-var Options
         */
        protected array $options;
        /**
         * @param Client  $client  Elastica Client object
         * @param mixed[] $options Handler configuration
         *
         * @phpstan-param InputOptions $options
         */
        public function __construct(\Elastica\Client $client, array $options = [], int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * @inheritDoc
         */
        public function setFormatter(\Monolog\Formatter\FormatterInterface $formatter): \Monolog\Handler\HandlerInterface
        {
        }
        /**
         * @return mixed[]
         *
         * @phpstan-return Options
         */
        public function getOptions(): array
        {
        }
        /**
         * @inheritDoc
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
        /**
         * @inheritDoc
         */
        public function handleBatch(array $records): void
        {
        }
        /**
         * Use Elasticsearch bulk API to send list of documents
         *
         * @param Document[] $documents
         *
         * @throws \RuntimeException
         */
        protected function bulkSend(array $documents): void
        {
        }
    }
    /**
     * Elasticsearch handler
     *
     * @link https://www.elastic.co/guide/en/elasticsearch/client/php-api/current/index.html
     *
     * Simple usage example:
     *
     *    $client = \Elasticsearch\ClientBuilder::create()
     *        ->setHosts($hosts)
     *        ->build();
     *
     *    $options = array(
     *        'index' => 'elastic_index_name',
     *        'type'  => 'elastic_doc_type',
     *    );
     *    $handler = new ElasticsearchHandler($client, $options);
     *    $log = new Logger('application');
     *    $log->pushHandler($handler);
     *
     * @author Avtandil Kikabidze <akalongman@gmail.com>
     * @phpstan-type Options array{
     *     index: string,
     *     type: string,
     *     ignore_error: bool,
     *     op_type: 'index'|'create'
     * }
     * @phpstan-type InputOptions array{
     *     index?: string,
     *     type?: string,
     *     ignore_error?: bool,
     *     op_type?: 'index'|'create'
     * }
     */
    class ElasticsearchHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        protected \Elasticsearch\Client|\Elastic\Elasticsearch\Client $client;
        /**
         * @var mixed[] Handler config options
         * @phpstan-var Options
         */
        protected array $options;
        /**
         * @param Client|Client8 $client  Elasticsearch Client object
         * @param mixed[]        $options Handler configuration
         *
         * @phpstan-param InputOptions $options
         */
        public function __construct(\Elasticsearch\Client|\Elastic\Elasticsearch\Client $client, array $options = [], int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * @inheritDoc
         */
        public function setFormatter(\Monolog\Formatter\FormatterInterface $formatter): \Monolog\Handler\HandlerInterface
        {
        }
        /**
         * Getter options
         *
         * @return mixed[]
         *
         * @phpstan-return Options
         */
        public function getOptions(): array
        {
        }
        /**
         * @inheritDoc
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
        /**
         * @inheritDoc
         */
        public function handleBatch(array $records): void
        {
        }
        /**
         * Use Elasticsearch bulk API to send list of documents
         *
         * @param  array<array<mixed>> $records Records + _index/_type keys
         * @throws \RuntimeException
         */
        protected function bulkSend(array $records): void
        {
        }
        /**
         * Creates elasticsearch exception from responses array
         *
         * Only the first error is converted into an exception.
         *
         * @param mixed[]|Elasticsearch $responses returned by $this->client->bulk()
         */
        protected function createExceptionFromResponses($responses): \Throwable
        {
        }
        /**
         * Creates elasticsearch exception from error array
         *
         * @param mixed[] $error
         */
        protected function createExceptionFromError(array $error): \Throwable
        {
        }
    }
    /**
     * Stores to PHP error_log() handler.
     *
     * @author Elan Ruusamäe <glen@delfi.ee>
     */
    class ErrorLogHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        public const OPERATING_SYSTEM = 0;
        public const SAPI = 4;
        /** @var 0|1|3|4 */
        protected int $messageType;
        protected bool $expandNewlines;
        /**
         * @param 0|1|3|4 $messageType    Says where the error should go.
         * @param bool $expandNewlines If set to true, newlines in the message will be expanded to be take multiple log entries
         *
         * @throws \InvalidArgumentException If an unsupported message type is set
         */
        public function __construct(int $messageType = self::OPERATING_SYSTEM, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true, bool $expandNewlines = false)
        {
        }
        /**
         * @return int[] With all available types
         */
        public static function getAvailableTypes(): array
        {
        }
        /**
         * @inheritDoc
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
    }
    /**
     * Forwards records to multiple handlers
     *
     * @author Lenar Lõhmus <lenar@city.ee>
     */
    class GroupHandler extends \Monolog\Handler\Handler implements \Monolog\Handler\ProcessableHandlerInterface, \Monolog\ResettableInterface
    {
        use \Monolog\Handler\ProcessableHandlerTrait;
        /** @var HandlerInterface[] */
        protected array $handlers;
        protected bool $bubble;
        /**
         * @param HandlerInterface[] $handlers Array of Handlers.
         * @param bool               $bubble   Whether the messages that are handled can bubble up the stack or not
         *
         * @throws \InvalidArgumentException if an unsupported handler is set
         */
        public function __construct(array $handlers, bool $bubble = true)
        {
        }
        /**
         * @inheritDoc
         */
        public function isHandling(\Monolog\LogRecord $record): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function handle(\Monolog\LogRecord $record): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function handleBatch(array $records): void
        {
        }
        public function reset(): void
        {
        }
        public function close(): void
        {
        }
        /**
         * @inheritDoc
         */
        public function setFormatter(\Monolog\Formatter\FormatterInterface $formatter): \Monolog\Handler\HandlerInterface
        {
        }
    }
    /**
     * Forwards records to at most one handler
     *
     * If a handler fails, the exception is suppressed and the record is forwarded to the next handler.
     *
     * As soon as one handler handles a record successfully, the handling stops there.
     */
    class FallbackGroupHandler extends \Monolog\Handler\GroupHandler
    {
        /**
         * @inheritDoc
         */
        public function handle(\Monolog\LogRecord $record): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function handleBatch(array $records): void
        {
        }
    }
    /**
     * Simple handler wrapper that filters records based on a list of levels
     *
     * It can be configured with an exact list of levels to allow, or a min/max level.
     *
     * @author Hennadiy Verkh
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    class FilterHandler extends \Monolog\Handler\Handler implements \Monolog\Handler\ProcessableHandlerInterface, \Monolog\ResettableInterface, \Monolog\Handler\FormattableHandlerInterface
    {
        use \Monolog\Handler\ProcessableHandlerTrait;
        /**
         * Handler or factory Closure($record, $this)
         *
         * @phpstan-var (Closure(LogRecord|null, HandlerInterface): HandlerInterface)|HandlerInterface
         */
        protected \Closure|\Monolog\Handler\HandlerInterface $handler;
        /**
         * Minimum level for logs that are passed to handler
         *
         * @var bool[] Map of Level value => true
         * @phpstan-var array<value-of<Level::VALUES>, true>
         */
        protected array $acceptedLevels;
        /**
         * Whether the messages that are handled can bubble up the stack or not
         */
        protected bool $bubble;
        /**
         * @phpstan-param (Closure(LogRecord|null, HandlerInterface): HandlerInterface)|HandlerInterface $handler
         *
         * @param Closure|HandlerInterface                             $handler        Handler or factory Closure($record|null, $filterHandler).
         * @param int|string|Level|array<int|string|Level|LogLevel::*> $minLevelOrList A list of levels to accept or a minimum level if maxLevel is provided
         * @param int|string|Level|LogLevel::*                         $maxLevel       Maximum level to accept, only used if $minLevelOrList is not an array
         * @param bool                                                 $bubble         Whether the messages that are handled can bubble up the stack or not
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::*|array<value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::*> $minLevelOrList
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $maxLevel
         */
        public function __construct(\Closure|\Monolog\Handler\HandlerInterface $handler, int|string|\Monolog\Level|array $minLevelOrList = \Monolog\Level::Debug, int|string|\Monolog\Level $maxLevel = \Monolog\Level::Emergency, bool $bubble = true)
        {
        }
        /**
         * @phpstan-return list<Level> List of levels
         */
        public function getAcceptedLevels(): array
        {
        }
        /**
         * @param  int|string|Level|LogLevel::*|array<int|string|Level|LogLevel::*> $minLevelOrList A list of levels to accept or a minimum level or level name if maxLevel is provided
         * @param  int|string|Level|LogLevel::*                                     $maxLevel       Maximum level or level name to accept, only used if $minLevelOrList is not an array
         * @return $this
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::*|array<value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::*> $minLevelOrList
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $maxLevel
         */
        public function setAcceptedLevels(int|string|\Monolog\Level|array $minLevelOrList = \Monolog\Level::Debug, int|string|\Monolog\Level $maxLevel = \Monolog\Level::Emergency): self
        {
        }
        /**
         * @inheritDoc
         */
        public function isHandling(\Monolog\LogRecord $record): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function handle(\Monolog\LogRecord $record): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function handleBatch(array $records): void
        {
        }
        /**
         * Return the nested handler
         *
         * If the handler was provided as a factory, this will trigger the handler's instantiation.
         */
        public function getHandler(\Monolog\LogRecord|null $record = null): \Monolog\Handler\HandlerInterface
        {
        }
        /**
         * @inheritDoc
         */
        public function setFormatter(\Monolog\Formatter\FormatterInterface $formatter): \Monolog\Handler\HandlerInterface
        {
        }
        /**
         * @inheritDoc
         */
        public function getFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
        public function reset(): void
        {
        }
    }
}
namespace Monolog\Handler\FingersCrossed {
    /**
     * Interface for activation strategies for the FingersCrossedHandler.
     *
     * @author Johannes M. Schmitt <schmittjoh@gmail.com>
     */
    interface ActivationStrategyInterface
    {
        /**
         * Returns whether the given record activates the handler.
         */
        public function isHandlerActivated(\Monolog\LogRecord $record): bool;
    }
    /**
     * Channel and Error level based monolog activation strategy. Allows to trigger activation
     * based on level per channel. e.g. trigger activation on level 'ERROR' by default, except
     * for records of the 'sql' channel; those should trigger activation on level 'WARN'.
     *
     * Example:
     *
     * <code>
     *   $activationStrategy = new ChannelLevelActivationStrategy(
     *       Level::Critical,
     *       array(
     *           'request' => Level::Alert,
     *           'sensitive' => Level::Error,
     *       )
     *   );
     *   $handler = new FingersCrossedHandler(new StreamHandler('php://stderr'), $activationStrategy);
     * </code>
     *
     * @author Mike Meessen <netmikey@gmail.com>
     */
    class ChannelLevelActivationStrategy implements \Monolog\Handler\FingersCrossed\ActivationStrategyInterface
    {
        /**
         * @param int|string|Level|LogLevel::*                $defaultActionLevel   The default action level to be used if the record's category doesn't match any
         * @param array<string, int|string|Level|LogLevel::*> $channelToActionLevel An array that maps channel names to action levels.
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $defaultActionLevel
         * @phpstan-param array<string, value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::*> $channelToActionLevel
         */
        public function __construct(int|string|\Monolog\Level $defaultActionLevel, array $channelToActionLevel = [])
        {
        }
        public function isHandlerActivated(\Monolog\LogRecord $record): bool
        {
        }
    }
    /**
     * Error level based activation strategy.
     *
     * @author Johannes M. Schmitt <schmittjoh@gmail.com>
     */
    class ErrorLevelActivationStrategy implements \Monolog\Handler\FingersCrossed\ActivationStrategyInterface
    {
        /**
         * @param int|string|Level $actionLevel Level or name or value
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $actionLevel
         */
        public function __construct(int|string|\Monolog\Level $actionLevel)
        {
        }
        public function isHandlerActivated(\Monolog\LogRecord $record): bool
        {
        }
    }
}
namespace Monolog\Handler {
    /**
     * Buffers all records until a certain level is reached
     *
     * The advantage of this approach is that you don't get any clutter in your log files.
     * Only requests which actually trigger an error (or whatever your actionLevel is) will be
     * in the logs, but they will contain all records, not only those above the level threshold.
     *
     * You can then have a passthruLevel as well which means that at the end of the request,
     * even if it did not get activated, it will still send through log records of e.g. at least a
     * warning level.
     *
     * You can find the various activation strategies in the
     * Monolog\Handler\FingersCrossed\ namespace.
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    class FingersCrossedHandler extends \Monolog\Handler\Handler implements \Monolog\Handler\ProcessableHandlerInterface, \Monolog\ResettableInterface, \Monolog\Handler\FormattableHandlerInterface
    {
        use \Monolog\Handler\ProcessableHandlerTrait;
        /**
         * Handler or factory Closure($record, $this)
         *
         * @phpstan-var (Closure(LogRecord|null, HandlerInterface): HandlerInterface)|HandlerInterface
         */
        protected \Closure|\Monolog\Handler\HandlerInterface $handler;
        protected \Monolog\Handler\FingersCrossed\ActivationStrategyInterface $activationStrategy;
        protected bool $buffering = true;
        protected int $bufferSize;
        /** @var LogRecord[] */
        protected array $buffer = [];
        protected bool $stopBuffering;
        protected \Monolog\Level|null $passthruLevel = null;
        protected bool $bubble;
        /**
         * @phpstan-param (Closure(LogRecord|null, HandlerInterface): HandlerInterface)|HandlerInterface $handler
         *
         * @param Closure|HandlerInterface          $handler            Handler or factory Closure($record|null, $fingersCrossedHandler).
         * @param int|string|Level|LogLevel::*|null $activationStrategy Strategy which determines when this handler takes action, or a level name/value at which the handler is activated
         * @param int                               $bufferSize         How many entries should be buffered at most, beyond that the oldest items are removed from the buffer.
         * @param bool                              $bubble             Whether the messages that are handled can bubble up the stack or not
         * @param bool                              $stopBuffering      Whether the handler should stop buffering after being triggered (default true)
         * @param int|string|Level|LogLevel::*|null $passthruLevel      Minimum level to always flush to handler on close, even if strategy not triggered
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::*|ActivationStrategyInterface|null $activationStrategy
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::*|null $passthruLevel
         */
        public function __construct(\Closure|\Monolog\Handler\HandlerInterface $handler, int|string|\Monolog\Level|\Monolog\Handler\FingersCrossed\ActivationStrategyInterface|null $activationStrategy = null, int $bufferSize = 0, bool $bubble = true, bool $stopBuffering = true, int|string|\Monolog\Level|null $passthruLevel = null)
        {
        }
        /**
         * @inheritDoc
         */
        public function isHandling(\Monolog\LogRecord $record): bool
        {
        }
        /**
         * Manually activate this logger regardless of the activation strategy
         */
        public function activate(): void
        {
        }
        /**
         * @inheritDoc
         */
        public function handle(\Monolog\LogRecord $record): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function close(): void
        {
        }
        public function reset(): void
        {
        }
        /**
         * Clears the buffer without flushing any messages down to the wrapped handler.
         *
         * It also resets the handler to its initial buffering state.
         */
        public function clear(): void
        {
        }
        /**
         * Return the nested handler
         *
         * If the handler was provided as a factory, this will trigger the handler's instantiation.
         */
        public function getHandler(\Monolog\LogRecord|null $record = null): \Monolog\Handler\HandlerInterface
        {
        }
        /**
         * @inheritDoc
         */
        public function setFormatter(\Monolog\Formatter\FormatterInterface $formatter): \Monolog\Handler\HandlerInterface
        {
        }
        /**
         * @inheritDoc
         */
        public function getFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * Simple FirePHP Handler (http://www.firephp.org/), which uses the Wildfire protocol.
     *
     * @author Eric Clemmons (@ericclemmons) <eric@uxdriven.com>
     */
    class FirePHPHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        use \Monolog\Handler\WebRequestRecognizerTrait;
        /**
         * WildFire JSON header message format
         */
        protected const PROTOCOL_URI = 'http://meta.wildfirehq.org/Protocol/JsonStream/0.2';
        /**
         * FirePHP structure for parsing messages & their presentation
         */
        protected const STRUCTURE_URI = 'http://meta.firephp.org/Wildfire/Structure/FirePHP/FirebugConsole/0.1';
        /**
         * Must reference a "known" plugin, otherwise headers won't display in FirePHP
         */
        protected const PLUGIN_URI = 'http://meta.firephp.org/Wildfire/Plugin/FirePHP/Library-FirePHPCore/0.3';
        /**
         * Header prefix for Wildfire to recognize & parse headers
         */
        protected const HEADER_PREFIX = 'X-Wf';
        /**
         * Whether or not Wildfire vendor-specific headers have been generated & sent yet
         */
        protected static bool $initialized = false;
        /**
         * Shared static message index between potentially multiple handlers
         */
        protected static int $messageIndex = 1;
        protected static bool $sendHeaders = true;
        /**
         * Base header creation function used by init headers & record headers
         *
         * @param array<int|string> $meta    Wildfire Plugin, Protocol & Structure Indexes
         * @param string            $message Log message
         *
         * @return array<string, string> Complete header string ready for the client as key and message as value
         *
         * @phpstan-return non-empty-array<string, string>
         */
        protected function createHeader(array $meta, string $message): array
        {
        }
        /**
         * Creates message header from record
         *
         * @return array<string, string>
         *
         * @phpstan-return non-empty-array<string, string>
         *
         * @see createHeader()
         */
        protected function createRecordHeader(\Monolog\LogRecord $record): array
        {
        }
        /**
         * @inheritDoc
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
        /**
         * Wildfire initialization headers to enable message parsing
         *
         * @see createHeader()
         * @see sendHeader()
         *
         * @return array<string, string>
         */
        protected function getInitHeaders(): array
        {
        }
        /**
         * Send header string to the client
         */
        protected function sendHeader(string $header, string $content): void
        {
        }
        /**
         * Creates & sends header for a record, ensuring init headers have been sent prior
         *
         * @see sendHeader()
         * @see sendInitHeaders()
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * Verifies if the headers are accepted by the current user agent
         */
        protected function headersAccepted(): bool
        {
        }
    }
    /**
     * Stores to any socket - uses fsockopen() or pfsockopen().
     *
     * @author Pablo de Leon Belloc <pablolb@gmail.com>
     * @see    http://php.net/manual/en/function.fsockopen.php
     */
    class SocketHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        /**
         * @param string     $connectionString  Socket connection string
         * @param bool       $persistent        Flag to enable/disable persistent connections
         * @param float      $timeout           Socket timeout to wait until the request is being aborted
         * @param float      $writingTimeout    Socket timeout to wait until the request should've been sent/written
         * @param float|null $connectionTimeout Socket connect timeout to wait until the connection should've been
         *                                      established
         * @param int|null   $chunkSize         Sets the chunk size. Only has effect during connection in the writing cycle
         *
         * @throws \InvalidArgumentException If an invalid timeout value (less than 0) is passed.
         */
        public function __construct(string $connectionString, $level = \Monolog\Level::Debug, bool $bubble = true, bool $persistent = false, float $timeout = 0.0, float $writingTimeout = 10.0, ?float $connectionTimeout = null, ?int $chunkSize = null)
        {
        }
        /**
         * Connect (if necessary) and write to the socket
         *
         * @inheritDoc
         *
         * @throws \UnexpectedValueException
         * @throws \RuntimeException
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * We will not close a PersistentSocket instance so it can be reused in other requests.
         */
        public function close(): void
        {
        }
        /**
         * Close socket, if open
         */
        public function closeSocket(): void
        {
        }
        /**
         * Set socket connection to be persistent. It only has effect before the connection is initiated.
         *
         * @return $this
         */
        public function setPersistent(bool $persistent): self
        {
        }
        /**
         * Set connection timeout.  Only has effect before we connect.
         *
         * @see http://php.net/manual/en/function.fsockopen.php
         * @return $this
         */
        public function setConnectionTimeout(float $seconds): self
        {
        }
        /**
         * Set write timeout. Only has effect before we connect.
         *
         * @see http://php.net/manual/en/function.stream-set-timeout.php
         * @return $this
         */
        public function setTimeout(float $seconds): self
        {
        }
        /**
         * Set writing timeout. Only has effect during connection in the writing cycle.
         *
         * @param  float $seconds 0 for no timeout
         * @return $this
         */
        public function setWritingTimeout(float $seconds): self
        {
        }
        /**
         * Set chunk size. Only has effect during connection in the writing cycle.
         *
         * @return $this
         */
        public function setChunkSize(int $bytes): self
        {
        }
        /**
         * Get current connection string
         */
        public function getConnectionString(): string
        {
        }
        /**
         * Get persistent setting
         */
        public function isPersistent(): bool
        {
        }
        /**
         * Get current connection timeout setting
         */
        public function getConnectionTimeout(): float
        {
        }
        /**
         * Get current in-transfer timeout
         */
        public function getTimeout(): float
        {
        }
        /**
         * Get current local writing timeout
         */
        public function getWritingTimeout(): float
        {
        }
        /**
         * Get current chunk size
         */
        public function getChunkSize(): ?int
        {
        }
        /**
         * Check to see if the socket is currently available.
         *
         * UDP might appear to be connected but might fail when writing.  See http://php.net/fsockopen for details.
         */
        public function isConnected(): bool
        {
        }
        /**
         * Wrapper to allow mocking
         *
         * @return resource|false
         */
        protected function pfsockopen()
        {
        }
        /**
         * Wrapper to allow mocking
         *
         * @return resource|false
         */
        protected function fsockopen()
        {
        }
        /**
         * Wrapper to allow mocking
         *
         * @see http://php.net/manual/en/function.stream-set-timeout.php
         */
        protected function streamSetTimeout(): bool
        {
        }
        /**
         * Wrapper to allow mocking
         *
         * @see http://php.net/manual/en/function.stream-set-chunk-size.php
         *
         * @return int|false
         */
        protected function streamSetChunkSize(): int|bool
        {
        }
        /**
         * Wrapper to allow mocking
         *
         * @return int|false
         */
        protected function fwrite(string $data): int|bool
        {
        }
        /**
         * Wrapper to allow mocking
         *
         * @return mixed[]|bool
         */
        protected function streamGetMetadata(): array|bool
        {
        }
        protected function generateDataStream(\Monolog\LogRecord $record): string
        {
        }
        /**
         * @return resource|null
         */
        protected function getResource()
        {
        }
    }
    /**
     * Sends logs to Fleep.io using Webhook integrations
     *
     * You'll need a Fleep.io account to use this handler.
     *
     * @see https://fleep.io/integrations/webhooks/ Fleep Webhooks Documentation
     * @author Ando Roots <ando@sqroot.eu>
     */
    class FleepHookHandler extends \Monolog\Handler\SocketHandler
    {
        protected const FLEEP_HOST = 'fleep.io';
        protected const FLEEP_HOOK_URI = '/hook/';
        /**
         * @var string Webhook token (specifies the conversation where logs are sent)
         */
        protected string $token;
        /**
         * Construct a new Fleep.io Handler.
         *
         * For instructions on how to create a new web hook in your conversations
         * see https://fleep.io/integrations/webhooks/
         *
         * @param  string                    $token Webhook token
         * @throws MissingExtensionException if OpenSSL is missing
         */
        public function __construct(string $token, $level = \Monolog\Level::Debug, bool $bubble = true, bool $persistent = false, float $timeout = 0.0, float $writingTimeout = 10.0, ?float $connectionTimeout = null, ?int $chunkSize = null)
        {
        }
        /**
         * Returns the default formatter to use with this handler
         *
         * Overloaded to remove empty context and extra arrays from the end of the log message.
         *
         * @return LineFormatter
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
        /**
         * Handles a log record
         */
        public function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * @inheritDoc
         */
        protected function generateDataStream(\Monolog\LogRecord $record): string
        {
        }
    }
    /**
     * Sends notifications through the Flowdock push API
     *
     * This must be configured with a FlowdockFormatter instance via setFormatter()
     *
     * Notes:
     * API token - Flowdock API token
     *
     * @author Dominik Liebler <liebler.dominik@gmail.com>
     * @see https://www.flowdock.com/api/push
     * @deprecated Since 2.9.0 and 3.3.0, Flowdock was shutdown we will thus drop this handler in Monolog 4
     */
    class FlowdockHandler extends \Monolog\Handler\SocketHandler
    {
        protected string $apiToken;
        /**
         * @throws MissingExtensionException if OpenSSL is missing
         */
        public function __construct(string $apiToken, $level = \Monolog\Level::Debug, bool $bubble = true, bool $persistent = false, float $timeout = 0.0, float $writingTimeout = 10.0, ?float $connectionTimeout = null, ?int $chunkSize = null)
        {
        }
        /**
         * @inheritDoc
         */
        public function setFormatter(\Monolog\Formatter\FormatterInterface $formatter): \Monolog\Handler\HandlerInterface
        {
        }
        /**
         * Gets the default formatter.
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * @inheritDoc
         */
        protected function generateDataStream(\Monolog\LogRecord $record): string
        {
        }
    }
    /**
     * Handler to send messages to a Graylog2 (http://www.graylog2.org) server
     *
     * @author Matt Lehner <mlehner@gmail.com>
     * @author Benjamin Zikarsky <benjamin@zikarsky.de>
     */
    class GelfHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        /**
         * @var PublisherInterface the publisher object that sends the message to the server
         */
        protected \Gelf\PublisherInterface $publisher;
        /**
         * @param PublisherInterface $publisher a gelf publisher object
         */
        public function __construct(\Gelf\PublisherInterface $publisher, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * @inheritDoc
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * This simple wrapper class can be used to extend handlers functionality.
     *
     * Example: A custom filtering that can be applied to any handler.
     *
     * Inherit from this class and override handle() like this:
     *
     *   public function handle(LogRecord $record)
     *   {
     *        if ($record meets certain conditions) {
     *            return false;
     *        }
     *        return $this->handler->handle($record);
     *   }
     *
     * @author Alexey Karapetov <alexey@karapetov.com>
     */
    class HandlerWrapper implements \Monolog\Handler\HandlerInterface, \Monolog\Handler\ProcessableHandlerInterface, \Monolog\Handler\FormattableHandlerInterface, \Monolog\ResettableInterface
    {
        protected \Monolog\Handler\HandlerInterface $handler;
        public function __construct(\Monolog\Handler\HandlerInterface $handler)
        {
        }
        /**
         * @inheritDoc
         */
        public function isHandling(\Monolog\LogRecord $record): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function handle(\Monolog\LogRecord $record): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function handleBatch(array $records): void
        {
        }
        /**
         * @inheritDoc
         */
        public function close(): void
        {
        }
        /**
         * @inheritDoc
         */
        public function pushProcessor(callable $callback): \Monolog\Handler\HandlerInterface
        {
        }
        /**
         * @inheritDoc
         */
        public function popProcessor(): callable
        {
        }
        /**
         * @inheritDoc
         */
        public function setFormatter(\Monolog\Formatter\FormatterInterface $formatter): \Monolog\Handler\HandlerInterface
        {
        }
        /**
         * @inheritDoc
         */
        public function getFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
        public function reset(): void
        {
        }
    }
    /**
     * IFTTTHandler uses cURL to trigger IFTTT Maker actions
     *
     * Register a secret key and trigger/event name at https://ifttt.com/maker
     *
     * value1 will be the channel from monolog's Logger constructor,
     * value2 will be the level name (ERROR, WARNING, ..)
     * value3 will be the log record's message
     *
     * @author Nehal Patel <nehal@nehalpatel.me>
     */
    class IFTTTHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        /**
         * @param string $eventName The name of the IFTTT Maker event that should be triggered
         * @param string $secretKey A valid IFTTT secret key
         *
         * @throws MissingExtensionException If the curl extension is missing
         */
        public function __construct(string $eventName, string $secretKey, int|string|\Monolog\Level $level = \Monolog\Level::Error, bool $bubble = true)
        {
        }
        /**
         * @inheritDoc
         */
        public function write(\Monolog\LogRecord $record): void
        {
        }
    }
    /**
     * Inspired on LogEntriesHandler.
     *
     * @author Robert Kaufmann III <rok3@rok3.me>
     * @author Gabriel Machado <gabriel.ms1@hotmail.com>
     */
    class InsightOpsHandler extends \Monolog\Handler\SocketHandler
    {
        protected string $logToken;
        /**
         * @param string $token  Log token supplied by InsightOps
         * @param string $region Region where InsightOps account is hosted. Could be 'us' or 'eu'.
         * @param bool   $useSSL Whether or not SSL encryption should be used
         *
         * @throws MissingExtensionException If SSL encryption is set to true and OpenSSL is missing
         */
        public function __construct(string $token, string $region = 'us', bool $useSSL = true, $level = \Monolog\Level::Debug, bool $bubble = true, bool $persistent = false, float $timeout = 0.0, float $writingTimeout = 10.0, ?float $connectionTimeout = null, ?int $chunkSize = null)
        {
        }
        /**
         * @inheritDoc
         */
        protected function generateDataStream(\Monolog\LogRecord $record): string
        {
        }
    }
    /**
     * @author Robert Kaufmann III <rok3@rok3.me>
     */
    class LogEntriesHandler extends \Monolog\Handler\SocketHandler
    {
        protected string $logToken;
        /**
         * @param string $token  Log token supplied by LogEntries
         * @param bool   $useSSL Whether or not SSL encryption should be used.
         * @param string $host   Custom hostname to send the data to if needed
         *
         * @throws MissingExtensionException If SSL encryption is set to true and OpenSSL is missing
         */
        public function __construct(string $token, bool $useSSL = true, $level = \Monolog\Level::Debug, bool $bubble = true, string $host = 'data.logentries.com', bool $persistent = false, float $timeout = 0.0, float $writingTimeout = 10.0, ?float $connectionTimeout = null, ?int $chunkSize = null)
        {
        }
        /**
         * @inheritDoc
         */
        protected function generateDataStream(\Monolog\LogRecord $record): string
        {
        }
    }
    /**
     * Sends errors to Loggly.
     *
     * @author Przemek Sobstel <przemek@sobstel.org>
     * @author Adam Pancutt <adam@pancutt.com>
     * @author Gregory Barchard <gregory@barchard.net>
     */
    class LogglyHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        protected const HOST = 'logs-01.loggly.com';
        protected const ENDPOINT_SINGLE = 'inputs';
        protected const ENDPOINT_BATCH = 'bulk';
        /**
         * Caches the curl handlers for every given endpoint.
         *
         * @var CurlHandle[]
         */
        protected array $curlHandlers = [];
        protected string $token;
        /** @var string[] */
        protected array $tag = [];
        /**
         * @param string $token API token supplied by Loggly
         *
         * @throws MissingExtensionException If the curl extension is missing
         */
        public function __construct(string $token, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        /**
         * Loads and returns the shared curl handler for the given endpoint.
         */
        protected function getCurlHandler(string $endpoint): \CurlHandle
        {
        }
        /**
         * @param  string[]|string $tag
         * @return $this
         */
        public function setTag(string|array $tag): self
        {
        }
        /**
         * @param  string[]|string $tag
         * @return $this
         */
        public function addTag(string|array $tag): self
        {
        }
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        public function handleBatch(array $records): void
        {
        }
        protected function send(string $data, string $endpoint): void
        {
        }
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * @author Julien Breux <julien.breux@gmail.com>
     */
    class LogmaticHandler extends \Monolog\Handler\SocketHandler
    {
        /**
         * @param string $token    Log token supplied by Logmatic.
         * @param string $hostname Host name supplied by Logmatic.
         * @param string $appName  Application name supplied by Logmatic.
         * @param bool   $useSSL   Whether or not SSL encryption should be used.
         *
         * @throws MissingExtensionException If SSL encryption is set to true and OpenSSL is missing
         */
        public function __construct(string $token, string $hostname = '', string $appName = '', bool $useSSL = true, $level = \Monolog\Level::Debug, bool $bubble = true, bool $persistent = false, float $timeout = 0.0, float $writingTimeout = 10.0, ?float $connectionTimeout = null, ?int $chunkSize = null)
        {
        }
        /**
         * @inheritDoc
         */
        protected function generateDataStream(\Monolog\LogRecord $record): string
        {
        }
        /**
         * @inheritDoc
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * Base class for all mail handlers
     *
     * @author Gyula Sallai
     */
    abstract class MailHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        /**
         * @inheritDoc
         */
        public function handleBatch(array $records): void
        {
        }
        /**
         * Send a mail with the given content
         *
         * @param string $content formatted email body to be sent
         * @param array  $records the array of log records that formed this content
         *
         * @phpstan-param non-empty-array<LogRecord> $records
         */
        abstract protected function send(string $content, array $records): void;
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * @phpstan-param non-empty-array<LogRecord> $records
         */
        protected function getHighestRecord(array $records): \Monolog\LogRecord
        {
        }
        protected function isHtmlBody(string $body): bool
        {
        }
        /**
         * Gets the default formatter.
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * MandrillHandler uses cURL to send the emails to the Mandrill API
     *
     * @author Adam Nicholson <adamnicholson10@gmail.com>
     */
    class MandrillHandler extends \Monolog\Handler\MailHandler
    {
        protected \Swift_Message $message;
        protected string $apiKey;
        /**
         * @phpstan-param (Swift_Message|callable(): Swift_Message) $message
         *
         * @param string                 $apiKey  A valid Mandrill API key
         * @param callable|Swift_Message $message An example message for real messages, only the body will be replaced
         *
         * @throws \InvalidArgumentException if not a Swift Message is set
         */
        public function __construct(string $apiKey, callable|\Swift_Message $message, int|string|\Monolog\Level $level = \Monolog\Level::Error, bool $bubble = true)
        {
        }
        /**
         * @inheritDoc
         */
        protected function send(string $content, array $records): void
        {
        }
    }
    /**
     * Exception can be thrown if an extension for a handler is missing
     *
     * @author Christian Bergau <cbergau86@gmail.com>
     */
    class MissingExtensionException extends \Exception
    {
    }
    /**
     * Logs to a MongoDB database.
     *
     * Usage example:
     *
     *   $log = new \Monolog\Logger('application');
     *   $client = new \MongoDB\Client('mongodb://localhost:27017');
     *   $mongodb = new \Monolog\Handler\MongoDBHandler($client, 'logs', 'prod');
     *   $log->pushHandler($mongodb);
     *
     * The above examples uses the MongoDB PHP library's client class; however, the
     * MongoDB\Driver\Manager class from ext-mongodb is also supported.
     */
    class MongoDBHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        /**
         * Constructor.
         *
         * @param Client|Manager $mongodb    MongoDB library or driver client
         * @param string         $database   Database name
         * @param string         $collection Collection name
         */
        public function __construct(\MongoDB\Client|\MongoDB\Driver\Manager $mongodb, string $database, string $collection, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * @inheritDoc
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * NativeMailerHandler uses the mail() function to send the emails
     *
     * @author Christophe Coevoet <stof@notk.org>
     * @author Mark Garrett <mark@moderndeveloperllc.com>
     */
    class NativeMailerHandler extends \Monolog\Handler\MailHandler
    {
        /**
         * The email addresses to which the message will be sent
         * @var string[]
         */
        protected array $to;
        /**
         * The subject of the email
         */
        protected string $subject;
        /**
         * Optional headers for the message
         * @var string[]
         */
        protected array $headers = [];
        /**
         * Optional parameters for the message
         * @var string[]
         */
        protected array $parameters = [];
        /**
         * The wordwrap length for the message
         */
        protected int $maxColumnWidth;
        /**
         * The Content-type for the message
         */
        protected string|null $contentType = null;
        /**
         * The encoding for the message
         */
        protected string $encoding = 'utf-8';
        /**
         * @param string|string[] $to             The receiver of the mail
         * @param string          $subject        The subject of the mail
         * @param string          $from           The sender of the mail
         * @param int             $maxColumnWidth The maximum column width that the message lines will have
         */
        public function __construct(string|array $to, string $subject, string $from, int|string|\Monolog\Level $level = \Monolog\Level::Error, bool $bubble = true, int $maxColumnWidth = 70)
        {
        }
        /**
         * Add headers to the message
         *
         * @param  string|string[] $headers Custom added headers
         * @return $this
         */
        public function addHeader($headers): self
        {
        }
        /**
         * Add parameters to the message
         *
         * @param  string|string[] $parameters Custom added parameters
         * @return $this
         */
        public function addParameter($parameters): self
        {
        }
        /**
         * @inheritDoc
         */
        protected function send(string $content, array $records): void
        {
        }
        public function getContentType(): ?string
        {
        }
        public function getEncoding(): string
        {
        }
        /**
         * @param  string $contentType The content type of the email - Defaults to text/plain. Use text/html for HTML messages.
         * @return $this
         */
        public function setContentType(string $contentType): self
        {
        }
        /**
         * @return $this
         */
        public function setEncoding(string $encoding): self
        {
        }
    }
    /**
     * Class to record a log on a NewRelic application.
     * Enabling New Relic High Security mode may prevent capture of useful information.
     *
     * This handler requires a NormalizerFormatter to function and expects an array in $record->formatted
     *
     * @see https://docs.newrelic.com/docs/agents/php-agent
     * @see https://docs.newrelic.com/docs/accounts-partnerships/accounts/security/high-security
     */
    class NewRelicHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        /**
         * @inheritDoc
         */
        public function __construct(
            int|string|\Monolog\Level $level = \Monolog\Level::Error,
            bool $bubble = true,
            /**
             * Name of the New Relic application that will receive logs from this handler.
             */
            protected string|null $appName = null,
            /**
             * Some context and extra data is passed into the handler as arrays of values. Do we send them as is
             * (useful if we are using the API), or explode them for display on the NewRelic RPM website?
             */
            protected bool $explodeArrays = false,
            /**
             * Name of the current transaction
             */
            protected string|null $transactionName = null
        )
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * Checks whether the NewRelic extension is enabled in the system.
         */
        protected function isNewRelicEnabled(): bool
        {
        }
        /**
         * Returns the appname where this log should be sent. Each log can override the default appname, set in this
         * handler's constructor, by providing the appname in it's context.
         *
         * @param mixed[] $context
         */
        protected function getAppName(array $context): ?string
        {
        }
        /**
         * Returns the name of the current transaction. Each log can override the default transaction name, set in this
         * handler's constructor, by providing the transaction_name in it's context
         *
         * @param mixed[] $context
         */
        protected function getTransactionName(array $context): ?string
        {
        }
        /**
         * Sets the NewRelic application that should receive this log.
         */
        protected function setNewRelicAppName(string $appName): void
        {
        }
        /**
         * Overwrites the name of the current transaction
         */
        protected function setNewRelicTransactionName(string $transactionName): void
        {
        }
        /**
         * @param mixed $value
         */
        protected function setNewRelicParameter(string $key, $value): void
        {
        }
        /**
         * @inheritDoc
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * No-op
     *
     * This handler handles anything, but does nothing, and does not stop bubbling to the rest of the stack.
     * This can be used for testing, or to disable a handler when overriding a configuration without
     * influencing the rest of the stack.
     *
     * @author Roel Harbers <roelharbers@gmail.com>
     */
    class NoopHandler extends \Monolog\Handler\Handler
    {
        /**
         * @inheritDoc
         */
        public function isHandling(\Monolog\LogRecord $record): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function handle(\Monolog\LogRecord $record): bool
        {
        }
    }
    /**
     * Blackhole
     *
     * Any record it can handle will be thrown away. This can be used
     * to put on top of an existing stack to override it temporarily.
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    class NullHandler extends \Monolog\Handler\Handler
    {
        /**
         * @param string|int|Level $level The minimum logging level at which this handler will be triggered
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $level
         */
        public function __construct(string|int|\Monolog\Level $level = \Monolog\Level::Debug)
        {
        }
        /**
         * @inheritDoc
         */
        public function isHandling(\Monolog\LogRecord $record): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function handle(\Monolog\LogRecord $record): bool
        {
        }
    }
    /**
     * Handler to only pass log messages when a certain threshold of number of messages is reached.
     *
     * This can be useful in cases of processing a batch of data, but you're for example only interested
     * in case it fails catastrophically instead of a warning for 1 or 2 events. Worse things can happen, right?
     *
     * Usage example:
     *
     * ```
     *   $log = new Logger('application');
     *   $handler = new SomeHandler(...)
     *
     *   // Pass all warnings to the handler when more than 10 & all error messages when more then 5
     *   $overflow = new OverflowHandler($handler, [Level::Warning->value => 10, Level::Error->value => 5]);
     *
     *   $log->pushHandler($overflow);
     *```
     *
     * @author Kris Buist <krisbuist@gmail.com>
     */
    class OverflowHandler extends \Monolog\Handler\AbstractHandler implements \Monolog\Handler\FormattableHandlerInterface
    {
        /**
         * @param array<int, int> $thresholdMap Dictionary of log level value => threshold
         */
        public function __construct(\Monolog\Handler\HandlerInterface $handler, array $thresholdMap = [], $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        /**
         * Handles a record.
         *
         * All records may be passed to this method, and the handler should discard
         * those that it does not want to handle.
         *
         * The return value of this function controls the bubbling process of the handler stack.
         * Unless the bubbling is interrupted (by returning true), the Logger class will keep on
         * calling further handlers in the stack with a given log record.
         *
         * @inheritDoc
         */
        public function handle(\Monolog\LogRecord $record): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function setFormatter(\Monolog\Formatter\FormatterInterface $formatter): \Monolog\Handler\HandlerInterface
        {
        }
        /**
         * @inheritDoc
         */
        public function getFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * Monolog handler for Google Chrome extension "PHP Console"
     *
     * Display PHP error/debug log messages in Google Chrome console and notification popups, executes PHP code remotely
     *
     * Usage:
     * 1. Install Google Chrome extension [now dead and removed from the chrome store]
     * 2. See overview https://github.com/barbushin/php-console#overview
     * 3. Install PHP Console library https://github.com/barbushin/php-console#installation
     * 4. Example (result will looks like http://i.hizliresim.com/vg3Pz4.png)
     *
     *      $logger = new \Monolog\Logger('all', array(new \Monolog\Handler\PHPConsoleHandler()));
     *      \Monolog\ErrorHandler::register($logger);
     *      echo $undefinedVar;
     *      $logger->debug('SELECT * FROM users', array('db', 'time' => 0.012));
     *      PC::debug($_SERVER); // PHP Console debugger for any type of vars
     *
     * @author Sergey Barbushin https://www.linkedin.com/in/barbushin
     * @phpstan-type Options array{
     *     enabled: bool,
     *     classesPartialsTraceIgnore: string[],
     *     debugTagsKeysInContext: array<int|string>,
     *     useOwnErrorsHandler: bool,
     *     useOwnExceptionsHandler: bool,
     *     sourcesBasePath: string|null,
     *     registerHelper: bool,
     *     serverEncoding: string|null,
     *     headersLimit: int|null,
     *     password: string|null,
     *     enableSslOnlyMode: bool,
     *     ipMasks: string[],
     *     enableEvalListener: bool,
     *     dumperDetectCallbacks: bool,
     *     dumperLevelLimit: int,
     *     dumperItemsCountLimit: int,
     *     dumperItemSizeLimit: int,
     *     dumperDumpSizeLimit: int,
     *     detectDumpTraceAndSource: bool,
     *     dataStorage: Storage|null
     * }
     * @phpstan-type InputOptions array{
     *     enabled?: bool,
     *     classesPartialsTraceIgnore?: string[],
     *     debugTagsKeysInContext?: array<int|string>,
     *     useOwnErrorsHandler?: bool,
     *     useOwnExceptionsHandler?: bool,
     *     sourcesBasePath?: string|null,
     *     registerHelper?: bool,
     *     serverEncoding?: string|null,
     *     headersLimit?: int|null,
     *     password?: string|null,
     *     enableSslOnlyMode?: bool,
     *     ipMasks?: string[],
     *     enableEvalListener?: bool,
     *     dumperDetectCallbacks?: bool,
     *     dumperLevelLimit?: int,
     *     dumperItemsCountLimit?: int,
     *     dumperItemSizeLimit?: int,
     *     dumperDumpSizeLimit?: int,
     *     detectDumpTraceAndSource?: bool,
     *     dataStorage?: Storage|null
     * }
     *
     * @deprecated Since 2.8.0 and 3.2.0, PHPConsole is abandoned and thus we will drop this handler in Monolog 4
     */
    class PHPConsoleHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        /**
         * @param  array<string, mixed> $options   See \Monolog\Handler\PHPConsoleHandler::$options for more details
         * @param  Connector|null       $connector Instance of \PhpConsole\Connector class (optional)
         * @throws \RuntimeException
         * @phpstan-param InputOptions $options
         */
        public function __construct(array $options = [], ?\PhpConsole\Connector $connector = null, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        public function getConnector(): \PhpConsole\Connector
        {
        }
        /**
         * @return array<string, mixed>
         */
        public function getOptions(): array
        {
        }
        public function handle(\Monolog\LogRecord $record): bool
        {
        }
        /**
         * Writes the record down to the log of the implementing handler
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * @inheritDoc
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * Stores to STDIN of any process, specified by a command.
     *
     * Usage example:
     * <pre>
     * $log = new Logger('myLogger');
     * $log->pushHandler(new ProcessHandler('/usr/bin/php /var/www/monolog/someScript.php'));
     * </pre>
     *
     * @author Kolja Zuelsdorf <koljaz@web.de>
     */
    class ProcessHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        /**
         * @var array<int, string[]>
         */
        protected const DESCRIPTOR_SPEC = [
            0 => ['pipe', 'r'],
            // STDIN is a pipe that the child will read from
            1 => ['pipe', 'w'],
            // STDOUT is a pipe that the child will write to
            2 => ['pipe', 'w'],
        ];
        /**
         * @param  string                    $command Command for the process to start. Absolute paths are recommended,
         *                                            especially if you do not use the $cwd parameter.
         * @param  string|null               $cwd     "Current working directory" (CWD) for the process to be executed in.
         * @param  float                     $timeout The maximum timeout (in seconds) for the stream_select() function.
         * @throws \InvalidArgumentException
         */
        public function __construct(string $command, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true, ?string $cwd = null, float $timeout = 1.0)
        {
        }
        /**
         * Writes the record down to the log of the implementing handler
         *
         * @throws \UnexpectedValueException
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * Selects the STDERR stream.
         *
         * @return int|bool
         */
        protected function selectErrorStream()
        {
        }
        /**
         * Reads the errors of the process, if there are any.
         *
         * @codeCoverageIgnore
         * @return string Empty string if there are no errors.
         */
        protected function readProcessErrors(): string
        {
        }
        /**
         * Writes to the input stream of the opened process.
         *
         * @codeCoverageIgnore
         */
        protected function writeProcessInput(string $string): void
        {
        }
        /**
         * @inheritDoc
         */
        public function close(): void
        {
        }
    }
    /**
     * Proxies log messages to an existing PSR-3 compliant logger.
     *
     * If a formatter is configured, the formatter's output MUST be a string and the
     * formatted message will be fed to the wrapped PSR logger instead of the original
     * log record's message.
     *
     * @author Michael Moussa <michael.moussa@gmail.com>
     */
    class PsrHandler extends \Monolog\Handler\AbstractHandler implements \Monolog\Handler\FormattableHandlerInterface
    {
        /**
         * PSR-3 compliant logger
         */
        protected \Psr\Log\LoggerInterface $logger;
        protected \Monolog\Formatter\FormatterInterface|null $formatter = null;
        /**
         * @param LoggerInterface $logger The underlying PSR-3 compliant logger to which messages will be proxied
         */
        public function __construct(\Psr\Log\LoggerInterface $logger, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true, bool $includeExtra = false)
        {
        }
        /**
         * @inheritDoc
         */
        public function handle(\Monolog\LogRecord $record): bool
        {
        }
        /**
         * Sets the formatter.
         */
        public function setFormatter(\Monolog\Formatter\FormatterInterface $formatter): \Monolog\Handler\HandlerInterface
        {
        }
        /**
         * Gets the formatter.
         */
        public function getFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * Sends notifications through the pushover api to mobile phones
     *
     * @author Sebastian Göttschkes <sebastian.goettschkes@googlemail.com>
     * @see    https://www.pushover.net/api
     */
    class PushoverHandler extends \Monolog\Handler\SocketHandler
    {
        /**
         * @param string       $token  Pushover api token
         * @param string|array $users  Pushover user id or array of ids the message will be sent to
         * @param string|null  $title  Title sent to the Pushover API
         * @param bool         $useSSL Whether to connect via SSL. Required when pushing messages to users that are not
         *                             the pushover.net app owner. OpenSSL is required for this option.
         * @param int          $retry  The retry parameter specifies how often (in seconds) the Pushover servers will
         *                             send the same notification to the user.
         * @param int          $expire The expire parameter specifies how many seconds your notification will continue
         *                             to be retried for (every retry seconds).
         *
         * @param int|string|Level|LogLevel::* $highPriorityLevel The minimum logging level at which this handler will start
         *                                                        sending "high priority" requests to the Pushover API
         * @param int|string|Level|LogLevel::* $emergencyLevel    The minimum logging level at which this handler will start
         *                                                        sending "emergency" requests to the Pushover API
         *
         *
         * @phpstan-param string|array<int|string>    $users
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $highPriorityLevel
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $emergencyLevel
         */
        public function __construct(string $token, $users, ?string $title = null, int|string|\Monolog\Level $level = \Monolog\Level::Critical, bool $bubble = true, bool $useSSL = true, int|string|\Monolog\Level $highPriorityLevel = \Monolog\Level::Critical, int|string|\Monolog\Level $emergencyLevel = \Monolog\Level::Emergency, int $retry = 30, int $expire = 25200, bool $persistent = false, float $timeout = 0.0, float $writingTimeout = 10.0, ?float $connectionTimeout = null, ?int $chunkSize = null)
        {
        }
        protected function generateDataStream(\Monolog\LogRecord $record): string
        {
        }
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * @param  int|string|Level|LogLevel::* $level
         * @return $this
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $level
         */
        public function setHighPriorityLevel(int|string|\Monolog\Level $level): self
        {
        }
        /**
         * @param  int|string|Level|LogLevel::* $level
         * @return $this
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $level
         */
        public function setEmergencyLevel(int|string|\Monolog\Level $level): self
        {
        }
        /**
         * Use the formatted message?
         *
         * @return $this
         */
        public function useFormattedMessage(bool $useFormattedMessage): self
        {
        }
    }
    /**
     * Logs to a Redis key using rpush
     *
     * usage example:
     *
     *   $log = new Logger('application');
     *   $redis = new RedisHandler(new Predis\Client("tcp://localhost:6379"), "logs");
     *   $log->pushHandler($redis);
     *
     * @author Thomas Tourlourat <thomas@tourlourat.com>
     */
    class RedisHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        protected int $capSize;
        /**
         * @param Predis<Predis>|Redis $redis   The redis instance
         * @param string               $key     The key name to push records to
         * @param int                  $capSize Number of entries to limit list size to, 0 = unlimited
         */
        public function __construct(\Predis\Client|\Redis $redis, string $key, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true, int $capSize = 0)
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * Write and cap the collection
         * Writes the record to the redis list and caps its
         */
        protected function writeCapped(\Monolog\LogRecord $record): void
        {
        }
        /**
         * @inheritDoc
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * Sends the message to a Redis Pub/Sub channel using PUBLISH
     *
     * usage example:
     *
     *   $log = new Logger('application');
     *   $redis = new RedisPubSubHandler(new Predis\Client("tcp://localhost:6379"), "logs", Level::Warning);
     *   $log->pushHandler($redis);
     *
     * @author Gaëtan Faugère <gaetan@fauge.re>
     */
    class RedisPubSubHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        /**
         * @param Predis<Predis>|Redis $redis The redis instance
         * @param string               $key   The channel key to publish records to
         */
        public function __construct(\Predis\Client|\Redis $redis, string $key, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * @inheritDoc
         */
        protected function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * Sends errors to Rollbar
     *
     * If the context data contains a `payload` key, that is used as an array
     * of payload options to RollbarLogger's log method.
     *
     * Rollbar's context info will contain the context + extra keys from the log record
     * merged, and then on top of that a few keys:
     *
     *  - level (rollbar level name)
     *  - monolog_level (monolog level name, raw level, as rollbar only has 5 but monolog 8)
     *  - channel
     *  - datetime (unix timestamp)
     *
     * @author Paul Statezny <paulstatezny@gmail.com>
     */
    class RollbarHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        protected \Rollbar\RollbarLogger $rollbarLogger;
        protected bool $initialized = false;
        /**
         * @param RollbarLogger $rollbarLogger RollbarLogger object constructed with valid token
         */
        public function __construct(\Rollbar\RollbarLogger $rollbarLogger, int|string|\Monolog\Level $level = \Monolog\Level::Error, bool $bubble = true)
        {
        }
        /**
         * Translates Monolog log levels to Rollbar levels.
         *
         * @return 'debug'|'info'|'warning'|'error'|'critical'
         */
        protected function toRollbarLevel(\Monolog\Level $level): string
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        public function flush(): void
        {
        }
        /**
         * @inheritDoc
         */
        public function close(): void
        {
        }
        /**
         * @inheritDoc
         */
        public function reset(): void
        {
        }
    }
    /**
     * Stores to any stream resource
     *
     * Can be used to store into php://stderr, remote and local files, etc.
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    class StreamHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        protected const MAX_CHUNK_SIZE = 2147483647;
        /** 10MB */
        protected const DEFAULT_CHUNK_SIZE = 10 * 1024 * 1024;
        protected int $streamChunkSize;
        /** @var resource|null */
        protected $stream;
        protected string|null $url = null;
        protected int|null $filePermission;
        protected bool $useLocking;
        protected string $fileOpenMode;
        /**
         * @param resource|string $stream         If a missing path can't be created, an UnexpectedValueException will be thrown on first write
         * @param int|null        $filePermission Optional file permissions (default (0644) are only for owner read/write)
         * @param bool            $useLocking     Try to lock log file before doing any writes
         * @param string          $fileOpenMode   The fopen() mode used when opening a file, if $stream is a file path
         *
         * @throws \InvalidArgumentException If stream is not a resource or string
         */
        public function __construct($stream, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true, ?int $filePermission = null, bool $useLocking = false, string $fileOpenMode = 'a')
        {
        }
        /**
         * @inheritDoc
         */
        public function reset(): void
        {
        }
        /**
         * @inheritDoc
         */
        public function close(): void
        {
        }
        /**
         * Return the currently active stream if it is open
         *
         * @return resource|null
         */
        public function getStream()
        {
        }
        /**
         * Return the stream URL if it was configured with a URL and not an active resource
         */
        public function getUrl(): ?string
        {
        }
        public function getStreamChunkSize(): int
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * Write to stream
         * @param resource $stream
         */
        protected function streamWrite($stream, \Monolog\LogRecord $record): void
        {
        }
    }
    /**
     * Stores logs to files that are rotated every day and a limited number of files are kept.
     *
     * This rotation is only intended to be used as a workaround. Using logrotate to
     * handle the rotation is strongly encouraged when you can use it.
     *
     * @author Christophe Coevoet <stof@notk.org>
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    class RotatingFileHandler extends \Monolog\Handler\StreamHandler
    {
        public const FILE_PER_DAY = 'Y-m-d';
        public const FILE_PER_MONTH = 'Y-m';
        public const FILE_PER_YEAR = 'Y';
        protected string $filename;
        protected int $maxFiles;
        protected bool|null $mustRotate = null;
        protected \DateTimeImmutable $nextRotation;
        protected string $filenameFormat;
        protected string $dateFormat;
        /**
         * @param int      $maxFiles       The maximal amount of files to keep (0 means unlimited)
         * @param int|null $filePermission Optional file permissions (default (0644) are only for owner read/write)
         * @param bool     $useLocking     Try to lock log file before doing any writes
         */
        public function __construct(string $filename, int $maxFiles = 0, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true, ?int $filePermission = null, bool $useLocking = false, string $dateFormat = self::FILE_PER_DAY, string $filenameFormat = '{filename}-{date}')
        {
        }
        /**
         * @inheritDoc
         */
        public function close(): void
        {
        }
        /**
         * @inheritDoc
         */
        public function reset(): void
        {
        }
        /**
         * @return $this
         */
        public function setFilenameFormat(string $filenameFormat, string $dateFormat): self
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * Rotates the files.
         */
        protected function rotate(): void
        {
        }
        protected function getTimedFilename(): string
        {
        }
        protected function getGlobPattern(): string
        {
        }
        protected function setDateFormat(string $dateFormat): void
        {
        }
        protected function getNextRotation(): \DateTimeImmutable
        {
        }
    }
    /**
     * Sampling handler
     *
     * A sampled event stream can be useful for logging high frequency events in
     * a production environment where you only need an idea of what is happening
     * and are not concerned with capturing every occurrence. Since the decision to
     * handle or not handle a particular event is determined randomly, the
     * resulting sampled log is not guaranteed to contain 1/N of the events that
     * occurred in the application, but based on the Law of large numbers, it will
     * tend to be close to this ratio with a large number of attempts.
     *
     * @author Bryan Davis <bd808@wikimedia.org>
     * @author Kunal Mehta <legoktm@gmail.com>
     */
    class SamplingHandler extends \Monolog\Handler\AbstractHandler implements \Monolog\Handler\ProcessableHandlerInterface, \Monolog\Handler\FormattableHandlerInterface
    {
        use \Monolog\Handler\ProcessableHandlerTrait;
        /**
         * Handler or factory Closure($record, $this)
         *
         * @phpstan-var (Closure(LogRecord|null, HandlerInterface): HandlerInterface)|HandlerInterface
         */
        protected \Closure|\Monolog\Handler\HandlerInterface $handler;
        protected int $factor;
        /**
         * @phpstan-param (Closure(LogRecord|null, HandlerInterface): HandlerInterface)|HandlerInterface $handler
         *
         * @param Closure|HandlerInterface $handler Handler or factory Closure($record|null, $samplingHandler).
         * @param int                      $factor  Sample factor (e.g. 10 means every ~10th record is sampled)
         */
        public function __construct(\Closure|\Monolog\Handler\HandlerInterface $handler, int $factor)
        {
        }
        public function isHandling(\Monolog\LogRecord $record): bool
        {
        }
        public function handle(\Monolog\LogRecord $record): bool
        {
        }
        /**
         * Return the nested handler
         *
         * If the handler was provided as a factory, this will trigger the handler's instantiation.
         */
        public function getHandler(\Monolog\LogRecord|null $record = null): \Monolog\Handler\HandlerInterface
        {
        }
        /**
         * @inheritDoc
         */
        public function setFormatter(\Monolog\Formatter\FormatterInterface $formatter): \Monolog\Handler\HandlerInterface
        {
        }
        /**
         * @inheritDoc
         */
        public function getFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * SendGridrHandler uses the SendGrid API v2 function to send Log emails, more information in https://sendgrid.com/docs/API_Reference/Web_API/mail.html
     *
     * @author Ricardo Fontanelli <ricardo.fontanelli@hotmail.com>
     */
    class SendGridHandler extends \Monolog\Handler\MailHandler
    {
        /**
         * The SendGrid API User
         */
        protected string $apiUser;
        /**
         * The SendGrid API Key
         */
        protected string $apiKey;
        /**
         * The email addresses to which the message will be sent
         */
        protected string $from;
        /**
         * The email addresses to which the message will be sent
         * @var string[]
         */
        protected array $to;
        /**
         * The subject of the email
         */
        protected string $subject;
        /**
         * @param string          $apiUser The SendGrid API User
         * @param string          $apiKey  The SendGrid API Key
         * @param string          $from    The sender of the email
         * @param string|string[] $to      The recipients of the email
         * @param string          $subject The subject of the mail
         *
         * @throws MissingExtensionException If the curl extension is missing
         */
        public function __construct(string $apiUser, string $apiKey, string $from, string|array $to, string $subject, int|string|\Monolog\Level $level = \Monolog\Level::Error, bool $bubble = true)
        {
        }
        /**
         * @inheritDoc
         */
        protected function send(string $content, array $records): void
        {
        }
    }
}
namespace Monolog\Handler\Slack {
    /**
     * Slack record utility helping to log to Slack webhooks or API.
     *
     * @author Greg Kedzierski <greg@gregkedzierski.com>
     * @author Haralan Dobrev <hkdobrev@gmail.com>
     * @see    https://api.slack.com/incoming-webhooks
     * @see    https://api.slack.com/docs/message-attachments
     */
    class SlackRecord
    {
        public const COLOR_DANGER = 'danger';
        public const COLOR_WARNING = 'warning';
        public const COLOR_GOOD = 'good';
        public const COLOR_DEFAULT = '#e3e4e6';
        /**
         * @param string[] $excludeFields
         */
        public function __construct(?string $channel = null, ?string $username = null, bool $useAttachment = true, ?string $userIcon = null, bool $useShortAttachment = false, bool $includeContextAndExtra = false, array $excludeFields = [], \Monolog\Formatter\FormatterInterface|null $formatter = null)
        {
        }
        /**
         * Returns required data in format that Slack
         * is expecting.
         *
         * @phpstan-return mixed[]
         */
        public function getSlackData(\Monolog\LogRecord $record): array
        {
        }
        /**
         * Returns a Slack message attachment color associated with
         * provided level.
         */
        public function getAttachmentColor(\Monolog\Level $level): string
        {
        }
        /**
         * Stringifies an array of key/value pairs to be used in attachment fields
         *
         * @param mixed[] $fields
         */
        public function stringify(array $fields): string
        {
        }
        /**
         * Channel used by the bot when posting
         *
         * @param  ?string $channel
         * @return $this
         */
        public function setChannel(?string $channel = null): self
        {
        }
        /**
         * Username used by the bot when posting
         *
         * @param  ?string $username
         * @return $this
         */
        public function setUsername(?string $username = null): self
        {
        }
        /**
         * @return $this
         */
        public function useAttachment(bool $useAttachment = true): self
        {
        }
        /**
         * @return $this
         */
        public function setUserIcon(?string $userIcon = null): self
        {
        }
        /**
         * @return $this
         */
        public function useShortAttachment(bool $useShortAttachment = false): self
        {
        }
        /**
         * @return $this
         */
        public function includeContextAndExtra(bool $includeContextAndExtra = false): self
        {
        }
        /**
         * @param  string[] $excludeFields
         * @return $this
         */
        public function excludeFields(array $excludeFields = []): self
        {
        }
        /**
         * @return $this
         */
        public function setFormatter(?\Monolog\Formatter\FormatterInterface $formatter = null): self
        {
        }
    }
}
namespace Monolog\Handler {
    /**
     * Sends notifications through Slack API
     *
     * @author Greg Kedzierski <greg@gregkedzierski.com>
     * @see    https://api.slack.com/
     */
    class SlackHandler extends \Monolog\Handler\SocketHandler
    {
        /**
         * @param  string                    $token                  Slack API token
         * @param  string                    $channel                Slack channel (encoded ID or name)
         * @param  string|null               $username               Name of a bot
         * @param  bool                      $useAttachment          Whether the message should be added to Slack as attachment (plain text otherwise)
         * @param  string|null               $iconEmoji              The emoji name to use (or null)
         * @param  bool                      $useShortAttachment     Whether the context/extra messages added to Slack as attachments are in a short style
         * @param  bool                      $includeContextAndExtra Whether the attachment should include context and extra data
         * @param  string[]                  $excludeFields          Dot separated list of fields to exclude from slack message. E.g. ['context.field1', 'extra.field2']
         * @throws MissingExtensionException If no OpenSSL PHP extension configured
         */
        public function __construct(string $token, string $channel, ?string $username = null, bool $useAttachment = true, ?string $iconEmoji = null, $level = \Monolog\Level::Critical, bool $bubble = true, bool $useShortAttachment = false, bool $includeContextAndExtra = false, array $excludeFields = [], bool $persistent = false, float $timeout = 0.0, float $writingTimeout = 10.0, ?float $connectionTimeout = null, ?int $chunkSize = null)
        {
        }
        public function getSlackRecord(): \Monolog\Handler\Slack\SlackRecord
        {
        }
        public function getToken(): string
        {
        }
        /**
         * @inheritDoc
         */
        protected function generateDataStream(\Monolog\LogRecord $record): string
        {
        }
        /**
         * @return string[]
         */
        protected function prepareContentData(\Monolog\LogRecord $record): array
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * Finalizes the request by reading some bytes and then closing the socket
         *
         * If we do not read some but close the socket too early, slack sometimes
         * drops the request entirely.
         */
        protected function finalizeWrite(): void
        {
        }
        public function setFormatter(\Monolog\Formatter\FormatterInterface $formatter): \Monolog\Handler\HandlerInterface
        {
        }
        public function getFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
        /**
         * Channel used by the bot when posting
         *
         * @return $this
         */
        public function setChannel(string $channel): self
        {
        }
        /**
         * Username used by the bot when posting
         *
         * @return $this
         */
        public function setUsername(string $username): self
        {
        }
        /**
         * @return $this
         */
        public function useAttachment(bool $useAttachment): self
        {
        }
        /**
         * @return $this
         */
        public function setIconEmoji(string $iconEmoji): self
        {
        }
        /**
         * @return $this
         */
        public function useShortAttachment(bool $useShortAttachment): self
        {
        }
        /**
         * @return $this
         */
        public function includeContextAndExtra(bool $includeContextAndExtra): self
        {
        }
        /**
         * @param  string[] $excludeFields
         * @return $this
         */
        public function excludeFields(array $excludeFields): self
        {
        }
    }
    /**
     * Sends notifications through Slack Webhooks
     *
     * @author Haralan Dobrev <hkdobrev@gmail.com>
     * @see    https://api.slack.com/incoming-webhooks
     */
    class SlackWebhookHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        /**
         * @param string      $webhookUrl             Slack Webhook URL
         * @param string|null $channel                Slack channel (encoded ID or name)
         * @param string|null $username               Name of a bot
         * @param bool        $useAttachment          Whether the message should be added to Slack as attachment (plain text otherwise)
         * @param string|null $iconEmoji              The emoji name to use (or null)
         * @param bool        $useShortAttachment     Whether the the context/extra messages added to Slack as attachments are in a short style
         * @param bool        $includeContextAndExtra Whether the attachment should include context and extra data
         * @param string[]    $excludeFields          Dot separated list of fields to exclude from slack message. E.g. ['context.field1', 'extra.field2']
         *
         * @throws MissingExtensionException If the curl extension is missing
         */
        public function __construct(string $webhookUrl, ?string $channel = null, ?string $username = null, bool $useAttachment = true, ?string $iconEmoji = null, bool $useShortAttachment = false, bool $includeContextAndExtra = false, $level = \Monolog\Level::Critical, bool $bubble = true, array $excludeFields = [])
        {
        }
        public function getSlackRecord(): \Monolog\Handler\Slack\SlackRecord
        {
        }
        public function getWebhookUrl(): string
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        public function setFormatter(\Monolog\Formatter\FormatterInterface $formatter): \Monolog\Handler\HandlerInterface
        {
        }
        public function getFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
    /**
     * Writes to any sqs queue.
     *
     * @author Martijn van Calker <git@amvc.nl>
     */
    class SqsHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        /** 256 KB in bytes - maximum message size in SQS */
        protected const MAX_MESSAGE_SIZE = 262144;
        /** 100 KB in bytes - head message size for new error log */
        protected const HEAD_MESSAGE_SIZE = 102400;
        public function __construct(\Aws\Sqs\SqsClient $sqsClient, string $queueUrl, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
    }
    /**
     * SymfonyMailerHandler uses Symfony's Mailer component to send the emails
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    class SymfonyMailerHandler extends \Monolog\Handler\MailHandler
    {
        protected \Symfony\Component\Mailer\MailerInterface|\Symfony\Component\Mailer\Transport\TransportInterface $mailer;
        /**
         * @phpstan-param Email|Closure(string, LogRecord[]): Email $email
         *
         * @param MailerInterface|TransportInterface $mailer The mailer to use
         * @param Closure|Email                      $email  An email template, the subject/body will be replaced
         */
        public function __construct($mailer, \Symfony\Component\Mime\Email|\Closure $email, int|string|\Monolog\Level $level = \Monolog\Level::Error, bool $bubble = true)
        {
        }
        /**
         * {@inheritDoc}
         */
        protected function send(string $content, array $records): void
        {
        }
        /**
         * Gets the formatter for the Swift_Message subject.
         *
         * @param string|null $format The format of the subject
         */
        protected function getSubjectFormatter(?string $format): \Monolog\Formatter\FormatterInterface
        {
        }
        /**
         * Creates instance of Email to be sent
         *
         * @param string      $content formatted email body to be sent
         * @param LogRecord[] $records Log records that formed the content
         */
        protected function buildMessage(string $content, array $records): \Symfony\Component\Mime\Email
        {
        }
    }
    /**
     * Logs to syslog service.
     *
     * usage example:
     *
     *   $log = new Logger('application');
     *   $syslog = new SyslogHandler('myfacility', 'local6');
     *   $formatter = new LineFormatter("%channel%.%level_name%: %message% %extra%");
     *   $syslog->setFormatter($formatter);
     *   $log->pushHandler($syslog);
     *
     * @author Sven Paulus <sven@karlsruhe.org>
     */
    class SyslogHandler extends \Monolog\Handler\AbstractSyslogHandler
    {
        protected string $ident;
        protected int $logopts;
        /**
         * @param string|int $facility Either one of the names of the keys in $this->facilities, or a LOG_* facility constant
         * @param int        $logopts  Option flags for the openlog() call, defaults to LOG_PID
         */
        public function __construct(string $ident, string|int $facility = LOG_USER, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true, int $logopts = LOG_PID)
        {
        }
        /**
         * @inheritDoc
         */
        public function close(): void
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
    }
}
namespace Monolog\Handler\SyslogUdp {
    class UdpSocket
    {
        protected const DATAGRAM_MAX_LENGTH = 65023;
        protected string $ip;
        protected int $port;
        protected ?\Socket $socket = null;
        public function __construct(string $ip, int $port = 514)
        {
        }
        public function write(string $line, string $header = ""): void
        {
        }
        public function close(): void
        {
        }
        protected function getSocket(): \Socket
        {
        }
        protected function send(string $chunk): void
        {
        }
        protected function assembleMessage(string $line, string $header): string
        {
        }
    }
}
namespace Monolog\Handler {
    /**
     * A Handler for logging to a remote syslogd server.
     *
     * @author Jesper Skovgaard Nielsen <nulpunkt@gmail.com>
     * @author Dominik Kukacka <dominik.kukacka@gmail.com>
     */
    class SyslogUdpHandler extends \Monolog\Handler\AbstractSyslogHandler
    {
        const RFC3164 = 0;
        const RFC5424 = 1;
        const RFC5424e = 2;
        protected \Monolog\Handler\SyslogUdp\UdpSocket $socket;
        protected string $ident;
        /** @var self::RFC* */
        protected int $rfc;
        /**
         * @param  string                    $host     Either IP/hostname or a path to a unix socket (port must be 0 then)
         * @param  int                       $port     Port number, or 0 if $host is a unix socket
         * @param  string|int                $facility Either one of the names of the keys in $this->facilities, or a LOG_* facility constant
         * @param  bool                      $bubble   Whether the messages that are handled can bubble up the stack or not
         * @param  string                    $ident    Program name or tag for each log message.
         * @param  int                       $rfc      RFC to format the message for.
         * @throws MissingExtensionException when there is no socket extension
         *
         * @phpstan-param self::RFC* $rfc
         */
        public function __construct(string $host, int $port = 514, string|int $facility = LOG_USER, int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true, string $ident = 'php', int $rfc = self::RFC5424)
        {
        }
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        public function close(): void
        {
        }
        /**
         * Make common syslog header (see rfc5424 or rfc3164)
         */
        protected function makeCommonSyslogHeader(int $severity, \DateTimeInterface $datetime): string
        {
        }
        /**
         * Inject your own socket, mainly used for testing
         *
         * @return $this
         */
        public function setSocket(\Monolog\Handler\SyslogUdp\UdpSocket $socket): self
        {
        }
    }
    /**
     * Handler sends logs to Telegram using Telegram Bot API.
     *
     * How to use:
     *  1) Create a Telegram bot with https://telegram.me/BotFather;
     *  2) Create a Telegram channel or a group where logs will be recorded;
     *  3) Add the created bot from step 1 to the created channel/group from step 2.
     *
     * In order to create an instance of TelegramBotHandler use
     *  1. The Telegram bot API key from step 1
     *  2. The channel name with the `@` prefix if you created a public channel (e.g. `@my_public_channel`),
     *     or the channel ID with the `-100` prefix if you created a private channel (e.g. `-1001234567890`),
     *     or the group ID from step 2 (e.g. `-1234567890`).
     *
     * @link https://core.telegram.org/bots/api
     *
     * @author Mazur Alexandr <alexandrmazur96@gmail.com>
     */
    class TelegramBotHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        /**
         * @param  string                    $apiKey               Telegram bot access token provided by BotFather
         * @param  string                    $channel              Telegram channel name
         * @param  bool                      $splitLongMessages    Split a message longer than MAX_MESSAGE_LENGTH into parts and send in multiple messages
         * @param  bool                      $delayBetweenMessages Adds delay between sending a split message according to Telegram API
         * @param  int                       $topic                Telegram message thread id, unique identifier for the target message thread (topic) of the forum
         * @throws MissingExtensionException If the curl extension is missing
         */
        public function __construct(string $apiKey, string $channel, $level = \Monolog\Level::Debug, bool $bubble = true, ?string $parseMode = null, ?bool $disableWebPagePreview = null, ?bool $disableNotification = null, bool $splitLongMessages = false, bool $delayBetweenMessages = false, ?int $topic = null)
        {
        }
        /**
         * @return $this
         */
        public function setParseMode(string|null $parseMode = null): self
        {
        }
        /**
         * @return $this
         */
        public function disableWebPagePreview(bool|null $disableWebPagePreview = null): self
        {
        }
        /**
         * @return $this
         */
        public function disableNotification(bool|null $disableNotification = null): self
        {
        }
        /**
         * True - split a message longer than MAX_MESSAGE_LENGTH into parts and send in multiple messages.
         * False - truncates a message that is too long.
         *
         * @return $this
         */
        public function splitLongMessages(bool $splitLongMessages = false): self
        {
        }
        /**
         * Adds 1-second delay between sending a split message (according to Telegram API to avoid 429 Too Many Requests).
         *
         * @return $this
         */
        public function delayBetweenMessages(bool $delayBetweenMessages = false): self
        {
        }
        /**
         * @return $this
         */
        public function setTopic(?int $topic = null): self
        {
        }
        /**
         * @inheritDoc
         */
        public function handleBatch(array $records): void
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * Send request to @link https://api.telegram.org/bot on SendMessage action.
         */
        protected function send(string $message): void
        {
        }
        protected function sendCurl(string $message): void
        {
        }
    }
    /**
     * Used for testing purposes.
     *
     * It records all records and gives you access to them for verification.
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     *
     * @method bool hasEmergency(array{message: string, context?: mixed[]}|string $recordAssertions)
     * @method bool hasAlert(array{message: string, context?: mixed[]}|string $recordAssertions)
     * @method bool hasCritical(array{message: string, context?: mixed[]}|string $recordAssertions)
     * @method bool hasError(array{message: string, context?: mixed[]}|string $recordAssertions)
     * @method bool hasWarning(array{message: string, context?: mixed[]}|string $recordAssertions)
     * @method bool hasNotice(array{message: string, context?: mixed[]}|string $recordAssertions)
     * @method bool hasInfo(array{message: string, context?: mixed[]}|string $recordAssertions)
     * @method bool hasDebug(array{message: string, context?: mixed[]}|string $recordAssertions)
     *
     * @method bool hasEmergencyRecords()
     * @method bool hasAlertRecords()
     * @method bool hasCriticalRecords()
     * @method bool hasErrorRecords()
     * @method bool hasWarningRecords()
     * @method bool hasNoticeRecords()
     * @method bool hasInfoRecords()
     * @method bool hasDebugRecords()
     *
     * @method bool hasEmergencyThatContains(string $message)
     * @method bool hasAlertThatContains(string $message)
     * @method bool hasCriticalThatContains(string $message)
     * @method bool hasErrorThatContains(string $message)
     * @method bool hasWarningThatContains(string $message)
     * @method bool hasNoticeThatContains(string $message)
     * @method bool hasInfoThatContains(string $message)
     * @method bool hasDebugThatContains(string $message)
     *
     * @method bool hasEmergencyThatMatches(string $regex)
     * @method bool hasAlertThatMatches(string $regex)
     * @method bool hasCriticalThatMatches(string $regex)
     * @method bool hasErrorThatMatches(string $regex)
     * @method bool hasWarningThatMatches(string $regex)
     * @method bool hasNoticeThatMatches(string $regex)
     * @method bool hasInfoThatMatches(string $regex)
     * @method bool hasDebugThatMatches(string $regex)
     *
     * @method bool hasEmergencyThatPasses(callable $predicate)
     * @method bool hasAlertThatPasses(callable $predicate)
     * @method bool hasCriticalThatPasses(callable $predicate)
     * @method bool hasErrorThatPasses(callable $predicate)
     * @method bool hasWarningThatPasses(callable $predicate)
     * @method bool hasNoticeThatPasses(callable $predicate)
     * @method bool hasInfoThatPasses(callable $predicate)
     * @method bool hasDebugThatPasses(callable $predicate)
     */
    class TestHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        /** @var LogRecord[] */
        protected array $records = [];
        /** @phpstan-var array<value-of<Level::VALUES>, LogRecord[]> */
        protected array $recordsByLevel = [];
        /**
         * @return array<LogRecord>
         */
        public function getRecords(): array
        {
        }
        public function clear(): void
        {
        }
        public function reset(): void
        {
        }
        public function setSkipReset(bool $skipReset): void
        {
        }
        /**
         * @param int|string|Level|LogLevel::* $level Logging level value or name
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $level
         */
        public function hasRecords(int|string|\Monolog\Level $level): bool
        {
        }
        /**
         * @param string|array $recordAssertions Either a message string or an array containing message and optionally context keys that will be checked against all records
         *
         * @phpstan-param array{message: string, context?: mixed[]}|string $recordAssertions
         */
        public function hasRecord(string|array $recordAssertions, \Monolog\Level $level): bool
        {
        }
        public function hasRecordThatContains(string $message, \Monolog\Level $level): bool
        {
        }
        public function hasRecordThatMatches(string $regex, \Monolog\Level $level): bool
        {
        }
        /**
         * @phpstan-param callable(LogRecord, int): mixed $predicate
         */
        public function hasRecordThatPasses(callable $predicate, \Monolog\Level $level): bool
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * @param mixed[] $args
         */
        public function __call(string $method, array $args): bool
        {
        }
    }
    /**
     * Forwards records to multiple handlers suppressing failures of each handler
     * and continuing through to give every handler a chance to succeed.
     *
     * @author Craig D'Amelio <craig@damelio.ca>
     */
    class WhatFailureGroupHandler extends \Monolog\Handler\GroupHandler
    {
        /**
         * @inheritDoc
         */
        public function handle(\Monolog\LogRecord $record): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function handleBatch(array $records): void
        {
        }
        /**
         * {@inheritDoc}
         */
        public function close(): void
        {
        }
    }
    /**
     * Handler sending logs to Zend Monitor
     *
     * @author  Christian Bergau <cbergau86@gmail.com>
     * @author  Jason Davis <happydude@jasondavis.net>
     */
    class ZendMonitorHandler extends \Monolog\Handler\AbstractProcessingHandler
    {
        /**
         * @throws MissingExtensionException
         */
        public function __construct(int|string|\Monolog\Level $level = \Monolog\Level::Debug, bool $bubble = true)
        {
        }
        /**
         * Translates Monolog log levels to ZendMonitor levels.
         */
        protected function toZendMonitorLevel(\Monolog\Level $level): int
        {
        }
        /**
         * @inheritDoc
         */
        protected function write(\Monolog\LogRecord $record): void
        {
        }
        /**
         * Write to Zend Monitor Events
         * @param string       $type      Text displayed in "Class Name (custom)" field
         * @param string       $message   Text displayed in "Error String"
         * @param array<mixed> $formatted Displayed in Custom Variables tab
         * @param int          $severity  Set the event severity level (-1,0,1)
         */
        protected function writeZendMonitorCustomEvent(string $type, string $message, array $formatted, int $severity): void
        {
        }
        /**
         * @inheritDoc
         */
        public function getDefaultFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
}
namespace Psr\Log {
    /**
     * Describes a logger instance.
     *
     * The message MUST be a string or object implementing __toString().
     *
     * The message MAY contain placeholders in the form: {foo} where foo
     * will be replaced by the context data in key "foo".
     *
     * The context array can contain arbitrary data. The only assumption that
     * can be made by implementors is that if an Exception instance is given
     * to produce a stack trace, it MUST be in a key named "exception".
     *
     * See https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md
     * for the full interface specification.
     */
    interface LoggerInterface
    {
        /**
         * System is unusable.
         *
         * @param mixed[] $context
         */
        public function emergency(string|\Stringable $message, array $context = []): void;
        /**
         * Action must be taken immediately.
         *
         * Example: Entire website down, database unavailable, etc. This should
         * trigger the SMS alerts and wake you up.
         *
         * @param mixed[] $context
         */
        public function alert(string|\Stringable $message, array $context = []): void;
        /**
         * Critical conditions.
         *
         * Example: Application component unavailable, unexpected exception.
         *
         * @param mixed[] $context
         */
        public function critical(string|\Stringable $message, array $context = []): void;
        /**
         * Runtime errors that do not require immediate action but should typically
         * be logged and monitored.
         *
         * @param mixed[] $context
         */
        public function error(string|\Stringable $message, array $context = []): void;
        /**
         * Exceptional occurrences that are not errors.
         *
         * Example: Use of deprecated APIs, poor use of an API, undesirable things
         * that are not necessarily wrong.
         *
         * @param mixed[] $context
         */
        public function warning(string|\Stringable $message, array $context = []): void;
        /**
         * Normal but significant events.
         *
         * @param mixed[] $context
         */
        public function notice(string|\Stringable $message, array $context = []): void;
        /**
         * Interesting events.
         *
         * Example: User logs in, SQL logs.
         *
         * @param mixed[] $context
         */
        public function info(string|\Stringable $message, array $context = []): void;
        /**
         * Detailed debug information.
         *
         * @param mixed[] $context
         */
        public function debug(string|\Stringable $message, array $context = []): void;
        /**
         * Logs with an arbitrary level.
         *
         * @param mixed $level
         * @param mixed[] $context
         *
         * @throws \Psr\Log\InvalidArgumentException
         */
        public function log($level, string|\Stringable $message, array $context = []): void;
    }
}
namespace Monolog {
    /**
     * Monolog log channel
     *
     * It contains a stack of Handlers and a stack of Processors,
     * and uses them to store records that are added to it.
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     * @final
     */
    class Logger implements \Psr\Log\LoggerInterface, \Monolog\ResettableInterface
    {
        /**
         * Detailed debug information
         *
         * @deprecated Use \Monolog\Level::Debug
         */
        public const DEBUG = 100;
        /**
         * Interesting events
         *
         * Examples: User logs in, SQL logs.
         *
         * @deprecated Use \Monolog\Level::Info
         */
        public const INFO = 200;
        /**
         * Uncommon events
         *
         * @deprecated Use \Monolog\Level::Notice
         */
        public const NOTICE = 250;
        /**
         * Exceptional occurrences that are not errors
         *
         * Examples: Use of deprecated APIs, poor use of an API,
         * undesirable things that are not necessarily wrong.
         *
         * @deprecated Use \Monolog\Level::Warning
         */
        public const WARNING = 300;
        /**
         * Runtime errors
         *
         * @deprecated Use \Monolog\Level::Error
         */
        public const ERROR = 400;
        /**
         * Critical conditions
         *
         * Example: Application component unavailable, unexpected exception.
         *
         * @deprecated Use \Monolog\Level::Critical
         */
        public const CRITICAL = 500;
        /**
         * Action must be taken immediately
         *
         * Example: Entire website down, database unavailable, etc.
         * This should trigger the SMS alerts and wake you up.
         *
         * @deprecated Use \Monolog\Level::Alert
         */
        public const ALERT = 550;
        /**
         * Urgent alert.
         *
         * @deprecated Use \Monolog\Level::Emergency
         */
        public const EMERGENCY = 600;
        /**
         * Monolog API version
         *
         * This is only bumped when API breaks are done and should
         * follow the major version of the library
         */
        public const API = 3;
        protected string $name;
        /**
         * The handler stack
         *
         * @var list<HandlerInterface>
         */
        protected array $handlers;
        /**
         * Processors that will process all log records
         *
         * To process records of a single handler instead, add the processor on that specific handler
         *
         * @var array<(callable(LogRecord): LogRecord)|ProcessorInterface>
         */
        protected array $processors;
        protected bool $microsecondTimestamps = true;
        protected \DateTimeZone $timezone;
        protected \Closure|null $exceptionHandler = null;
        /**
         * @param string             $name       The logging channel, a simple descriptive name that is attached to all log records
         * @param list<HandlerInterface> $handlers   Optional stack of handlers, the first one in the array is called first, etc.
         * @param callable[]         $processors Optional array of processors
         * @param DateTimeZone|null  $timezone   Optional timezone, if not provided date_default_timezone_get() will be used
         *
         * @phpstan-param array<(callable(LogRecord): LogRecord)|ProcessorInterface> $processors
         */
        public function __construct(string $name, array $handlers = [], array $processors = [], \DateTimeZone|null $timezone = null)
        {
        }
        public function getName(): string
        {
        }
        /**
         * Return a new cloned instance with the name changed
         *
         * @return static
         */
        public function withName(string $name): self
        {
        }
        /**
         * Pushes a handler on to the stack.
         *
         * @return $this
         */
        public function pushHandler(\Monolog\Handler\HandlerInterface $handler): self
        {
        }
        /**
         * Pops a handler from the stack
         *
         * @throws \LogicException If empty handler stack
         */
        public function popHandler(): \Monolog\Handler\HandlerInterface
        {
        }
        /**
         * Set handlers, replacing all existing ones.
         *
         * If a map is passed, keys will be ignored.
         *
         * @param  list<HandlerInterface> $handlers
         * @return $this
         */
        public function setHandlers(array $handlers): self
        {
        }
        /**
         * @return list<HandlerInterface>
         */
        public function getHandlers(): array
        {
        }
        /**
         * Adds a processor on to the stack.
         *
         * @phpstan-param ProcessorInterface|(callable(LogRecord): LogRecord) $callback
         * @return $this
         */
        public function pushProcessor(\Monolog\Processor\ProcessorInterface|callable $callback): self
        {
        }
        /**
         * Removes the processor on top of the stack and returns it.
         *
         * @phpstan-return ProcessorInterface|(callable(LogRecord): LogRecord)
         * @throws \LogicException If empty processor stack
         */
        public function popProcessor(): callable
        {
        }
        /**
         * @return callable[]
         * @phpstan-return array<ProcessorInterface|(callable(LogRecord): LogRecord)>
         */
        public function getProcessors(): array
        {
        }
        /**
         * Control the use of microsecond resolution timestamps in the 'datetime'
         * member of new records.
         *
         * As of PHP7.1 microseconds are always included by the engine, so
         * there is no performance penalty and Monolog 2 enabled microseconds
         * by default. This function lets you disable them though in case you want
         * to suppress microseconds from the output.
         *
         * @param  bool  $micro True to use microtime() to create timestamps
         * @return $this
         */
        public function useMicrosecondTimestamps(bool $micro): self
        {
        }
        /**
         * @return $this
         */
        public function useLoggingLoopDetection(bool $detectCycles): self
        {
        }
        /**
         * Adds a log record.
         *
         * @param  int                    $level    The logging level (a Monolog or RFC 5424 level)
         * @param  string                 $message  The log message
         * @param  mixed[]                $context  The log context
         * @param  JsonSerializableDateTimeImmutable|null $datetime Optional log date to log into the past or future
         *
         * @return bool                   Whether the record has been processed
         *
         * @phpstan-param value-of<Level::VALUES>|Level $level
         */
        public function addRecord(int|\Monolog\Level $level, string $message, array $context = [], \Monolog\JsonSerializableDateTimeImmutable|null $datetime = null): bool
        {
        }
        /**
         * Ends a log cycle and frees all resources used by handlers.
         *
         * Closing a Handler means flushing all buffers and freeing any open resources/handles.
         * Handlers that have been closed should be able to accept log records again and re-open
         * themselves on demand, but this may not always be possible depending on implementation.
         *
         * This is useful at the end of a request and will be called automatically on every handler
         * when they get destructed.
         */
        public function close(): void
        {
        }
        /**
         * Ends a log cycle and resets all handlers and processors to their initial state.
         *
         * Resetting a Handler or a Processor means flushing/cleaning all buffers, resetting internal
         * state, and getting it back to a state in which it can receive log records again.
         *
         * This is useful in case you want to avoid logs leaking between two requests or jobs when you
         * have a long running process like a worker or an application server serving multiple requests
         * in one process.
         */
        public function reset(): void
        {
        }
        /**
         * Gets the name of the logging level as a string.
         *
         * This still returns a string instead of a Level for BC, but new code should not rely on this method.
         *
         * @throws \Psr\Log\InvalidArgumentException If level is not defined
         *
         * @phpstan-param  value-of<Level::VALUES>|Level $level
         * @phpstan-return value-of<Level::NAMES>
         *
         * @deprecated Since 3.0, use {@see toMonologLevel} or {@see \Monolog\Level->getName()} instead
         */
        public static function getLevelName(int|\Monolog\Level $level): string
        {
        }
        /**
         * Converts PSR-3 levels to Monolog ones if necessary
         *
         * @param  int|string|Level|LogLevel::*      $level Level number (monolog) or name (PSR-3)
         * @throws \Psr\Log\InvalidArgumentException If level is not defined
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $level
         */
        public static function toMonologLevel(string|int|\Monolog\Level $level): \Monolog\Level
        {
        }
        /**
         * Checks whether the Logger has a handler that listens on the given level
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $level
         */
        public function isHandling(int|string|\Monolog\Level $level): bool
        {
        }
        /**
         * Set a custom exception handler that will be called if adding a new record fails
         *
         * The Closure will receive an exception object and the record that failed to be logged
         *
         * @return $this
         */
        public function setExceptionHandler(\Closure|null $callback): self
        {
        }
        public function getExceptionHandler(): \Closure|null
        {
        }
        /**
         * Adds a log record at an arbitrary level.
         *
         * This method allows for compatibility with common interfaces.
         *
         * @param mixed             $level   The log level (a Monolog, PSR-3 or RFC 5424 level)
         * @param string|Stringable $message The log message
         * @param mixed[]           $context The log context
         *
         * @phpstan-param Level|LogLevel::* $level
         */
        public function log($level, string|\Stringable $message, array $context = []): void
        {
        }
        /**
         * Adds a log record at the DEBUG level.
         *
         * This method allows for compatibility with common interfaces.
         *
         * @param string|Stringable $message The log message
         * @param mixed[]           $context The log context
         */
        public function debug(string|\Stringable $message, array $context = []): void
        {
        }
        /**
         * Adds a log record at the INFO level.
         *
         * This method allows for compatibility with common interfaces.
         *
         * @param string|Stringable $message The log message
         * @param mixed[]           $context The log context
         */
        public function info(string|\Stringable $message, array $context = []): void
        {
        }
        /**
         * Adds a log record at the NOTICE level.
         *
         * This method allows for compatibility with common interfaces.
         *
         * @param string|Stringable $message The log message
         * @param mixed[]           $context The log context
         */
        public function notice(string|\Stringable $message, array $context = []): void
        {
        }
        /**
         * Adds a log record at the WARNING level.
         *
         * This method allows for compatibility with common interfaces.
         *
         * @param string|Stringable $message The log message
         * @param mixed[]           $context The log context
         */
        public function warning(string|\Stringable $message, array $context = []): void
        {
        }
        /**
         * Adds a log record at the ERROR level.
         *
         * This method allows for compatibility with common interfaces.
         *
         * @param string|Stringable $message The log message
         * @param mixed[]           $context The log context
         */
        public function error(string|\Stringable $message, array $context = []): void
        {
        }
        /**
         * Adds a log record at the CRITICAL level.
         *
         * This method allows for compatibility with common interfaces.
         *
         * @param string|Stringable $message The log message
         * @param mixed[]           $context The log context
         */
        public function critical(string|\Stringable $message, array $context = []): void
        {
        }
        /**
         * Adds a log record at the ALERT level.
         *
         * This method allows for compatibility with common interfaces.
         *
         * @param string|Stringable $message The log message
         * @param mixed[]           $context The log context
         */
        public function alert(string|\Stringable $message, array $context = []): void
        {
        }
        /**
         * Adds a log record at the EMERGENCY level.
         *
         * This method allows for compatibility with common interfaces.
         *
         * @param string|Stringable $message The log message
         * @param mixed[]           $context The log context
         */
        public function emergency(string|\Stringable $message, array $context = []): void
        {
        }
        /**
         * Sets the timezone to be used for the timestamp of log records.
         *
         * @return $this
         */
        public function setTimezone(\DateTimeZone $tz): self
        {
        }
        /**
         * Returns the timezone to be used for the timestamp of log records.
         */
        public function getTimezone(): \DateTimeZone
        {
        }
        /**
         * Delegates exception management to the custom exception handler,
         * or throws the exception if no custom handler is set.
         */
        protected function handleException(\Throwable $e, \Monolog\LogRecord $record): void
        {
        }
        /**
         * @return array<string, mixed>
         */
        public function __serialize(): array
        {
        }
        /**
         * @param array<string, mixed> $data
         */
        public function __unserialize(array $data): void
        {
        }
    }
    /**
     * Monolog log record
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     * @template-implements ArrayAccess<'message'|'level'|'context'|'level_name'|'channel'|'datetime'|'extra'|'formatted', int|string|\DateTimeImmutable|array<mixed>>
     */
    class LogRecord implements \ArrayAccess
    {
        public function __construct(
            public readonly \DateTimeImmutable $datetime,
            public readonly string $channel,
            public readonly \Monolog\Level $level,
            public readonly string $message,
            /** @var array<mixed> */
            public readonly array $context = [],
            /** @var array<mixed> */
            public array $extra = [],
            public mixed $formatted = null
        )
        {
        }
        public function offsetSet(mixed $offset, mixed $value): void
        {
        }
        public function offsetExists(mixed $offset): bool
        {
        }
        public function offsetUnset(mixed $offset): void
        {
        }
        public function &offsetGet(mixed $offset): mixed
        {
        }
        /**
         * @phpstan-return array{message: string, context: mixed[], level: value-of<Level::VALUES>, level_name: value-of<Level::NAMES>, channel: string, datetime: \DateTimeImmutable, extra: mixed[]}
         */
        public function toArray(): array
        {
        }
        public function with(mixed ...$args): self
        {
        }
    }
}
namespace Monolog\Processor {
    /**
     * An optional interface to allow labelling Monolog processors.
     *
     * @author Nicolas Grekas <p@tchwork.com>
     */
    interface ProcessorInterface
    {
        /**
         * @return LogRecord The processed record
         */
        public function __invoke(\Monolog\LogRecord $record);
    }
    /**
     * Generates a context from a Closure if the Closure is the only value
     * in the context
     *
     * It helps reduce the performance impact of debug logs if they do
     * need to create lots of context information. If this processor is added
     * on the correct handler the context data will only be generated
     * when the logs are actually logged to that handler, which is useful when
     * using FingersCrossedHandler or other filtering handlers to conditionally
     * log records.
     */
    class ClosureContextProcessor implements \Monolog\Processor\ProcessorInterface
    {
        public function __invoke(\Monolog\LogRecord $record): \Monolog\LogRecord
        {
        }
    }
    /**
     * Injects Git branch and Git commit SHA in all records
     *
     * @author Nick Otter
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    class GitProcessor implements \Monolog\Processor\ProcessorInterface
    {
        /**
         * @param int|string|Level|LogLevel::* $level The minimum logging level at which this Processor will be triggered
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $level
         */
        public function __construct(int|string|\Monolog\Level $level = \Monolog\Level::Debug)
        {
        }
        /**
         * @inheritDoc
         */
        public function __invoke(\Monolog\LogRecord $record): \Monolog\LogRecord
        {
        }
    }
    /**
     * Injects value of gethostname in all records
     */
    class HostnameProcessor implements \Monolog\Processor\ProcessorInterface
    {
        public function __construct()
        {
        }
        /**
         * @inheritDoc
         */
        public function __invoke(\Monolog\LogRecord $record): \Monolog\LogRecord
        {
        }
    }
    /**
     * Injects line/file:class/function where the log message came from
     *
     * Warning: This only works if the handler processes the logs directly.
     * If you put the processor on a handler that is behind a FingersCrossedHandler
     * for example, the processor will only be called once the trigger level is reached,
     * and all the log records will have the same file/line/.. data from the call that
     * triggered the FingersCrossedHandler.
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    class IntrospectionProcessor implements \Monolog\Processor\ProcessorInterface
    {
        protected \Monolog\Level $level;
        /** @var string[] */
        protected array $skipClassesPartials;
        protected int $skipStackFramesCount;
        protected const SKIP_FUNCTIONS = ['call_user_func', 'call_user_func_array'];
        protected const SKIP_CLASSES = ['Monolog\\'];
        /**
         * @param string|int|Level $level               The minimum logging level at which this Processor will be triggered
         * @param string[]         $skipClassesPartials
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $level
         */
        public function __construct(int|string|\Monolog\Level $level = \Monolog\Level::Debug, array $skipClassesPartials = [], int $skipStackFramesCount = 0)
        {
        }
        /**
         * @inheritDoc
         */
        public function __invoke(\Monolog\LogRecord $record): \Monolog\LogRecord
        {
        }
    }
    /**
     * Injects sys_getloadavg in all records @see https://www.php.net/manual/en/function.sys-getloadavg.php
     *
     * @author Johan Vlaar <johan.vlaar.1994@gmail.com>
     */
    class LoadAverageProcessor implements \Monolog\Processor\ProcessorInterface
    {
        public const LOAD_1_MINUTE = 0;
        public const LOAD_5_MINUTE = 1;
        public const LOAD_15_MINUTE = 2;
        /**
         * @var int
         */
        protected $avgSystemLoad;
        /**
         * @param self::LOAD_* $avgSystemLoad
         */
        public function __construct(int $avgSystemLoad = self::LOAD_1_MINUTE)
        {
        }
        /**
         * {@inheritDoc}
         */
        public function __invoke(\Monolog\LogRecord $record): \Monolog\LogRecord
        {
        }
    }
    /**
     * Some methods that are common for all memory processors
     *
     * @author Rob Jensen
     */
    abstract class MemoryProcessor implements \Monolog\Processor\ProcessorInterface
    {
        /**
         * @var bool If true, get the real size of memory allocated from system. Else, only the memory used by emalloc() is reported.
         */
        protected bool $realUsage;
        /**
         * @var bool If true, then format memory size to human readable string (MB, KB, B depending on size)
         */
        protected bool $useFormatting;
        /**
         * @param bool $realUsage     Set this to true to get the real size of memory allocated from system.
         * @param bool $useFormatting If true, then format memory size to human readable string (MB, KB, B depending on size)
         */
        public function __construct(bool $realUsage = true, bool $useFormatting = true)
        {
        }
        /**
         * Formats bytes into a human readable string if $this->useFormatting is true, otherwise return $bytes as is
         *
         * @return string|int Formatted string if $this->useFormatting is true, otherwise return $bytes as int
         */
        protected function formatBytes(int $bytes)
        {
        }
    }
    /**
     * Injects memory_get_peak_usage in all records
     *
     * @see Monolog\Processor\MemoryProcessor::__construct() for options
     * @author Rob Jensen
     */
    class MemoryPeakUsageProcessor extends \Monolog\Processor\MemoryProcessor
    {
        /**
         * @inheritDoc
         */
        public function __invoke(\Monolog\LogRecord $record): \Monolog\LogRecord
        {
        }
    }
    /**
     * Injects memory_get_usage in all records
     *
     * @see Monolog\Processor\MemoryProcessor::__construct() for options
     * @author Rob Jensen
     */
    class MemoryUsageProcessor extends \Monolog\Processor\MemoryProcessor
    {
        /**
         * @inheritDoc
         */
        public function __invoke(\Monolog\LogRecord $record): \Monolog\LogRecord
        {
        }
    }
    /**
     * Injects Hg branch and Hg revision number in all records
     *
     * @author Jonathan A. Schweder <jonathanschweder@gmail.com>
     */
    class MercurialProcessor implements \Monolog\Processor\ProcessorInterface
    {
        /**
         * @param int|string|Level $level The minimum logging level at which this Processor will be triggered
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $level
         */
        public function __construct(int|string|\Monolog\Level $level = \Monolog\Level::Debug)
        {
        }
        /**
         * @inheritDoc
         */
        public function __invoke(\Monolog\LogRecord $record): \Monolog\LogRecord
        {
        }
    }
    /**
     * Adds value of getmypid into records
     *
     * @author Andreas Hörnicke
     */
    class ProcessIdProcessor implements \Monolog\Processor\ProcessorInterface
    {
        /**
         * @inheritDoc
         */
        public function __invoke(\Monolog\LogRecord $record): \Monolog\LogRecord
        {
        }
    }
    /**
     * Processes a record's message according to PSR-3 rules
     *
     * It replaces {foo} with the value from $context['foo']
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    class PsrLogMessageProcessor implements \Monolog\Processor\ProcessorInterface
    {
        public const SIMPLE_DATE = "Y-m-d\\TH:i:s.uP";
        /**
         * @param string|null $dateFormat              The format of the timestamp: one supported by DateTime::format
         * @param bool        $removeUsedContextFields If set to true the fields interpolated into message gets unset
         */
        public function __construct(?string $dateFormat = null, bool $removeUsedContextFields = false)
        {
        }
        /**
         * @inheritDoc
         */
        public function __invoke(\Monolog\LogRecord $record): \Monolog\LogRecord
        {
        }
    }
    /**
     * Adds a tags array into record
     *
     * @author Martijn Riemers
     */
    class TagProcessor implements \Monolog\Processor\ProcessorInterface
    {
        /**
         * @param string[] $tags
         */
        public function __construct(array $tags = [])
        {
        }
        /**
         * @param  string[] $tags
         * @return $this
         */
        public function addTags(array $tags = []): self
        {
        }
        /**
         * @param  string[] $tags
         * @return $this
         */
        public function setTags(array $tags = []): self
        {
        }
        /**
         * @inheritDoc
         */
        public function __invoke(\Monolog\LogRecord $record): \Monolog\LogRecord
        {
        }
    }
    /**
     * Adds a unique identifier into records
     *
     * @author Simon Mönch <sm@webfactory.de>
     */
    class UidProcessor implements \Monolog\Processor\ProcessorInterface, \Monolog\ResettableInterface
    {
        /**
         * @param int<1, 32> $length
         */
        public function __construct(int $length = 7)
        {
        }
        /**
         * @inheritDoc
         */
        public function __invoke(\Monolog\LogRecord $record): \Monolog\LogRecord
        {
        }
        public function getUid(): string
        {
        }
        public function reset(): void
        {
        }
    }
    /**
     * Injects url/method and remote IP of the current web request in all records
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     */
    class WebProcessor implements \Monolog\Processor\ProcessorInterface
    {
        /**
         * @var array<string, mixed>|ArrayAccess<string, mixed>
         */
        protected array|\ArrayAccess $serverData;
        /**
         * Default fields
         *
         * Array is structured as [key in record.extra => key in $serverData]
         *
         * @var array<string, string>
         */
        protected array $extraFields = ['url' => 'REQUEST_URI', 'ip' => 'REMOTE_ADDR', 'http_method' => 'REQUEST_METHOD', 'server' => 'SERVER_NAME', 'referrer' => 'HTTP_REFERER', 'user_agent' => 'HTTP_USER_AGENT'];
        /**
         * @param array<string, mixed>|ArrayAccess<string, mixed>|null $serverData  Array or object w/ ArrayAccess that provides access to the $_SERVER data
         * @param array<string, string>|array<string>|null             $extraFields Field names and the related key inside $serverData to be added (or just a list of field names to use the default configured $serverData mapping). If not provided it defaults to: [url, ip, http_method, server, referrer] + unique_id if present in server data
         */
        public function __construct(array|\ArrayAccess|null $serverData = null, array|null $extraFields = null)
        {
        }
        /**
         * @inheritDoc
         */
        public function __invoke(\Monolog\LogRecord $record): \Monolog\LogRecord
        {
        }
        /**
         * @return $this
         */
        public function addExtraField(string $extraName, string $serverName): self
        {
        }
    }
}
namespace Monolog {
    /**
     * Monolog log registry
     *
     * Allows to get `Logger` instances in the global scope
     * via static method calls on this class.
     *
     * <code>
     * $application = new Monolog\Logger('application');
     * $api = new Monolog\Logger('api');
     *
     * Monolog\Registry::addLogger($application);
     * Monolog\Registry::addLogger($api);
     *
     * function testLogger()
     * {
     *     Monolog\Registry::api()->error('Sent to $api Logger instance');
     *     Monolog\Registry::application()->error('Sent to $application Logger instance');
     * }
     * </code>
     *
     * @author Tomas Tatarko <tomas@tatarko.sk>
     */
    class Registry
    {
        /**
         * Adds new logging channel to the registry
         *
         * @param  Logger                    $logger    Instance of the logging channel
         * @param  string|null               $name      Name of the logging channel ($logger->getName() by default)
         * @param  bool                      $overwrite Overwrite instance in the registry if the given name already exists?
         * @throws \InvalidArgumentException If $overwrite set to false and named Logger instance already exists
         */
        public static function addLogger(\Monolog\Logger $logger, ?string $name = null, bool $overwrite = false): void
        {
        }
        /**
         * Checks if such logging channel exists by name or instance
         *
         * @param string|Logger $logger Name or logger instance
         */
        public static function hasLogger($logger): bool
        {
        }
        /**
         * Removes instance from registry by name or instance
         *
         * @param string|Logger $logger Name or logger instance
         */
        public static function removeLogger($logger): void
        {
        }
        /**
         * Clears the registry
         */
        public static function clear(): void
        {
        }
        /**
         * Gets Logger instance from the registry
         *
         * @param  string                    $name Name of the requested Logger instance
         * @throws \InvalidArgumentException If named Logger instance is not in the registry
         */
        public static function getInstance(string $name): \Monolog\Logger
        {
        }
        /**
         * Gets Logger instance from the registry via static method call
         *
         * @param  string                    $name      Name of the requested Logger instance
         * @param  mixed[]                   $arguments Arguments passed to static method call
         * @throws \InvalidArgumentException If named Logger instance is not in the registry
         * @return Logger                    Requested instance of Logger
         */
        public static function __callStatic(string $name, array $arguments): \Monolog\Logger
        {
        }
    }
    /**
     * Monolog POSIX signal handler
     *
     * @author Robert Gust-Bardon <robert@gust-bardon.org>
     */
    class SignalHandler
    {
        public function __construct(\Psr\Log\LoggerInterface $logger)
        {
        }
        /**
         * @param  int|string|Level $level Level or level name
         * @return $this
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $level
         */
        public function registerSignalHandler(int $signo, int|string|\Monolog\Level $level = \Psr\Log\LogLevel::CRITICAL, bool $callPrevious = true, bool $restartSyscalls = true, ?bool $async = true): self
        {
        }
        /**
         * @param mixed $siginfo
         */
        public function handleSignal(int $signo, $siginfo = null): void
        {
        }
    }
}
namespace Monolog\Test {
    /**
     * Lets you easily generate log records and a dummy formatter for testing purposes
     *
     * @author Jordi Boggiano <j.boggiano@seld.be>
     *
     * @internal feel free to reuse this to test your own handlers, this is marked internal to avoid issues with PHPStorm https://github.com/Seldaek/monolog/issues/1677
     */
    class TestCase extends \PHPUnit\Framework\TestCase
    {
        /**
         * @param array<mixed> $context
         * @param array<mixed> $extra
         *
         * @phpstan-param value-of<Level::VALUES>|value-of<Level::NAMES>|Level|LogLevel::* $level
         */
        protected function getRecord(int|string|\Monolog\Level $level = \Monolog\Level::Warning, string|\Stringable $message = 'test', array $context = [], string $channel = 'test', \DateTimeImmutable $datetime = new \Monolog\JsonSerializableDateTimeImmutable(true), array $extra = []): \Monolog\LogRecord
        {
        }
        /**
         * @phpstan-return list<LogRecord>
         */
        protected function getMultipleRecords(): array
        {
        }
        protected function getIdentityFormatter(): \Monolog\Formatter\FormatterInterface
        {
        }
    }
}
namespace Monolog {
    final class Utils
    {
        const DEFAULT_JSON_FLAGS = JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE | JSON_PRESERVE_ZERO_FRACTION | JSON_INVALID_UTF8_SUBSTITUTE | JSON_PARTIAL_OUTPUT_ON_ERROR;
        public static function getClass(object $object): string
        {
        }
        public static function substr(string $string, int $start, ?int $length = null): string
        {
        }
        /**
         * Makes sure if a relative path is passed in it is turned into an absolute path
         *
         * @param string $streamUrl stream URL or path without protocol
         */
        public static function canonicalizePath(string $streamUrl): string
        {
        }
        /**
         * Return the JSON representation of a value
         *
         * @param  mixed             $data
         * @param  int               $encodeFlags  flags to pass to json encode, defaults to DEFAULT_JSON_FLAGS
         * @param  bool              $ignoreErrors whether to ignore encoding errors or to throw on error, when ignored and the encoding fails, "null" is returned which is valid json for null
         * @throws \RuntimeException if encoding fails and errors are not ignored
         * @return string            when errors are ignored and the encoding fails, "null" is returned which is valid json for null
         */
        public static function jsonEncode($data, ?int $encodeFlags = null, bool $ignoreErrors = false): string
        {
        }
        /**
         * Handle a json_encode failure.
         *
         * If the failure is due to invalid string encoding, try to clean the
         * input and encode again. If the second encoding attempt fails, the
         * initial error is not encoding related or the input can't be cleaned then
         * raise a descriptive exception.
         *
         * @param  int               $code        return code of json_last_error function
         * @param  mixed             $data        data that was meant to be encoded
         * @param  int               $encodeFlags flags to pass to json encode, defaults to JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE | JSON_PRESERVE_ZERO_FRACTION
         * @throws \RuntimeException if failure can't be corrected
         * @return string            JSON encoded data after error correction
         */
        public static function handleJsonError(int $code, $data, ?int $encodeFlags = null): string
        {
        }
        /**
         * Converts a string with a valid 'memory_limit' format, to bytes.
         *
         * @param  string|false $val
         * @return int|false    Returns an integer representing bytes. Returns FALSE in case of error.
         */
        public static function expandIniShorthandBytes($val)
        {
        }
        public static function getRecordMessageForException(\Monolog\LogRecord $record): string
        {
        }
    }
}
namespace FastRoute {
    class BadRouteException extends \LogicException
    {
    }
    interface DataGenerator
    {
        /**
         * Adds a route to the data generator. The route data uses the
         * same format that is returned by RouterParser::parser().
         *
         * The handler doesn't necessarily need to be a callable, it
         * can be arbitrary data that will be returned when the route
         * matches.
         *
         * @param string $httpMethod
         * @param array $routeData
         * @param mixed $handler
         */
        public function addRoute($httpMethod, $routeData, $handler);
        /**
         * Returns dispatcher data in some unspecified format, which
         * depends on the used method of dispatch.
         */
        public function getData();
    }
}
namespace FastRoute\DataGenerator {
    abstract class RegexBasedAbstract implements \FastRoute\DataGenerator
    {
        /** @var mixed[][] */
        protected $staticRoutes = [];
        /** @var Route[][] */
        protected $methodToRegexToRoutesMap = [];
        /**
         * @return int
         */
        abstract protected function getApproxChunkSize();
        /**
         * @return mixed[]
         */
        abstract protected function processChunk($regexToRoutesMap);
        public function addRoute($httpMethod, $routeData, $handler)
        {
        }
        /**
         * @return mixed[]
         */
        public function getData()
        {
        }
    }
    class CharCountBased extends \FastRoute\DataGenerator\RegexBasedAbstract
    {
        protected function getApproxChunkSize()
        {
        }
        protected function processChunk($regexToRoutesMap)
        {
        }
    }
    class GroupCountBased extends \FastRoute\DataGenerator\RegexBasedAbstract
    {
        protected function getApproxChunkSize()
        {
        }
        protected function processChunk($regexToRoutesMap)
        {
        }
    }
    class GroupPosBased extends \FastRoute\DataGenerator\RegexBasedAbstract
    {
        protected function getApproxChunkSize()
        {
        }
        protected function processChunk($regexToRoutesMap)
        {
        }
    }
    class MarkBased extends \FastRoute\DataGenerator\RegexBasedAbstract
    {
        protected function getApproxChunkSize()
        {
        }
        protected function processChunk($regexToRoutesMap)
        {
        }
    }
}
namespace FastRoute {
    interface Dispatcher
    {
        const NOT_FOUND = 0;
        const FOUND = 1;
        const METHOD_NOT_ALLOWED = 2;
        /**
         * Dispatches against the provided HTTP method verb and URI.
         *
         * Returns array with one of the following formats:
         *
         *     [self::NOT_FOUND]
         *     [self::METHOD_NOT_ALLOWED, ['GET', 'OTHER_ALLOWED_METHODS']]
         *     [self::FOUND, $handler, ['varName' => 'value', ...]]
         *
         * @param string $httpMethod
         * @param string $uri
         *
         * @return array
         */
        public function dispatch($httpMethod, $uri);
    }
}
namespace FastRoute\Dispatcher {
    abstract class RegexBasedAbstract implements \FastRoute\Dispatcher
    {
        /** @var mixed[][] */
        protected $staticRouteMap = [];
        /** @var mixed[] */
        protected $variableRouteData = [];
        /**
         * @return mixed[]
         */
        abstract protected function dispatchVariableRoute($routeData, $uri);
        public function dispatch($httpMethod, $uri)
        {
        }
    }
    class CharCountBased extends \FastRoute\Dispatcher\RegexBasedAbstract
    {
        public function __construct($data)
        {
        }
        protected function dispatchVariableRoute($routeData, $uri)
        {
        }
    }
    class GroupCountBased extends \FastRoute\Dispatcher\RegexBasedAbstract
    {
        public function __construct($data)
        {
        }
        protected function dispatchVariableRoute($routeData, $uri)
        {
        }
    }
    class GroupPosBased extends \FastRoute\Dispatcher\RegexBasedAbstract
    {
        public function __construct($data)
        {
        }
        protected function dispatchVariableRoute($routeData, $uri)
        {
        }
    }
    class MarkBased extends \FastRoute\Dispatcher\RegexBasedAbstract
    {
        public function __construct($data)
        {
        }
        protected function dispatchVariableRoute($routeData, $uri)
        {
        }
    }
}
namespace FastRoute {
    class Route
    {
        /** @var string */
        public $httpMethod;
        /** @var string */
        public $regex;
        /** @var array */
        public $variables;
        /** @var mixed */
        public $handler;
        /**
         * Constructs a route (value object).
         *
         * @param string $httpMethod
         * @param mixed  $handler
         * @param string $regex
         * @param array  $variables
         */
        public function __construct($httpMethod, $handler, $regex, $variables)
        {
        }
        /**
         * Tests whether this route matches the given string.
         *
         * @param string $str
         *
         * @return bool
         */
        public function matches($str)
        {
        }
    }
    class RouteCollector
    {
        /** @var RouteParser */
        protected $routeParser;
        /** @var DataGenerator */
        protected $dataGenerator;
        /** @var string */
        protected $currentGroupPrefix;
        /**
         * Constructs a route collector.
         *
         * @param RouteParser   $routeParser
         * @param DataGenerator $dataGenerator
         */
        public function __construct(\FastRoute\RouteParser $routeParser, \FastRoute\DataGenerator $dataGenerator)
        {
        }
        /**
         * Adds a route to the collection.
         *
         * The syntax used in the $route string depends on the used route parser.
         *
         * @param string|string[] $httpMethod
         * @param string $route
         * @param mixed  $handler
         */
        public function addRoute($httpMethod, $route, $handler)
        {
        }
        /**
         * Create a route group with a common prefix.
         *
         * All routes created in the passed callback will have the given group prefix prepended.
         *
         * @param string $prefix
         * @param callable $callback
         */
        public function addGroup($prefix, callable $callback)
        {
        }
        /**
         * Adds a GET route to the collection
         * 
         * This is simply an alias of $this->addRoute('GET', $route, $handler)
         *
         * @param string $route
         * @param mixed  $handler
         */
        public function get($route, $handler)
        {
        }
        /**
         * Adds a POST route to the collection
         * 
         * This is simply an alias of $this->addRoute('POST', $route, $handler)
         *
         * @param string $route
         * @param mixed  $handler
         */
        public function post($route, $handler)
        {
        }
        /**
         * Adds a PUT route to the collection
         * 
         * This is simply an alias of $this->addRoute('PUT', $route, $handler)
         *
         * @param string $route
         * @param mixed  $handler
         */
        public function put($route, $handler)
        {
        }
        /**
         * Adds a DELETE route to the collection
         * 
         * This is simply an alias of $this->addRoute('DELETE', $route, $handler)
         *
         * @param string $route
         * @param mixed  $handler
         */
        public function delete($route, $handler)
        {
        }
        /**
         * Adds a PATCH route to the collection
         * 
         * This is simply an alias of $this->addRoute('PATCH', $route, $handler)
         *
         * @param string $route
         * @param mixed  $handler
         */
        public function patch($route, $handler)
        {
        }
        /**
         * Adds a HEAD route to the collection
         *
         * This is simply an alias of $this->addRoute('HEAD', $route, $handler)
         *
         * @param string $route
         * @param mixed  $handler
         */
        public function head($route, $handler)
        {
        }
        /**
         * Returns the collected route data, as provided by the data generator.
         *
         * @return array
         */
        public function getData()
        {
        }
    }
    interface RouteParser
    {
        /**
         * Parses a route string into multiple route data arrays.
         *
         * The expected output is defined using an example:
         *
         * For the route string "/fixedRoutePart/{varName}[/moreFixed/{varName2:\d+}]", if {varName} is interpreted as
         * a placeholder and [...] is interpreted as an optional route part, the expected result is:
         *
         * [
         *     // first route: without optional part
         *     [
         *         "/fixedRoutePart/",
         *         ["varName", "[^/]+"],
         *     ],
         *     // second route: with optional part
         *     [
         *         "/fixedRoutePart/",
         *         ["varName", "[^/]+"],
         *         "/moreFixed/",
         *         ["varName2", [0-9]+"],
         *     ],
         * ]
         *
         * Here one route string was converted into two route data arrays.
         *
         * @param string $route Route string to parse
         *
         * @return mixed[][] Array of route data arrays
         */
        public function parse($route);
    }
}
namespace FastRoute\RouteParser {
    /**
     * Parses route strings of the following form:
     *
     * "/user/{name}[/{id:[0-9]+}]"
     */
    class Std implements \FastRoute\RouteParser
    {
        const VARIABLE_REGEX = <<<'REGEX'
        \{
            \s* ([a-zA-Z_][a-zA-Z0-9_-]*) \s*
            (?:
                : \s* ([^{}]*(?:\{(?-1)\}[^{}]*)*)
            )?
        \}
        REGEX;
        const DEFAULT_DISPATCH_REGEX = '[^/]+';
        public function parse($route)
        {
        }
    }
}
namespace FastRoute\Dispatcher {
    abstract class DispatcherTest extends \PHPUnit\Framework\TestCase
    {
        /**
         * Delegate dispatcher selection to child test classes
         */
        abstract protected function getDispatcherClass();
        /**
         * Delegate dataGenerator selection to child test classes
         */
        abstract protected function getDataGeneratorClass();
        /**
         * @dataProvider provideFoundDispatchCases
         */
        public function testFoundDispatches($method, $uri, $callback, $handler, $argDict)
        {
        }
        /**
         * @dataProvider provideNotFoundDispatchCases
         */
        public function testNotFoundDispatches($method, $uri, $callback)
        {
        }
        /**
         * @dataProvider provideMethodNotAllowedDispatchCases
         */
        public function testMethodNotAllowedDispatches($method, $uri, $callback, $availableMethods)
        {
        }
        /**
         * @expectedException \FastRoute\BadRouteException
         * @expectedExceptionMessage Cannot use the same placeholder "test" twice
         */
        public function testDuplicateVariableNameError()
        {
        }
        /**
         * @expectedException \FastRoute\BadRouteException
         * @expectedExceptionMessage Cannot register two routes matching "/user/([^/]+)" for method "GET"
         */
        public function testDuplicateVariableRoute()
        {
        }
        /**
         * @expectedException \FastRoute\BadRouteException
         * @expectedExceptionMessage Cannot register two routes matching "/user" for method "GET"
         */
        public function testDuplicateStaticRoute()
        {
        }
        /**
         * @expectedException \FastRoute\BadRouteException
         * @expectedExceptionMessage Static route "/user/nikic" is shadowed by previously defined variable route "/user/([^/]+)" for method "GET"
         */
        public function testShadowedStaticRoute()
        {
        }
        /**
         * @expectedException \FastRoute\BadRouteException
         * @expectedExceptionMessage Regex "(en|de)" for parameter "lang" contains a capturing group
         */
        public function testCapturing()
        {
        }
        public function provideFoundDispatchCases()
        {
        }
        public function provideNotFoundDispatchCases()
        {
        }
        public function provideMethodNotAllowedDispatchCases()
        {
        }
    }
    class CharCountBasedTest extends \FastRoute\Dispatcher\DispatcherTest
    {
        protected function getDispatcherClass()
        {
        }
        protected function getDataGeneratorClass()
        {
        }
    }
    class GroupCountBasedTest extends \FastRoute\Dispatcher\DispatcherTest
    {
        protected function getDispatcherClass()
        {
        }
        protected function getDataGeneratorClass()
        {
        }
    }
    class GroupPosBasedTest extends \FastRoute\Dispatcher\DispatcherTest
    {
        protected function getDispatcherClass()
        {
        }
        protected function getDataGeneratorClass()
        {
        }
    }
    class MarkBasedTest extends \FastRoute\Dispatcher\DispatcherTest
    {
        public function setUp()
        {
        }
        protected function getDispatcherClass()
        {
        }
        protected function getDataGeneratorClass()
        {
        }
    }
}
namespace FastRoute {
    class HackTypecheckerTest extends \PHPUnit\Framework\TestCase
    {
        const SERVER_ALREADY_RUNNING_CODE = 77;
        public function testTypechecks($recurse = true)
        {
        }
    }
    class RouteCollectorTest extends \PHPUnit\Framework\TestCase
    {
        public function testShortcuts()
        {
        }
        public function testGroups()
        {
        }
    }
    class DummyRouteCollector extends \FastRoute\RouteCollector
    {
        public $routes = [];
        public function __construct()
        {
        }
        public function addRoute($method, $route, $handler)
        {
        }
    }
}
namespace FastRoute\RouteParser {
    class StdTest extends \PHPUnit\Framework\TestCase
    {
        /** @dataProvider provideTestParse */
        public function testParse($routeString, $expectedRouteDatas)
        {
        }
        /** @dataProvider provideTestParseError */
        public function testParseError($routeString, $expectedExceptionMessage)
        {
        }
        public function provideTestParse()
        {
        }
        public function provideTestParseError()
        {
        }
    }
}
namespace OomphInc\ComposerInstallersExtender\Installers {
    /**
     * Provides a custom installer class for custom installer types.
     *
     * By default, the parent class has no specified locations. By not providing an
     * array of locations we are forcing the installer to use custom installer
     * paths.
     */
    class CustomInstaller extends \Composer\Installers\BaseInstaller
    {
    }
    class Installer extends \Composer\Installers\Installer
    {
        /**
         * A list of installer types.
         *
         * @var array
         */
        protected $installerTypes;
        /**
         * {@inheritDoc}
         */
        public function getInstallPath(\Composer\Package\PackageInterface $package): string
        {
        }
        /**
         * {@inheritDoc}
         */
        public function supports($packageType): bool
        {
        }
        /**
         * Get a list of custom installer types.
         *
         * @return array
         */
        public function getInstallerTypes(): array
        {
        }
    }
}
namespace OomphInc\ComposerInstallersExtender {
    class Plugin implements \Composer\Plugin\PluginInterface
    {
        /**
         * {@inheritDoc}
         */
        public function activate(\Composer\Composer $composer, \Composer\IO\IOInterface $io): void
        {
        }
        /**
         * {@inheritDoc}
         */
        public function deactivate(\Composer\Composer $composer, \Composer\IO\IOInterface $io): void
        {
        }
        /**
         * {@inheritDoc}
         */
        public function uninstall(\Composer\Composer $composer, \Composer\IO\IOInterface $io): void
        {
        }
    }
}
namespace OomphInc\ComposerInstallersExtender\Tests\Installers {
    class CustomInstallerTest extends \PHPUnit\Framework\TestCase
    {
        public function testLocations(): void
        {
        }
    }
}
namespace OomphInc\ComposerInstallersExtender\Installers {
    class InstallerTest extends \PHPUnit\Framework\TestCase
    {
        protected $composer;
        protected $io;
        public function setUp(): void
        {
        }
        public function testGetInstallPath(): void
        {
        }
        public function testSupports(): void
        {
        }
        /**
         * @dataProvider installerTypesDataProvider
         */
        public function testGetInstallerTypes($package, array $expected): void
        {
        }
        public function installerTypesDataProvider(): array
        {
        }
    }
}
namespace OomphInc\ComposerInstallersExtender\Tests {
    class PluginTest extends \PHPUnit\Framework\TestCase
    {
        protected $composer;
        protected $io;
        public function setUp(): void
        {
        }
        public function testActive(): void
        {
        }
    }
}
namespace ParagonIE\ConstantTime {
    /**
     *  Copyright (c) 2016 - 2022 Paragon Initiative Enterprises.
     *  Copyright (c) 2014 Steve "Sc00bz" Thomas (steve at tobtu dot com)
     *
     *  Permission is hereby granted, free of charge, to any person obtaining a copy
     *  of this software and associated documentation files (the "Software"), to deal
     *  in the Software without restriction, including without limitation the rights
     *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     *  copies of the Software, and to permit persons to whom the Software is
     *  furnished to do so, subject to the following conditions:
     *
     *  The above copyright notice and this permission notice shall be included in all
     *  copies or substantial portions of the Software.
     *
     *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     *  SOFTWARE.
     */
    /**
     * Interface EncoderInterface
     * @package ParagonIE\ConstantTime
     */
    interface EncoderInterface
    {
        /**
         * Convert a binary string into a hexadecimal string without cache-timing
         * leaks
         *
         * @param string $binString (raw binary)
         * @return string
         */
        public static function encode(string $binString): string;
        /**
         * Convert a binary string into a hexadecimal string without cache-timing
         * leaks
         *
         * @param string $encodedString
         * @param bool $strictPadding Error on invalid padding
         * @return string (raw binary)
         */
        public static function decode(string $encodedString, bool $strictPadding = false): string;
    }
    /**
     *  Copyright (c) 2016 - 2022 Paragon Initiative Enterprises.
     *  Copyright (c) 2014 Steve "Sc00bz" Thomas (steve at tobtu dot com)
     *
     *  Permission is hereby granted, free of charge, to any person obtaining a copy
     *  of this software and associated documentation files (the "Software"), to deal
     *  in the Software without restriction, including without limitation the rights
     *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     *  copies of the Software, and to permit persons to whom the Software is
     *  furnished to do so, subject to the following conditions:
     *
     *  The above copyright notice and this permission notice shall be included in all
     *  copies or substantial portions of the Software.
     *
     *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     *  SOFTWARE.
     */
    /**
     * Class Base32
     * [A-Z][2-7]
     *
     * @package ParagonIE\ConstantTime
     */
    abstract class Base32 implements \ParagonIE\ConstantTime\EncoderInterface
    {
        /**
         * Decode a Base32-encoded string into raw binary
         *
         * @param string $encodedString
         * @param bool $strictPadding
         * @return string
         */
        public static function decode(
            #[\SensitiveParameter]
            string $encodedString,
            bool $strictPadding = false
        ): string
        {
        }
        /**
         * Decode an uppercase Base32-encoded string into raw binary
         *
         * @param string $src
         * @param bool $strictPadding
         * @return string
         */
        public static function decodeUpper(
            #[\SensitiveParameter]
            string $src,
            bool $strictPadding = false
        ): string
        {
        }
        /**
         * Encode into Base32 (RFC 4648)
         *
         * @param string $binString
         * @return string
         * @throws TypeError
         */
        public static function encode(
            #[\SensitiveParameter]
            string $binString
        ): string
        {
        }
        /**
         * Encode into Base32 (RFC 4648)
         *
         * @param string $src
         * @return string
         * @throws TypeError
         */
        public static function encodeUnpadded(
            #[\SensitiveParameter]
            string $src
        ): string
        {
        }
        /**
         * Encode into uppercase Base32 (RFC 4648)
         *
         * @param string $src
         * @return string
         * @throws TypeError
         */
        public static function encodeUpper(
            #[\SensitiveParameter]
            string $src
        ): string
        {
        }
        /**
         * Encode into uppercase Base32 (RFC 4648)
         *
         * @param string $src
         * @return string
         * @throws TypeError
         */
        public static function encodeUpperUnpadded(
            #[\SensitiveParameter]
            string $src
        ): string
        {
        }
        /**
         * Uses bitwise operators instead of table-lookups to turn 5-bit integers
         * into 8-bit integers.
         *
         * @param int $src
         * @return int
         */
        protected static function decode5Bits(int $src): int
        {
        }
        /**
         * Uses bitwise operators instead of table-lookups to turn 5-bit integers
         * into 8-bit integers.
         *
         * Uppercase variant.
         *
         * @param int $src
         * @return int
         */
        protected static function decode5BitsUpper(int $src): int
        {
        }
        /**
         * Uses bitwise operators instead of table-lookups to turn 8-bit integers
         * into 5-bit integers.
         *
         * @param int $src
         * @return string
         */
        protected static function encode5Bits(int $src): string
        {
        }
        /**
         * Uses bitwise operators instead of table-lookups to turn 8-bit integers
         * into 5-bit integers.
         *
         * Uppercase variant.
         *
         * @param int $src
         * @return string
         */
        protected static function encode5BitsUpper(int $src): string
        {
        }
        /**
         * @param string $encodedString
         * @param bool $upper
         * @return string
         */
        public static function decodeNoPadding(
            #[\SensitiveParameter]
            string $encodedString,
            bool $upper = false
        ): string
        {
        }
        /**
         * Base32 decoding
         *
         * @param string $src
         * @param bool $upper
         * @param bool $strictPadding
         * @return string
         *
         * @throws TypeError
         */
        protected static function doDecode(
            #[\SensitiveParameter]
            string $src,
            bool $upper = false,
            bool $strictPadding = false
        ): string
        {
        }
        /**
         * Base32 Encoding
         *
         * @param string $src
         * @param bool $upper
         * @param bool $pad
         * @return string
         * @throws TypeError
         */
        protected static function doEncode(
            #[\SensitiveParameter]
            string $src,
            bool $upper = false,
            $pad = true
        ): string
        {
        }
    }
    /**
     *  Copyright (c) 2016 - 2022 Paragon Initiative Enterprises.
     *  Copyright (c) 2014 Steve "Sc00bz" Thomas (steve at tobtu dot com)
     *
     *  Permission is hereby granted, free of charge, to any person obtaining a copy
     *  of this software and associated documentation files (the "Software"), to deal
     *  in the Software without restriction, including without limitation the rights
     *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     *  copies of the Software, and to permit persons to whom the Software is
     *  furnished to do so, subject to the following conditions:
     *
     *  The above copyright notice and this permission notice shall be included in all
     *  copies or substantial portions of the Software.
     *
     *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     *  SOFTWARE.
     */
    /**
     * Class Base32Hex
     * [0-9][A-V]
     *
     * @package ParagonIE\ConstantTime
     */
    abstract class Base32Hex extends \ParagonIE\ConstantTime\Base32
    {
        /**
         * Uses bitwise operators instead of table-lookups to turn 5-bit integers
         * into 8-bit integers.
         *
         * @param int $src
         * @return int
         */
        protected static function decode5Bits(int $src): int
        {
        }
        /**
         * Uses bitwise operators instead of table-lookups to turn 5-bit integers
         * into 8-bit integers.
         *
         * @param int $src
         * @return int
         */
        protected static function decode5BitsUpper(int $src): int
        {
        }
        /**
         * Uses bitwise operators instead of table-lookups to turn 8-bit integers
         * into 5-bit integers.
         *
         * @param int $src
         * @return string
         */
        protected static function encode5Bits(int $src): string
        {
        }
        /**
         * Uses bitwise operators instead of table-lookups to turn 8-bit integers
         * into 5-bit integers.
         *
         * Uppercase variant.
         *
         * @param int $src
         * @return string
         */
        protected static function encode5BitsUpper(int $src): string
        {
        }
    }
    /**
     *  Copyright (c) 2016 - 2022 Paragon Initiative Enterprises.
     *  Copyright (c) 2014 Steve "Sc00bz" Thomas (steve at tobtu dot com)
     *
     *  Permission is hereby granted, free of charge, to any person obtaining a copy
     *  of this software and associated documentation files (the "Software"), to deal
     *  in the Software without restriction, including without limitation the rights
     *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     *  copies of the Software, and to permit persons to whom the Software is
     *  furnished to do so, subject to the following conditions:
     *
     *  The above copyright notice and this permission notice shall be included in all
     *  copies or substantial portions of the Software.
     *
     *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     *  SOFTWARE.
     */
    /**
     * Class Base64
     * [A-Z][a-z][0-9]+/
     *
     * @package ParagonIE\ConstantTime
     */
    abstract class Base64 implements \ParagonIE\ConstantTime\EncoderInterface
    {
        /**
         * Encode into Base64
         *
         * Base64 character set "[A-Z][a-z][0-9]+/"
         *
         * @param string $binString
         * @return string
         *
         * @throws TypeError
         */
        public static function encode(
            #[\SensitiveParameter]
            string $binString
        ): string
        {
        }
        /**
         * Encode into Base64, no = padding
         *
         * Base64 character set "[A-Z][a-z][0-9]+/"
         *
         * @param string $src
         * @return string
         *
         * @throws TypeError
         */
        public static function encodeUnpadded(
            #[\SensitiveParameter]
            string $src
        ): string
        {
        }
        /**
         * @param string $src
         * @param bool $pad   Include = padding?
         * @return string
         *
         * @throws TypeError
         */
        protected static function doEncode(
            #[\SensitiveParameter]
            string $src,
            bool $pad = true
        ): string
        {
        }
        /**
         * decode from base64 into binary
         *
         * Base64 character set "./[A-Z][a-z][0-9]"
         *
         * @param string $encodedString
         * @param bool $strictPadding
         * @return string
         *
         * @throws RangeException
         * @throws TypeError
         */
        public static function decode(
            #[\SensitiveParameter]
            string $encodedString,
            bool $strictPadding = false
        ): string
        {
        }
        /**
         * @param string $encodedString
         * @return string
         */
        public static function decodeNoPadding(
            #[\SensitiveParameter]
            string $encodedString
        ): string
        {
        }
        /**
         * Uses bitwise operators instead of table-lookups to turn 6-bit integers
         * into 8-bit integers.
         *
         * Base64 character set:
         * [A-Z]      [a-z]      [0-9]      +     /
         * 0x41-0x5a, 0x61-0x7a, 0x30-0x39, 0x2b, 0x2f
         *
         * @param int $src
         * @return int
         */
        protected static function decode6Bits(int $src): int
        {
        }
        /**
         * Uses bitwise operators instead of table-lookups to turn 8-bit integers
         * into 6-bit integers.
         *
         * @param int $src
         * @return string
         */
        protected static function encode6Bits(int $src): string
        {
        }
    }
    /**
     *  Copyright (c) 2016 - 2022 Paragon Initiative Enterprises.
     *  Copyright (c) 2014 Steve "Sc00bz" Thomas (steve at tobtu dot com)
     *
     *  Permission is hereby granted, free of charge, to any person obtaining a copy
     *  of this software and associated documentation files (the "Software"), to deal
     *  in the Software without restriction, including without limitation the rights
     *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     *  copies of the Software, and to permit persons to whom the Software is
     *  furnished to do so, subject to the following conditions:
     *
     *  The above copyright notice and this permission notice shall be included in all
     *  copies or substantial portions of the Software.
     *
     *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     *  SOFTWARE.
     */
    /**
     * Class Base64DotSlash
     * ./[A-Z][a-z][0-9]
     *
     * @package ParagonIE\ConstantTime
     */
    abstract class Base64DotSlash extends \ParagonIE\ConstantTime\Base64
    {
        /**
         * Uses bitwise operators instead of table-lookups to turn 6-bit integers
         * into 8-bit integers.
         *
         * Base64 character set:
         * ./         [A-Z]      [a-z]     [0-9]
         * 0x2e-0x2f, 0x41-0x5a, 0x61-0x7a, 0x30-0x39
         *
         * @param int $src
         * @return int
         */
        protected static function decode6Bits(int $src): int
        {
        }
        /**
         * Uses bitwise operators instead of table-lookups to turn 8-bit integers
         * into 6-bit integers.
         *
         * @param int $src
         * @return string
         */
        protected static function encode6Bits(int $src): string
        {
        }
    }
    /**
     *  Copyright (c) 2016 - 2022 Paragon Initiative Enterprises.
     *  Copyright (c) 2014 Steve "Sc00bz" Thomas (steve at tobtu dot com)
     *
     *  Permission is hereby granted, free of charge, to any person obtaining a copy
     *  of this software and associated documentation files (the "Software"), to deal
     *  in the Software without restriction, including without limitation the rights
     *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     *  copies of the Software, and to permit persons to whom the Software is
     *  furnished to do so, subject to the following conditions:
     *
     *  The above copyright notice and this permission notice shall be included in all
     *  copies or substantial portions of the Software.
     *
     *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     *  SOFTWARE.
     */
    /**
     * Class Base64DotSlashOrdered
     * ./[0-9][A-Z][a-z]
     *
     * @package ParagonIE\ConstantTime
     */
    abstract class Base64DotSlashOrdered extends \ParagonIE\ConstantTime\Base64
    {
        /**
         * Uses bitwise operators instead of table-lookups to turn 6-bit integers
         * into 8-bit integers.
         *
         * Base64 character set:
         * [.-9]      [A-Z]      [a-z]
         * 0x2e-0x39, 0x41-0x5a, 0x61-0x7a
         *
         * @param int $src
         * @return int
         */
        protected static function decode6Bits(int $src): int
        {
        }
        /**
         * Uses bitwise operators instead of table-lookups to turn 8-bit integers
         * into 6-bit integers.
         *
         * @param int $src
         * @return string
         */
        protected static function encode6Bits(int $src): string
        {
        }
    }
    /**
     *  Copyright (c) 2016 - 2022 Paragon Initiative Enterprises.
     *  Copyright (c) 2014 Steve "Sc00bz" Thomas (steve at tobtu dot com)
     *
     *  Permission is hereby granted, free of charge, to any person obtaining a copy
     *  of this software and associated documentation files (the "Software"), to deal
     *  in the Software without restriction, including without limitation the rights
     *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     *  copies of the Software, and to permit persons to whom the Software is
     *  furnished to do so, subject to the following conditions:
     *
     *  The above copyright notice and this permission notice shall be included in all
     *  copies or substantial portions of the Software.
     *
     *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     *  SOFTWARE.
     */
    /**
     * Class Base64UrlSafe
     * [A-Z][a-z][0-9]\-_
     *
     * @package ParagonIE\ConstantTime
     */
    abstract class Base64UrlSafe extends \ParagonIE\ConstantTime\Base64
    {
        /**
         * Uses bitwise operators instead of table-lookups to turn 6-bit integers
         * into 8-bit integers.
         *
         * Base64 character set:
         * [A-Z]      [a-z]      [0-9]      -     _
         * 0x41-0x5a, 0x61-0x7a, 0x30-0x39, 0x2d, 0x5f
         *
         * @param int $src
         * @return int
         */
        protected static function decode6Bits(int $src): int
        {
        }
        /**
         * Uses bitwise operators instead of table-lookups to turn 8-bit integers
         * into 6-bit integers.
         *
         * @param int $src
         * @return string
         */
        protected static function encode6Bits(int $src): string
        {
        }
    }
    /**
     *  Copyright (c) 2016 - 2022 Paragon Initiative Enterprises.
     *  Copyright (c) 2014 Steve "Sc00bz" Thomas (steve at tobtu dot com)
     *
     *  Permission is hereby granted, free of charge, to any person obtaining a copy
     *  of this software and associated documentation files (the "Software"), to deal
     *  in the Software without restriction, including without limitation the rights
     *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     *  copies of the Software, and to permit persons to whom the Software is
     *  furnished to do so, subject to the following conditions:
     *
     *  The above copyright notice and this permission notice shall be included in all
     *  copies or substantial portions of the Software.
     *
     *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     *  SOFTWARE.
     */
    /**
     * Class Binary
     *
     * Binary string operators that don't choke on
     * mbstring.func_overload
     *
     * @package ParagonIE\ConstantTime
     */
    abstract class Binary
    {
        /**
         * Safe string length
         *
         * @ref mbstring.func_overload
         *
         * @param string $str
         * @return int
         */
        public static function safeStrlen(
            #[\SensitiveParameter]
            string $str
        ): int
        {
        }
        /**
         * Safe substring
         *
         * @ref mbstring.func_overload
         *
         * @staticvar boolean $exists
         * @param string $str
         * @param int $start
         * @param ?int $length
         * @return string
         *
         * @throws TypeError
         */
        public static function safeSubstr(
            #[\SensitiveParameter]
            string $str,
            int $start = 0,
            ?int $length = null
        ): string
        {
        }
    }
    /**
     *  Copyright (c) 2016 - 2022 Paragon Initiative Enterprises.
     *  Copyright (c) 2014 Steve "Sc00bz" Thomas (steve at tobtu dot com)
     *
     *  Permission is hereby granted, free of charge, to any person obtaining a copy
     *  of this software and associated documentation files (the "Software"), to deal
     *  in the Software without restriction, including without limitation the rights
     *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     *  copies of the Software, and to permit persons to whom the Software is
     *  furnished to do so, subject to the following conditions:
     *
     *  The above copyright notice and this permission notice shall be included in all
     *  copies or substantial portions of the Software.
     *
     *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     *  SOFTWARE.
     */
    /**
     * Class Encoding
     * @package ParagonIE\ConstantTime
     */
    abstract class Encoding
    {
        /**
         * RFC 4648 Base32 encoding
         *
         * @param string $str
         * @return string
         * @throws TypeError
         */
        public static function base32Encode(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * RFC 4648 Base32 encoding
         *
         * @param string $str
         * @return string
         * @throws TypeError
         */
        public static function base32EncodeUpper(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * RFC 4648 Base32 decoding
         *
         * @param string $str
         * @return string
         * @throws TypeError
         */
        public static function base32Decode(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * RFC 4648 Base32 decoding
         *
         * @param string $str
         * @return string
         * @throws TypeError
         */
        public static function base32DecodeUpper(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * RFC 4648 Base32 encoding
         *
         * @param string $str
         * @return string
         * @throws TypeError
         */
        public static function base32HexEncode(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * RFC 4648 Base32Hex encoding
         *
         * @param string $str
         * @return string
         * @throws TypeError
         */
        public static function base32HexEncodeUpper(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * RFC 4648 Base32Hex decoding
         *
         * @param string $str
         * @return string
         * @throws TypeError
         */
        public static function base32HexDecode(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * RFC 4648 Base32Hex decoding
         *
         * @param string $str
         * @return string
         * @throws TypeError
         */
        public static function base32HexDecodeUpper(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * RFC 4648 Base64 encoding
         *
         * @param string $str
         * @return string
         * @throws TypeError
         */
        public static function base64Encode(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * RFC 4648 Base64 decoding
         *
         * @param string $str
         * @return string
         * @throws TypeError
         */
        public static function base64Decode(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * Encode into Base64
         *
         * Base64 character set "./[A-Z][a-z][0-9]"
         * @param string $str
         * @return string
         * @throws TypeError
         */
        public static function base64EncodeDotSlash(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * Decode from base64 to raw binary
         *
         * Base64 character set "./[A-Z][a-z][0-9]"
         *
         * @param string $str
         * @return string
         * @throws \RangeException
         * @throws TypeError
         */
        public static function base64DecodeDotSlash(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * Encode into Base64
         *
         * Base64 character set "[.-9][A-Z][a-z]" or "./[0-9][A-Z][a-z]"
         * @param string $str
         * @return string
         * @throws TypeError
         */
        public static function base64EncodeDotSlashOrdered(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * Decode from base64 to raw binary
         *
         * Base64 character set "[.-9][A-Z][a-z]" or "./[0-9][A-Z][a-z]"
         *
         * @param string $str
         * @return string
         * @throws \RangeException
         * @throws TypeError
         */
        public static function base64DecodeDotSlashOrdered(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * Convert a binary string into a hexadecimal string without cache-timing
         * leaks
         *
         * @param string $bin_string (raw binary)
         * @return string
         * @throws TypeError
         */
        public static function hexEncode(
            #[\SensitiveParameter]
            string $bin_string
        ): string
        {
        }
        /**
         * Convert a hexadecimal string into a binary string without cache-timing
         * leaks
         *
         * @param string $hex_string
         * @return string (raw binary)
         * @throws \RangeException
         */
        public static function hexDecode(
            #[\SensitiveParameter]
            string $hex_string
        ): string
        {
        }
        /**
         * Convert a binary string into a hexadecimal string without cache-timing
         * leaks
         *
         * @param string $bin_string (raw binary)
         * @return string
         * @throws TypeError
         */
        public static function hexEncodeUpper(
            #[\SensitiveParameter]
            string $bin_string
        ): string
        {
        }
        /**
         * Convert a binary string into a hexadecimal string without cache-timing
         * leaks
         *
         * @param string $bin_string (raw binary)
         * @return string
         */
        public static function hexDecodeUpper(
            #[\SensitiveParameter]
            string $bin_string
        ): string
        {
        }
    }
    /**
     *  Copyright (c) 2016 - 2022 Paragon Initiative Enterprises.
     *  Copyright (c) 2014 Steve "Sc00bz" Thomas (steve at tobtu dot com)
     *
     *  Permission is hereby granted, free of charge, to any person obtaining a copy
     *  of this software and associated documentation files (the "Software"), to deal
     *  in the Software without restriction, including without limitation the rights
     *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     *  copies of the Software, and to permit persons to whom the Software is
     *  furnished to do so, subject to the following conditions:
     *
     *  The above copyright notice and this permission notice shall be included in all
     *  copies or substantial portions of the Software.
     *
     *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     *  SOFTWARE.
     */
    /**
     * Class Hex
     * @package ParagonIE\ConstantTime
     */
    abstract class Hex implements \ParagonIE\ConstantTime\EncoderInterface
    {
        /**
         * Convert a binary string into a hexadecimal string without cache-timing
         * leaks
         *
         * @param string $binString (raw binary)
         * @return string
         * @throws TypeError
         */
        public static function encode(
            #[\SensitiveParameter]
            string $binString
        ): string
        {
        }
        /**
         * Convert a binary string into a hexadecimal string without cache-timing
         * leaks, returning uppercase letters (as per RFC 4648)
         *
         * @param string $binString (raw binary)
         * @return string
         * @throws TypeError
         */
        public static function encodeUpper(
            #[\SensitiveParameter]
            string $binString
        ): string
        {
        }
        /**
         * Convert a hexadecimal string into a binary string without cache-timing
         * leaks
         *
         * @param string $encodedString
         * @param bool $strictPadding
         * @return string (raw binary)
         * @throws RangeException
         */
        public static function decode(
            #[\SensitiveParameter]
            string $encodedString,
            bool $strictPadding = false
        ): string
        {
        }
    }
    /**
     *  Copyright (c) 2016 - 2022 Paragon Initiative Enterprises.
     *  Copyright (c) 2014 Steve "Sc00bz" Thomas (steve at tobtu dot com)
     *
     *  Permission is hereby granted, free of charge, to any person obtaining a copy
     *  of this software and associated documentation files (the "Software"), to deal
     *  in the Software without restriction, including without limitation the rights
     *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     *  copies of the Software, and to permit persons to whom the Software is
     *  furnished to do so, subject to the following conditions:
     *
     *  The above copyright notice and this permission notice shall be included in all
     *  copies or substantial portions of the Software.
     *
     *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     *  SOFTWARE.
     */
    /**
     * Class RFC4648
     *
     * This class conforms strictly to the RFC
     *
     * @package ParagonIE\ConstantTime
     */
    abstract class RFC4648
    {
        /**
         * RFC 4648 Base64 encoding
         *
         * "foo" -> "Zm9v"
         *
         * @param string $str
         * @return string
         *
         * @throws TypeError
         */
        public static function base64Encode(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * RFC 4648 Base64 decoding
         *
         * "Zm9v" -> "foo"
         *
         * @param string $str
         * @return string
         *
         * @throws TypeError
         */
        public static function base64Decode(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * RFC 4648 Base64 (URL Safe) encoding
         *
         * "foo" -> "Zm9v"
         *
         * @param string $str
         * @return string
         *
         * @throws TypeError
         */
        public static function base64UrlSafeEncode(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * RFC 4648 Base64 (URL Safe) decoding
         *
         * "Zm9v" -> "foo"
         *
         * @param string $str
         * @return string
         *
         * @throws TypeError
         */
        public static function base64UrlSafeDecode(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * RFC 4648 Base32 encoding
         *
         * "foo" -> "MZXW6==="
         *
         * @param string $str
         * @return string
         *
         * @throws TypeError
         */
        public static function base32Encode(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * RFC 4648 Base32 encoding
         *
         * "MZXW6===" -> "foo"
         *
         * @param string $str
         * @return string
         *
         * @throws TypeError
         */
        public static function base32Decode(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * RFC 4648 Base32-Hex encoding
         *
         * "foo" -> "CPNMU==="
         *
         * @param string $str
         * @return string
         *
         * @throws TypeError
         */
        public static function base32HexEncode(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * RFC 4648 Base32-Hex decoding
         *
         * "CPNMU===" -> "foo"
         *
         * @param string $str
         * @return string
         *
         * @throws TypeError
         */
        public static function base32HexDecode(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * RFC 4648 Base16 decoding
         *
         * "foo" -> "666F6F"
         *
         * @param string $str
         * @return string
         *
         * @throws TypeError
         */
        public static function base16Encode(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
        /**
         * RFC 4648 Base16 decoding
         *
         * "666F6F" -> "foo"
         *
         * @param string $str
         * @return string
         */
        public static function base16Decode(
            #[\SensitiveParameter]
            string $str
        ): string
        {
        }
    }
}
namespace PhpAmqpLib\Channel {
    abstract class AbstractChannel
    {
        /**
         * @deprecated
         */
        const PROTOCOL_080 = \PhpAmqpLib\Wire\Constants080::VERSION;
        /**
         * @deprecated
         */
        const PROTOCOL_091 = \PhpAmqpLib\Wire\Constants091::VERSION;
        /**
         * Lower level queue for frames
         * @var \SplQueue|Frame[]
         */
        protected $frame_queue;
        /**
         * Higher level queue for methods
         * @var array
         */
        protected $method_queue = array();
        /** @var bool */
        protected $auto_decode = false;
        /** @var Wire\Constants */
        protected $constants;
        /** @var \PhpAmqpLib\Helper\DebugHelper */
        protected $debug;
        /** @var null|AbstractConnection */
        protected $connection;
        /**
         * @var string
         * @deprecated
         */
        protected $protocolVersion;
        /** @var int */
        protected $maxBodySize;
        /** @var Protocol080|Protocol091 */
        protected $protocolWriter;
        /** @var Wait080|Wait091 */
        protected $waitHelper;
        /** @var MethodMap080|MethodMap091 */
        protected $methodMap;
        /** @var int|null */
        protected $channel_id;
        /** @var Wire\AMQPBufferReader */
        protected $msg_property_reader;
        /** @var Wire\AMQPBufferReader */
        protected $dispatch_reader;
        /**
         * @param AbstractConnection $connection
         * @param int $channel_id
         * @throws \PhpAmqpLib\Exception\AMQPRuntimeException
         */
        public function __construct(\PhpAmqpLib\Connection\AbstractConnection $connection, $channel_id)
        {
        }
        /**
         * @return string
         * @throws AMQPOutOfRangeException
         * @deprecated
         */
        public static function getProtocolVersion()
        {
        }
        /**
         * @return int|null
         */
        public function getChannelId()
        {
        }
        /**
         * @param int $max_bytes Max message body size for this channel
         * @return $this
         */
        public function setBodySizeLimit($max_bytes)
        {
        }
        /**
         * @return AbstractConnection|null
         */
        public function getConnection()
        {
        }
        /**
         * @return array
         */
        public function getMethodQueue()
        {
        }
        /**
         * @return bool
         */
        public function hasPendingMethods()
        {
        }
        /**
         * @param string $method_sig
         * @param string $args
         * @param AMQPMessage|null $amqpMessage
         * @return mixed
         * @throws \PhpAmqpLib\Exception\AMQPRuntimeException
         */
        public function dispatch($method_sig, $args, $amqpMessage)
        {
        }
        /**
         * @param int|float|null $timeout
         * @return Frame
         */
        protected function next_frame($timeout = 0): \PhpAmqpLib\Channel\Frame
        {
        }
        /**
         * @param array $method_sig
         * @param \PhpAmqpLib\Wire\AMQPWriter|string $args
         */
        protected function send_method_frame($method_sig, $args = '')
        {
        }
        /**
         * This is here for performance reasons to batch calls to fwrite from basic.publish
         *
         * @param array $method_sig
         * @param \PhpAmqpLib\Wire\AMQPWriter|string $args
         * @param \PhpAmqpLib\Wire\AMQPWriter $pkt
         * @return \PhpAmqpLib\Wire\AMQPWriter
         */
        protected function prepare_method_frame($method_sig, $args = '', $pkt = null)
        {
        }
        /**
         * @return AMQPMessage
         * @throws \PhpAmqpLib\Exception\AMQPRuntimeException
         * @throws AMQPInvalidFrameException
         */
        public function wait_content(): \PhpAmqpLib\Message\AMQPMessage
        {
        }
        protected function createMessage(\PhpAmqpLib\Wire\AMQPReader $propertyReader, int $bodySize): \PhpAmqpLib\Message\AMQPMessage
        {
        }
        /**
         * Wait for some expected AMQP methods and dispatch to them.
         * Unexpected methods are queued up for later calls to this PHP
         * method.
         *
         * @param array|null $allowed_methods
         * @param bool $non_blocking
         * @param int|float|null $timeout
         * @return mixed
         * @throws \PhpAmqpLib\Exception\AMQPRuntimeException
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException
         * @throws \PhpAmqpLib\Exception\AMQPConnectionClosedException
         * @throws AMQPOutOfBoundsException
         */
        public function wait($allowed_methods = null, $non_blocking = false, $timeout = 0)
        {
        }
        /**
         * @param array|null $allowed_methods
         * @return array
         */
        protected function process_deferred_methods($allowed_methods)
        {
        }
        /**
         * @param array $queued_method
         * @return mixed
         */
        protected function dispatch_deferred_method($queued_method)
        {
        }
        /**
         * @param Frame $frame
         * @throws \PhpAmqpLib\Exception\AMQPInvalidFrameException
         */
        protected function validate_method_frame(\PhpAmqpLib\Channel\Frame $frame): void
        {
        }
        /**
         * @param Frame $frame
         * @param int $expectedType
         * @throws AMQPInvalidFrameException
         */
        protected function validate_frame(\PhpAmqpLib\Channel\Frame $frame, int $expectedType): void
        {
        }
        /**
         * @param Frame $frame
         * @throws AMQPOutOfBoundsException
         * @throws AMQPInvalidFrameException
         */
        protected function validate_frame_payload(\PhpAmqpLib\Channel\Frame $frame): void
        {
        }
        protected function parseMethod(string $payload): \PhpAmqpLib\Channel\Method
        {
        }
        /**
         * @param array|null $allowed_methods
         * @param string $method_sig
         * @return bool
         */
        protected function should_dispatch_method($allowed_methods, $method_sig)
        {
        }
        /**
         * @param string $method_sig
         * @return AMQPMessage|null
         */
        protected function maybe_wait_for_content($method_sig)
        {
        }
        /**
         * @param callable $handler
         * @param array $arguments
         */
        protected function dispatch_to_handler($handler, array $arguments = [])
        {
        }
    }
    class AMQPChannel extends \PhpAmqpLib\Channel\AbstractChannel
    {
        /**
         * @var callable[]
         * @internal Use is_consuming() to check if there is active callbacks
         */
        public $callbacks = array();
        /** @var bool Whether or not the channel has been "opened" */
        protected $is_open = false;
        /** @var int */
        protected $default_ticket = 0;
        /** @var bool */
        protected $active = true;
        /** @var bool */
        protected $stopConsume = false;
        /** @var array */
        protected $alerts = array();
        /** @var bool */
        protected $auto_decode;
        /**
         * These parameters will be passed to function in case of basic_return:
         *    param int $reply_code
         *    param string $reply_text
         *    param string $exchange
         *    param string $routing_key
         *    param AMQPMessage $msg
         *
         * @var null|callable
         */
        protected $basic_return_callback;
        /** @var array Used to keep track of the messages that are going to be batch published. */
        protected $batch_messages = array();
        /**
         * Maximum time to wait for operations on this channel, in seconds.
         * @var float
         */
        protected $channel_rpc_timeout;
        /**
         * @param AbstractConnection $connection
         * @param int|null $channel_id
         * @param bool $auto_decode
         * @param int|float $channel_rpc_timeout
         * @throws \PhpAmqpLib\Exception\AMQPOutOfBoundsException
         * @throws \PhpAmqpLib\Exception\AMQPRuntimeException
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException
         * @throws \PhpAmqpLib\Exception\AMQPConnectionClosedException
         */
        public function __construct($connection, $channel_id = null, $auto_decode = true, $channel_rpc_timeout = 0)
        {
        }
        /**
         * @return bool
         */
        public function is_open()
        {
        }
        /**
         * Tear down this object, after we've agreed to close with the server.
         */
        protected function do_close()
        {
        }
        /**
         * Only for AMQP0.8.0
         * This method allows the server to send a non-fatal warning to
         * the client.  This is used for methods that are normally
         * asynchronous and thus do not have confirmations, and for which
         * the server may detect errors that need to be reported.  Fatal
         * errors are handled as channel or connection exceptions; non-
         * fatal errors are sent through this method.
         *
         * @param AMQPReader $reader
         */
        protected function channel_alert(\PhpAmqpLib\Wire\AMQPReader $reader): void
        {
        }
        /**
         * Request a channel close
         *
         * @param int $reply_code
         * @param string $reply_text
         * @param array $method_sig
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @return mixed
         */
        public function close($reply_code = 0, $reply_text = '', $method_sig = array(0, 0))
        {
        }
        /**
         * Closes a channel if no connection or a connection is closed
         *
         * @return bool
         */
        public function closeIfDisconnected(): bool
        {
        }
        /**
         * @param AMQPReader $reader
         * @throws AMQPProtocolChannelException
         */
        protected function channel_close(\PhpAmqpLib\Wire\AMQPReader $reader): void
        {
        }
        /**
         * Confirm a channel close
         * Alias of AMQPChannel::do_close()
         */
        protected function channel_close_ok()
        {
        }
        /**
         * Enables/disables flow from peer
         *
         * @param bool $active
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @return mixed
         */
        public function flow($active)
        {
        }
        protected function channel_flow(\PhpAmqpLib\Wire\AMQPReader $reader): void
        {
        }
        /**
         * @param bool $active
         */
        protected function x_flow_ok($active)
        {
        }
        protected function channel_flow_ok(\PhpAmqpLib\Wire\AMQPReader $reader): bool
        {
        }
        /**
         * @param string $out_of_band
         * @throws \PhpAmqpLib\Exception\AMQPOutOfBoundsException
         * @throws \PhpAmqpLib\Exception\AMQPRuntimeException
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException
         * @throws \PhpAmqpLib\Exception\AMQPConnectionClosedException
         * @return mixed
         */
        protected function x_open($out_of_band = '')
        {
        }
        protected function channel_open_ok()
        {
        }
        /**
         * Requests an access ticket
         *
         * @param string $realm
         * @param bool $exclusive
         * @param bool $passive
         * @param bool $active
         * @param bool $write
         * @param bool $read
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @return mixed
         */
        public function access_request($realm, $exclusive = false, $passive = false, $active = false, $write = false, $read = false)
        {
        }
        /**
         * Grants access to server resources
         *
         * @param AMQPReader $reader
         * @return int
         */
        protected function access_request_ok(\PhpAmqpLib\Wire\AMQPReader $reader): int
        {
        }
        /**
         * Declares exchange
         *
         * @param string $exchange
         * @param string $type
         * @param bool $passive
         * @param bool $durable
         * @param bool $auto_delete
         * @param bool $internal
         * @param bool $nowait
         * @param AMQPTable|array $arguments
         * @param int|null $ticket
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @return mixed|null
         */
        public function exchange_declare($exchange, $type, $passive = false, $durable = false, $auto_delete = true, $internal = false, $nowait = false, $arguments = array(), $ticket = null)
        {
        }
        /**
         * Confirms an exchange declaration
         */
        protected function exchange_declare_ok()
        {
        }
        /**
         * Deletes an exchange
         *
         * @param string $exchange
         * @param bool $if_unused
         * @param bool $nowait
         * @param int|null $ticket
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @return mixed|null
         */
        public function exchange_delete($exchange, $if_unused = false, $nowait = false, $ticket = null)
        {
        }
        /**
         * Confirms deletion of an exchange
         */
        protected function exchange_delete_ok()
        {
        }
        /**
         * Binds dest exchange to source exchange
         *
         * @param string $destination
         * @param string $source
         * @param string $routing_key
         * @param bool $nowait
         * @param \PhpAmqpLib\Wire\AMQPTable|array $arguments
         * @param int|null $ticket
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @return mixed|null
         */
        public function exchange_bind($destination, $source, $routing_key = '', $nowait = false, $arguments = array(), $ticket = null)
        {
        }
        /**
         * Confirms bind successful
         */
        protected function exchange_bind_ok()
        {
        }
        /**
         * Unbinds dest exchange from source exchange
         *
         * @param string $destination
         * @param string $source
         * @param string $routing_key
         * @param bool $nowait
         * @param \PhpAmqpLib\Wire\AMQPTable|array $arguments
         * @param int|null $ticket
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @return mixed
         */
        public function exchange_unbind($destination, $source, $routing_key = '', $nowait = false, $arguments = array(), $ticket = null)
        {
        }
        /**
         * Confirms unbind successful
         */
        protected function exchange_unbind_ok()
        {
        }
        /**
         * Binds queue to an exchange
         *
         * @param string $queue
         * @param string $exchange
         * @param string $routing_key
         * @param bool $nowait
         * @param \PhpAmqpLib\Wire\AMQPTable|array $arguments
         * @param int|null $ticket
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @return mixed|null
         */
        public function queue_bind($queue, $exchange, $routing_key = '', $nowait = false, $arguments = array(), $ticket = null)
        {
        }
        /**
         * Confirms bind successful
         */
        protected function queue_bind_ok()
        {
        }
        /**
         * Unbind queue from an exchange
         *
         * @param string $queue
         * @param string $exchange
         * @param string $routing_key
         * @param \PhpAmqpLib\Wire\AMQPTable|array $arguments
         * @param int|null $ticket
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @return mixed
         */
        public function queue_unbind($queue, $exchange, $routing_key = '', $arguments = array(), $ticket = null)
        {
        }
        /**
         * Confirms unbind successful
         */
        protected function queue_unbind_ok()
        {
        }
        /**
         * Declares queue, creates if needed
         *
         * @param string $queue
         * @param bool $passive
         * @param bool $durable
         * @param bool $exclusive
         * @param bool $auto_delete
         * @param bool $nowait
         * @param array|AMQPTable $arguments
         * @param int|null $ticket
         * @return array|null
         *@throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         */
        public function queue_declare($queue = '', $passive = false, $durable = false, $exclusive = false, $auto_delete = true, $nowait = false, $arguments = array(), $ticket = null)
        {
        }
        /**
         * Confirms a queue definition
         *
         * @param AMQPReader $reader
         * @return string[]
         */
        protected function queue_declare_ok(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * Deletes a queue
         *
         * @param string $queue
         * @param bool $if_unused
         * @param bool $if_empty
         * @param bool $nowait
         * @param int|null $ticket
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @return mixed|null
         */
        public function queue_delete($queue = '', $if_unused = false, $if_empty = false, $nowait = false, $ticket = null)
        {
        }
        /**
         * Confirms deletion of a queue
         *
         * @param AMQPReader $reader
         * @return int|string
         */
        protected function queue_delete_ok(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * Purges a queue
         *
         * @param string $queue
         * @param bool $nowait
         * @param int|null $ticket
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @return mixed|null
         */
        public function queue_purge($queue = '', $nowait = false, $ticket = null)
        {
        }
        /**
         * Confirms a queue purge
         *
         * @param AMQPReader $reader
         * @return int|string
         */
        protected function queue_purge_ok(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * Acknowledges one or more messages
         *
         * @param int $delivery_tag
         * @param bool $multiple
         */
        public function basic_ack($delivery_tag, $multiple = false)
        {
        }
        /**
         * Called when the server sends a basic.ack
         *
         * @param AMQPReader $reader
         * @throws AMQPRuntimeException
         */
        protected function basic_ack_from_server(\PhpAmqpLib\Wire\AMQPReader $reader): void
        {
        }
        /**
         * Called when the server sends a basic.nack
         *
         * @param AMQPReader $reader
         * @throws AMQPRuntimeException
         */
        protected function basic_nack_from_server(\PhpAmqpLib\Wire\AMQPReader $reader): void
        {
        }
        /**
         * Handles the deletion of messages from this->publishedMessages and dispatches them to the $handler
         *
         * @param int $delivery_tag
         * @param bool $multiple
         * @param callable $handler
         */
        protected function internal_ack_handler($delivery_tag, $multiple, $handler)
        {
        }
        /**
         * @param AMQPMessage[] $messages
         * @param string $value
         * @return mixed
         */
        protected function get_keys_less_or_equal(array $messages, $value)
        {
        }
        /**
         * Rejects one or several received messages
         *
         * @param int $delivery_tag
         * @param bool $multiple
         * @param bool $requeue
         */
        public function basic_nack($delivery_tag, $multiple = false, $requeue = false)
        {
        }
        /**
         * Ends a queue consumer
         *
         * @param string $consumer_tag
         * @param bool $nowait
         * @param bool $noreturn
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @return mixed
         */
        public function basic_cancel($consumer_tag, $nowait = false, $noreturn = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @throws \PhpAmqpLib\Exception\AMQPBasicCancelException
         */
        protected function basic_cancel_from_server(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * Confirm a cancelled consumer
         *
         * @param AMQPReader $reader
         * @return string
         */
        protected function basic_cancel_ok(\PhpAmqpLib\Wire\AMQPReader $reader): string
        {
        }
        /**
         * @return bool
         */
        public function is_consuming()
        {
        }
        /**
         * Start a queue consumer.
         * This method asks the server to start a "consumer", which is a transient request for messages
         * from a specific queue.
         * Consumers last as long as the channel they were declared on, or until the client cancels them.
         *
         * @link https://www.rabbitmq.com/amqp-0-9-1-reference.html#basic.consume
         *
         * @param string $queue
         * @param string $consumer_tag
         * @param bool $no_local
         * @param bool $no_ack
         * @param bool $exclusive
         * @param bool $nowait
         * @param callable|null $callback
         * @param int|null $ticket
         * @param \PhpAmqpLib\Wire\AMQPTable|array $arguments
         *
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @throws \InvalidArgumentException
         * @return string
         */
        public function basic_consume($queue = '', $consumer_tag = '', $no_local = false, $no_ack = false, $exclusive = false, $nowait = false, $callback = null, $ticket = null, $arguments = array())
        {
        }
        /**
         * Confirms a new consumer
         *
         * @param AMQPReader $reader
         * @return string
         */
        protected function basic_consume_ok(\PhpAmqpLib\Wire\AMQPReader $reader): string
        {
        }
        /**
         * Notifies the client of a consumer message
         *
         * @param AMQPReader $reader
         * @param AMQPMessage $message
         */
        protected function basic_deliver(\PhpAmqpLib\Wire\AMQPReader $reader, \PhpAmqpLib\Message\AMQPMessage $message): void
        {
        }
        /**
         * Direct access to a queue if no message was available in the queue, return null
         *
         * @param string $queue
         * @param bool $no_ack
         * @param int|null $ticket
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @return AMQPMessage|null
         */
        public function basic_get($queue = '', $no_ack = false, $ticket = null)
        {
        }
        /**
         * Indicates no messages available
         */
        protected function basic_get_empty()
        {
        }
        /**
         * Provides client with a message
         *
         * @param AMQPReader $reader
         * @param AMQPMessage $message
         * @return AMQPMessage
         */
        protected function basic_get_ok(\PhpAmqpLib\Wire\AMQPReader $reader, \PhpAmqpLib\Message\AMQPMessage $message): \PhpAmqpLib\Message\AMQPMessage
        {
        }
        /**
         * Publishes a message
         *
         * @param AMQPMessage $msg
         * @param string $exchange
         * @param string $routing_key
         * @param bool $mandatory
         * @param bool $immediate
         * @param int|null $ticket
         * @throws AMQPChannelClosedException
         * @throws AMQPConnectionClosedException
         * @throws AMQPConnectionBlockedException
         */
        public function basic_publish($msg, $exchange = '', $routing_key = '', $mandatory = false, $immediate = false, $ticket = null)
        {
        }
        /**
         * @param AMQPMessage $message
         * @param string $exchange
         * @param string $routing_key
         * @param bool $mandatory
         * @param bool $immediate
         * @param int|null $ticket
         */
        public function batch_basic_publish($message, $exchange = '', $routing_key = '', $mandatory = false, $immediate = false, $ticket = null)
        {
        }
        /**
         * Publish batch
         *
         * @return void
         * @throws AMQPChannelClosedException
         * @throws AMQPConnectionClosedException
         * @throws AMQPConnectionBlockedException
         */
        public function publish_batch()
        {
        }
        /**
         * Specifies QoS
         * 
         * See https://www.rabbitmq.com/consumer-prefetch.html#overview for details
         * 
         * @param int $prefetch_size Default is 0 (Alias for unlimited)
         * @param int $prefetch_count Default is 0 (Alias for unlimited)
         * @param bool $global Default is false, prefetch size and count are applied to each channel consumer separately
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @return mixed
         */
        public function basic_qos($prefetch_size, $prefetch_count, $a_global)
        {
        }
        /**
         * Confirms QoS request
         */
        protected function basic_qos_ok()
        {
        }
        /**
         * Redelivers unacknowledged messages
         *
         * @param bool $requeue
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @return mixed
         */
        public function basic_recover($requeue = false)
        {
        }
        /**
         * Confirm the requested recover
         */
        protected function basic_recover_ok()
        {
        }
        /**
         * Rejects an incoming message
         *
         * @param int $delivery_tag
         * @param bool $requeue
         */
        public function basic_reject($delivery_tag, $requeue)
        {
        }
        /**
         * Returns a failed message
         *
         * @param AMQPReader $reader
         * @param AMQPMessage $message
         */
        protected function basic_return(\PhpAmqpLib\Wire\AMQPReader $reader, \PhpAmqpLib\Message\AMQPMessage $message)
        {
        }
        /**
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @return mixed
         */
        public function tx_commit()
        {
        }
        /**
         * Confirms a successful commit
         */
        protected function tx_commit_ok()
        {
        }
        /**
         * Rollbacks the current transaction
         *
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @return mixed
         */
        public function tx_rollback()
        {
        }
        /**
         * Confirms a successful rollback
         */
        protected function tx_rollback_ok()
        {
        }
        /**
         * Puts the channel into confirm mode
         * Beware that only non-transactional channels may be put into confirm mode and vice versa
         *
         * @param bool $nowait
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         */
        public function confirm_select($nowait = false)
        {
        }
        /**
         * Confirms a selection
         */
        public function confirm_select_ok()
        {
        }
        /**
         * Waits for pending acks and nacks from the server.
         * If there are no pending acks, the method returns immediately
         *
         * @param int|float $timeout Waits until $timeout value is reached
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException
         * @throws \PhpAmqpLib\Exception\AMQPRuntimeException
         */
        public function wait_for_pending_acks($timeout = 0)
        {
        }
        /**
         * Waits for pending acks, nacks and returns from the server.
         * If there are no pending acks, the method returns immediately.
         *
         * @param int|float $timeout If set to value > 0 the method will wait at most $timeout seconds for pending acks.
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException
         * @throws \PhpAmqpLib\Exception\AMQPRuntimeException
         */
        public function wait_for_pending_acks_returns($timeout = 0)
        {
        }
        /**
         * Selects standard transaction mode
         *
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException if the specified operation timeout was exceeded
         * @return mixed
         */
        public function tx_select()
        {
        }
        /**
         * Confirms transaction mode
         */
        protected function tx_select_ok()
        {
        }
        /**
         * @param int|null $ticket
         * @return int
         */
        protected function getTicket($ticket)
        {
        }
        /**
         * Helper method to get a particular method from $this->publishedMessages, removes it from the array and returns it.
         *
         * @param int $index
         * @return AMQPMessage
         */
        protected function get_and_unset_message($index)
        {
        }
        /**
         * Sets callback for basic_return
         *
         * @param  callable $callback
         * @throws \InvalidArgumentException if $callback is not callable
         */
        public function set_return_listener($callback)
        {
        }
        /**
         * Sets a handler which called for any message nack'ed by the server, with the AMQPMessage as first argument.
         *
         * @param callable $callback
         * @throws \InvalidArgumentException
         */
        public function set_nack_handler($callback)
        {
        }
        /**
         * Sets a handler which called for any message ack'ed by the server, with the AMQPMessage as first argument.
         *
         * @param callable $callback
         * @throws \InvalidArgumentException
         */
        public function set_ack_handler($callback)
        {
        }
        /**
         * Wait and process all incoming messages in an endless loop,
         * until connection exception or manual stop using self::stopConsume()
         *
         * @param float $maximumPoll Maximum time in seconds between read attempts
         * @throws \PhpAmqpLib\Exception\AMQPOutOfBoundsException
         * @throws \PhpAmqpLib\Exception\AMQPRuntimeException
         * @throws \PhpAmqpLib\Exception\AMQPConnectionClosedException
         * @throws \ErrorException
         * @since 3.2.0
         */
        public function consume(float $maximumPoll = 10.0): void
        {
        }
        /**
         * Stop AMQPChannel::consume() loop. Useful for signal handlers and other interrupts.
         * @since 3.2.0
         */
        public function stopConsume()
        {
        }
    }
    /**
     * @link https://livebook.manning.com/book/rabbitmq-in-depth/chapter-2/v-13/22
     * @link https://www.rabbitmq.com/resources/specs/amqp0-9-1.pdf 4.2.6 Content Framing
     */
    final class Frame
    {
        public const FRAME_HEADER_SIZE = \PhpAmqpLib\Wire\AMQPReader::OCTET + \PhpAmqpLib\Wire\AMQPReader::SHORT + \PhpAmqpLib\Wire\AMQPReader::LONG;
        public const END = 0xce;
        public const TYPE_METHOD = 1;
        public const TYPE_HEADER = 2;
        public const TYPE_BODY = 3;
        public const TYPE_HEARTBEAT = 8;
        public function __construct(int $type, int $channel, int $size, ?string $payload = null)
        {
        }
        /**
         * @return int
         */
        public function getType(): int
        {
        }
        /**
         * @return int
         */
        public function getChannel(): int
        {
        }
        /**
         * @return int
         */
        public function getSize(): int
        {
        }
        public function getPayload(): ?string
        {
        }
        public function isMethod(): bool
        {
        }
        public function isHeartbeat(): bool
        {
        }
    }
    final class Method
    {
        public function __construct(int $class, int $method, string $arguments)
        {
        }
        public function getClass(): int
        {
        }
        public function getMethod(): int
        {
        }
        public function getArguments(): string
        {
        }
        public function getSignature(): string
        {
        }
    }
}
namespace PhpAmqpLib\Connection {
    abstract class AbstractConnection extends \PhpAmqpLib\Channel\AbstractChannel
    {
        /**
         * @var array
         * @internal
         */
        public static $LIBRARY_PROPERTIES = array('product' => array('S', \PhpAmqpLib\Package::NAME), 'platform' => array('S', 'PHP'), 'version' => array('S', \PhpAmqpLib\Package::VERSION), 'information' => array('S', ''), 'copyright' => array('S', ''), 'capabilities' => array('F', array('authentication_failure_close' => array('t', true), 'publisher_confirms' => array('t', true), 'consumer_cancel_notify' => array('t', true), 'exchange_exchange_bindings' => array('t', true), 'basic.nack' => array('t', true), 'connection.blocked' => array('t', true))));
        /**
         * @var AMQPChannel[]|AbstractChannel[]
         * @internal
         */
        public $channels = array();
        /** @var int */
        protected $version_major;
        /** @var int */
        protected $version_minor;
        /** @var array */
        protected $server_properties;
        /** @var array */
        protected $mechanisms;
        /** @var array */
        protected $locales;
        /** @var bool */
        protected $wait_tune_ok;
        /** @var string */
        protected $known_hosts;
        /** @var null|Wire\AMQPIOReader */
        protected $input;
        /** @var string */
        protected $vhost;
        /** @var bool */
        protected $insist;
        /** @var string */
        protected $login_method;
        /**
         * @var null|string
         */
        protected $login_response;
        /** @var string */
        protected $locale;
        /** @var int */
        protected $heartbeat;
        /** @var float */
        protected $last_frame;
        /** @var int */
        protected $channel_max = 65535;
        /** @var int */
        protected $frame_max = 131072;
        /** @var array Constructor parameters for clone */
        protected $construct_params;
        /** @var bool Close the connection in destructor */
        protected $close_on_destruct = true;
        /** @var bool Maintain connection status */
        protected $is_connected = false;
        /** @var AbstractIO */
        protected $io;
        /** @var int Connection timeout value*/
        protected $connection_timeout;
        /** @var AMQPConnectionConfig|null */
        protected $config;
        /**
         * If connection is blocked due to the broker running low on resources.
         * @var bool
         */
        protected $blocked = false;
        /**
         * If a frame is currently being written
         * @var bool
         */
        protected $writing = false;
        /**
         * @param string $user
         * @param string $password
         * @param string $vhost
         * @param bool $insist
         * @param string $login_method
         * @param null $login_response @deprecated
         * @param string $locale
         * @param AbstractIO $io
         * @param int $heartbeat
         * @param int|float $connection_timeout
         * @param int|float $channel_rpc_timeout
         * @param \PhpAmqpLib\Connection\AMQPConnectionConfig | null $config
         * @throws \Exception
         */
        public function __construct($user, $password, $vhost = '/', $insist = false, $login_method = 'AMQPLAIN', $login_response = null, $locale = 'en_US', ?\PhpAmqpLib\Wire\IO\AbstractIO $io = null, $heartbeat = 0, $connection_timeout = 0, $channel_rpc_timeout = 0.0, ?\PhpAmqpLib\Connection\AMQPConnectionConfig $config = null)
        {
        }
        /**
         * Connects to the AMQP server
         * @throws \Exception
         */
        protected function connect()
        {
        }
        /**
         * Reconnects using the original connection settings.
         * This will not recreate any channels that were established previously
         * @throws \Exception
         */
        public function reconnect()
        {
        }
        /**
         * Cloning will use the old properties to make a new connection to the same server
         */
        public function __clone()
        {
        }
        public function __destruct()
        {
        }
        /**
         * Attempts to close the connection safely
         */
        protected function safeClose()
        {
        }
        /**
         * @param int|null $sec
         * @param int $usec
         * @return int
         * @throws AMQPIOException
         * @throws AMQPRuntimeException
         * @throws AMQPConnectionClosedException
         * @throws AMQPRuntimeException
         */
        public function select(?int $sec, int $usec = 0): int
        {
        }
        /**
         * Allows to not close the connection
         * it's useful after the fork when you don't want to close parent process connection
         *
         * @param bool $close
         */
        public function set_close_on_destruct($close = true)
        {
        }
        protected function close_input()
        {
        }
        protected function close_socket()
        {
        }
        /**
         * @param string $data
         * @throws AMQPIOException
         */
        public function write($data)
        {
        }
        protected function do_close()
        {
        }
        /**
         * @return int
         * @throws AMQPRuntimeException
         */
        public function get_free_channel_id()
        {
        }
        /**
         * @param int $channel
         * @param int $class_id
         * @param int $weight
         * @param int $body_size
         * @param string $packed_properties
         * @param string $body
         * @param AMQPWriter $pkt
         * @throws AMQPIOException
         */
        public function send_content($channel, $class_id, $weight, $body_size, $packed_properties, $body, $pkt)
        {
        }
        /**
         * Returns a new AMQPWriter or mutates the provided $pkt
         *
         * @param int $channel
         * @param int $class_id
         * @param int $weight
         * @param int $body_size
         * @param string $packed_properties
         * @param string $body
         * @param AMQPWriter|null $pkt
         * @return AMQPWriter
         */
        public function prepare_content($channel, $class_id, $weight, $body_size, $packed_properties, $body, $pkt)
        {
        }
        /**
         * @param int $channel
         * @param array $method_sig
         * @param AMQPWriter|string $args
         * @param null $pkt
         * @throws AMQPIOException
         */
        protected function send_channel_method_frame($channel, $method_sig, $args = '', $pkt = null)
        {
        }
        /**
         * Returns a new AMQPWriter or mutates the provided $pkt
         *
         * @param int $channel
         * @param array $method_sig
         * @param AMQPWriter|string $args
         * @param AMQPWriter|null $pkt
         * @return AMQPWriter
         */
        protected function prepare_channel_method_frame($channel, $method_sig, $args = '', $pkt = null)
        {
        }
        /**
         * Waits for a frame from the server
         *
         * @param int|float|null $timeout
         * @return Frame
         * @throws \Exception
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException
         * @throws AMQPRuntimeException
         */
        protected function wait_frame($timeout = 0): \PhpAmqpLib\Channel\Frame
        {
        }
        /**
         * Waits for a frame from the server destined for a particular channel.
         *
         * @param int $channel_id
         * @param int|float|null $timeout
         * @return Frame
         * @throws \Exception
         */
        protected function wait_channel(int $channel_id, $timeout = 0): \PhpAmqpLib\Channel\Frame
        {
        }
        /**
         * Fetches a channel object identified by the numeric channel_id, or
         * create that object if it doesn't already exist.
         *
         * @param int|null $channel_id
         * @return AMQPChannel
         * @throws \PhpAmqpLib\Exception\AMQPOutOfBoundsException
         * @throws \PhpAmqpLib\Exception\AMQPRuntimeException
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException
         * @throws \PhpAmqpLib\Exception\AMQPConnectionClosedException
         */
        public function channel($channel_id = null)
        {
        }
        /**
         * Requests a connection close
         *
         * @param int $reply_code
         * @param string $reply_text
         * @param array $method_sig
         * @return mixed|null
         * @throws \Exception
         */
        public function close($reply_code = 0, $reply_text = '', $method_sig = array(0, 0))
        {
        }
        /**
         * @param AMQPReader $reader
         * @throws AMQPConnectionClosedException
         */
        protected function connection_close(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * Confirms a connection close
         */
        protected function x_close_ok()
        {
        }
        /**
         * Confirm a connection close
         */
        protected function connection_close_ok()
        {
        }
        /**
         * @param string $virtual_host
         * @param string $capabilities
         * @param bool $insist
         * @return mixed
         */
        protected function x_open($virtual_host, $capabilities = '', $insist = false)
        {
        }
        /**
         * Signals that the connection is ready
         *
         * @param AMQPReader $args
         */
        protected function connection_open_ok($args)
        {
        }
        /**
         * Asks the client to use a different server
         *
         * @param AMQPReader $args
         * @return string
         */
        protected function connection_redirect($args)
        {
        }
        /**
         * Security mechanism challenge
         *
         * @param AMQPReader $args
         */
        protected function connection_secure($args)
        {
        }
        /**
         * Security mechanism response
         *
         * @param string $response
         */
        protected function x_secure_ok($response)
        {
        }
        /**
         * Starts connection negotiation
         *
         * @param AMQPReader $args
         */
        protected function connection_start($args)
        {
        }
        /**
         * @param AMQPTable|array $clientProperties
         * @param string $mechanism
         * @param string $response
         * @param string $locale
         */
        protected function x_start_ok($clientProperties, $mechanism, $response, $locale)
        {
        }
        /**
         * Proposes connection tuning parameters
         *
         * @param AMQPReader $args
         */
        protected function connection_tune($args)
        {
        }
        /**
         * Negotiates connection tuning parameters
         *
         * @param int $channel_max
         * @param int $frame_max
         * @param int $heartbeat
         */
        protected function x_tune_ok($channel_max, $frame_max, $heartbeat)
        {
        }
        /**
         * @return AbstractIO
         * @deprecated
         */
        public function getIO()
        {
        }
        /**
         * Check connection heartbeat if enabled.
         * @throws AMQPHeartbeatMissedException If too much time passed since last connection activity.
         * @throws AMQPConnectionClosedException If connection was closed due to network issues or timeouts.
         * @throws AMQPSocketException If connection was already closed.
         * @throws AMQPTimeoutException If heartbeat write takes too much time.
         * @throws AMQPIOException If other connection problems occurred.
         */
        public function checkHeartBeat()
        {
        }
        /**
         * @return float|int
         */
        public function getLastActivity()
        {
        }
        /**
         * @return float
         * @since 3.2.0
         */
        public function getReadTimeout(): float
        {
        }
        /**
         * Handles connection blocked notifications
         *
         * @param AMQPReader $args
         */
        protected function connection_blocked(\PhpAmqpLib\Wire\AMQPReader $args)
        {
        }
        /**
         * Handles connection unblocked notifications
         */
        protected function connection_unblocked()
        {
        }
        /**
         * Sets a handler which is called whenever a connection.block is sent from the server
         *
         * @param callable $callback
         * @throws \InvalidArgumentException if $callback is not callable
         */
        public function set_connection_block_handler($callback)
        {
        }
        /**
         * Sets a handler which is called whenever a connection.block is sent from the server
         *
         * @param callable $callback
         * @throws \InvalidArgumentException if $callback is not callable
         */
        public function set_connection_unblock_handler($callback)
        {
        }
        /**
         * Gets the connection status
         *
         * @return bool
         */
        public function isConnected()
        {
        }
        /**
         * Get the connection blocked state.
         * @return bool
         * @since 2.12.0
         */
        public function isBlocked()
        {
        }
        /**
         * Get the io writing state.
         * @return bool
         */
        public function isWriting()
        {
        }
        /**
         * Set the connection status
         *
         * @param bool $is_connected
         */
        protected function setIsConnected($is_connected)
        {
        }
        /**
         * Closes all available channels
         */
        protected function closeChannels()
        {
        }
        /**
         * Closes all available channels if disconnected
         */
        protected function closeChannelsIfDisconnected()
        {
        }
        /**
         * Should the connection be attempted during construction?
         *
         * @return bool
         */
        public function connectOnConstruct(): bool
        {
        }
        /**
         * @return array
         */
        public function getServerProperties()
        {
        }
        /**
         * @return int
         */
        public function getHeartbeat()
        {
        }
        /**
         * Get the library properties for populating the client protocol information
         *
         * @return array
         */
        public function getLibraryProperties()
        {
        }
        /**
         * @param array $hosts
         * @param array $options
         *
         * @return mixed
         * @throws \Exception
         * @deprecated Use AMQPConnectionFactory.
         */
        public static function create_connection($hosts, $options = array())
        {
        }
        public static function validate_host($host)
        {
        }
    }
    /**
     * @since 3.2.0
     */
    final class AMQPConnectionConfig
    {
        public const AUTH_PLAIN = 'PLAIN';
        public const AUTH_AMQPPLAIN = 'AMQPLAIN';
        public const AUTH_EXTERNAL = 'EXTERNAL';
        public const IO_TYPE_STREAM = 'stream';
        public const IO_TYPE_SOCKET = 'socket';
        public function getIoType(): string
        {
        }
        /**
         * Set which IO type will be used, stream or socket.
         * @param string $ioType
         */
        public function setIoType(string $ioType): void
        {
        }
        public function isLazy(): bool
        {
        }
        public function setIsLazy(bool $isLazy): void
        {
        }
        public function getHost(): string
        {
        }
        public function setHost(string $host): void
        {
        }
        public function getPort(): int
        {
        }
        public function setPort(int $port): void
        {
        }
        public function getUser(): string
        {
        }
        public function setUser(string $user): void
        {
        }
        public function getPassword(): string
        {
        }
        public function setPassword(string $password): void
        {
        }
        public function getVhost(): string
        {
        }
        public function setVhost(string $vhost): void
        {
        }
        public function isInsist(): bool
        {
        }
        public function setInsist(bool $insist): void
        {
        }
        public function getLoginMethod(): string
        {
        }
        public function setLoginMethod(string $loginMethod): void
        {
        }
        public function getLoginResponse(): ?string
        {
        }
        public function setLoginResponse(string $loginResponse): void
        {
        }
        public function getLocale(): string
        {
        }
        public function setLocale(string $locale): void
        {
        }
        public function getConnectionTimeout(): float
        {
        }
        public function setConnectionTimeout(float $connectionTimeout): void
        {
        }
        public function getReadTimeout(): float
        {
        }
        public function setReadTimeout(float $readTimeout): void
        {
        }
        public function getWriteTimeout(): float
        {
        }
        public function setWriteTimeout(float $writeTimeout): void
        {
        }
        public function getChannelRPCTimeout(): float
        {
        }
        public function setChannelRPCTimeout(float $channelRPCTimeout): void
        {
        }
        public function getHeartbeat(): int
        {
        }
        public function setHeartbeat(int $heartbeat): void
        {
        }
        public function isKeepalive(): bool
        {
        }
        public function setKeepalive(bool $keepalive): void
        {
        }
        public function isSecure(): bool
        {
        }
        public function setIsSecure(bool $isSecure): void
        {
        }
        /**
         * @deprecated Use getSslCryptoMethod()
         */
        public function getNetworkProtocol(): string
        {
        }
        /**
         * @deprecated Use setIsSecure() and setSslCryptoMethod()
         */
        public function setNetworkProtocol(string $networkProtocol): void
        {
        }
        /**
         * @return resource|null
         */
        public function getStreamContext()
        {
        }
        /**
         * @param resource|null $streamContext
         */
        public function setStreamContext($streamContext): void
        {
        }
        /**
         * @return int
         * @since 3.2.1
         */
        public function getSendBufferSize(): int
        {
        }
        /**
         * Socket send buffer size. Set 0 to keep system default.
         * @param int $sendBufferSize
         * @return void
         * @since 3.2.1
         */
        public function setSendBufferSize(int $sendBufferSize): void
        {
        }
        public function isSignalsDispatchEnabled(): bool
        {
        }
        public function enableSignalDispatch(bool $dispatchSignals): void
        {
        }
        /**
         * @return string
         * @deprecated
         */
        public function getAMQPProtocol(): string
        {
        }
        /**
         * @param string $protocol
         * @deprecated
         */
        public function setAMQPProtocol(string $protocol): void
        {
        }
        public function isProtocolStrictFieldsEnabled(): bool
        {
        }
        public function setProtocolStrictFields(bool $protocolStrictFields): void
        {
        }
        public function getSslCaCert(): ?string
        {
        }
        public function setSslCaCert(?string $sslCaCert): void
        {
        }
        public function getSslCaPath(): ?string
        {
        }
        public function setSslCaPath(?string $sslCaPath): void
        {
        }
        public function getSslCert(): ?string
        {
        }
        public function setSslCert(?string $sslCert): void
        {
        }
        public function getSslKey(): ?string
        {
        }
        public function setSslKey(?string $sslKey): void
        {
        }
        public function getSslVerify(): ?bool
        {
        }
        public function setSslVerify(?bool $sslVerify): void
        {
        }
        public function getSslVerifyName(): ?bool
        {
        }
        public function setSslVerifyName(?bool $sslVerifyName): void
        {
        }
        public function getSslPassPhrase(): ?string
        {
        }
        public function setSslPassPhrase(?string $sslPassPhrase): void
        {
        }
        public function getSslCiphers(): ?string
        {
        }
        public function setSslCiphers(?string $sslCiphers): void
        {
        }
        public function getSslSecurityLevel(): ?int
        {
        }
        public function setSslSecurityLevel(?int $sslSecurityLevel): void
        {
        }
        public function getSslCryptoMethod(): ?int
        {
        }
        public function setSslCryptoMethod(?int $sslCryptoMethod): void
        {
        }
        public function isDebugPackets(): bool
        {
        }
        public function setDebugPackets(bool $debugPackets): void
        {
        }
        /**
         * @return string
         */
        public function getConnectionName(): string
        {
        }
        /**
         * @param string $connectionName
         */
        public function setConnectionName(string $connectionName): void
        {
        }
    }
    /**
     * @since 3.2.0
     */
    class AMQPConnectionFactory
    {
        public static function create(\PhpAmqpLib\Connection\AMQPConnectionConfig $config): \PhpAmqpLib\Connection\AbstractConnection
        {
        }
    }
    class AMQPStreamConnection extends \PhpAmqpLib\Connection\AbstractConnection
    {
        /**
         * @param string $host
         * @param int $port
         * @param string $user
         * @param string $password
         * @param string $vhost
         * @param bool $insist
         * @param string $login_method
         * @param null $login_response @deprecated
         * @param string $locale
         * @param float $connection_timeout
         * @param float $read_write_timeout
         * @param resource|array|null $context
         * @param bool $keepalive
         * @param int $heartbeat
         * @param float $channel_rpc_timeout
         * @param string|AMQPConnectionConfig|null $ssl_protocol @deprecated
         * @param AMQPConnectionConfig|null $config
         * @throws \Exception
         */
        public function __construct($host, $port, $user, $password, $vhost = '/', $insist = false, $login_method = 'AMQPLAIN', $login_response = null, $locale = 'en_US', $connection_timeout = 3.0, $read_write_timeout = 3.0, $context = null, $keepalive = false, $heartbeat = 0, $channel_rpc_timeout = 0.0, $ssl_protocol = null, ?\PhpAmqpLib\Connection\AMQPConnectionConfig $config = null)
        {
        }
        /**
         * @deprecated Use AmqpConnectionFactory
         * @throws \Exception
         */
        protected static function try_create_connection($host, $port, $user, $password, $vhost, $options)
        {
        }
    }
    /**
     * @deprecated AMQPStreamConnection can be lazy too. Use AMQPConnectionFactory with AMQPConnectionConfig::setIsLazy(true)
     */
    class AMQPLazyConnection extends \PhpAmqpLib\Connection\AMQPStreamConnection
    {
        /**
         * @inheritDoc
         */
        public function connectOnConstruct(): bool
        {
        }
        /**
         * @param string[][] $hosts
         * @param string[] $options
         * @return self
         * @throws \Exception
         * @deprecated Use ConnectionFactory
         */
        public static function create_connection($hosts, $options = array())
        {
        }
    }
    class AMQPSocketConnection extends \PhpAmqpLib\Connection\AbstractConnection
    {
        /**
         * @param string $host
         * @param int $port
         * @param string $user
         * @param string $password
         * @param string $vhost
         * @param bool $insist
         * @param string $login_method
         * @param null $login_response @deprecated
         * @param string $locale
         * @param int|float $read_timeout
         * @param bool $keepalive
         * @param int $write_timeout
         * @param int $heartbeat
         * @param float $channel_rpc_timeout
         * @param AMQPConnectionConfig|null $config
         * @throws \Exception
         */
        public function __construct($host, $port, $user, $password, $vhost = '/', $insist = false, $login_method = 'AMQPLAIN', $login_response = null, $locale = 'en_US', $read_timeout = 3, $keepalive = false, $write_timeout = 3, $heartbeat = 0, $channel_rpc_timeout = 0.0, ?\PhpAmqpLib\Connection\AMQPConnectionConfig $config = null)
        {
        }
        /**
         * @deprecated Use AmqpConnectionFactory
         * @throws \Exception
         */
        protected static function try_create_connection($host, $port, $user, $password, $vhost, $options)
        {
        }
    }
    /**
     * @deprecated AMQPSocketConnection can be lazy too. Use AMQPConnectionFactory with AMQPConnectionConfig::setIsLazy(true)
     */
    class AMQPLazySocketConnection extends \PhpAmqpLib\Connection\AMQPSocketConnection
    {
        /**
         * @inheritDoc
         */
        public function connectOnConstruct(): bool
        {
        }
        /**
         * @param string[][] $hosts
         * @param string[] $options
         * @return self
         * @throws \Exception
         * @deprecated Use ConnectionFactory
         */
        public static function create_connection($hosts, $options = array())
        {
        }
    }
    /**
     * @deprecated Use AMQPConnectionFactory with AMQPConnectionConfig::setIsSecure(true) and AMQPConnectionConfig::setSsl* methods.
     */
    class AMQPSSLConnection extends \PhpAmqpLib\Connection\AMQPStreamConnection
    {
        /**
         * @param string $host
         * @param int $port
         * @param string $user
         * @param string $password
         * @param string $vhost
         * @param array $ssl_options
         * @param array $options
         * @param AMQPConnectionConfig|null $config
         * @throws \Exception
         */
        public function __construct($host, $port, $user, $password, $vhost = '/', $ssl_options = array(), $options = array(), ?\PhpAmqpLib\Connection\AMQPConnectionConfig $config = null)
        {
        }
        /**
         * @deprecated Use AmqpConnectionFactory
         * @throws \Exception
         */
        public static function try_create_connection($host, $port, $user, $password, $vhost, $options)
        {
        }
    }
    /**
     * @deprecated AMQPLazySSLConnection can be lazy too. Use AMQPConnectionFactory with AMQPConnectionConfig::setIsLazy(true)
     */
    class AMQPLazySSLConnection extends \PhpAmqpLib\Connection\AMQPSSLConnection
    {
        /**
         * @inheritDoc
         */
        public function connectOnConstruct(): bool
        {
        }
        /**
         * @param string[][] $hosts
         * @param string[] $options
         * @return self
         * @throws \Exception
         * @deprecated Use ConnectionFactory
         */
        public static function create_connection($hosts, $options = array())
        {
        }
    }
}
namespace PhpAmqpLib\Connection\Heartbeat {
    /**
     * Manages pcntl-based heartbeat sending for a {@link AbstractConnection}.
     */
    abstract class AbstractSignalHeartbeatSender
    {
        /**
         * @var AbstractConnection|null
         */
        protected $connection;
        /**
         * @var bool
         */
        protected $wasActive = false;
        /**
         * @param AbstractConnection $connection
         * @throws AMQPRuntimeException
         */
        public function __construct(\PhpAmqpLib\Connection\AbstractConnection $connection)
        {
        }
        public function __destruct()
        {
        }
        /**
         * @return bool
         */
        protected function isSupported(): bool
        {
        }
        /**
         * Starts the heartbeats
         */
        abstract public function register(): void;
        /**
         * Stops the heartbeats.
         */
        abstract public function unregister(): void;
        /**
         * Handles the heartbeat when a signal interrupt is received
         *
         * @param int $interval
         */
        protected function handleSignal(int $interval): void
        {
        }
    }
    /**
     * @see AbstractSignalHeartbeatSender
     *
     * This version of a signal based heartbeat sendler relies on using SIGALRM and uses the OS to trigger an alarm
     * after a given time.
     */
    final class PCNTLHeartbeatSender extends \PhpAmqpLib\Connection\Heartbeat\AbstractSignalHeartbeatSender
    {
        public function register(): void
        {
        }
        public function unregister(): void
        {
        }
    }
    /**
     * @see AbstractSignalHeartbeatSender
     * @since 3.2.0
     *
     * This version of a signal based heartbeat sender allows using any signal number. It forks the current process
     * to create a child process that periodically sends a signal to the parent process.
     * The default signal used is SIGUSR1
     */
    final class SIGHeartbeatSender extends \PhpAmqpLib\Connection\Heartbeat\AbstractSignalHeartbeatSender
    {
        /**
         * @param AbstractConnection $connection
         * @param int $signal
         * @throws AMQPRuntimeException
         */
        public function __construct(\PhpAmqpLib\Connection\AbstractConnection $connection, int $signal = SIGUSR1)
        {
        }
        public function register(): void
        {
        }
        public function unregister(): void
        {
        }
    }
}
namespace PhpAmqpLib\Exception {
    interface AMQPExceptionInterface extends \Throwable
    {
    }
    class AMQPBasicCancelException extends \Exception implements \PhpAmqpLib\Exception\AMQPExceptionInterface
    {
        /**
         * @var string
         * @internal Use getter getConsumerTag()
         */
        public $consumerTag;
        /**
         * @param string $consumerTag
         */
        public function __construct($consumerTag)
        {
        }
        /**
         * @return string
         */
        public function getConsumerTag()
        {
        }
    }
    class AMQPRuntimeException extends \RuntimeException implements \PhpAmqpLib\Exception\AMQPExceptionInterface
    {
    }
    class AMQPChannelClosedException extends \PhpAmqpLib\Exception\AMQPRuntimeException
    {
    }
    class AMQPConnectionBlockedException extends \PhpAmqpLib\Exception\AMQPRuntimeException
    {
        public function __construct($message = '', $code = 0, $previous = null)
        {
        }
    }
    /**
     * When connection was closed by server, proxy or some tunnel due to timeout or network issue.
     */
    class AMQPConnectionClosedException extends \PhpAmqpLib\Exception\AMQPRuntimeException
    {
    }
    class AMQPDataReadException extends \PhpAmqpLib\Exception\AMQPRuntimeException
    {
    }
    class AMQPEmptyDeliveryTagException extends \PhpAmqpLib\Exception\AMQPRuntimeException
    {
    }
    class AMQPHeartbeatMissedException extends \PhpAmqpLib\Exception\AMQPConnectionClosedException
    {
    }
    class AMQPInvalidArgumentException extends \RuntimeException implements \PhpAmqpLib\Exception\AMQPExceptionInterface
    {
    }
    class AMQPInvalidFrameException extends \PhpAmqpLib\Exception\AMQPRuntimeException
    {
    }
    class AMQPIOException extends \Exception implements \PhpAmqpLib\Exception\AMQPExceptionInterface
    {
    }
    class AMQPIOWaitException extends \PhpAmqpLib\Exception\AMQPRuntimeException
    {
    }
    class AMQPLogicException extends \LogicException implements \PhpAmqpLib\Exception\AMQPExceptionInterface
    {
    }
    /**
     * Used mostly in non-blocking methods when no data is ready for processing.
     */
    class AMQPNoDataException extends \PhpAmqpLib\Exception\AMQPRuntimeException
    {
    }
    class AMQPNotImplementedException extends \PhpAmqpLib\Exception\AMQPRuntimeException
    {
    }
    class AMQPOutOfBoundsException extends \OutOfBoundsException implements \PhpAmqpLib\Exception\AMQPExceptionInterface
    {
    }
    class AMQPOutOfRangeException extends \OutOfRangeException implements \PhpAmqpLib\Exception\AMQPExceptionInterface
    {
    }
    class AMQPProtocolException extends \Exception implements \PhpAmqpLib\Exception\AMQPExceptionInterface
    {
        /** @var int */
        public $amqp_reply_code;
        /** @var string */
        public $amqp_reply_text;
        /** @var int[] */
        public $amqp_method_sig;
        /** @var array */
        public $args;
        /**
         * @param int $reply_code
         * @param string $reply_text
         * @param int[] $method_sig
         */
        public function __construct($reply_code, $reply_text, $method_sig)
        {
        }
    }
    class AMQPProtocolChannelException extends \PhpAmqpLib\Exception\AMQPProtocolException
    {
    }
    class AMQPSocketException extends \PhpAmqpLib\Exception\AMQPRuntimeException
    {
    }
    class AMQPTimeoutException extends \RuntimeException implements \PhpAmqpLib\Exception\AMQPExceptionInterface
    {
        public function __construct($message = '', $timeout = 0, $code = 0, ?\Exception $previous = null)
        {
        }
        /**
         * @param int|float|null $timeout
         * @param int $code
         * @return self
         */
        public static function writeTimeout($timeout, $code = 0)
        {
        }
        /**
         * @return int|float|null
         */
        public function getTimeout()
        {
        }
    }
}
namespace PhpAmqpLib\Exchange {
    final class AMQPExchangeType
    {
        const DIRECT = 'direct';
        const FANOUT = 'fanout';
        const TOPIC = 'topic';
        const HEADERS = 'headers';
    }
}
namespace PhpAmqpLib\Helper {
    class Assert
    {
        /**
         * @param mixed $argument
         * @throws \InvalidArgumentException
         */
        public static function isCallable($argument)
        {
        }
    }
    class BigInteger extends \phpseclib\Math\BigInteger
    {
    }
    class DebugHelper
    {
        /**
         * @var bool
         */
        protected $debug;
        /**
         * @var resource
         */
        protected $debug_output;
        /**
         * @var Constants
         */
        protected $constants;
        /**
         * @param Constants $constants
         */
        public function __construct(\PhpAmqpLib\Wire\Constants $constants)
        {
        }
        /**
         * @param string $msg
         */
        public function debug_msg($msg)
        {
        }
        /**
         * @param array|null $allowed_methods
         */
        public function debug_allowed_methods($allowed_methods)
        {
        }
        /**
         * @param string|array $method_sig
         */
        public function debug_method_signature1($method_sig)
        {
        }
        /**
         * @param string $msg
         * @param string|array $method_sig
         */
        public function debug_method_signature($msg, $method_sig)
        {
        }
        /**
         * @param string $data
         */
        public function debug_hexdump($data)
        {
        }
        /**
         * @param int $version_major
         * @param int $version_minor
         * @param array $server_properties
         * @param array $mechanisms
         * @param array $locales
         */
        public function debug_connection_start($version_major, $version_minor, $server_properties, $mechanisms, $locales)
        {
        }
        /**
         * @param string $s
         */
        protected function print_msg($s)
        {
        }
    }
    class MiscHelper
    {
        /**
         * @param string|array $a
         * @return string
         */
        public static function methodSig($a)
        {
        }
        /**
         * Gets a number (either int or float) and returns an array containing its integer part as first element and its
         * decimal part mutliplied by 10^6. Useful for some PHP stream functions that need seconds and microseconds as
         * different arguments
         *
         * @param int|float $number
         * @return int[]
         */
        public static function splitSecondsMicroseconds($number)
        {
        }
        /**
         * View any string as a hexdump.
         *
         * This is most commonly used to view binary data from streams
         * or sockets while debugging, but can be used to view any string
         * with non-viewable characters.
         *
         * @version     1.3.2
         * @author      Aidan Lister <aidan@php.net>
         * @author      Peter Waller <iridum@php.net>
         * @link        http://aidanlister.com/repos/v/function.hexdump.php
         *
         * @param string $data The string to be dumped
         * @param bool $htmloutput Set to false for non-HTML output
         * @param bool $uppercase Set to true for uppercase hex
         * @param bool $return Set to true to return the dump
         * @return string|null
         */
        public static function hexdump($data, $htmloutput = true, $uppercase = false, $return = false)
        {
        }
        /**
         * @param array $table
         * @return string
         */
        public static function dump_table($table)
        {
        }
    }
}
namespace PhpAmqpLib\Helper\Protocol {
    class MethodMap080
    {
        /**
         * @var array
         */
        protected $method_map = array('10,10' => 'connection_start', '10,11' => 'connection_start_ok', '10,20' => 'connection_secure', '10,21' => 'connection_secure_ok', '10,30' => 'connection_tune', '10,31' => 'connection_tune_ok', '10,40' => 'connection_open', '10,41' => 'connection_open_ok', '10,50' => 'connection_redirect', '10,60' => 'connection_close', '10,61' => 'connection_close_ok', '20,10' => 'channel_open', '20,11' => 'channel_open_ok', '20,20' => 'channel_flow', '20,21' => 'channel_flow_ok', '20,30' => 'channel_alert', '20,40' => 'channel_close', '20,41' => 'channel_close_ok', '30,10' => 'access_request', '30,11' => 'access_request_ok', '40,10' => 'exchange_declare', '40,11' => 'exchange_declare_ok', '40,20' => 'exchange_delete', '40,21' => 'exchange_delete_ok', '50,10' => 'queue_declare', '50,11' => 'queue_declare_ok', '50,20' => 'queue_bind', '50,21' => 'queue_bind_ok', '50,30' => 'queue_purge', '50,31' => 'queue_purge_ok', '50,40' => 'queue_delete', '50,41' => 'queue_delete_ok', '50,50' => 'queue_unbind', '50,51' => 'queue_unbind_ok', '60,10' => 'basic_qos', '60,11' => 'basic_qos_ok', '60,20' => 'basic_consume', '60,21' => 'basic_consume_ok', '60,30' => 'basic_cancel', '60,31' => 'basic_cancel_ok', '60,40' => 'basic_publish', '60,50' => 'basic_return', '60,60' => 'basic_deliver', '60,70' => 'basic_get', '60,71' => 'basic_get_ok', '60,72' => 'basic_get_empty', '60,80' => 'basic_ack', '60,90' => 'basic_reject', '60,100' => 'basic_recover_async', '60,110' => 'basic_recover', '60,111' => 'basic_recover_ok', '70,10' => 'file_qos', '70,11' => 'file_qos_ok', '70,20' => 'file_consume', '70,21' => 'file_consume_ok', '70,30' => 'file_cancel', '70,31' => 'file_cancel_ok', '70,40' => 'file_open', '70,41' => 'file_open_ok', '70,50' => 'file_stage', '70,60' => 'file_publish', '70,70' => 'file_return', '70,80' => 'file_deliver', '70,90' => 'file_ack', '70,100' => 'file_reject', '80,10' => 'stream_qos', '80,11' => 'stream_qos_ok', '80,20' => 'stream_consume', '80,21' => 'stream_consume_ok', '80,30' => 'stream_cancel', '80,31' => 'stream_cancel_ok', '80,40' => 'stream_publish', '80,50' => 'stream_return', '80,60' => 'stream_deliver', '90,10' => 'tx_select', '90,11' => 'tx_select_ok', '90,20' => 'tx_commit', '90,21' => 'tx_commit_ok', '90,30' => 'tx_rollback', '90,31' => 'tx_rollback_ok', '100,10' => 'dtx_select', '100,11' => 'dtx_select_ok', '100,20' => 'dtx_start', '100,21' => 'dtx_start_ok', '110,10' => 'tunnel_request', '120,10' => 'test_integer', '120,11' => 'test_integer_ok', '120,20' => 'test_string', '120,21' => 'test_string_ok', '120,30' => 'test_table', '120,31' => 'test_table_ok', '120,40' => 'test_content', '120,41' => 'test_content_ok');
        /**
         * @var string $method_sig
         * @return string
         */
        public function get_method($method_sig)
        {
        }
        /**
         * @var string $method_sig
         * @return bool
         */
        public function valid_method($method_sig)
        {
        }
    }
    class MethodMap091
    {
        /**
         * @var array
         */
        protected $method_map = array('10,10' => 'connection_start', '10,11' => 'connection_start_ok', '10,20' => 'connection_secure', '10,21' => 'connection_secure_ok', '10,30' => 'connection_tune', '10,31' => 'connection_tune_ok', '10,40' => 'connection_open', '10,41' => 'connection_open_ok', '10,50' => 'connection_close', '10,51' => 'connection_close_ok', '10,60' => 'connection_blocked', '10,61' => 'connection_unblocked', '20,10' => 'channel_open', '20,11' => 'channel_open_ok', '20,20' => 'channel_flow', '20,21' => 'channel_flow_ok', '20,40' => 'channel_close', '20,41' => 'channel_close_ok', '30,10' => 'access_request', '30,11' => 'access_request_ok', '40,10' => 'exchange_declare', '40,11' => 'exchange_declare_ok', '40,20' => 'exchange_delete', '40,21' => 'exchange_delete_ok', '40,30' => 'exchange_bind', '40,31' => 'exchange_bind_ok', '40,40' => 'exchange_unbind', '40,51' => 'exchange_unbind_ok', '50,10' => 'queue_declare', '50,11' => 'queue_declare_ok', '50,20' => 'queue_bind', '50,21' => 'queue_bind_ok', '50,30' => 'queue_purge', '50,31' => 'queue_purge_ok', '50,40' => 'queue_delete', '50,41' => 'queue_delete_ok', '50,50' => 'queue_unbind', '50,51' => 'queue_unbind_ok', '60,10' => 'basic_qos', '60,11' => 'basic_qos_ok', '60,20' => 'basic_consume', '60,21' => 'basic_consume_ok', '60,30' => 'basic_cancel_from_server', '60,31' => 'basic_cancel_ok', '60,40' => 'basic_publish', '60,50' => 'basic_return', '60,60' => 'basic_deliver', '60,70' => 'basic_get', '60,71' => 'basic_get_ok', '60,72' => 'basic_get_empty', '60,80' => 'basic_ack_from_server', '60,90' => 'basic_reject', '60,100' => 'basic_recover_async', '60,110' => 'basic_recover', '60,111' => 'basic_recover_ok', '60,120' => 'basic_nack_from_server', '90,10' => 'tx_select', '90,11' => 'tx_select_ok', '90,20' => 'tx_commit', '90,21' => 'tx_commit_ok', '90,30' => 'tx_rollback', '90,31' => 'tx_rollback_ok', '85,10' => 'confirm_select', '85,11' => 'confirm_select_ok');
        /**
         * @var string $method_sig
         * @return string
         */
        public function get_method($method_sig)
        {
        }
        /**
         * @var string $method_sig
         * @return bool
         */
        public function valid_method($method_sig)
        {
        }
    }
    class Protocol080
    {
        /**
         * @param int $version_major
         * @param int $version_minor
         * @param mixed $server_properties
         * @param string $mechanisms
         * @param string $locales
         * @return array
         */
        public function connectionStart($version_major = 0, $version_minor = 8, $server_properties = [], $mechanisms = 'PLAIN', $locales = 'en_US')
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function connectionStartOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param string $challenge
         * @return array
         */
        public function connectionSecure($challenge)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function connectionSecureOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $channel_max
         * @param int $frame_max
         * @param int $heartbeat
         * @return array
         */
        public function connectionTune($channel_max = 0, $frame_max = 0, $heartbeat = 0)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function connectionTuneOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param string $virtual_host
         * @param string $capabilities
         * @param bool $insist
         * @return array
         */
        public function connectionOpen($virtual_host = '/', $capabilities = '', $insist = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function connectionOpenOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param string $host
         * @param string $known_hosts
         * @return array
         */
        public function connectionRedirect($host, $known_hosts = '')
        {
        }
        /**
         * @param int $reply_code
         * @param string $reply_text
         * @param int $class_id
         * @param int $method_id
         * @return array
         */
        public function connectionClose($reply_code, $reply_text, $class_id, $method_id)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function connectionCloseOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param string $out_of_band
         * @return array
         */
        public function channelOpen($out_of_band = '')
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function channelOpenOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param bool $active
         * @return array
         */
        public function channelFlow($active)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function channelFlowOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $reply_code
         * @param string $reply_text
         * @param \PhpAmqpLib\Wire\AMQPTable|array $details
         * @return array
         */
        public function channelAlert($reply_code, $reply_text = '', $details = array())
        {
        }
        /**
         * @param int $reply_code
         * @param string $reply_text
         * @param int $class_id
         * @param int $method_id
         * @return array
         */
        public function channelClose($reply_code, $reply_text, $class_id, $method_id)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function channelCloseOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param string $realm
         * @param bool $exclusive
         * @param bool $passive
         * @param bool $active
         * @param bool $write
         * @param bool $read
         * @return array
         */
        public function accessRequest($realm = '/data', $exclusive = false, $passive = true, $active = true, $write = true, $read = true)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function accessRequestOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $exchange
         * @param string $type
         * @param bool $passive
         * @param bool $durable
         * @param bool $auto_delete
         * @param bool $internal
         * @param bool $nowait
         * @param \PhpAmqpLib\Wire\AMQPTable|array $arguments
         * @return array
         */
        public function exchangeDeclare($ticket = 1, $exchange = '', $type = 'direct', $passive = false, $durable = false, $auto_delete = false, $internal = false, $nowait = false, $arguments = array())
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function exchangeDeclareOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $exchange
         * @param bool $if_unused
         * @param bool $nowait
         * @return array
         */
        public function exchangeDelete($ticket = 1, $exchange = '', $if_unused = false, $nowait = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function exchangeDeleteOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $queue
         * @param bool $passive
         * @param bool $durable
         * @param bool $exclusive
         * @param bool $auto_delete
         * @param bool $nowait
         * @param \PhpAmqpLib\Wire\AMQPTable|array $arguments
         * @return array
         */
        public function queueDeclare($ticket = 1, $queue = '', $passive = false, $durable = false, $exclusive = false, $auto_delete = false, $nowait = false, $arguments = array())
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function queueDeclareOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $queue
         * @param string $exchange
         * @param string $routing_key
         * @param bool $nowait
         * @param \PhpAmqpLib\Wire\AMQPTable|array $arguments
         * @return array
         */
        public function queueBind($ticket = 1, $queue = '', $exchange = '', $routing_key = '', $nowait = false, $arguments = array())
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function queueBindOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $queue
         * @param bool $nowait
         * @return array
         */
        public function queuePurge($ticket = 1, $queue = '', $nowait = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function queuePurgeOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $queue
         * @param bool $if_unused
         * @param bool $if_empty
         * @param bool $nowait
         * @return array
         */
        public function queueDelete($ticket = 1, $queue = '', $if_unused = false, $if_empty = false, $nowait = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function queueDeleteOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $queue
         * @param string $exchange
         * @param string $routing_key
         * @param \PhpAmqpLib\Wire\AMQPTable|array $arguments
         * @return array
         */
        public function queueUnbind($ticket = 1, $queue = '', $exchange = '', $routing_key = '', $arguments = array())
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function queueUnbindOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $prefetch_size
         * @param int $prefetch_count
         * @param bool $global
         * @return array
         */
        public function basicQos($prefetch_size = 0, $prefetch_count = 0, $global = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function basicQosOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $queue
         * @param string $consumer_tag
         * @param bool $no_local
         * @param bool $no_ack
         * @param bool $exclusive
         * @param bool $nowait
         * @return array
         */
        public function basicConsume($ticket = 1, $queue = '', $consumer_tag = '', $no_local = false, $no_ack = false, $exclusive = false, $nowait = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function basicConsumeOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param string $consumer_tag
         * @param bool $nowait
         * @return array
         */
        public function basicCancel($consumer_tag, $nowait = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function basicCancelOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $exchange
         * @param string $routing_key
         * @param bool $mandatory
         * @param bool $immediate
         * @return array
         */
        public function basicPublish($ticket = 1, $exchange = '', $routing_key = '', $mandatory = false, $immediate = false)
        {
        }
        /**
         * @param int $reply_code
         * @param string $reply_text
         * @param string $exchange
         * @param string $routing_key
         * @return array
         */
        public function basicReturn($reply_code, $reply_text, $exchange, $routing_key)
        {
        }
        /**
         * @param string $consumer_tag
         * @param int $delivery_tag
         * @param bool $redelivered
         * @param string $exchange
         * @param string $routing_key
         * @return array
         */
        public function basicDeliver($consumer_tag, $delivery_tag, $redelivered, $exchange, $routing_key)
        {
        }
        /**
         * @param int $ticket
         * @param string $queue
         * @param bool $no_ack
         * @return array
         */
        public function basicGet($ticket = 1, $queue = '', $no_ack = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function basicGetOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function basicGetEmpty(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $delivery_tag
         * @param bool $multiple
         * @return array
         */
        public function basicAck($delivery_tag = 0, $multiple = false)
        {
        }
        /**
         * @param int $delivery_tag
         * @param bool $requeue
         * @return array
         */
        public function basicReject($delivery_tag, $requeue = true)
        {
        }
        /**
         * @param bool $requeue
         * @return array
         */
        public function basicRecoverAsync($requeue = false)
        {
        }
        /**
         * @param bool $requeue
         * @return array
         */
        public function basicRecover($requeue = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function basicRecoverOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $prefetch_size
         * @param int $prefetch_count
         * @param bool $global
         * @return array
         */
        public function fileQos($prefetch_size = 0, $prefetch_count = 0, $global = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function fileQosOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $queue
         * @param string $consumer_tag
         * @param bool $no_local
         * @param bool $no_ack
         * @param bool $exclusive
         * @param bool $nowait
         * @return array
         */
        public function fileConsume($ticket = 1, $queue = '', $consumer_tag = '', $no_local = false, $no_ack = false, $exclusive = false, $nowait = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function fileConsumeOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param string $consumer_tag
         * @param bool $nowait
         * @return array
         */
        public function fileCancel($consumer_tag, $nowait = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function fileCancelOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param string $identifier
         * @param int $content_size
         * @return array
         */
        public function fileOpen($identifier, $content_size)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function fileOpenOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @return array
         */
        public function fileStage()
        {
        }
        /**
         * @param int $ticket
         * @param string $exchange
         * @param string $routing_key
         * @param bool $mandatory
         * @param bool $immediate
         * @param string $identifier
         * @return array
         */
        public function filePublish($ticket = 1, $exchange = '', $routing_key = '', $mandatory = false, $immediate = false, $identifier = '')
        {
        }
        /**
         * @param int $reply_code
         * @param string $reply_text
         * @param string $exchange
         * @param string $routing_key
         * @return array
         */
        public function fileReturn($reply_code = 200, $reply_text = '', $exchange = '', $routing_key = '')
        {
        }
        /**
         * @param string $consumer_tag
         * @param int $delivery_tag
         * @param bool $redelivered
         * @param string $exchange
         * @param string $routing_key
         * @param string $identifier
         * @return array
         */
        public function fileDeliver($consumer_tag, $delivery_tag, $redelivered, $exchange, $routing_key, $identifier)
        {
        }
        /**
         * @param int $delivery_tag
         * @param bool $multiple
         * @return array
         */
        public function fileAck($delivery_tag = 0, $multiple = false)
        {
        }
        /**
         * @param int $delivery_tag
         * @param bool $requeue
         * @return array
         */
        public function fileReject($delivery_tag, $requeue = true)
        {
        }
        /**
         * @param int $prefetch_size
         * @param int $prefetch_count
         * @param int $consume_rate
         * @param bool $global
         * @return array
         */
        public function streamQos($prefetch_size = 0, $prefetch_count = 0, $consume_rate = 0, $global = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function streamQosOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $queue
         * @param string $consumer_tag
         * @param bool $no_local
         * @param bool $exclusive
         * @param bool $nowait
         * @return array
         */
        public function streamConsume($ticket = 1, $queue = '', $consumer_tag = '', $no_local = false, $exclusive = false, $nowait = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function streamConsumeOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param string $consumer_tag
         * @param bool $nowait
         * @return array
         */
        public function streamCancel($consumer_tag, $nowait = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function streamCancelOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $exchange
         * @param string $routing_key
         * @param bool $mandatory
         * @param bool $immediate
         * @return array
         */
        public function streamPublish($ticket = 1, $exchange = '', $routing_key = '', $mandatory = false, $immediate = false)
        {
        }
        /**
         * @param int $reply_code
         * @param string $reply_text
         * @param string $exchange
         * @param string $routing_key
         * @return array
         */
        public function streamReturn($reply_code = 200, $reply_text = '', $exchange = '', $routing_key = '')
        {
        }
        /**
         * @param string $consumer_tag
         * @param int $delivery_tag
         * @param string $exchange
         * @param string $queue
         * @return array
         */
        public function streamDeliver($consumer_tag, $delivery_tag, $exchange, $queue)
        {
        }
        /**
         * @return array
         */
        public function txSelect()
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function txSelectOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @return array
         */
        public function txCommit()
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function txCommitOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @return array
         */
        public function txRollback()
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function txRollbackOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @return array
         */
        public function dtxSelect()
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function dtxSelectOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param string $dtx_identifier
         * @return array
         */
        public function dtxStart($dtx_identifier)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function dtxStartOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param \PhpAmqpLib\Wire\AMQPTable|array $meta_data
         * @return array
         */
        public function tunnelRequest($meta_data)
        {
        }
        /**
         * @param int $integer_1
         * @param int $integer_2
         * @param int $integer_3
         * @param int $integer_4
         * @param int $operation
         * @return array
         */
        public function testInteger($integer_1, $integer_2, $integer_3, $integer_4, $operation)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function testIntegerOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param string $string_1
         * @param string $string_2
         * @param int $operation
         * @return array
         */
        public function testString($string_1, $string_2, $operation)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function testStringOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param \PhpAmqpLib\Wire\AMQPTable|array $table
         * @param int $integer_op
         * @param int $string_op
         * @return array
         */
        public function testTable($table, $integer_op, $string_op)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function testTableOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @return array
         */
        public function testContent()
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function testContentOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
    }
    class Protocol091
    {
        /**
         * @param int $version_major
         * @param int $version_minor
         * @param mixed $server_properties
         * @param string $mechanisms
         * @param string $locales
         * @return array
         */
        public function connectionStart($version_major = 0, $version_minor = 9, $server_properties = [], $mechanisms = 'PLAIN', $locales = 'en_US')
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function connectionStartOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param string $challenge
         * @return array
         */
        public function connectionSecure($challenge)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function connectionSecureOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $channel_max
         * @param int $frame_max
         * @param int $heartbeat
         * @return array
         */
        public function connectionTune($channel_max = 0, $frame_max = 0, $heartbeat = 0)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function connectionTuneOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param string $virtual_host
         * @param string $capabilities
         * @param bool $insist
         * @return array
         */
        public function connectionOpen($virtual_host = '/', $capabilities = '', $insist = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function connectionOpenOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $reply_code
         * @param string $reply_text
         * @param int $class_id
         * @param int $method_id
         * @return array
         */
        public function connectionClose($reply_code, $reply_text, $class_id, $method_id)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function connectionCloseOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param string $reason
         * @return array
         */
        public function connectionBlocked($reason = '')
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function connectionUnblocked(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param string $out_of_band
         * @return array
         */
        public function channelOpen($out_of_band = '')
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function channelOpenOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param bool $active
         * @return array
         */
        public function channelFlow($active)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function channelFlowOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $reply_code
         * @param string $reply_text
         * @param int $class_id
         * @param int $method_id
         * @return array
         */
        public function channelClose($reply_code, $reply_text, $class_id, $method_id)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function channelCloseOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param string $realm
         * @param bool $exclusive
         * @param bool $passive
         * @param bool $active
         * @param bool $write
         * @param bool $read
         * @return array
         */
        public function accessRequest($realm = '/data', $exclusive = false, $passive = true, $active = true, $write = true, $read = true)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function accessRequestOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $exchange
         * @param string $type
         * @param bool $passive
         * @param bool $durable
         * @param bool $auto_delete
         * @param bool $internal
         * @param bool $nowait
         * @param \PhpAmqpLib\Wire\AMQPTable|array $arguments
         * @return array
         */
        public function exchangeDeclare($ticket = 0, $exchange = '', $type = 'direct', $passive = false, $durable = false, $auto_delete = false, $internal = false, $nowait = false, $arguments = array())
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function exchangeDeclareOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $exchange
         * @param bool $if_unused
         * @param bool $nowait
         * @return array
         */
        public function exchangeDelete($ticket = 0, $exchange = '', $if_unused = false, $nowait = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function exchangeDeleteOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $destination
         * @param string $source
         * @param string $routing_key
         * @param bool $nowait
         * @param \PhpAmqpLib\Wire\AMQPTable|array $arguments
         * @return array
         */
        public function exchangeBind($ticket = 0, $destination = '', $source = '', $routing_key = '', $nowait = false, $arguments = array())
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function exchangeBindOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $destination
         * @param string $source
         * @param string $routing_key
         * @param bool $nowait
         * @param \PhpAmqpLib\Wire\AMQPTable|array $arguments
         * @return array
         */
        public function exchangeUnbind($ticket = 0, $destination = '', $source = '', $routing_key = '', $nowait = false, $arguments = array())
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function exchangeUnbindOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $queue
         * @param bool $passive
         * @param bool $durable
         * @param bool $exclusive
         * @param bool $auto_delete
         * @param bool $nowait
         * @param \PhpAmqpLib\Wire\AMQPTable|array $arguments
         * @return array
         */
        public function queueDeclare($ticket = 0, $queue = '', $passive = false, $durable = false, $exclusive = false, $auto_delete = false, $nowait = false, $arguments = array())
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function queueDeclareOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $queue
         * @param string $exchange
         * @param string $routing_key
         * @param bool $nowait
         * @param \PhpAmqpLib\Wire\AMQPTable|array $arguments
         * @return array
         */
        public function queueBind($ticket = 0, $queue = '', $exchange = '', $routing_key = '', $nowait = false, $arguments = array())
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function queueBindOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $queue
         * @param bool $nowait
         * @return array
         */
        public function queuePurge($ticket = 0, $queue = '', $nowait = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function queuePurgeOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $queue
         * @param bool $if_unused
         * @param bool $if_empty
         * @param bool $nowait
         * @return array
         */
        public function queueDelete($ticket = 0, $queue = '', $if_unused = false, $if_empty = false, $nowait = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function queueDeleteOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $queue
         * @param string $exchange
         * @param string $routing_key
         * @param \PhpAmqpLib\Wire\AMQPTable|array $arguments
         * @return array
         */
        public function queueUnbind($ticket = 0, $queue = '', $exchange = '', $routing_key = '', $arguments = array())
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function queueUnbindOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * Specifies QoS
         * 
         * See https://www.rabbitmq.com/consumer-prefetch.html#overview for details
         * 
         * @param int $prefetch_size Default is 0 (Alias for unlimited)
         * @param int $prefetch_count Default is 0 (Alias for unlimited)
         * @param bool $global Default is false, prefetch size and count are applied to each channel consumer separately
         * @return array
         */
        public function basicQos($prefetch_size = 0, $prefetch_count = 0, $global = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function basicQosOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $queue
         * @param string $consumer_tag
         * @param bool $no_local
         * @param bool $no_ack
         * @param bool $exclusive
         * @param bool $nowait
         * @param \PhpAmqpLib\Wire\AMQPTable|array $arguments
         * @return array
         */
        public function basicConsume($ticket = 0, $queue = '', $consumer_tag = '', $no_local = false, $no_ack = false, $exclusive = false, $nowait = false, $arguments = array())
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function basicConsumeOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param string $consumer_tag
         * @param bool $nowait
         * @return array
         */
        public function basicCancel($consumer_tag, $nowait = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function basicCancelOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $ticket
         * @param string $exchange
         * @param string $routing_key
         * @param bool $mandatory
         * @param bool $immediate
         * @return array
         */
        public function basicPublish($ticket = 0, $exchange = '', $routing_key = '', $mandatory = false, $immediate = false)
        {
        }
        /**
         * @param int $reply_code
         * @param string $reply_text
         * @param string $exchange
         * @param string $routing_key
         * @return array
         */
        public function basicReturn($reply_code, $reply_text, $exchange, $routing_key)
        {
        }
        /**
         * @param string $consumer_tag
         * @param int $delivery_tag
         * @param bool $redelivered
         * @param string $exchange
         * @param string $routing_key
         * @return array
         */
        public function basicDeliver($consumer_tag, $delivery_tag, $redelivered, $exchange, $routing_key)
        {
        }
        /**
         * @param int $ticket
         * @param string $queue
         * @param bool $no_ack
         * @return array
         */
        public function basicGet($ticket = 0, $queue = '', $no_ack = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function basicGetOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function basicGetEmpty(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $delivery_tag
         * @param bool $multiple
         * @return array
         */
        public function basicAck($delivery_tag = 0, $multiple = false)
        {
        }
        /**
         * @param int $delivery_tag
         * @param bool $requeue
         * @return array
         */
        public function basicReject($delivery_tag, $requeue = true)
        {
        }
        /**
         * @param bool $requeue
         * @return array
         */
        public function basicRecoverAsync($requeue = false)
        {
        }
        /**
         * @param bool $requeue
         * @return array
         */
        public function basicRecover($requeue = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function basicRecoverOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param int $delivery_tag
         * @param bool $multiple
         * @param bool $requeue
         * @return array
         */
        public function basicNack($delivery_tag = 0, $multiple = false, $requeue = true)
        {
        }
        /**
         * @return array
         */
        public function txSelect()
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function txSelectOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @return array
         */
        public function txCommit()
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function txCommitOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @return array
         */
        public function txRollback()
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function txRollbackOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * @param bool $nowait
         * @return array
         */
        public function confirmSelect($nowait = false)
        {
        }
        /**
         * @param AMQPReader $reader
         * @return array
         */
        public static function confirmSelectOk(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
    }
    class Wait080
    {
        /**
         * @var array
         */
        protected $wait = array('connection.start' => '10,10', 'connection.start_ok' => '10,11', 'connection.secure' => '10,20', 'connection.secure_ok' => '10,21', 'connection.tune' => '10,30', 'connection.tune_ok' => '10,31', 'connection.open' => '10,40', 'connection.open_ok' => '10,41', 'connection.redirect' => '10,50', 'connection.close' => '10,60', 'connection.close_ok' => '10,61', 'channel.open' => '20,10', 'channel.open_ok' => '20,11', 'channel.flow' => '20,20', 'channel.flow_ok' => '20,21', 'channel.alert' => '20,30', 'channel.close' => '20,40', 'channel.close_ok' => '20,41', 'access.request' => '30,10', 'access.request_ok' => '30,11', 'exchange.declare' => '40,10', 'exchange.declare_ok' => '40,11', 'exchange.delete' => '40,20', 'exchange.delete_ok' => '40,21', 'queue.declare' => '50,10', 'queue.declare_ok' => '50,11', 'queue.bind' => '50,20', 'queue.bind_ok' => '50,21', 'queue.purge' => '50,30', 'queue.purge_ok' => '50,31', 'queue.delete' => '50,40', 'queue.delete_ok' => '50,41', 'queue.unbind' => '50,50', 'queue.unbind_ok' => '50,51', 'basic.qos' => '60,10', 'basic.qos_ok' => '60,11', 'basic.consume' => '60,20', 'basic.consume_ok' => '60,21', 'basic.cancel' => '60,30', 'basic.cancel_ok' => '60,31', 'basic.publish' => '60,40', 'basic.return' => '60,50', 'basic.deliver' => '60,60', 'basic.get' => '60,70', 'basic.get_ok' => '60,71', 'basic.get_empty' => '60,72', 'basic.ack' => '60,80', 'basic.reject' => '60,90', 'basic.recover_async' => '60,100', 'basic.recover' => '60,110', 'basic.recover_ok' => '60,111', 'file.qos' => '70,10', 'file.qos_ok' => '70,11', 'file.consume' => '70,20', 'file.consume_ok' => '70,21', 'file.cancel' => '70,30', 'file.cancel_ok' => '70,31', 'file.open' => '70,40', 'file.open_ok' => '70,41', 'file.stage' => '70,50', 'file.publish' => '70,60', 'file.return' => '70,70', 'file.deliver' => '70,80', 'file.ack' => '70,90', 'file.reject' => '70,100', 'stream.qos' => '80,10', 'stream.qos_ok' => '80,11', 'stream.consume' => '80,20', 'stream.consume_ok' => '80,21', 'stream.cancel' => '80,30', 'stream.cancel_ok' => '80,31', 'stream.publish' => '80,40', 'stream.return' => '80,50', 'stream.deliver' => '80,60', 'tx.select' => '90,10', 'tx.select_ok' => '90,11', 'tx.commit' => '90,20', 'tx.commit_ok' => '90,21', 'tx.rollback' => '90,30', 'tx.rollback_ok' => '90,31', 'dtx.select' => '100,10', 'dtx.select_ok' => '100,11', 'dtx.start' => '100,20', 'dtx.start_ok' => '100,21', 'tunnel.request' => '110,10', 'test.integer' => '120,10', 'test.integer_ok' => '120,11', 'test.string' => '120,20', 'test.string_ok' => '120,21', 'test.table' => '120,30', 'test.table_ok' => '120,31', 'test.content' => '120,40', 'test.content_ok' => '120,41');
        /**
         * @var string $method
         * @return string
         */
        public function get_wait($method)
        {
        }
    }
    class Wait091
    {
        /**
         * @var array
         */
        protected $wait = array('connection.start' => '10,10', 'connection.start_ok' => '10,11', 'connection.secure' => '10,20', 'connection.secure_ok' => '10,21', 'connection.tune' => '10,30', 'connection.tune_ok' => '10,31', 'connection.open' => '10,40', 'connection.open_ok' => '10,41', 'connection.close' => '10,50', 'connection.close_ok' => '10,51', 'connection.blocked' => '10,60', 'connection.unblocked' => '10,61', 'channel.open' => '20,10', 'channel.open_ok' => '20,11', 'channel.flow' => '20,20', 'channel.flow_ok' => '20,21', 'channel.close' => '20,40', 'channel.close_ok' => '20,41', 'access.request' => '30,10', 'access.request_ok' => '30,11', 'exchange.declare' => '40,10', 'exchange.declare_ok' => '40,11', 'exchange.delete' => '40,20', 'exchange.delete_ok' => '40,21', 'exchange.bind' => '40,30', 'exchange.bind_ok' => '40,31', 'exchange.unbind' => '40,40', 'exchange.unbind_ok' => '40,51', 'queue.declare' => '50,10', 'queue.declare_ok' => '50,11', 'queue.bind' => '50,20', 'queue.bind_ok' => '50,21', 'queue.purge' => '50,30', 'queue.purge_ok' => '50,31', 'queue.delete' => '50,40', 'queue.delete_ok' => '50,41', 'queue.unbind' => '50,50', 'queue.unbind_ok' => '50,51', 'basic.qos' => '60,10', 'basic.qos_ok' => '60,11', 'basic.consume' => '60,20', 'basic.consume_ok' => '60,21', 'basic.cancel' => '60,30', 'basic.cancel_ok' => '60,31', 'basic.publish' => '60,40', 'basic.return' => '60,50', 'basic.deliver' => '60,60', 'basic.get' => '60,70', 'basic.get_ok' => '60,71', 'basic.get_empty' => '60,72', 'basic.ack' => '60,80', 'basic.reject' => '60,90', 'basic.recover_async' => '60,100', 'basic.recover' => '60,110', 'basic.recover_ok' => '60,111', 'basic.nack' => '60,120', 'tx.select' => '90,10', 'tx.select_ok' => '90,11', 'tx.commit' => '90,20', 'tx.commit_ok' => '90,21', 'tx.rollback' => '90,30', 'tx.rollback_ok' => '90,31', 'confirm.select' => '85,10', 'confirm.select_ok' => '85,11');
        /**
         * @var string $method
         * @return string
         */
        public function get_wait($method)
        {
        }
    }
}
namespace PhpAmqpLib\Helper {
    /**
     * @property-read int $SOCKET_EPIPE
     * @property-read int $SOCKET_ENETDOWN
     * @property-read int $SOCKET_ENETUNREACH
     * @property-read int $SOCKET_ENETRESET
     * @property-read int $SOCKET_ECONNABORTED
     * @property-read int $SOCKET_ECONNRESET
     * @property-read int $SOCKET_ECONNREFUSED
     * @property-read int $SOCKET_ETIMEDOUT
     * @property-read int $SOCKET_EWOULDBLOCK
     * @property-read int $SOCKET_EINTR
     * @property-read int $SOCKET_EAGAIN
     */
    final class SocketConstants
    {
        public function __construct()
        {
        }
        /**
         * @param string $name
         * @return int
         */
        public function __get($name)
        {
        }
        /**
         * @param string $name
         * @param int $value
         * @internal
         */
        public function __set($name, $value)
        {
        }
        /**
         * @param string $name
         * @return bool
         */
        public function __isset($name)
        {
        }
        /**
         * @return self
         */
        public static function getInstance()
        {
        }
    }
}
namespace PhpAmqpLib\Message {
    /**
     * A Message for use with the Channnel.basic_* methods.
     */
    class AMQPMessage
    {
        const DELIVERY_MODE_NON_PERSISTENT = 1;
        const DELIVERY_MODE_PERSISTENT = 2;
        /**
         * @var string
         * @deprecated Will be removed in version 4.0, use getBody() instead.
         */
        public $body;
        /**
         * @var int
         * @deprecated Will be removed in version 4.0, use getBodySize() instead.
         */
        public $body_size;
        /**
         * @var bool
         * @deprecated Will be removed in version 4.0, use isTruncated() instead.
         */
        public $is_truncated = false;
        /**
         * @var string
         * @deprecated Will be removed in version 4.0, use getContentEncoding() instead.
         */
        public $content_encoding;
        /**
         * @var array
         * @internal
         * @deprecated Will be removed in version 4.0, use one of getters to get delivery info.
         */
        public $delivery_info = array();
        /** @var array Properties content */
        protected $properties = array();
        /** @var null|string Compiled properties */
        protected $serialized_properties;
        /** @var array */
        protected static $propertyDefinitions = array('content_type' => 'shortstr', 'content_encoding' => 'shortstr', 'application_headers' => 'table_object', 'delivery_mode' => 'octet', 'priority' => 'octet', 'correlation_id' => 'shortstr', 'reply_to' => 'shortstr', 'expiration' => 'shortstr', 'message_id' => 'shortstr', 'timestamp' => 'timestamp', 'type' => 'shortstr', 'user_id' => 'shortstr', 'app_id' => 'shortstr', 'cluster_id' => 'shortstr');
        /**
         * @param string $body
         * @param array $properties
         */
        public function __construct($body = '', $properties = array())
        {
        }
        /**
         * Acknowledge one or more messages.
         *
         * @param bool $multiple If true, the delivery tag is treated as "up to and including",
         *                       so that multiple messages can be acknowledged with a single method.
         * @since 2.12.0
         * @link https://www.rabbitmq.com/amqp-0-9-1-reference.html#basic.ack
         */
        public function ack($multiple = false)
        {
        }
        /**
         * Reject one or more incoming messages.
         *
         * @param bool $requeue If true, the server will attempt to requeue the message. If requeue is false or the requeue
         *                       attempt fails the messages are discarded or dead-lettered.
         * @param bool $multiple If true, the delivery tag is treated as "up to and including",
         *                       so that multiple messages can be rejected with a single method.
         * @since 2.12.0
         * @link https://www.rabbitmq.com/amqp-0-9-1-reference.html#basic.nack
         */
        public function nack($requeue = false, $multiple = false)
        {
        }
        /**
         * Reject an incoming message.
         *
         * @param bool $requeue If requeue is true, the server will attempt to requeue the message.
         *                     If requeue is false or the requeue attempt fails the messages are discarded or dead-lettered.
         * @since 2.12.0
         * @link https://www.rabbitmq.com/amqp-0-9-1-reference.html#basic.reject
         */
        public function reject($requeue = true)
        {
        }
        /**
         * @throws \LogicException When response to broker was already sent.
         */
        protected function assertUnacked()
        {
        }
        protected function onResponse()
        {
        }
        /**
         * @return AMQPChannel|null
         * @since 2.12.0
         */
        public function getChannel()
        {
        }
        /**
         * @param AMQPChannel $channel
         * @return $this
         * @throws \RuntimeException
         * @since 2.12.0
         */
        public function setChannel($channel)
        {
        }
        /**
         * @param int $deliveryTag
         * @param bool $redelivered
         * @param string $exchange
         * @param string $routingKey
         * @return $this
         * @since 2.12.0
         */
        public function setDeliveryInfo($deliveryTag, $redelivered, $exchange, $routingKey)
        {
        }
        /**
         * @return bool|null
         * @since 2.12.0
         */
        public function isRedelivered()
        {
        }
        /**
         * @return string|null
         * @since 2.12.0
         */
        public function getExchange()
        {
        }
        /**
         * @return string|null
         * @since 2.12.0
         */
        public function getRoutingKey()
        {
        }
        /**
         * @return string|null
         * @since 2.12.0
         */
        public function getConsumerTag()
        {
        }
        /**
         * @param string $consumerTag
         * @return $this
         * @since 2.12.0
         */
        public function setConsumerTag($consumerTag)
        {
        }
        /**
         * @return int|null
         * @since 2.12.0
         */
        public function getMessageCount()
        {
        }
        /**
         * @param int $messageCount
         * @return $this
         * @since 2.12.0
         */
        public function setMessageCount($messageCount)
        {
        }
        /**
         * @return string
         */
        public function getBody()
        {
        }
        /**
         * Sets the message payload
         *
         * @param string $body
         * @return $this
         */
        public function setBody($body)
        {
        }
        /**
         * @return string
         */
        public function getContentEncoding()
        {
        }
        /**
         * @return int
         */
        public function getBodySize()
        {
        }
        /**
         * @param int $body_size Message body size in byte(s)
         * @return AMQPMessage
         */
        public function setBodySize($body_size)
        {
        }
        /**
         * @return boolean
         */
        public function isTruncated()
        {
        }
        /**
         * @param bool $is_truncated
         * @return AMQPMessage
         */
        public function setIsTruncated($is_truncated)
        {
        }
        /**
         * @param int|string $deliveryTag
         * @return $this
         * @since 2.12.0
         */
        public function setDeliveryTag($deliveryTag)
        {
        }
        /**
         * @return int
         *
         * @throws AMQPEmptyDeliveryTagException
         */
        public function getDeliveryTag()
        {
        }
        /**
         * Check whether a property exists in the 'properties' dictionary
         * or if present - in the 'delivery_info' dictionary.
         *
         * @param string $name
         * @return bool
         */
        public function has($name)
        {
        }
        /**
         * Look for additional properties in the 'properties' dictionary,
         * and if present - the 'delivery_info' dictionary.
         *
         * @param string $name
         * @return mixed|AMQPChannel
         * @throws \OutOfBoundsException
         */
        public function get($name)
        {
        }
        /**
         * Returns the properties content
         *
         * @return array
         */
        public function get_properties()
        {
        }
        /**
         * Sets a property value
         *
         * @param string $name The property name (one of the property definition)
         * @param mixed $value The property value
         * @throws \OutOfBoundsException
         */
        public function set($name, $value)
        {
        }
        /**
         * Given the raw bytes containing the property-flags and
         * property-list from a content-frame-header, parse and insert
         * into a dictionary stored in this object as an attribute named
         * 'properties'.
         *
         * @param AMQPReader $reader
         * NOTE: do not mutate $reader
         * @return $this
         */
        public function load_properties(\PhpAmqpLib\Wire\AMQPReader $reader)
        {
        }
        /**
         * Serializes the 'properties' attribute (a dictionary) into the
         * raw bytes making up a set of property flags and a property
         * list, suitable for putting into a content frame header.
         *
         * @return string
         * @todo Inject the AMQPWriter to make the method easier to test
         */
        public function serialize_properties()
        {
        }
    }
}
namespace PhpAmqpLib {
    final class Package
    {
        public const NAME = 'AMQPLib';
        public const VERSION = '3.7.3';
    }
}
namespace PhpAmqpLib\Wire {
    /**
     * Iterator implemented for transparent integration with AMQPWriter::write_[array|table]()
     */
    abstract class AMQPAbstractCollection implements \Iterator, \ArrayAccess
    {
        //protocol defines available field types and their corresponding symbols
        const PROTOCOL_RBT = 'rabbit';
        //pseudo proto
        //Abstract data types
        const T_INT_SHORTSHORT = 1;
        const T_INT_SHORTSHORT_U = 2;
        const T_INT_SHORT = 3;
        const T_INT_SHORT_U = 4;
        const T_INT_LONG = 5;
        const T_INT_LONG_U = 6;
        const T_INT_LONGLONG = 7;
        const T_INT_LONGLONG_U = 8;
        const T_DECIMAL = 9;
        const T_TIMESTAMP = 10;
        const T_VOID = 11;
        const T_BOOL = 12;
        const T_STRING_SHORT = 13;
        const T_STRING_LONG = 14;
        const T_ARRAY = 15;
        const T_TABLE = 16;
        const T_BYTES = 17;
        const T_FLOAT = 18;
        const T_DOUBLE = 19;
        /**
         * @var array
         */
        protected $data = array();
        public function __construct(?array $data = null)
        {
        }
        /**
         * @return int
         */
        abstract public function getType();
        /**
         * @param mixed $val
         * @param int|null $type
         * @param string $key
         */
        final protected function setValue($val, $type = null, $key = null)
        {
        }
        /**
         * @return array
         */
        final public function getNativeData()
        {
        }
        /**
         * @param array $val
         * @return array
         */
        final protected function encodeCollection(array $val)
        {
        }
        /**
         * @param array $val
         * @return array
         */
        final protected function decodeCollection(array $val)
        {
        }
        public function offsetExists($offset): bool
        {
        }
        /**
         * @param mixed $offset
         * @return mixed
         */
        #[\ReturnTypeWillChange]
        public function offsetGet($offset)
        {
        }
        public function offsetSet($offset, $value): void
        {
        }
        public function offsetUnset($offset): void
        {
        }
        /**
         * @param mixed $val
         * @return mixed
         * @throws Exception\AMQPOutOfBoundsException
         */
        protected function encodeValue($val)
        {
        }
        /**
         * @param mixed $val
         * @param int $type
         * @return array|bool|\DateTime|null
         */
        protected function decodeValue($val, $type)
        {
        }
        /**
         * @param string $val
         * @return array
         */
        protected function encodeString($val)
        {
        }
        /**
         * @param int $val
         * @return array
         */
        protected function encodeInt($val)
        {
        }
        /**
         * @param float $val
         * @return array
         */
        protected function encodeFloat($val)
        {
        }
        /**
         * @param bool $val
         * @return array
         */
        protected function encodeBool($val)
        {
        }
        /**
         * @return array
         */
        protected function encodeVoid()
        {
        }
        /**
         * @return string
         * @deprecated
         */
        final public static function getProtocol()
        {
        }
        /**
         * @param string $proto
         * @return bool
         */
        final public static function isProtocol($proto)
        {
        }
        /**
         * @return array  [dataTypeConstant => dataTypeSymbol]
         */
        final public static function getSupportedDataTypes()
        {
        }
        /**
         * @param string $type
         * @param bool $return Whether to return or raise AMQPOutOfRangeException
         * @return boolean
         */
        final public static function checkDataTypeIsSupported($type, $return = true)
        {
        }
        /**
         * @param int $type
         * @return string
         */
        final public static function getSymbolForDataType($type)
        {
        }
        /**
         * @param string $symbol
         * @return integer
         */
        final public static function getDataTypeForSymbol($symbol)
        {
        }
        /**
         * @return mixed
         */
        #[\ReturnTypeWillChange]
        public function current()
        {
        }
        /**
         * @return mixed
         */
        #[\ReturnTypeWillChange]
        public function key()
        {
        }
        public function next(): void
        {
        }
        public function rewind(): void
        {
        }
        public function valid(): bool
        {
        }
    }
    class AMQPArray extends \PhpAmqpLib\Wire\AMQPAbstractCollection
    {
        /**
         * @param array|null $data
         */
        public function __construct(?array $data = null)
        {
        }
        /**
         * @return int
         */
        final public function getType()
        {
        }
        /**
         * @param mixed $val
         * @param int|null $type
         * @return $this
         */
        public function push($val, $type = null)
        {
        }
    }
    abstract class AMQPByteStream
    {
        public const BIT = 1;
        public const OCTET = 1;
        public const SHORTSTR = 1;
        public const SHORT = 2;
        public const LONG = 4;
        public const SIGNED_LONG = 4;
        public const READ_PHP_INT = 4;
        // use READ_ to avoid possible clashes with PHP
        public const LONGLONG = 8;
        public const TIMESTAMP = 8;
        /** @var bool */
        protected const PLATFORM_64BIT = PHP_INT_SIZE === 8;
        /** @var BigInteger[][] */
        protected static $bigIntegers = array();
        /**
         * @var bool
         */
        protected static $isLittleEndian;
        /**
         * Converts byte-string between native and network byte order, in both directions
         *
         * @param string $bytes
         * @return string
         */
        protected function correctEndianness($bytes)
        {
        }
        /**
         * @param string $bytes
         * @return string
         */
        protected function convertByteOrder($bytes)
        {
        }
        /**
         * @param int $longInt
         * @return bool
         */
        protected function getLongMSB($longInt)
        {
        }
        /**
         * @param string $bytes
         * @return bool
         */
        protected function getMSB($bytes)
        {
        }
        /**
         * @return bool
         */
        protected static function isLittleEndian()
        {
        }
        /**
         * @param string $value
         * @param int $base
         * @return BigInteger
         */
        protected static function getBigInteger($value, $base = 10)
        {
        }
    }
    abstract class AMQPReader extends \PhpAmqpLib\Wire\AMQPByteStream
    {
        /** @var int */
        protected $offset = 0;
        /** @var int */
        protected $bitcount = 0;
        /** @var int */
        protected $bits = 0;
        /**
         * Close the byte stream.
         */
        abstract public function close(): void;
        abstract protected function rawread(int $n): string;
        /**
         * @param int $n
         * @return string
         */
        public function read($n)
        {
        }
        public function read_bit(): bool
        {
        }
        /**
         * @return int
         */
        public function read_octet()
        {
        }
        /**
         * @return int
         */
        public function read_signed_octet()
        {
        }
        /**
         * @return int
         */
        public function read_short()
        {
        }
        /**
         * @return int
         */
        public function read_signed_short()
        {
        }
        /**
         * Reads 32 bit integer in big-endian byte order.
         *
         * On 64 bit systems it will return always unsigned int
         * value in 0..2^32 range.
         *
         * On 32 bit systems it will return signed int value in
         * -2^31...+2^31 range.
         *
         * Use with caution!
         * @return int|string
         */
        public function read_php_int()
        {
        }
        /**
         * PHP does not have unsigned 32 bit int,
         * so we return it as a string
         *
         * @return int|string
         */
        public function read_long()
        {
        }
        /**
         * Even on 64 bit systems PHP integers are signed.
         * Since we need an unsigned value here we return it as a string.
         *
         * @return int|string
         */
        public function read_longlong()
        {
        }
        /**
         * @return int|string
         */
        public function read_signed_longlong()
        {
        }
        /**
         * @return float
         */
        public function read_float()
        {
        }
        /**
         * @return float
         */
        public function read_double()
        {
        }
        /**
         * Read a utf-8 encoded string that's stored in up to
         * 255 bytes.  Return it decoded as a PHP unicode object.
         * @return string
         */
        public function read_shortstr()
        {
        }
        /**
         * Read a string that's up to 2**32 bytes, the encoding
         * isn't specified in the AMQP spec, so just return it as
         * a plain PHP string.
         * @return string
         */
        public function read_longstr()
        {
        }
        /**
         * Read and AMQP timestamp, which is a 64-bit integer representing
         * seconds since the Unix epoch in 1-second resolution.
         * @return int|string
         */
        public function read_timestamp()
        {
        }
        /**
         * Read an AMQP table, and return as a PHP array. keys are strings,
         * values are (type,value) tuples.
         *
         * @param bool $returnObject Whether to return AMQPArray instance instead of plain array
         * @return array|AMQPTable
         */
        public function read_table(bool $returnObject = false)
        {
        }
        /**
         * @return array|AMQPTable
         */
        public function read_table_object()
        {
        }
        /**
         * Reads the array in the next value.
         *
         * @param bool $returnObject Whether to return AMQPArray instance instead of plain array
         * @return array|AMQPArray
         */
        public function read_array($returnObject = false)
        {
        }
        /**
         * @return array|AMQPArray
         */
        public function read_array_object()
        {
        }
        /**
         * @return array{type:int, channel:int, size:int}
         */
        public function readFrameHeader(): array
        {
        }
        /**
         * Reads the next value as the provided field type.
         *
         * @param int $fieldType One of AMQPAbstractCollection::T_* constants
         * @param bool $collectionsAsObjects Description
         * @return mixed
         * @throws \PhpAmqpLib\Exception\AMQPDataReadException
         */
        public function read_value(int $fieldType, bool $collectionsAsObjects = false)
        {
        }
        protected function tell(): int
        {
        }
        protected function resetCounters(): void
        {
        }
    }
    class AMQPBufferReader extends \PhpAmqpLib\Wire\AMQPReader
    {
        public function __construct(string $buffer)
        {
        }
        public function close(): void
        {
        }
        /**
         * Resets the object from the injected param
         *
         * Used to not need to create a new AMQPBufferReader instance every time.
         * when we can just pass a string and reset the object state.
         * NOTE: since we are working with strings we don't need to pass an AbstractIO
         *       or a timeout.
         *
         * @param string $str
         */
        public function reset(string $str): void
        {
        }
        protected function rawread(int $n): string
        {
        }
    }
    /**
     * AMQP protocol decimal value.
     *
     * Values are represented as (n,e) pairs. The actual value
     * is n * 10^(-e).
     *
     * From 0.8 spec: Decimal values are
     * not intended to support floating point values, but rather
     * business values such as currency rates and amounts. The
     * 'decimals' octet is not signed.
     */
    class AMQPDecimal
    {
        /** @var int */
        protected $n;
        /** @var int */
        protected $e;
        /**
         * @param int $n
         * @param int $e
         * @throws \PhpAmqpLib\Exception\AMQPOutOfBoundsException
         */
        public function __construct($n, $e)
        {
        }
        /**
         * @return string
         */
        public function asBCvalue()
        {
        }
        /**
         * @return int
         */
        public function getE()
        {
        }
        /**
         * @return int
         */
        public function getN()
        {
        }
    }
    class AMQPIOReader extends \PhpAmqpLib\Wire\AMQPReader
    {
        /** @var int|float|null */
        protected $timeout;
        public function __construct(\PhpAmqpLib\Wire\IO\AbstractIO $io, $timeout = 0)
        {
        }
        public function close(): void
        {
        }
        /**
         * @return float|int|mixed|null
         */
        public function getTimeout()
        {
        }
        /**
         * Sets the timeout (second)
         *
         * @param int|float|null $timeout
         */
        public function setTimeout($timeout)
        {
        }
        /**
         * @param int $n
         * @return string
         * @throws RuntimeException
         * @throws AMQPDataReadException|AMQPNoDataException|AMQPIOException
         */
        protected function rawread(int $n): string
        {
        }
        /**
         * Waits until some data is retrieved from the socket.
         *
         * AMQPTimeoutException can be raised if the timeout is set
         *
         * @throws AMQPTimeoutException when timeout is set and no data received
         * @throws AMQPNoDataException when no data is ready to read from IO
         */
        protected function wait(): void
        {
        }
    }
    class AMQPTable extends \PhpAmqpLib\Wire\AMQPAbstractCollection
    {
        /**
         * @return int
         */
        final public function getType()
        {
        }
        /**
         * @param string $key
         * @param mixed $val
         * @param int|null $type
         */
        public function set($key, $val, $type = null)
        {
        }
    }
    class AMQPWriter extends \PhpAmqpLib\Wire\AMQPByteStream
    {
        /** @var string */
        protected $out = '';
        /** @var array */
        protected $bits = array();
        /** @var int */
        protected $bitcount = 0;
        /**
         * Get what's been encoded so far.
         *
         * @return string
         */
        public function getvalue()
        {
        }
        /**
         * Write a plain PHP string, with no special encoding.
         *
         * @param string $s
         *
         * @return $this
         */
        public function write($s)
        {
        }
        /**
         * Write a boolean value.
         * (deprecated, use write_bits instead)
         *
         * @deprecated
         * @param bool $b
         * @return $this
         */
        public function write_bit($b)
        {
        }
        /**
         * Write multiple bits as an octet
         *
         * @param bool[] $bits
         * @return $this
         */
        public function write_bits($bits)
        {
        }
        /**
         * Write an integer as an unsigned 8-bit value
         *
         * @param int $n
         * @return $this
         * @throws \PhpAmqpLib\Exception\AMQPInvalidArgumentException
         */
        public function write_octet($n)
        {
        }
        /**
         * @param int $n
         * @return $this
         */
        public function write_signed_octet($n)
        {
        }
        /**
         * Write an integer as an unsigned 16-bit value
         *
         * @param int $n
         * @return $this
         * @throws \PhpAmqpLib\Exception\AMQPInvalidArgumentException
         */
        public function write_short($n)
        {
        }
        /**
         * @param int $n
         * @return $this
         */
        public function write_signed_short($n)
        {
        }
        /**
         * Write an integer as an unsigned 32-bit value
         *
         * @param int|string $n
         * @return $this
         */
        public function write_long($n)
        {
        }
        /**
         * Write a numeric value as an unsigned 64-bit value
         *
         * @param int|string $n
         * @return $this
         * @throws AMQPOutOfRangeException
         */
        public function write_longlong($n)
        {
        }
        /**
         * @param int|string $n
         * @return $this
         */
        public function write_signed_longlong($n)
        {
        }
        /**
         * Write a string up to 255 bytes long after encoding.
         * Assume UTF-8 encoding
         *
         * @param string $s
         * @return $this
         * @throws \PhpAmqpLib\Exception\AMQPInvalidArgumentException
         */
        public function write_shortstr($s)
        {
        }
        /**
         * Write a string up to 2**32 bytes long.  Assume UTF-8 encoding
         *
         * @param string $s
         * @return $this
         */
        public function write_longstr($s)
        {
        }
        /**
         * Supports the writing of Array types, so that you can implement
         * array methods, like Rabbitmq's HA parameters
         *
         * @param AMQPArray|array $a Instance of AMQPArray or PHP array WITHOUT format hints (unlike write_table())
         * @return self
         */
        public function write_array($a)
        {
        }
        /**
         * Write unix time_t value as 64 bit timestamp
         *
         * @param int $v
         * @return $this
         */
        public function write_timestamp($v)
        {
        }
        /**
         * Write PHP array, as table. Input array format: keys are strings,
         * values are (type,value) tuples.
         *
         * @param AMQPTable|array $d Instance of AMQPTable or PHP array WITH format hints (unlike write_array())
         * @return $this
         * @throws \PhpAmqpLib\Exception\AMQPInvalidArgumentException
         */
        public function write_table($d)
        {
        }
        /**
         * for compat with method mapping used by AMQPMessage
         *
         * @param AMQPTable|array $d
         * @return $this
         */
        public function write_table_object($d)
        {
        }
    }
    abstract class Constants
    {
        const VERSION = '';
        const AMQP_HEADER = '';
        /**
         * @var array<int, string>
         */
        protected static $FRAME_TYPES = array();
        /**
         * @var array<int, string>
         */
        protected static $CONTENT_METHODS = array();
        /**
         * @var array<int, string>
         */
        protected static $CLOSE_METHODS = array();
        /**
         * @var array<string, string>
         */
        public static $GLOBAL_METHOD_NAMES = array();
        /**
         * @return string
         */
        public function getHeader()
        {
        }
        /**
         * @param int $type
         * @return bool
         */
        public function isFrameType($type)
        {
        }
        /**
         * @param int $type
         * @return string
         */
        public function getFrameType($type)
        {
        }
        /**
         * @param string $method
         * @return bool
         */
        public function isContentMethod($method)
        {
        }
        /**
         * @param string $method
         * @return bool
         */
        public function isCloseMethod($method)
        {
        }
    }
    final class Constants080 extends \PhpAmqpLib\Wire\Constants
    {
        const VERSION = '8.0';
        const AMQP_HEADER = "AMQP\x01\x01\x08\x00";
        /**
         * @var array
         */
        public static $FRAME_TYPES = array(1 => 'FRAME-METHOD', 2 => 'FRAME-HEADER', 3 => 'FRAME-BODY', 4 => 'FRAME-OOB-METHOD', 5 => 'FRAME-OOB-HEADER', 6 => 'FRAME-OOB-BODY', 7 => 'FRAME-TRACE', 8 => 'FRAME-HEARTBEAT', 4096 => 'FRAME-MIN-SIZE', 206 => 'FRAME-END', 501 => 'FRAME-ERROR');
        /**
         * @var array
         */
        public static $CONTENT_METHODS = array(0 => '60,40', 1 => '60,50', 2 => '60,60', 3 => '60,71', 4 => '70,50', 5 => '70,70', 6 => '80,40', 7 => '80,50', 8 => '80,60', 9 => '110,10', 10 => '120,40', 11 => '120,41');
        /**
         * @var array
         */
        public static $CLOSE_METHODS = array(0 => '10,60', 1 => '20,40');
        /**
         * @var array
         */
        public static $GLOBAL_METHOD_NAMES = array('10,10' => 'Connection.start', '10,11' => 'Connection.start_ok', '10,20' => 'Connection.secure', '10,21' => 'Connection.secure_ok', '10,30' => 'Connection.tune', '10,31' => 'Connection.tune_ok', '10,40' => 'Connection.open', '10,41' => 'Connection.open_ok', '10,50' => 'Connection.redirect', '10,60' => 'Connection.close', '10,61' => 'Connection.close_ok', '20,10' => 'Channel.open', '20,11' => 'Channel.open_ok', '20,20' => 'Channel.flow', '20,21' => 'Channel.flow_ok', '20,30' => 'Channel.alert', '20,40' => 'Channel.close', '20,41' => 'Channel.close_ok', '30,10' => 'Access.request', '30,11' => 'Access.request_ok', '40,10' => 'Exchange.declare', '40,11' => 'Exchange.declare_ok', '40,20' => 'Exchange.delete', '40,21' => 'Exchange.delete_ok', '50,10' => 'Queue.declare', '50,11' => 'Queue.declare_ok', '50,20' => 'Queue.bind', '50,21' => 'Queue.bind_ok', '50,30' => 'Queue.purge', '50,31' => 'Queue.purge_ok', '50,40' => 'Queue.delete', '50,41' => 'Queue.delete_ok', '50,50' => 'Queue.unbind', '50,51' => 'Queue.unbind_ok', '60,10' => 'Basic.qos', '60,11' => 'Basic.qos_ok', '60,20' => 'Basic.consume', '60,21' => 'Basic.consume_ok', '60,30' => 'Basic.cancel', '60,31' => 'Basic.cancel_ok', '60,40' => 'Basic.publish', '60,50' => 'Basic.return', '60,60' => 'Basic.deliver', '60,70' => 'Basic.get', '60,71' => 'Basic.get_ok', '60,72' => 'Basic.get_empty', '60,80' => 'Basic.ack', '60,90' => 'Basic.reject', '60,100' => 'Basic.recover_async', '60,110' => 'Basic.recover', '60,111' => 'Basic.recover_ok', '70,10' => 'File.qos', '70,11' => 'File.qos_ok', '70,20' => 'File.consume', '70,21' => 'File.consume_ok', '70,30' => 'File.cancel', '70,31' => 'File.cancel_ok', '70,40' => 'File.open', '70,41' => 'File.open_ok', '70,50' => 'File.stage', '70,60' => 'File.publish', '70,70' => 'File.return', '70,80' => 'File.deliver', '70,90' => 'File.ack', '70,100' => 'File.reject', '80,10' => 'Stream.qos', '80,11' => 'Stream.qos_ok', '80,20' => 'Stream.consume', '80,21' => 'Stream.consume_ok', '80,30' => 'Stream.cancel', '80,31' => 'Stream.cancel_ok', '80,40' => 'Stream.publish', '80,50' => 'Stream.return', '80,60' => 'Stream.deliver', '90,10' => 'Tx.select', '90,11' => 'Tx.select_ok', '90,20' => 'Tx.commit', '90,21' => 'Tx.commit_ok', '90,30' => 'Tx.rollback', '90,31' => 'Tx.rollback_ok', '100,10' => 'Dtx.select', '100,11' => 'Dtx.select_ok', '100,20' => 'Dtx.start', '100,21' => 'Dtx.start_ok', '110,10' => 'Tunnel.request', '120,10' => 'Test.integer', '120,11' => 'Test.integer_ok', '120,20' => 'Test.string', '120,21' => 'Test.string_ok', '120,30' => 'Test.table', '120,31' => 'Test.table_ok', '120,40' => 'Test.content', '120,41' => 'Test.content_ok');
    }
    final class Constants091 extends \PhpAmqpLib\Wire\Constants
    {
        const VERSION = '0.9.1';
        const AMQP_HEADER = "AMQP\x00\x00\t\x01";
        /**
         * @var array
         */
        public static $FRAME_TYPES = array(1 => 'FRAME-METHOD', 2 => 'FRAME-HEADER', 3 => 'FRAME-BODY', 8 => 'FRAME-HEARTBEAT', 4096 => 'FRAME-MIN-SIZE', 206 => 'FRAME-END', 501 => 'FRAME-ERROR');
        /**
         * @var array
         */
        public static $CONTENT_METHODS = array(0 => '60,40', 1 => '60,50', 2 => '60,60', 3 => '60,71');
        /**
         * @var array
         */
        public static $CLOSE_METHODS = array(0 => '10,50', 1 => '20,40');
        /**
         * @var array
         */
        public static $GLOBAL_METHOD_NAMES = array('10,10' => 'Connection.start', '10,11' => 'Connection.start_ok', '10,20' => 'Connection.secure', '10,21' => 'Connection.secure_ok', '10,30' => 'Connection.tune', '10,31' => 'Connection.tune_ok', '10,40' => 'Connection.open', '10,41' => 'Connection.open_ok', '10,50' => 'Connection.close', '10,51' => 'Connection.close_ok', '10,60' => 'Connection.blocked', '10,61' => 'Connection.unblocked', '20,10' => 'Channel.open', '20,11' => 'Channel.open_ok', '20,20' => 'Channel.flow', '20,21' => 'Channel.flow_ok', '20,40' => 'Channel.close', '20,41' => 'Channel.close_ok', '30,10' => 'Access.request', '30,11' => 'Access.request_ok', '40,10' => 'Exchange.declare', '40,11' => 'Exchange.declare_ok', '40,20' => 'Exchange.delete', '40,21' => 'Exchange.delete_ok', '40,30' => 'Exchange.bind', '40,31' => 'Exchange.bind_ok', '40,40' => 'Exchange.unbind', '40,51' => 'Exchange.unbind_ok', '50,10' => 'Queue.declare', '50,11' => 'Queue.declare_ok', '50,20' => 'Queue.bind', '50,21' => 'Queue.bind_ok', '50,30' => 'Queue.purge', '50,31' => 'Queue.purge_ok', '50,40' => 'Queue.delete', '50,41' => 'Queue.delete_ok', '50,50' => 'Queue.unbind', '50,51' => 'Queue.unbind_ok', '60,10' => 'Basic.qos', '60,11' => 'Basic.qos_ok', '60,20' => 'Basic.consume', '60,21' => 'Basic.consume_ok', '60,30' => 'Basic.cancel', '60,31' => 'Basic.cancel_ok', '60,40' => 'Basic.publish', '60,50' => 'Basic.return', '60,60' => 'Basic.deliver', '60,70' => 'Basic.get', '60,71' => 'Basic.get_ok', '60,72' => 'Basic.get_empty', '60,80' => 'Basic.ack', '60,90' => 'Basic.reject', '60,100' => 'Basic.recover_async', '60,110' => 'Basic.recover', '60,111' => 'Basic.recover_ok', '60,120' => 'Basic.nack', '90,10' => 'Tx.select', '90,11' => 'Tx.select_ok', '90,20' => 'Tx.commit', '90,21' => 'Tx.commit_ok', '90,30' => 'Tx.rollback', '90,31' => 'Tx.rollback_ok', '85,10' => 'Confirm.select', '85,11' => 'Confirm.select_ok');
    }
}
namespace PhpAmqpLib\Wire\IO {
    abstract class AbstractIO
    {
        const BUFFER_SIZE = 8192;
        /** @var null|AMQPConnectionConfig */
        protected $config;
        /** @var string */
        protected $host;
        /** @var int */
        protected $port;
        /** @var int|float */
        protected $connection_timeout;
        /** @var float */
        protected $read_timeout;
        /** @var float */
        protected $write_timeout;
        /** @var int */
        protected $heartbeat;
        /** @var int */
        protected $initial_heartbeat;
        /** @var bool */
        protected $keepalive;
        /** @var int|float */
        protected $last_read;
        /** @var int|float */
        protected $last_write;
        /** @var \ErrorException|null */
        protected $last_error;
        /** @var bool */
        protected $canDispatchPcntlSignal = false;
        /**
         * @param int $len
         * @return string
         * @throws \PhpAmqpLib\Exception\AMQPIOException
         * @throws AMQPRuntimeException
         * @throws \PhpAmqpLib\Exception\AMQPSocketException
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException
         * @throws \PhpAmqpLib\Exception\AMQPConnectionClosedException
         */
        abstract public function read($len);
        /**
         * @param string $data
         * @throws \PhpAmqpLib\Exception\AMQPIOException
         * @throws \PhpAmqpLib\Exception\AMQPSocketException
         * @throws \PhpAmqpLib\Exception\AMQPConnectionClosedException
         * @throws \PhpAmqpLib\Exception\AMQPTimeoutException
         */
        abstract public function write($data);
        /**
         * @return void
         */
        abstract public function close();
        /**
         * @param int|null $sec
         * @param int $usec
         * @return int
         * @throws AMQPIOWaitException
         * @throws AMQPRuntimeException
         * @throws AMQPConnectionClosedException
         */
        public function select(?int $sec, int $usec = 0)
        {
        }
        /**
         * @param int|null $sec
         * @param int $usec
         * @return int|bool
         * @throws AMQPConnectionClosedException
         */
        abstract protected function do_select(?int $sec, int $usec);
        /**
         * Set ups the connection.
         * @return void
         * @throws \PhpAmqpLib\Exception\AMQPIOException
         * @throws AMQPRuntimeException
         */
        abstract public function connect();
        /**
         * Set connection params connection tune(negotiation).
         * @param int $heartbeat
         */
        public function afterTune(int $heartbeat): void
        {
        }
        /**
         * Heartbeat logic: check connection health here
         * @return void
         * @throws AMQPRuntimeException
         */
        public function check_heartbeat()
        {
        }
        /**
         * @throws \PhpAmqpLib\Exception\AMQPHeartbeatMissedException
         */
        protected function checkBrokerHeartbeat(): void
        {
        }
        /**
         * @return float|int
         */
        public function getLastActivity()
        {
        }
        public function getReadTimeout(): float
        {
        }
        /**
         * @return $this
         */
        public function disableHeartbeat()
        {
        }
        /**
         * @return $this
         */
        public function reenableHeartbeat()
        {
        }
        /**
         * Sends a heartbeat message
         */
        protected function write_heartbeat()
        {
        }
        /**
         * Begin tracking errors and set the error handler
         */
        protected function setErrorHandler(): void
        {
        }
        protected function throwOnError(): void
        {
        }
        protected function restoreErrorHandler(): void
        {
        }
        /**
         * Internal error handler to deal with stream and socket errors.
         *
         * @param  int $errno
         * @param  string $errstr
         * @param  string $errfile
         * @param  int $errline
         * @return void
         */
        public function error_handler($errno, $errstr, $errfile, $errline): void
        {
        }
        protected function isPcntlSignalEnabled(): bool
        {
        }
    }
    class SocketIO extends \PhpAmqpLib\Wire\IO\AbstractIO
    {
        /**
         * @param string $host
         * @param int $port
         * @param int|float $read_timeout
         * @param bool $keepalive
         * @param int|float|null $write_timeout if null defaults to read timeout
         * @param int $heartbeat how often to send heartbeat. 0 means off
         * @param null|AMQPConnectionConfig $config
         */
        public function __construct($host, $port, $read_timeout = 3, $keepalive = false, $write_timeout = null, $heartbeat = 0, ?\PhpAmqpLib\Connection\AMQPConnectionConfig $config = null)
        {
        }
        /**
         * @inheritdoc
         */
        public function connect()
        {
        }
        /**
         * @deprecated
         * @return null|resource|\Socket
         */
        public function getSocket()
        {
        }
        /**
         * @inheritdoc
         */
        public function read($len)
        {
        }
        /**
         * @inheritdoc
         */
        public function write($data)
        {
        }
        /**
         * @inheritdoc
         */
        public function close()
        {
        }
        /**
         * @inheritdoc
         */
        protected function do_select(?int $sec, int $usec)
        {
        }
        /**
         * @return int|bool
         */
        protected function select_write()
        {
        }
        /**
         * @throws \PhpAmqpLib\Exception\AMQPIOException
         */
        protected function enable_keepalive(): void
        {
        }
        /**
         * @inheritdoc
         */
        public function error_handler($errno, $errstr, $errfile, $errline): void
        {
        }
        /**
         * @inheritdoc
         */
        protected function setErrorHandler(): void
        {
        }
    }
    class StreamIO extends \PhpAmqpLib\Wire\IO\AbstractIO
    {
        /** @var null|resource */
        protected $context;
        /**
         * @param string $host
         * @param int $port
         * @param float $connection_timeout
         * @param float $read_write_timeout
         * @param resource|null $context
         * @param bool $keepalive
         * @param int $heartbeat
         * @param string|null $ssl_protocol @deprecated
         */
        public function __construct($host, $port, $connection_timeout, $read_write_timeout, $context = null, $keepalive = false, $heartbeat = 0, $ssl_protocol = null)
        {
        }
        /**
         * @inheritdoc
         */
        public function connect()
        {
        }
        /**
         * @inheritdoc
         */
        public function read($len)
        {
        }
        /**
         * @inheritdoc
         */
        public function write($data)
        {
        }
        /**
         * @inheritdoc
         */
        public function error_handler($errno, $errstr, $errfile, $errline): void
        {
        }
        public function close()
        {
        }
        /**
         * @deprecated
         * @return null|resource|\Socket
         */
        public function getSocket()
        {
        }
        /**
         * @inheritdoc
         */
        protected function do_select(?int $sec, int $usec)
        {
        }
        /**
         * @return int|bool
         */
        protected function select_write()
        {
        }
        /**
         * @return mixed
         */
        protected function timed_out()
        {
        }
        /**
         * @throws \PhpAmqpLib\Exception\AMQPIOException
         */
        protected function enable_keepalive(): void
        {
        }
        /**
         * @param string $message
         * @return int
         */
        protected function extract_error_code($message)
        {
        }
    }
}
namespace Invoker {
    /**
     * Resolves a callable from a container.
     */
    class CallableResolver
    {
        public function __construct(\Psr\Container\ContainerInterface $container)
        {
        }
        /**
         * Resolve the given callable into a real PHP callable.
         *
         * @param callable|string|array $callable
         * @return callable Real PHP callable.
         * @throws NotCallableException|ReflectionException
         */
        public function resolve($callable): callable
        {
        }
    }
}
namespace Invoker\Exception {
    /**
     * Impossible to invoke the callable.
     */
    class InvocationException extends \Exception
    {
    }
    /**
     * The given callable is not actually callable.
     */
    class NotCallableException extends \Invoker\Exception\InvocationException
    {
        /**
         * @param mixed $value
         */
        public static function fromInvalidCallable($value, bool $containerEntry = false): self
        {
        }
    }
    /**
     * Not enough parameters could be resolved to invoke the callable.
     */
    class NotEnoughParametersException extends \Invoker\Exception\InvocationException
    {
    }
}
namespace Invoker {
    /**
     * Invoke a callable.
     */
    interface InvokerInterface
    {
        /**
         * Call the given function using the given parameters.
         *
         * @param callable|array|string $callable Function to call.
         * @param array $parameters Parameters to use.
         * @return mixed Result of the function.
         * @throws InvocationException Base exception class for all the sub-exceptions below.
         * @throws NotCallableException
         * @throws NotEnoughParametersException
         */
        public function call($callable, array $parameters = []);
    }
    /**
     * Invoke a callable.
     */
    class Invoker implements \Invoker\InvokerInterface
    {
        public function __construct(?\Invoker\ParameterResolver\ParameterResolver $parameterResolver = null, ?\Psr\Container\ContainerInterface $container = null)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function call($callable, array $parameters = [])
        {
        }
        /**
         * @return ParameterResolver By default it's a ResolverChain
         */
        public function getParameterResolver(): \Invoker\ParameterResolver\ParameterResolver
        {
        }
        public function getContainer(): ?\Psr\Container\ContainerInterface
        {
        }
        /**
         * @return CallableResolver|null Returns null if no container was given in the constructor.
         */
        public function getCallableResolver(): ?\Invoker\CallableResolver
        {
        }
    }
}
namespace Invoker\ParameterResolver {
    /**
     * Resolves the parameters to use to call the callable.
     */
    interface ParameterResolver
    {
        /**
         * Resolves the parameters to use to call the callable.
         *
         * `$resolvedParameters` contains parameters that have already been resolved.
         *
         * Each ParameterResolver must resolve parameters that are not already
         * in `$resolvedParameters`. That allows to chain multiple ParameterResolver.
         *
         * @param ReflectionFunctionAbstract $reflection Reflection object for the callable.
         * @param array $providedParameters Parameters provided by the caller.
         * @param array $resolvedParameters Parameters resolved (indexed by parameter position).
         * @return array
         */
        public function getParameters(\ReflectionFunctionAbstract $reflection, array $providedParameters, array $resolvedParameters);
    }
    /**
     * Tries to map an associative array (string-indexed) to the parameter names.
     *
     * E.g. `->call($callable, ['foo' => 'bar'])` will inject the string `'bar'`
     * in the parameter named `$foo`.
     *
     * Parameters that are not indexed by a string are ignored.
     */
    class AssociativeArrayResolver implements \Invoker\ParameterResolver\ParameterResolver
    {
        public function getParameters(\ReflectionFunctionAbstract $reflection, array $providedParameters, array $resolvedParameters): array
        {
        }
    }
}
namespace Invoker\ParameterResolver\Container {
    /**
     * Inject entries from a DI container using the parameter names.
     */
    class ParameterNameContainerResolver implements \Invoker\ParameterResolver\ParameterResolver
    {
        /**
         * @param ContainerInterface $container The container to get entries from.
         */
        public function __construct(\Psr\Container\ContainerInterface $container)
        {
        }
        public function getParameters(\ReflectionFunctionAbstract $reflection, array $providedParameters, array $resolvedParameters): array
        {
        }
    }
    /**
     * Inject entries from a DI container using the type-hints.
     */
    class TypeHintContainerResolver implements \Invoker\ParameterResolver\ParameterResolver
    {
        /**
         * @param ContainerInterface $container The container to get entries from.
         */
        public function __construct(\Psr\Container\ContainerInterface $container)
        {
        }
        public function getParameters(\ReflectionFunctionAbstract $reflection, array $providedParameters, array $resolvedParameters): array
        {
        }
    }
}
namespace Invoker\ParameterResolver {
    /**
     * Finds the default value for a parameter, *if it exists*.
     */
    class DefaultValueResolver implements \Invoker\ParameterResolver\ParameterResolver
    {
        public function getParameters(\ReflectionFunctionAbstract $reflection, array $providedParameters, array $resolvedParameters): array
        {
        }
    }
    /**
     * Simply returns all the values of the $providedParameters array that are
     * indexed by the parameter position (i.e. a number).
     *
     * E.g. `->call($callable, ['foo', 'bar'])` will simply resolve the parameters
     * to `['foo', 'bar']`.
     *
     * Parameters that are not indexed by a number (i.e. parameter position)
     * will be ignored.
     */
    class NumericArrayResolver implements \Invoker\ParameterResolver\ParameterResolver
    {
        public function getParameters(\ReflectionFunctionAbstract $reflection, array $providedParameters, array $resolvedParameters): array
        {
        }
    }
    /**
     * Dispatches the call to other resolvers until all parameters are resolved.
     *
     * Chain of responsibility pattern.
     */
    class ResolverChain implements \Invoker\ParameterResolver\ParameterResolver
    {
        public function __construct(array $resolvers = [])
        {
        }
        public function getParameters(\ReflectionFunctionAbstract $reflection, array $providedParameters, array $resolvedParameters): array
        {
        }
        /**
         * Push a parameter resolver after the ones already registered.
         */
        public function appendResolver(\Invoker\ParameterResolver\ParameterResolver $resolver): void
        {
        }
        /**
         * Insert a parameter resolver before the ones already registered.
         */
        public function prependResolver(\Invoker\ParameterResolver\ParameterResolver $resolver): void
        {
        }
    }
    /**
     * Inject entries using type-hints.
     *
     * Tries to match type-hints with the parameters provided.
     */
    class TypeHintResolver implements \Invoker\ParameterResolver\ParameterResolver
    {
        public function getParameters(\ReflectionFunctionAbstract $reflection, array $providedParameters, array $resolvedParameters): array
        {
        }
    }
}
namespace Invoker\Reflection {
    /**
     * Create a reflection object from a callable or a callable-like.
     *
     * @internal
     */
    class CallableReflection
    {
        /**
         * @param callable|array|string $callable Can be a callable or a callable-like.
         * @throws NotCallableException|ReflectionException
         */
        public static function create($callable): \ReflectionFunctionAbstract
        {
        }
    }
}
namespace DI\Attribute {
    /**
     * #[Inject] attribute.
     *
     * Marks a property or method as an injection point
     *
     * @api
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    #[\Attribute(\Attribute::TARGET_PROPERTY | \Attribute::TARGET_METHOD | \Attribute::TARGET_PARAMETER)]
    final class Inject
    {
        /**
         * @throws InvalidAttribute
         */
        public function __construct(string|array|null $name = null)
        {
        }
        /**
         * @return string|null Name of the entry to inject
         */
        public function getName(): string|null
        {
        }
        /**
         * @return array Parameters, indexed by the parameter number (index) or name
         */
        public function getParameters(): array
        {
        }
    }
    /**
     * "Injectable" attribute.
     *
     * Marks a class as injectable
     *
     * @api
     *
     * @author Domenic Muskulus <domenic@muskulus.eu>
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    #[\Attribute(\Attribute::TARGET_CLASS)]
    final class Injectable
    {
        /**
         * @param bool|null $lazy Should the object be lazy-loaded.
         */
        public function __construct(private ?bool $lazy = null)
        {
        }
        public function isLazy(): bool|null
        {
        }
    }
}
namespace DI {
    /**
     * Describes the basic interface of a factory.
     *
     * @api
     *
     * @since 4.0
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    interface FactoryInterface
    {
        /**
         * Resolves an entry by its name. If given a class name, it will return a new instance of that class.
         *
         * @param string $name       Entry name or a class name.
         * @param array  $parameters Optional parameters to use to build the entry. Use this to force specific
         *                           parameters to specific values. Parameters not defined in this array will
         *                           be automatically resolved.
         *
         * @throws \InvalidArgumentException The name parameter must be of type string.
         * @throws DependencyException       Error while resolving the entry.
         * @throws NotFoundException         No entry or class found for the given name.
         */
        public function make(string $name, array $parameters = []): mixed;
    }
    /**
     * Dependency Injection Container.
     *
     * @api
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class Container implements \Psr\Container\ContainerInterface, \DI\FactoryInterface, \Invoker\InvokerInterface
    {
        /**
         * Map of entries that are already resolved.
         */
        protected array $resolvedEntries = [];
        /**
         * Array of entries being resolved. Used to avoid circular dependencies and infinite loops.
         */
        protected array $entriesBeingResolved = [];
        /**
         * Container that wraps this container. If none, points to $this.
         */
        protected \Psr\Container\ContainerInterface $delegateContainer;
        protected \DI\Proxy\ProxyFactory $proxyFactory;
        public static function create(array $definitions): static
        {
        }
        /**
         * Use `$container = new Container()` if you want a container with the default configuration.
         *
         * If you want to customize the container's behavior, you are discouraged to create and pass the
         * dependencies yourself, the ContainerBuilder class is here to help you instead.
         *
         * @see ContainerBuilder
         *
         * @param ContainerInterface $wrapperContainer If the container is wrapped by another container.
         */
        public function __construct(array|\DI\Definition\Source\MutableDefinitionSource $definitions = [], ?\DI\Proxy\ProxyFactory $proxyFactory = null, ?\Psr\Container\ContainerInterface $wrapperContainer = null)
        {
        }
        /**
         * Returns an entry of the container by its name.
         *
         * @template T
         * @param string|class-string<T> $id Entry name or a class name.
         *
         * @return mixed|T
         * @throws DependencyException Error while resolving the entry.
         * @throws NotFoundException No entry found for the given name.
         */
        public function get(string $id): mixed
        {
        }
        /**
         * Build an entry of the container by its name.
         *
         * This method behave like get() except resolves the entry again every time.
         * For example if the entry is a class then a new instance will be created each time.
         *
         * This method makes the container behave like a factory.
         *
         * @template T
         * @param string|class-string<T> $name       Entry name or a class name.
         * @param array                  $parameters Optional parameters to use to build the entry. Use this to force
         *                                           specific parameters to specific values. Parameters not defined in this
         *                                           array will be resolved using the container.
         *
         * @return mixed|T
         * @throws InvalidArgumentException The name parameter must be of type string.
         * @throws DependencyException Error while resolving the entry.
         * @throws NotFoundException No entry found for the given name.
         */
        public function make(string $name, array $parameters = []): mixed
        {
        }
        public function has(string $id): bool
        {
        }
        /**
         * Inject all dependencies on an existing instance.
         *
         * @template T
         * @param object|T $instance Object to perform injection upon
         * @return object|T $instance Returns the same instance
         * @throws InvalidArgumentException
         * @throws DependencyException Error while injecting dependencies
         */
        public function injectOn(object $instance): object
        {
        }
        /**
         * Call the given function using the given parameters.
         *
         * Missing parameters will be resolved from the container.
         *
         * @param callable|array|string $callable Function to call.
         * @param array    $parameters Parameters to use. Can be indexed by the parameter names
         *                             or not indexed (same order as the parameters).
         *                             The array can also contain DI definitions, e.g. DI\get().
         *
         * @return mixed Result of the function.
         */
        public function call($callable, array $parameters = []): mixed
        {
        }
        /**
         * Define an object or a value in the container.
         *
         * @param string $name Entry name
         * @param mixed|DefinitionHelper $value Value, use definition helpers to define objects
         */
        public function set(string $name, mixed $value): void
        {
        }
        /**
         * Get defined container entries.
         *
         * @return string[]
         */
        public function getKnownEntryNames(): array
        {
        }
        /**
         * Get entry debug information.
         *
         * @param string $name Entry name
         *
         * @throws InvalidDefinition
         * @throws NotFoundException
         */
        public function debugEntry(string $name): string
        {
        }
        protected function setDefinition(string $name, \DI\Definition\Definition $definition): void
        {
        }
    }
    /**
     * Compiled version of the dependency injection container.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    abstract class CompiledContainer extends \DI\Container
    {
        /**
         * This const is overridden in child classes (compiled containers).
         * @var array
         */
        protected const METHOD_MAPPING = [];
        public function get(string $id): mixed
        {
        }
        public function has(string $id): bool
        {
        }
        protected function setDefinition(string $name, \DI\Definition\Definition $definition): void
        {
        }
        /**
         * Invoke the given callable.
         */
        protected function resolveFactory($callable, $entryName, array $extraParameters = []): mixed
        {
        }
    }
}
namespace DI\Compiler {
    /**
     * Compiles the container into PHP code much more optimized for performances.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class Compiler
    {
        public function __construct(private \DI\Proxy\ProxyFactory $proxyFactory)
        {
        }
        public function getProxyFactory(): \DI\Proxy\ProxyFactory
        {
        }
        /**
         * Compile the container.
         *
         * @return string The compiled container file name.
         */
        public function compile(\DI\Definition\Source\DefinitionSource $definitionSource, string $directory, string $className, string $parentClassName, bool $autowiringEnabled): string
        {
        }
        public function compileValue(mixed $value): string
        {
        }
    }
    /**
     * Compiles an object definition into native PHP code that, when executed, creates the object.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class ObjectCreationCompiler
    {
        public function __construct(private \DI\Compiler\Compiler $compiler)
        {
        }
        public function compile(\DI\Definition\ObjectDefinition $definition): string
        {
        }
        public function resolveParameters(?\DI\Definition\ObjectDefinition\MethodInjection $definition, ?\ReflectionMethod $method): array
        {
        }
    }
}
namespace DI\Factory {
    /**
     * Represents the container entry that was requested.
     *
     * Implementations of this interface can be injected in factory parameters in order
     * to know what was the name of the requested entry.
     *
     * @api
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    interface RequestedEntry
    {
        /**
         * Returns the name of the entry that was requested by the container.
         */
        public function getName(): string;
    }
}
namespace DI\Compiler {
    /**
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class RequestedEntryHolder implements \DI\Factory\RequestedEntry
    {
        public function __construct(private string $name)
        {
        }
        public function getName(): string
        {
        }
    }
}
namespace DI {
    /**
     * Helper to create and configure a Container.
     *
     * With the default options, the container created is appropriate for the development environment.
     *
     * Example:
     *
     *     $builder = new ContainerBuilder();
     *     $container = $builder->build();
     *
     * @api
     *
     * @since  3.2
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     *
     * @psalm-template ContainerClass of Container
     */
    class ContainerBuilder
    {
        protected string $sourceCacheNamespace = '';
        /**
         * @param class-string<Container> $containerClass Name of the container class, used to create the container.
         * @psalm-param class-string<ContainerClass> $containerClass
         */
        public function __construct(string $containerClass = \DI\Container::class)
        {
        }
        /**
         * Build and return a container.
         *
         * @return Container
         * @psalm-return ContainerClass
         */
        public function build()
        {
        }
        /**
         * Compile the container for optimum performances.
         *
         * Be aware that the container is compiled once and never updated!
         *
         * Therefore:
         *
         * - in production you should clear that directory every time you deploy
         * - in development you should not compile the container
         *
         * @see https://php-di.org/doc/performances.html
         *
         * @psalm-template T of CompiledContainer
         *
         * @param string $directory Directory in which to put the compiled container.
         * @param string $containerClass Name of the compiled class. Customize only if necessary.
         * @param class-string<Container> $containerParentClass Name of the compiled container parent class. Customize only if necessary.
         * @psalm-param class-string<T> $containerParentClass
         *
         * @psalm-return self<T>
         */
        public function enableCompilation(string $directory, string $containerClass = 'CompiledContainer', string $containerParentClass = \DI\CompiledContainer::class): self
        {
        }
        /**
         * Enable or disable the use of autowiring to guess injections.
         *
         * Enabled by default.
         *
         * @return $this
         */
        public function useAutowiring(bool $bool): self
        {
        }
        /**
         * Enable or disable the use of PHP 8 attributes to configure injections.
         *
         * Disabled by default.
         *
         * @return $this
         */
        public function useAttributes(bool $bool): self
        {
        }
        /**
         * Configure the proxy generation.
         *
         * For dev environment, use `writeProxiesToFile(false)` (default configuration)
         * For production environment, use `writeProxiesToFile(true, 'tmp/proxies')`
         *
         * @see https://php-di.org/doc/lazy-injection.html
         *
         * @param bool $writeToFile If true, write the proxies to disk to improve performances
         * @param string|null $proxyDirectory Directory where to write the proxies
         * @return $this
         * @throws InvalidArgumentException when writeToFile is set to true and the proxy directory is null
         */
        public function writeProxiesToFile(bool $writeToFile, ?string $proxyDirectory = null): self
        {
        }
        /**
         * If PHP-DI's container is wrapped by another container, we can
         * set this so that PHP-DI will use the wrapper rather than itself for building objects.
         *
         * @return $this
         */
        public function wrapContainer(\Psr\Container\ContainerInterface $otherContainer): self
        {
        }
        /**
         * Add definitions to the container.
         *
         * @param string|array|DefinitionSource ...$definitions Can be an array of definitions, the
         *                                                      name of a file containing definitions
         *                                                      or a DefinitionSource object.
         * @return $this
         */
        public function addDefinitions(string|array|\DI\Definition\Source\DefinitionSource ...$definitions): self
        {
        }
        /**
         * Enables the use of APCu to cache definitions.
         *
         * You must have APCu enabled to use it.
         *
         * Before using this feature, you should try these steps first:
         * - enable compilation if not already done (see `enableCompilation()`)
         * - if you use autowiring or attributes, add all the classes you are using into your configuration so that
         *   PHP-DI knows about them and compiles them
         * Once this is done, you can try to optimize performances further with APCu. It can also be useful if you use
         * `Container::make()` instead of `get()` (`make()` calls cannot be compiled so they are not optimized).
         *
         * Remember to clear APCu on each deploy else your application will have a stale cache. Do not enable the cache
         * in development environment: any change you will make to the code will be ignored because of the cache.
         *
         * @see https://php-di.org/doc/performances.html
         *
         * @param string $cacheNamespace use unique namespace per container when sharing a single APC memory pool to prevent cache collisions
         * @return $this
         */
        public function enableDefinitionCache(string $cacheNamespace = ''): self
        {
        }
        /**
         * Are we building a compiled container?
         */
        public function isCompilationEnabled(): bool
        {
        }
    }
}
namespace DI\Definition {
    /**
     * Definition.
     *
     * @internal This interface is internal to PHP-DI and may change between minor versions.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    interface Definition extends \DI\Factory\RequestedEntry, \Stringable
    {
        /**
         * Returns the name of the entry in the container.
         */
        public function getName(): string;
        /**
         * Set the name of the entry in the container.
         */
        public function setName(string $name): void;
        /**
         * Apply a callable that replaces the definitions nested in this definition.
         */
        public function replaceNestedDefinitions(callable $replacer): void;
        /**
         * Definitions can be cast to string for debugging information.
         */
        public function __toString(): string;
    }
    /**
     * Definition of an array containing values or references.
     *
     * @since 5.0
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class ArrayDefinition implements \DI\Definition\Definition
    {
        public function __construct(private array $values)
        {
        }
        public function getName(): string
        {
        }
        public function setName(string $name): void
        {
        }
        public function getValues(): array
        {
        }
        public function replaceNestedDefinitions(callable $replacer): void
        {
        }
        public function __toString(): string
        {
        }
    }
    /**
     * A definition that extends a previous definition with the same name.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    interface ExtendsPreviousDefinition extends \DI\Definition\Definition
    {
        public function setExtendedDefinition(\DI\Definition\Definition $definition): void;
    }
    /**
     * Extends an array definition by adding new elements into it.
     *
     * @since 5.0
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class ArrayDefinitionExtension extends \DI\Definition\ArrayDefinition implements \DI\Definition\ExtendsPreviousDefinition
    {
        public function getValues(): array
        {
        }
        public function setExtendedDefinition(\DI\Definition\Definition $definition): void
        {
        }
    }
    /**
     * Defines how an object can be instantiated.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class ObjectDefinition implements \DI\Definition\Definition
    {
        /**
         * Class name (if null, then the class name is $name).
         */
        protected ?string $className = null;
        protected ?\DI\Definition\ObjectDefinition\MethodInjection $constructorInjection = null;
        protected array $propertyInjections = [];
        /**
         * Method calls.
         * @var MethodInjection[][]
         */
        protected array $methodInjections = [];
        protected ?bool $lazy = null;
        /**
         * @param string $name Entry name
         */
        public function __construct(string $name, ?string $className = null)
        {
        }
        public function getName(): string
        {
        }
        public function setName(string $name): void
        {
        }
        public function setClassName(?string $className): void
        {
        }
        public function getClassName(): string
        {
        }
        public function getConstructorInjection(): ?\DI\Definition\ObjectDefinition\MethodInjection
        {
        }
        public function setConstructorInjection(\DI\Definition\ObjectDefinition\MethodInjection $constructorInjection): void
        {
        }
        public function completeConstructorInjection(\DI\Definition\ObjectDefinition\MethodInjection $injection): void
        {
        }
        /**
         * @return PropertyInjection[] Property injections
         */
        public function getPropertyInjections(): array
        {
        }
        public function addPropertyInjection(\DI\Definition\ObjectDefinition\PropertyInjection $propertyInjection): void
        {
        }
        /**
         * @return MethodInjection[] Method injections
         */
        public function getMethodInjections(): array
        {
        }
        public function addMethodInjection(\DI\Definition\ObjectDefinition\MethodInjection $methodInjection): void
        {
        }
        public function completeFirstMethodInjection(\DI\Definition\ObjectDefinition\MethodInjection $injection): void
        {
        }
        public function setLazy(?bool $lazy = null): void
        {
        }
        public function isLazy(): bool
        {
        }
        public function classExists(): bool
        {
        }
        public function isInstantiable(): bool
        {
        }
        public function replaceNestedDefinitions(callable $replacer): void
        {
        }
        /**
         * Replaces all the wildcards in the string with the given replacements.
         *
         * @param string[] $replacements
         */
        public function replaceWildcards(array $replacements): void
        {
        }
        public function __toString(): string
        {
        }
    }
    /**
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class AutowireDefinition extends \DI\Definition\ObjectDefinition
    {
    }
    /**
     * Definition of a value or class with a factory.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class FactoryDefinition implements \DI\Definition\Definition
    {
        /**
         * @param string $name Entry name
         * @param callable|array|string $factory Callable that returns the value associated to the entry name.
         * @param array $parameters Parameters to be passed to the callable
         */
        public function __construct(string $name, callable|array|string $factory, array $parameters = [])
        {
        }
        public function getName(): string
        {
        }
        public function setName(string $name): void
        {
        }
        /**
         * @return callable|array|string Callable that returns the value associated to the entry name.
         */
        public function getCallable(): callable|array|string
        {
        }
        /**
         * @return array Array containing the parameters to be passed to the callable, indexed by name.
         */
        public function getParameters(): array
        {
        }
        public function replaceNestedDefinitions(callable $replacer): void
        {
        }
        public function __toString(): string
        {
        }
    }
    /**
     * Factory that decorates a sub-definition.
     *
     * @since 5.0
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class DecoratorDefinition extends \DI\Definition\FactoryDefinition implements \DI\Definition\Definition, \DI\Definition\ExtendsPreviousDefinition
    {
        public function setExtendedDefinition(\DI\Definition\Definition $definition): void
        {
        }
        public function getDecoratedDefinition(): ?\DI\Definition\Definition
        {
        }
        public function replaceNestedDefinitions(callable $replacer): void
        {
        }
        public function __toString(): string
        {
        }
    }
}
namespace DI\Definition\Dumper {
    /**
     * Dumps object definitions to string for debugging purposes.
     *
     * @since 4.1
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class ObjectDefinitionDumper
    {
        /**
         * Returns the definition as string representation.
         */
        public function dump(\DI\Definition\ObjectDefinition $definition): string
        {
        }
    }
}
namespace DI\Definition {
    /**
     * Defines a reference to an environment variable, with fallback to a default
     * value if the environment variable is not defined.
     *
     * @author James Harris <james.harris@icecave.com.au>
     */
    class EnvironmentVariableDefinition implements \DI\Definition\Definition
    {
        /**
         * @param string $variableName The name of the environment variable
         * @param bool $isOptional Whether or not the environment variable definition is optional. If true and the environment variable given by $variableName has not been defined, $defaultValue is used.
         * @param mixed $defaultValue The default value to use if the environment variable is optional and not provided
         */
        public function __construct(private string $variableName, private bool $isOptional = false, private mixed $defaultValue = null)
        {
        }
        public function getName(): string
        {
        }
        public function setName(string $name): void
        {
        }
        /**
         * @return string The name of the environment variable
         */
        public function getVariableName(): string
        {
        }
        /**
         * @return bool Whether or not the environment variable definition is optional
         */
        public function isOptional(): bool
        {
        }
        /**
         * @return mixed The default value to use if the environment variable is optional and not provided
         */
        public function getDefaultValue(): mixed
        {
        }
        public function replaceNestedDefinitions(callable $replacer): void
        {
        }
        public function __toString(): string
        {
        }
    }
}
namespace DI\Definition\Exception {
    /**
     * Invalid DI definitions.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class InvalidDefinition extends \Exception implements \Psr\Container\ContainerExceptionInterface
    {
        public static function create(\DI\Definition\Definition $definition, string $message, ?\Exception $previous = null): self
        {
        }
    }
    /**
     * Error in the definitions using PHP attributes.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class InvalidAttribute extends \DI\Definition\Exception\InvalidDefinition
    {
    }
}
namespace DI\Definition\Helper {
    /**
     * Helps defining container entries.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    interface DefinitionHelper
    {
        /**
         * @param string $entryName Container entry name
         */
        public function getDefinition(string $entryName): \DI\Definition\Definition;
    }
    /**
     * Helps defining how to create an instance of a class.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class CreateDefinitionHelper implements \DI\Definition\Helper\DefinitionHelper
    {
        /**
         * Array of constructor parameters.
         */
        protected array $constructor = [];
        /**
         * Array of methods and their parameters.
         */
        protected array $methods = [];
        /**
         * Helper for defining an object.
         *
         * @param string|null $className Class name of the object.
         *                               If null, the name of the entry (in the container) will be used as class name.
         */
        public function __construct(?string $className = null)
        {
        }
        /**
         * Define the entry as lazy.
         *
         * A lazy entry is created only when it is used, a proxy is injected instead.
         *
         * @return $this
         */
        public function lazy(): self
        {
        }
        /**
         * Defines the arguments to use to call the constructor.
         *
         * This method takes a variable number of arguments, example:
         *     ->constructor($param1, $param2, $param3)
         *
         * @param mixed ...$parameters Parameters to use for calling the constructor of the class.
         *
         * @return $this
         */
        public function constructor(mixed ...$parameters): self
        {
        }
        /**
         * Defines a value to inject in a property of the object.
         *
         * @param string $property Entry in which to inject the value.
         * @param mixed  $value    Value to inject in the property.
         *
         * @return $this
         */
        public function property(string $property, mixed $value): self
        {
        }
        /**
         * Defines a method to call and the arguments to use.
         *
         * This method takes a variable number of arguments after the method name, example:
         *
         *     ->method('myMethod', $param1, $param2)
         *
         * Can be used multiple times to declare multiple calls.
         *
         * @param string $method       Name of the method to call.
         * @param mixed ...$parameters Parameters to use for calling the method.
         *
         * @return $this
         */
        public function method(string $method, mixed ...$parameters): self
        {
        }
        public function getDefinition(string $entryName): \DI\Definition\ObjectDefinition
        {
        }
    }
    /**
     * Helps defining how to create an instance of a class using autowiring.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class AutowireDefinitionHelper extends \DI\Definition\Helper\CreateDefinitionHelper
    {
        public const DEFINITION_CLASS = \DI\Definition\AutowireDefinition::class;
        /**
         * Defines a value for a specific argument of the constructor.
         *
         * This method is usually used together with attributes or autowiring, when a parameter
         * is not (or cannot be) type-hinted. Using this method instead of constructor() allows to
         * avoid defining all the parameters (letting them being resolved using attributes or autowiring)
         * and only define one.
         *
         * @param string|int $parameter Parameter name of position for which the value will be given.
         * @param mixed $value Value to give to this parameter.
         *
         * @return $this
         */
        public function constructorParameter(string|int $parameter, mixed $value): self
        {
        }
        /**
         * Defines a method to call and a value for a specific argument.
         *
         * This method is usually used together with attributes or autowiring, when a parameter
         * is not (or cannot be) type-hinted. Using this method instead of method() allows to
         * avoid defining all the parameters (letting them being resolved using attributes or
         * autowiring) and only define one.
         *
         * If multiple calls to the method have been configured already (e.g. in a previous definition)
         * then this method only overrides the parameter for the *first* call.
         *
         * @param string $method Name of the method to call.
         * @param string|int $parameter Parameter name of position for which the value will be given.
         * @param mixed $value Value to give to this parameter.
         *
         * @return $this
         */
        public function methodParameter(string $method, string|int $parameter, mixed $value): self
        {
        }
    }
    /**
     * Helps defining how to create an instance of a class using a factory (callable).
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class FactoryDefinitionHelper implements \DI\Definition\Helper\DefinitionHelper
    {
        /**
         * @param bool $decorate Is the factory decorating a previous definition?
         */
        public function __construct(callable|array|string $factory, bool $decorate = false)
        {
        }
        public function getDefinition(string $entryName): \DI\Definition\FactoryDefinition
        {
        }
        /**
         * Defines arguments to pass to the factory.
         *
         * Because factory methods do not yet support attributes or autowiring, this method
         * should be used to define all parameters except the ContainerInterface and RequestedEntry.
         *
         * Multiple calls can be made to the method to override individual values.
         *
         * @param string $parameter Name or index of the parameter for which the value will be given.
         * @param mixed  $value     Value to give to this parameter.
         *
         * @return $this
         */
        public function parameter(string $parameter, mixed $value): self
        {
        }
    }
}
namespace DI\Definition {
    /**
     * Defines injections on an existing class instance.
     *
     * @since  5.0
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class InstanceDefinition implements \DI\Definition\Definition
    {
        /**
         * @param object $instance Instance on which to inject dependencies.
         */
        public function __construct(private object $instance, private \DI\Definition\ObjectDefinition $objectDefinition)
        {
        }
        public function getName(): string
        {
        }
        public function setName(string $name): void
        {
        }
        public function getInstance(): object
        {
        }
        public function getObjectDefinition(): \DI\Definition\ObjectDefinition
        {
        }
        public function replaceNestedDefinitions(callable $replacer): void
        {
        }
        public function __toString(): string
        {
        }
    }
}
namespace DI\Definition\ObjectDefinition {
    /**
     * Describe an injection in an object method.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class MethodInjection implements \DI\Definition\Definition
    {
        /**
         * @param mixed[] $parameters
         */
        public function __construct(private string $methodName, private array $parameters = [])
        {
        }
        public static function constructor(array $parameters = []): self
        {
        }
        public function getMethodName(): string
        {
        }
        /**
         * @return mixed[]
         */
        public function getParameters(): array
        {
        }
        /**
         * Replace the parameters of the definition by a new array of parameters.
         */
        public function replaceParameters(array $parameters): void
        {
        }
        public function merge(self $definition): void
        {
        }
        public function getName(): string
        {
        }
        public function setName(string $name): void
        {
        }
        public function replaceNestedDefinitions(callable $replacer): void
        {
        }
        public function __toString(): string
        {
        }
    }
    /**
     * Describe an injection in a class property.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class PropertyInjection
    {
        /**
         * @param string $propertyName Property name
         * @param mixed $value Value that should be injected in the property
         */
        public function __construct(string $propertyName, mixed $value, ?string $className = null)
        {
        }
        public function getPropertyName(): string
        {
        }
        /**
         * @return mixed Value that should be injected in the property
         */
        public function getValue(): mixed
        {
        }
        public function getClassName(): ?string
        {
        }
        public function replaceNestedDefinition(callable $replacer): void
        {
        }
    }
}
namespace DI\Definition {
    /**
     * Describes a definition that can resolve itself.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    interface SelfResolvingDefinition
    {
        /**
         * Resolve the definition and return the resulting value.
         */
        public function resolve(\Psr\Container\ContainerInterface $container): mixed;
        /**
         * Check if a definition can be resolved.
         */
        public function isResolvable(\Psr\Container\ContainerInterface $container): bool;
    }
    /**
     * Represents a reference to another entry.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class Reference implements \DI\Definition\Definition, \DI\Definition\SelfResolvingDefinition
    {
        /**
         * @param string $targetEntryName Name of the target entry
         */
        public function __construct(private string $targetEntryName)
        {
        }
        public function getName(): string
        {
        }
        public function setName(string $name): void
        {
        }
        public function getTargetEntryName(): string
        {
        }
        public function resolve(\Psr\Container\ContainerInterface $container): mixed
        {
        }
        public function isResolvable(\Psr\Container\ContainerInterface $container): bool
        {
        }
        public function replaceNestedDefinitions(callable $replacer): void
        {
        }
        public function __toString(): string
        {
        }
    }
}
namespace DI\Definition\Resolver {
    /**
     * Resolves a definition to a value.
     *
     * @since 4.0
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     *
     * @template T of Definition
     */
    interface DefinitionResolver
    {
        /**
         * Resolve a definition to a value.
         *
         * @param Definition $definition Object that defines how the value should be obtained.
         * @psalm-param T $definition
         * @param array      $parameters Optional parameters to use to build the entry.
         * @return mixed Value obtained from the definition.
         *
         * @throws InvalidDefinition If the definition cannot be resolved.
         * @throws DependencyException
         */
        public function resolve(\DI\Definition\Definition $definition, array $parameters = []): mixed;
        /**
         * Check if a definition can be resolved.
         *
         * @param Definition $definition Object that defines how the value should be obtained.
         * @psalm-param T $definition
         * @param array      $parameters Optional parameters to use to build the entry.
         */
        public function isResolvable(\DI\Definition\Definition $definition, array $parameters = []): bool;
    }
    /**
     * Resolves an array definition to a value.
     *
     * @template-implements DefinitionResolver<ArrayDefinition>
     *
     * @since 5.0
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class ArrayResolver implements \DI\Definition\Resolver\DefinitionResolver
    {
        /**
         * @param DefinitionResolver $definitionResolver Used to resolve nested definitions.
         */
        public function __construct(private \DI\Definition\Resolver\DefinitionResolver $definitionResolver)
        {
        }
        /**
         * {@inheritDoc}
         *
         * Resolve an array definition to a value.
         *
         * An array definition can contain simple values or references to other entries.
         *
         * @param ArrayDefinition $definition
         */
        public function resolve(\DI\Definition\Definition $definition, array $parameters = []): array
        {
        }
        public function isResolvable(\DI\Definition\Definition $definition, array $parameters = []): bool
        {
        }
    }
    /**
     * Resolves a decorator definition to a value.
     *
     * @template-implements DefinitionResolver<DecoratorDefinition>
     *
     * @since 5.0
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class DecoratorResolver implements \DI\Definition\Resolver\DefinitionResolver
    {
        /**
         * The resolver needs a container. This container will be passed to the factory as a parameter
         * so that the factory can access other entries of the container.
         *
         * @param DefinitionResolver $definitionResolver Used to resolve nested definitions.
         */
        public function __construct(private \Psr\Container\ContainerInterface $container, private \DI\Definition\Resolver\DefinitionResolver $definitionResolver)
        {
        }
        /**
         * Resolve a decorator definition to a value.
         *
         * This will call the callable of the definition and pass it the decorated entry.
         *
         * @param DecoratorDefinition $definition
         */
        public function resolve(\DI\Definition\Definition $definition, array $parameters = []): mixed
        {
        }
        public function isResolvable(\DI\Definition\Definition $definition, array $parameters = []): bool
        {
        }
    }
    /**
     * Resolves a environment variable definition to a value.
     *
     * @template-implements DefinitionResolver<EnvironmentVariableDefinition>
     *
     * @author James Harris <james.harris@icecave.com.au>
     */
    class EnvironmentVariableResolver implements \DI\Definition\Resolver\DefinitionResolver
    {
        public function __construct(private \DI\Definition\Resolver\DefinitionResolver $definitionResolver, $variableReader = null)
        {
        }
        /**
         * Resolve an environment variable definition to a value.
         *
         * @param EnvironmentVariableDefinition $definition
         */
        public function resolve(\DI\Definition\Definition $definition, array $parameters = []): mixed
        {
        }
        public function isResolvable(\DI\Definition\Definition $definition, array $parameters = []): bool
        {
        }
        protected function getEnvVariable(string $variableName)
        {
        }
    }
    /**
     * Resolves a factory definition to a value.
     *
     * @template-implements DefinitionResolver<FactoryDefinition>
     *
     * @since 4.0
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class FactoryResolver implements \DI\Definition\Resolver\DefinitionResolver
    {
        /**
         * The resolver needs a container. This container will be passed to the factory as a parameter
         * so that the factory can access other entries of the container.
         */
        public function __construct(private \Psr\Container\ContainerInterface $container, private \DI\Definition\Resolver\DefinitionResolver $resolver)
        {
        }
        /**
         * Resolve a factory definition to a value.
         *
         * This will call the callable of the definition.
         *
         * @param FactoryDefinition $definition
         */
        public function resolve(\DI\Definition\Definition $definition, array $parameters = []): mixed
        {
        }
        public function isResolvable(\DI\Definition\Definition $definition, array $parameters = []): bool
        {
        }
    }
    /**
     * Create objects based on an object definition.
     *
     * @template-implements DefinitionResolver<ObjectDefinition>
     *
     * @since 4.0
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class ObjectCreator implements \DI\Definition\Resolver\DefinitionResolver
    {
        /**
         * @param DefinitionResolver $definitionResolver Used to resolve nested definitions.
         * @param ProxyFactory       $proxyFactory       Used to create proxies for lazy injections.
         */
        public function __construct(private \DI\Definition\Resolver\DefinitionResolver $definitionResolver, private \DI\Proxy\ProxyFactory $proxyFactory)
        {
        }
        /**
         * Resolve a class definition to a value.
         *
         * This will create a new instance of the class using the injections points defined.
         *
         * @param ObjectDefinition $definition
         */
        public function resolve(\DI\Definition\Definition $definition, array $parameters = []): ?object
        {
        }
        /**
         * The definition is not resolvable if the class is not instantiable (interface or abstract)
         * or if the class doesn't exist.
         *
         * @param ObjectDefinition $definition
         */
        public function isResolvable(\DI\Definition\Definition $definition, array $parameters = []): bool
        {
        }
        protected function injectMethodsAndProperties(object $object, \DI\Definition\ObjectDefinition $objectDefinition): void
        {
        }
        public static function setPrivatePropertyValue(?string $className, $object, string $propertyName, mixed $propertyValue): void
        {
        }
    }
    /**
     * Injects dependencies on an existing instance.
     *
     * @template-implements DefinitionResolver<InstanceDefinition>
     *
     * @since 5.0
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class InstanceInjector extends \DI\Definition\Resolver\ObjectCreator implements \DI\Definition\Resolver\DefinitionResolver
    {
        /**
         * Injects dependencies on an existing instance.
         *
         * @param InstanceDefinition $definition
         * @psalm-suppress ImplementedParamTypeMismatch
         */
        public function resolve(\DI\Definition\Definition $definition, array $parameters = []): ?object
        {
        }
        public function isResolvable(\DI\Definition\Definition $definition, array $parameters = []): bool
        {
        }
    }
    /**
     * Resolves parameters for a function call.
     *
     * @since  4.2
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class ParameterResolver
    {
        /**
         * @param DefinitionResolver $definitionResolver Will be used to resolve nested definitions.
         */
        public function __construct(private \DI\Definition\Resolver\DefinitionResolver $definitionResolver)
        {
        }
        /**
         * @return array Parameters to use to call the function.
         * @throws InvalidDefinition A parameter has no value defined or guessable.
         */
        public function resolveParameters(?\DI\Definition\ObjectDefinition\MethodInjection $definition = null, ?\ReflectionMethod $method = null, array $parameters = []): array
        {
        }
    }
    /**
     * Dispatches to more specific resolvers.
     *
     * Dynamic dispatch pattern.
     *
     * @since 5.0
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class ResolverDispatcher implements \DI\Definition\Resolver\DefinitionResolver
    {
        public function __construct(private \Psr\Container\ContainerInterface $container, private \DI\Proxy\ProxyFactory $proxyFactory)
        {
        }
        /**
         * Resolve a definition to a value.
         *
         * @param Definition $definition Object that defines how the value should be obtained.
         * @param array      $parameters Optional parameters to use to build the entry.
         *
         * @return mixed Value obtained from the definition.
         * @throws InvalidDefinition If the definition cannot be resolved.
         */
        public function resolve(\DI\Definition\Definition $definition, array $parameters = []): mixed
        {
        }
        public function isResolvable(\DI\Definition\Definition $definition, array $parameters = []): bool
        {
        }
    }
}
namespace DI\Definition\Source {
    /**
     * Source of definitions for entries of the container.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    interface DefinitionSource
    {
        /**
         * Returns the DI definition for the entry name.
         *
         * @throws InvalidDefinition An invalid definition was found.
         */
        public function getDefinition(string $name): \DI\Definition\Definition|null;
        /**
         * @return array<string,Definition> Definitions indexed by their name.
         */
        public function getDefinitions(): array;
    }
    /**
     * Source of definitions for entries of the container.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    interface Autowiring
    {
        /**
         * Autowire the given definition.
         *
         * @throws InvalidDefinition An invalid definition was found.
         */
        public function autowire(string $name, ?\DI\Definition\ObjectDefinition $definition = null): \DI\Definition\ObjectDefinition|null;
    }
    /**
     * Provides DI definitions by reading PHP 8 attributes such as #[Inject] and #[Injectable].
     *
     * This source automatically includes the reflection source.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class AttributeBasedAutowiring implements \DI\Definition\Source\DefinitionSource, \DI\Definition\Source\Autowiring
    {
        /**
         * @throws InvalidAttribute
         */
        public function autowire(string $name, ?\DI\Definition\ObjectDefinition $definition = null): \DI\Definition\ObjectDefinition|null
        {
        }
        /**
         * @throws InvalidAttribute
         * @throws InvalidArgumentException The class doesn't exist
         */
        public function getDefinition(string $name): \DI\Definition\ObjectDefinition|null
        {
        }
        /**
         * Autowiring cannot guess all existing definitions.
         */
        public function getDefinitions(): array
        {
        }
    }
    /**
     * Describes a definition source to which we can add new definitions.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    interface MutableDefinitionSource extends \DI\Definition\Source\DefinitionSource
    {
        public function addDefinition(\DI\Definition\Definition $definition): void;
    }
    /**
     * Reads DI definitions from a PHP array.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class DefinitionArray implements \DI\Definition\Source\DefinitionSource, \DI\Definition\Source\MutableDefinitionSource
    {
        public const WILDCARD = '*';
        public function __construct(array $definitions = [], ?\DI\Definition\Source\Autowiring $autowiring = null)
        {
        }
        /**
         * @param array $definitions DI definitions in a PHP array indexed by the definition name.
         */
        public function addDefinitions(array $definitions): void
        {
        }
        public function addDefinition(\DI\Definition\Definition $definition): void
        {
        }
        public function getDefinition(string $name): \DI\Definition\Definition|null
        {
        }
        public function getDefinitions(): array
        {
        }
    }
    /**
     * Reads DI definitions from a file returning a PHP array.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class DefinitionFile extends \DI\Definition\Source\DefinitionArray
    {
        /**
         * @param string $file File in which the definitions are returned as an array.
         */
        public function __construct(private string $file, ?\DI\Definition\Source\Autowiring $autowiring = null)
        {
        }
        public function getDefinition(string $name): \DI\Definition\Definition|null
        {
        }
        public function getDefinitions(): array
        {
        }
    }
    /**
     * Turns raw definitions/definition helpers into definitions ready
     * to be resolved or compiled.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class DefinitionNormalizer
    {
        public function __construct(private \DI\Definition\Source\Autowiring $autowiring)
        {
        }
        /**
         * Normalize a definition that is *not* nested in another one.
         *
         * This is usually a definition declared at the root of a definition array.
         *
         * @param string $name The definition name.
         * @param string[] $wildcardsReplacements Replacements for wildcard definitions.
         *
         * @throws InvalidDefinition
         */
        public function normalizeRootDefinition(mixed $definition, string $name, ?array $wildcardsReplacements = null): \DI\Definition\Definition
        {
        }
        /**
         * Normalize a definition that is nested in another one.
         *
         * @throws InvalidDefinition
         */
        public function normalizeNestedDefinition(mixed $definition): mixed
        {
        }
    }
    /**
     * Implementation used when autowiring is completely disabled.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class NoAutowiring implements \DI\Definition\Source\Autowiring
    {
        public function autowire(string $name, ?\DI\Definition\ObjectDefinition $definition = null): \DI\Definition\ObjectDefinition|null
        {
        }
    }
    /**
     * Reads DI class definitions using reflection.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class ReflectionBasedAutowiring implements \DI\Definition\Source\DefinitionSource, \DI\Definition\Source\Autowiring
    {
        public function autowire(string $name, ?\DI\Definition\ObjectDefinition $definition = null): \DI\Definition\ObjectDefinition|null
        {
        }
        public function getDefinition(string $name): \DI\Definition\ObjectDefinition|null
        {
        }
        /**
         * Autowiring cannot guess all existing definitions.
         */
        public function getDefinitions(): array
        {
        }
    }
    /**
     * Decorator that caches another definition source.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class SourceCache implements \DI\Definition\Source\DefinitionSource, \DI\Definition\Source\MutableDefinitionSource
    {
        public const CACHE_KEY = 'php-di.definitions.';
        public function __construct(private \DI\Definition\Source\DefinitionSource $cachedSource, private string $cacheNamespace = '')
        {
        }
        public function getDefinition(string $name): \DI\Definition\Definition|null
        {
        }
        /**
         * Used only for the compilation so we can skip the cache safely.
         */
        public function getDefinitions(): array
        {
        }
        public static function isSupported(): bool
        {
        }
        public function getCacheKey(string $name): string
        {
        }
        public function addDefinition(\DI\Definition\Definition $definition): void
        {
        }
    }
    /**
     * Manages a chain of other definition sources.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class SourceChain implements \DI\Definition\Source\DefinitionSource, \DI\Definition\Source\MutableDefinitionSource
    {
        /**
         * @param list<DefinitionSource> $sources
         */
        public function __construct(private array $sources)
        {
        }
        /**
         * @param int $startIndex Use this parameter to start looking from a specific
         *                        point in the source chain.
         */
        public function getDefinition(string $name, int $startIndex = 0): \DI\Definition\Definition|null
        {
        }
        public function getDefinitions(): array
        {
        }
        public function addDefinition(\DI\Definition\Definition $definition): void
        {
        }
        public function setMutableDefinitionSource(\DI\Definition\Source\MutableDefinitionSource $mutableSource): void
        {
        }
    }
}
namespace DI\Definition {
    /**
     * Definition of a string composed of other strings.
     *
     * @since 5.0
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class StringDefinition implements \DI\Definition\Definition, \DI\Definition\SelfResolvingDefinition
    {
        public function __construct(private string $expression)
        {
        }
        public function getName(): string
        {
        }
        public function setName(string $name): void
        {
        }
        public function getExpression(): string
        {
        }
        public function resolve(\Psr\Container\ContainerInterface $container): string
        {
        }
        public function isResolvable(\Psr\Container\ContainerInterface $container): bool
        {
        }
        public function replaceNestedDefinitions(callable $replacer): void
        {
        }
        public function __toString(): string
        {
        }
        /**
         * Resolve a string expression.
         */
        public static function resolveExpression(string $entryName, string $expression, \Psr\Container\ContainerInterface $container): string
        {
        }
    }
    /**
     * Definition of a value for dependency injection.
     *
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class ValueDefinition implements \DI\Definition\Definition, \DI\Definition\SelfResolvingDefinition
    {
        public function __construct(private mixed $value)
        {
        }
        public function getName(): string
        {
        }
        public function setName(string $name): void
        {
        }
        public function getValue(): mixed
        {
        }
        public function resolve(\Psr\Container\ContainerInterface $container): mixed
        {
        }
        public function isResolvable(\Psr\Container\ContainerInterface $container): bool
        {
        }
        public function replaceNestedDefinitions(callable $replacer): void
        {
        }
        public function __toString(): string
        {
        }
    }
}
namespace DI {
    /**
     * Exception for the Container.
     */
    class DependencyException extends \Exception implements \Psr\Container\ContainerExceptionInterface
    {
    }
}
namespace DI\Invoker {
    /**
     * Resolves callable parameters using definitions.
     *
     * @since 5.0
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class DefinitionParameterResolver implements \Invoker\ParameterResolver\ParameterResolver
    {
        public function __construct(private \DI\Definition\Resolver\DefinitionResolver $definitionResolver)
        {
        }
        public function getParameters(\ReflectionFunctionAbstract $reflection, array $providedParameters, array $resolvedParameters): array
        {
        }
    }
    /**
     * Inject the container, the definition or any other service using type-hints.
     *
     * {@internal This class is similar to TypeHintingResolver and TypeHintingContainerResolver,
     *            we use this instead for performance reasons}
     *
     * @author Quim Calpe <quim@kalpe.com>
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class FactoryParameterResolver implements \Invoker\ParameterResolver\ParameterResolver
    {
        public function __construct(private \Psr\Container\ContainerInterface $container)
        {
        }
        public function getParameters(\ReflectionFunctionAbstract $reflection, array $providedParameters, array $resolvedParameters): array
        {
        }
    }
}
namespace DI {
    /**
     * Exception thrown when a class or a value is not found in the container.
     */
    class NotFoundException extends \Exception implements \Psr\Container\NotFoundExceptionInterface
    {
    }
}
namespace DI\Proxy {
    /**
     * Creates proxy classes.
     *
     * Wraps Ocramius/ProxyManager LazyLoadingValueHolderFactory.
     *
     * @see LazyLoadingValueHolderFactory
     *
     * @since  5.0
     * @author Matthieu Napoli <matthieu@mnapoli.fr>
     */
    class ProxyFactory
    {
        /**
         * @param string|null $proxyDirectory If set, write the proxies to disk in this directory to improve performances.
         */
        public function __construct(private ?string $proxyDirectory = null)
        {
        }
        /**
         * Creates a new lazy proxy instance of the given class with
         * the given initializer.
         *
         * @param class-string $className name of the class to be proxied
         * @param \Closure $initializer initializer to be passed to the proxy
         */
        public function createProxy(string $className, \Closure $initializer): \ProxyManager\Proxy\LazyLoadingInterface
        {
        }
        /**
         * Generates and writes the proxy class to file.
         *
         * @param class-string $className name of the class to be proxied
         */
        public function generateProxyClass(string $className): void
        {
        }
    }
}
namespace Http\Discovery {
    /**
     * Registry that based find results on class existence.
     *
     * @author David de Boer <david@ddeboer.nl>
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     * @author Tobias Nyholm <tobias.nyholm@gmail.com>
     */
    abstract class ClassDiscovery
    {
        /**
         * Finds a class.
         *
         * @param string $type
         *
         * @return string|\Closure
         *
         * @throws DiscoveryFailedException
         */
        protected static function findOneByType($type)
        {
        }
        /**
         * Set new strategies and clear the cache.
         *
         * @param string[] $strategies list of fully qualified class names that implement DiscoveryStrategy
         */
        public static function setStrategies(array $strategies)
        {
        }
        /**
         * Returns the currently configured discovery strategies as fully qualified class names.
         *
         * @return string[]
         */
        public static function getStrategies(): iterable
        {
        }
        /**
         * Append a strategy at the end of the strategy queue.
         *
         * @param string $strategy Fully qualified class name of a DiscoveryStrategy
         */
        public static function appendStrategy($strategy)
        {
        }
        /**
         * Prepend a strategy at the beginning of the strategy queue.
         *
         * @param string $strategy Fully qualified class name to a DiscoveryStrategy
         */
        public static function prependStrategy($strategy)
        {
        }
        public static function clearCache()
        {
        }
        /**
         * Evaluates conditions to boolean.
         *
         * @return bool
         */
        protected static function evaluateCondition($condition)
        {
        }
        /**
         * Get an instance of the $class.
         *
         * @param string|\Closure $class a FQCN of a class or a closure that instantiate the class
         *
         * @return object
         *
         * @throws ClassInstantiationFailedException
         */
        protected static function instantiateClass($class)
        {
        }
        /**
         * We need a "safe" version of PHP's "class_exists" because Magento has a bug
         * (or they call it a "feature"). Magento is throwing an exception if you do class_exists()
         * on a class that ends with "Factory" and if that file does not exits.
         *
         * This function catches all potential exceptions and makes sure to always return a boolean.
         *
         * @param string $class
         *
         * @return bool
         */
        public static function safeClassExists($class)
        {
        }
    }
}
namespace Http\Discovery\Composer {
    /**
     * Auto-installs missing implementations.
     *
     * When a dependency requires both this package and one of the supported `*-implementation`
     * virtual packages, this plugin will auto-install a well-known implementation if none is
     * found. The plugin will first look at already installed packages and figure out the
     * preferred implementation to install based on the below stickyness rules (or on the first
     * listed implementation if no rules match.)
     *
     * Don't miss updating src/Strategy/Common*Strategy.php when adding a new supported package.
     *
     * @author Nicolas Grekas <p@tchwork.com>
     *
     * @internal
     */
    class Plugin implements \Composer\Plugin\PluginInterface, \Composer\EventDispatcher\EventSubscriberInterface
    {
        public static function getSubscribedEvents(): array
        {
        }
        public function activate(\Composer\Composer $composer, \Composer\IO\IOInterface $io): void
        {
        }
        public function deactivate(\Composer\Composer $composer, \Composer\IO\IOInterface $io)
        {
        }
        public function uninstall(\Composer\Composer $composer, \Composer\IO\IOInterface $io)
        {
        }
        public function postUpdate(\Composer\Script\Event $event)
        {
        }
        public function getMissingRequires(\Composer\Repository\InstalledRepositoryInterface $repo, array $requires, bool $isProject, array $pinnedAbstractions): array
        {
        }
        public function preAutoloadDump(\Composer\Script\Event $event)
        {
        }
    }
}
namespace Http\Discovery {
    /**
     * An interface implemented by all discovery related exceptions.
     *
     * @author Tobias Nyholm <tobias.nyholm@gmail.com>
     */
    interface Exception extends \Throwable
    {
    }
}
namespace Http\Discovery\Exception {
    /**
     * Thrown when a class fails to instantiate.
     *
     * @author Tobias Nyholm <tobias.nyholm@gmail.com>
     */
    final class ClassInstantiationFailedException extends \RuntimeException implements \Http\Discovery\Exception
    {
    }
    /**
     * Thrown when all discovery strategies fails to find a resource.
     *
     * @author Tobias Nyholm <tobias.nyholm@gmail.com>
     */
    final class DiscoveryFailedException extends \Exception implements \Http\Discovery\Exception
    {
        /**
         * @param string       $message
         * @param \Exception[] $exceptions
         */
        public function __construct($message, array $exceptions = [])
        {
        }
        /**
         * @param \Exception[] $exceptions
         */
        public static function create($exceptions)
        {
        }
        /**
         * @return \Exception[]
         */
        public function getExceptions()
        {
        }
    }
    /**
     * When we have used a strategy but no candidates provided by that strategy could be used.
     *
     * @author Tobias Nyholm <tobias.nyholm@gmail.com>
     */
    final class NoCandidateFoundException extends \Exception implements \Http\Discovery\Exception
    {
        /**
         * @param string $strategy
         */
        public function __construct($strategy, array $candidates)
        {
        }
    }
    /**
     * Thrown when a discovery does not find any matches.
     *
     * @final do NOT extend this class, not final for BC reasons
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    /* final */
    class NotFoundException extends \RuntimeException implements \Http\Discovery\Exception
    {
    }
    /**
     * This exception is thrown when we cannot use a discovery strategy. This is *not* thrown when
     * the discovery fails to find a class.
     *
     * @author Tobias Nyholm <tobias.nyholm@gmail.com>
     */
    class StrategyUnavailableException extends \RuntimeException implements \Http\Discovery\Exception
    {
    }
    /**
     * Thrown when we can't use Puli for discovery.
     *
     * @author Tobias Nyholm <tobias.nyholm@gmail.com>
     */
    final class PuliUnavailableException extends \Http\Discovery\Exception\StrategyUnavailableException
    {
    }
}
namespace Http\Discovery {
    /**
     * Finds an HTTP Asynchronous Client.
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     */
    final class HttpAsyncClientDiscovery extends \Http\Discovery\ClassDiscovery
    {
        /**
         * Finds an HTTP Async Client.
         *
         * @return HttpAsyncClient
         *
         * @throws Exception\NotFoundException
         */
        public static function find()
        {
        }
    }
    /**
     * Finds an HTTP Client.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     *
     * @deprecated This will be removed in 2.0. Consider using Psr18ClientDiscovery.
     */
    final class HttpClientDiscovery extends \Http\Discovery\ClassDiscovery
    {
        /**
         * Finds an HTTP Client.
         *
         * @return HttpClient
         *
         * @throws Exception\NotFoundException
         */
        public static function find()
        {
        }
    }
    /**
     * Finds a Message Factory.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     *
     * @deprecated This will be removed in 2.0. Consider using Psr17FactoryDiscovery.
     */
    final class MessageFactoryDiscovery extends \Http\Discovery\ClassDiscovery
    {
        /**
         * Finds a Message Factory.
         *
         * @return MessageFactory
         *
         * @throws Exception\NotFoundException
         */
        public static function find()
        {
        }
    }
    /**
     * Thrown when a discovery does not find any matches.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     *
     * @deprecated since since version 1.0, and will be removed in 2.0. Use {@link \Http\Discovery\Exception\NotFoundException} instead.
     */
    final class NotFoundException extends \Http\Discovery\Exception\NotFoundException
    {
    }
    /**
     * A generic PSR-17 implementation.
     *
     * You can create this class with concrete factory instances or let
     * it use discovery to find suitable implementations as needed.
     *
     * This class also provides two additional methods that are not in PSR17,
     * to help with creating PSR-7 objects from PHP superglobals:
     *  - createServerRequestFromGlobals()
     *  - createUriFromGlobals()
     *
     * The code in this class is inspired by the "nyholm/psr7", "guzzlehttp/psr7"
     * and "symfony/http-foundation" packages, all licenced under MIT.
     *
     * Copyright (c) 2004-2023 Fabien Potencier <fabien@symfony.com>
     * Copyright (c) 2015 Michael Dowling <mtdowling@gmail.com>
     * Copyright (c) 2015 Márk Sági-Kazár <mark.sagikazar@gmail.com>
     * Copyright (c) 2015 Graham Campbell <hello@gjcampbell.co.uk>
     * Copyright (c) 2016 Tobias Schultze <webmaster@tubo-world.de>
     * Copyright (c) 2016 George Mponos <gmponos@gmail.com>
     * Copyright (c) 2016-2018 Tobias Nyholm <tobias.nyholm@gmail.com>
     *
     * @author Nicolas Grekas <p@tchwork.com>
     */
    class Psr17Factory implements \Psr\Http\Message\RequestFactoryInterface, \Psr\Http\Message\ResponseFactoryInterface, \Psr\Http\Message\ServerRequestFactoryInterface, \Psr\Http\Message\StreamFactoryInterface, \Psr\Http\Message\UploadedFileFactoryInterface, \Psr\Http\Message\UriFactoryInterface
    {
        public function __construct(?\Psr\Http\Message\RequestFactoryInterface $requestFactory = null, ?\Psr\Http\Message\ResponseFactoryInterface $responseFactory = null, ?\Psr\Http\Message\ServerRequestFactoryInterface $serverRequestFactory = null, ?\Psr\Http\Message\StreamFactoryInterface $streamFactory = null, ?\Psr\Http\Message\UploadedFileFactoryInterface $uploadedFileFactory = null, ?\Psr\Http\Message\UriFactoryInterface $uriFactory = null)
        {
        }
        /**
         * @param UriInterface|string $uri
         */
        public function createRequest(string $method, $uri): \Psr\Http\Message\RequestInterface
        {
        }
        public function createResponse(int $code = 200, string $reasonPhrase = ''): \Psr\Http\Message\ResponseInterface
        {
        }
        /**
         * @param UriInterface|string $uri
         */
        public function createServerRequest(string $method, $uri, array $serverParams = []): \Psr\Http\Message\ServerRequestInterface
        {
        }
        public function createServerRequestFromGlobals(?array $server = null, ?array $get = null, ?array $post = null, ?array $cookie = null, ?array $files = null, ?\Psr\Http\Message\StreamInterface $body = null): \Psr\Http\Message\ServerRequestInterface
        {
        }
        public function createStream(string $content = ''): \Psr\Http\Message\StreamInterface
        {
        }
        public function createStreamFromFile(string $filename, string $mode = 'r'): \Psr\Http\Message\StreamInterface
        {
        }
        /**
         * @param resource $resource
         */
        public function createStreamFromResource($resource): \Psr\Http\Message\StreamInterface
        {
        }
        public function createUploadedFile(\Psr\Http\Message\StreamInterface $stream, ?int $size = null, int $error = \UPLOAD_ERR_OK, ?string $clientFilename = null, ?string $clientMediaType = null): \Psr\Http\Message\UploadedFileInterface
        {
        }
        public function createUri(string $uri = ''): \Psr\Http\Message\UriInterface
        {
        }
        public function createUriFromGlobals(?array $server = null): \Psr\Http\Message\UriInterface
        {
        }
    }
    /**
     * Finds PSR-17 factories.
     *
     * @author Tobias Nyholm <tobias.nyholm@gmail.com>
     */
    final class Psr17FactoryDiscovery extends \Http\Discovery\ClassDiscovery
    {
        /**
         * @return RequestFactoryInterface
         *
         * @throws RealNotFoundException
         */
        public static function findRequestFactory()
        {
        }
        /**
         * @return ResponseFactoryInterface
         *
         * @throws RealNotFoundException
         */
        public static function findResponseFactory()
        {
        }
        /**
         * @return ServerRequestFactoryInterface
         *
         * @throws RealNotFoundException
         */
        public static function findServerRequestFactory()
        {
        }
        /**
         * @return StreamFactoryInterface
         *
         * @throws RealNotFoundException
         */
        public static function findStreamFactory()
        {
        }
        /**
         * @return UploadedFileFactoryInterface
         *
         * @throws RealNotFoundException
         */
        public static function findUploadedFileFactory()
        {
        }
        /**
         * @return UriFactoryInterface
         *
         * @throws RealNotFoundException
         */
        public static function findUriFactory()
        {
        }
        /**
         * @return UriFactoryInterface
         *
         * @throws RealNotFoundException
         *
         * @deprecated This will be removed in 2.0. Consider using the findUriFactory() method.
         */
        public static function findUrlFactory()
        {
        }
    }
    /**
     * A generic PSR-18 and PSR-17 implementation.
     *
     * You can create this class with concrete client and factory instances
     * or let it use discovery to find suitable implementations as needed.
     *
     * @author Nicolas Grekas <p@tchwork.com>
     */
    class Psr18Client extends \Http\Discovery\Psr17Factory implements \Psr\Http\Client\ClientInterface
    {
        public function __construct(?\Psr\Http\Client\ClientInterface $client = null, ?\Psr\Http\Message\RequestFactoryInterface $requestFactory = null, ?\Psr\Http\Message\ResponseFactoryInterface $responseFactory = null, ?\Psr\Http\Message\ServerRequestFactoryInterface $serverRequestFactory = null, ?\Psr\Http\Message\StreamFactoryInterface $streamFactory = null, ?\Psr\Http\Message\UploadedFileFactoryInterface $uploadedFileFactory = null, ?\Psr\Http\Message\UriFactoryInterface $uriFactory = null)
        {
        }
        public function sendRequest(\Psr\Http\Message\RequestInterface $request): \Psr\Http\Message\ResponseInterface
        {
        }
    }
    /**
     * Finds a PSR-18 HTTP Client.
     *
     * @author Tobias Nyholm <tobias.nyholm@gmail.com>
     */
    final class Psr18ClientDiscovery extends \Http\Discovery\ClassDiscovery
    {
        /**
         * Finds a PSR-18 HTTP Client.
         *
         * @return ClientInterface
         *
         * @throws RealNotFoundException
         */
        public static function find()
        {
        }
    }
}
namespace Http\Discovery\Strategy {
    /**
     * @author Tobias Nyholm <tobias.nyholm@gmail.com>
     */
    interface DiscoveryStrategy
    {
        /**
         * Find a resource of a specific type.
         *
         * @param string $type
         *
         * @return array The return value is always an array with zero or more elements. Each
         *               element is an array with two keys ['class' => string, 'condition' => mixed].
         *
         * @throws StrategyUnavailableException if we cannot use this strategy
         */
        public static function getCandidates($type);
    }
    /**
     * @internal
     *
     * @author Tobias Nyholm <tobias.nyholm@gmail.com>
     *
     * Don't miss updating src/Composer/Plugin.php when adding a new supported class.
     */
    final class CommonClassesStrategy implements \Http\Discovery\Strategy\DiscoveryStrategy
    {
        public static function getCandidates($type)
        {
        }
        public static function buzzInstantiate()
        {
        }
        public static function symfonyPsr18Instantiate()
        {
        }
        public static function isGuzzleImplementingPsr18()
        {
        }
        public static function isSymfonyImplementingHttpClient()
        {
        }
        /**
         * Can be used as a condition.
         *
         * @return bool
         */
        public static function isPsr17FactoryInstalled()
        {
        }
    }
    /**
     * @internal
     *
     * @author Tobias Nyholm <tobias.nyholm@gmail.com>
     *
     * Don't miss updating src/Composer/Plugin.php when adding a new supported class.
     */
    final class CommonPsr17ClassesStrategy implements \Http\Discovery\Strategy\DiscoveryStrategy
    {
        public static function getCandidates($type)
        {
        }
    }
    /**
     * Find the Mock client.
     *
     * @author Sam Rapaport <me@samrapdev.com>
     */
    final class MockClientStrategy implements \Http\Discovery\Strategy\DiscoveryStrategy
    {
        public static function getCandidates($type)
        {
        }
    }
    /**
     * Find candidates using Puli.
     *
     * @internal
     *
     * @final
     *
     * @author David de Boer <david@ddeboer.nl>
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    class PuliBetaStrategy implements \Http\Discovery\Strategy\DiscoveryStrategy
    {
        /**
         * @var GeneratedPuliFactory
         */
        protected static $puliFactory;
        /**
         * @var Discovery
         */
        protected static $puliDiscovery;
        public static function getCandidates($type)
        {
        }
    }
}
namespace Http\Discovery {
    /**
     * Finds a Stream Factory.
     *
     * @author Михаил Красильников <m.krasilnikov@yandex.ru>
     *
     * @deprecated This will be removed in 2.0. Consider using Psr17FactoryDiscovery.
     */
    final class StreamFactoryDiscovery extends \Http\Discovery\ClassDiscovery
    {
        /**
         * Finds a Stream Factory.
         *
         * @return StreamFactory
         *
         * @throws Exception\NotFoundException
         */
        public static function find()
        {
        }
    }
    /**
     * Finds a URI Factory.
     *
     * @author David de Boer <david@ddeboer.nl>
     *
     * @deprecated This will be removed in 2.0. Consider using Psr17FactoryDiscovery.
     */
    final class UriFactoryDiscovery extends \Http\Discovery\ClassDiscovery
    {
        /**
         * Finds a URI Factory.
         *
         * @return UriFactory
         *
         * @throws Exception\NotFoundException
         */
        public static function find()
        {
        }
    }
}
namespace Http\Client {
    /**
     * {@inheritdoc}
     *
     * Provide the Httplug HttpClient interface for BC.
     * You should typehint Psr\Http\Client\ClientInterface in new code
     *
     * @deprecated since version 2.4, use Psr\Http\Client\ClientInterface instead; see https://www.php-fig.org/psr/psr-18/
     */
    interface HttpClient extends \Psr\Http\Client\ClientInterface
    {
    }
    /**
     * Sends a PSR-7 Request in an asynchronous way by returning a Promise.
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     */
    interface HttpAsyncClient
    {
        /**
         * Sends a PSR-7 request in an asynchronous way.
         *
         * Exceptions related to processing the request are available from the returned Promise.
         *
         * @return Promise resolves a PSR-7 Response or fails with an Http\Client\Exception
         *
         * @throws \Exception If processing the request is impossible (eg. bad configuration).
         */
        public function sendAsyncRequest(\Psr\Http\Message\RequestInterface $request);
    }
}
namespace Http\Adapter\Guzzle7 {
    /**
     * HTTP Adapter for Guzzle 7.
     *
     * @author Tobias Nyholm <tobias.nyholm@gmail.com>
     */
    final class Client implements \Http\Client\HttpClient, \Http\Client\HttpAsyncClient
    {
        public function __construct(?\GuzzleHttp\ClientInterface $guzzle = null)
        {
        }
        /**
         * Factory method to create the Guzzle 7 adapter with custom Guzzle configuration.
         */
        public static function createWithConfig(array $config): \Http\Adapter\Guzzle7\Client
        {
        }
        public function sendRequest(\Psr\Http\Message\RequestInterface $request): \Psr\Http\Message\ResponseInterface
        {
        }
        public function sendAsyncRequest(\Psr\Http\Message\RequestInterface $request)
        {
        }
    }
}
namespace Http\Client {
    /**
     * Every HTTP Client related Exception must implement this interface.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    interface Exception extends \Psr\Http\Client\ClientExceptionInterface
    {
    }
}
namespace Http\Adapter\Guzzle7\Exception {
    final class UnexpectedValueException extends \UnexpectedValueException implements \Http\Client\Exception
    {
    }
}
namespace Http\Promise {
    /**
     * Promise represents a value that may not be available yet, but will be resolved at some point in future.
     * It acts like a proxy to the actual value.
     *
     * This interface is an extension of the promises/a+ specification.
     *
     * @see https://promisesaplus.com/
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    interface Promise
    {
        /**
         * Promise has not been fulfilled or rejected.
         */
        const PENDING = 'pending';
        /**
         * Promise has been fulfilled.
         */
        const FULFILLED = 'fulfilled';
        /**
         * Promise has been rejected.
         */
        const REJECTED = 'rejected';
        /**
         * Adds behavior for when the promise is resolved or rejected (response will be available, or error happens).
         *
         * If you do not care about one of the cases, you can set the corresponding callable to null
         * The callback will be called when the value arrived and never more than once.
         *
         * @param callable|null $onFulfilled called when a response will be available
         * @param callable|null $onRejected  called when an exception occurs
         *
         * @return Promise a new resolved promise with value of the executed callback (onFulfilled / onRejected)
         */
        public function then(?callable $onFulfilled = null, ?callable $onRejected = null);
        /**
         * Returns the state of the promise, one of PENDING, FULFILLED or REJECTED.
         *
         * @return string
         */
        public function getState();
        /**
         * Wait for the promise to be fulfilled or rejected.
         *
         * When this method returns, the request has been resolved and if callables have been
         * specified, the appropriate one has terminated.
         *
         * When $unwrap is true (the default), the response is returned, or the exception thrown
         * on failure. Otherwise, nothing is returned or thrown.
         *
         * @param bool $unwrap Whether to return resolved value / throw reason or not
         *
         * @return ($unwrap is true ? mixed : null) Resolved value, null if $unwrap is set to false
         *
         * @throws \Throwable the rejection reason if $unwrap is set to true and the request failed
         */
        public function wait($unwrap = true);
    }
}
namespace Http\Adapter\Guzzle7 {
    /**
     * Wrapper around Guzzle promises.
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     */
    final class Promise implements \Http\Promise\Promise
    {
        public function __construct(\GuzzleHttp\Promise\PromiseInterface $promise, \Psr\Http\Message\RequestInterface $request)
        {
        }
        public function then(?callable $onFulfilled = null, ?callable $onRejected = null)
        {
        }
        public function getState()
        {
        }
        public function wait($unwrap = true)
        {
        }
    }
}
namespace Http\Client\Exception {
    /**
     * Base exception for transfer related exceptions.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    class TransferException extends \RuntimeException implements \Http\Client\Exception
    {
    }
    trait RequestAwareTrait
    {
        /**
         * @var RequestInterface
         */
        private $request;
        private function setRequest(\Psr\Http\Message\RequestInterface $request)
        {
        }
        public function getRequest(): \Psr\Http\Message\RequestInterface
        {
        }
    }
    /**
     * Exception for when a request failed, providing access to the failed request.
     *
     * This could be due to an invalid request, or one of the extending exceptions
     * for network errors or HTTP error responses.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    class RequestException extends \Http\Client\Exception\TransferException implements \Psr\Http\Client\RequestExceptionInterface
    {
        use \Http\Client\Exception\RequestAwareTrait;
        /**
         * @param string $message
         */
        public function __construct($message, \Psr\Http\Message\RequestInterface $request, ?\Exception $previous = null)
        {
        }
    }
    /**
     * Thrown when a response was received but the request itself failed.
     *
     * In addition to the request, this exception always provides access to the response object.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    class HttpException extends \Http\Client\Exception\RequestException
    {
        /**
         * @var ResponseInterface
         */
        protected $response;
        /**
         * @param string $message
         */
        public function __construct($message, \Psr\Http\Message\RequestInterface $request, \Psr\Http\Message\ResponseInterface $response, ?\Exception $previous = null)
        {
        }
        /**
         * Returns the response.
         *
         * @return ResponseInterface
         */
        public function getResponse()
        {
        }
        /**
         * Factory method to create a new exception with a normalized error message.
         */
        public static function create(\Psr\Http\Message\RequestInterface $request, \Psr\Http\Message\ResponseInterface $response, ?\Exception $previous = null)
        {
        }
    }
    /**
     * Thrown when the request cannot be completed because of network issues.
     *
     * There is no response object as this exception is thrown when no response has been received.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    class NetworkException extends \Http\Client\Exception\TransferException implements \Psr\Http\Client\NetworkExceptionInterface
    {
        use \Http\Client\Exception\RequestAwareTrait;
        /**
         * @param string $message
         */
        public function __construct($message, \Psr\Http\Message\RequestInterface $request, ?\Exception $previous = null)
        {
        }
    }
}
namespace Http\Client\Promise {
    final class HttpFulfilledPromise implements \Http\Promise\Promise
    {
        public function __construct(\Psr\Http\Message\ResponseInterface $response)
        {
        }
        public function then(?callable $onFulfilled = null, ?callable $onRejected = null)
        {
        }
        public function getState()
        {
        }
        public function wait($unwrap = true)
        {
        }
    }
    final class HttpRejectedPromise implements \Http\Promise\Promise
    {
        public function __construct(\Http\Client\Exception $exception)
        {
        }
        public function then(?callable $onFulfilled = null, ?callable $onRejected = null)
        {
        }
        public function getState()
        {
        }
        public function wait($unwrap = true)
        {
        }
    }
}
namespace Http\Message {
    /**
     * Add authentication information to a PSR-7 Request.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    interface Authentication
    {
        /**
         * Alter the request to add the authentication credentials.
         *
         * To do that, the implementation might use pre-stored credentials or do
         * separate HTTP requests to obtain a valid token.
         *
         * @param RequestInterface $request The request without authentication information
         *
         * @return RequestInterface The request with added authentication information
         */
        public function authenticate(\Psr\Http\Message\RequestInterface $request);
    }
}
namespace Http\Message\Authentication {
    /**
     * Authenticate a PSR-7 Request using Basic Auth based on credentials in the URI.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class AutoBasicAuth implements \Http\Message\Authentication
    {
        /**
         * @param bool|true $shouldRremoveUserInfo
         */
        public function __construct($shouldRremoveUserInfo = true)
        {
        }
        public function authenticate(\Psr\Http\Message\RequestInterface $request)
        {
        }
    }
    /**
     * Authenticate a PSR-7 Request using Basic Auth.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class BasicAuth implements \Http\Message\Authentication
    {
        /**
         * @param string $username
         * @param string $password
         */
        public function __construct($username, $password)
        {
        }
        public function authenticate(\Psr\Http\Message\RequestInterface $request)
        {
        }
    }
    /**
     * Authenticate a PSR-7 Request using a token.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class Bearer implements \Http\Message\Authentication
    {
        /**
         * @param string $token
         */
        public function __construct($token)
        {
        }
        public function authenticate(\Psr\Http\Message\RequestInterface $request)
        {
        }
    }
    /**
     * Authenticate a PSR-7 Request with a multiple authentication methods.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class Chain implements \Http\Message\Authentication
    {
        /**
         * @param Authentication[] $authenticationChain
         */
        public function __construct(array $authenticationChain = [])
        {
        }
        public function authenticate(\Psr\Http\Message\RequestInterface $request)
        {
        }
    }
    class Header implements \Http\Message\Authentication
    {
        /**
         * @param string|string[] $value
         */
        public function __construct(string $name, $value)
        {
        }
        public function authenticate(\Psr\Http\Message\RequestInterface $request)
        {
        }
    }
    /**
     * Authenticate a PSR-7 Request if the request is matching.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     *
     * @deprecated since since version 1.2, and will be removed in 2.0. Use {@link RequestConditional} instead.
     */
    final class Matching implements \Http\Message\Authentication
    {
        public function __construct(\Http\Message\Authentication $authentication, ?callable $matcher = null)
        {
        }
        public function authenticate(\Psr\Http\Message\RequestInterface $request)
        {
        }
        /**
         * Creates a matching authentication for an URL.
         *
         * @param string $url
         *
         * @return self
         */
        public static function createUrlMatcher(\Http\Message\Authentication $authentication, $url)
        {
        }
    }
    /**
     * Authenticate a PSR-7 Request by adding parameters to its query.
     *
     * Note: Although in some cases it can be useful, we do not recommend using query parameters for authentication.
     * Credentials in the URL is generally unsafe as they are not encrypted, anyone can see them.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class QueryParam implements \Http\Message\Authentication
    {
        public function __construct(array $params)
        {
        }
        public function authenticate(\Psr\Http\Message\RequestInterface $request)
        {
        }
    }
    /**
     * Authenticate a PSR-7 Request if the request is matching the given request matcher.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class RequestConditional implements \Http\Message\Authentication
    {
        public function __construct(\Http\Message\RequestMatcher $requestMatcher, \Http\Message\Authentication $authentication)
        {
        }
        public function authenticate(\Psr\Http\Message\RequestInterface $request)
        {
        }
    }
    /**
     * Authenticate a PSR-7 Request using WSSE.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class Wsse implements \Http\Message\Authentication
    {
        /**
         * @param string $username
         * @param string $password
         * @param string $hashAlgorithm To use a better hashing algorithm than the weak sha1, pass the algorithm to use, e.g. "sha512"
         */
        public function __construct($username, $password, $hashAlgorithm = 'sha1')
        {
        }
        public function authenticate(\Psr\Http\Message\RequestInterface $request)
        {
        }
    }
}
namespace Http\Message\Builder {
    /**
     * Fills response object with values.
     */
    class ResponseBuilder
    {
        /**
         * The response to be built.
         *
         * @var ResponseInterface
         */
        protected $response;
        /**
         * Create builder for the given response.
         */
        public function __construct(\Psr\Http\Message\ResponseInterface $response)
        {
        }
        /**
         * Return response.
         *
         * @return ResponseInterface
         */
        public function getResponse()
        {
        }
        /**
         * Add headers represented by an array of header lines.
         *
         * @param string[] $headers response headers as array of header lines
         *
         * @return $this
         *
         * @throws \UnexpectedValueException for invalid header values
         * @throws \InvalidArgumentException for invalid status code arguments
         */
        public function setHeadersFromArray(array $headers)
        {
        }
        /**
         * Add headers represented by a single string.
         *
         * @param string $headers response headers as single string
         *
         * @return $this
         *
         * @throws \InvalidArgumentException if $headers is not a string on object with __toString()
         * @throws \UnexpectedValueException for invalid header values
         */
        public function setHeadersFromString($headers)
        {
        }
        /**
         * Set response status from a status string.
         *
         * @param string $statusLine response status as a string
         *
         * @return $this
         *
         * @throws \InvalidArgumentException for invalid status line
         */
        public function setStatus($statusLine)
        {
        }
        /**
         * Add header represented by a string.
         *
         * @param string $headerLine response header as a string
         *
         * @return $this
         *
         * @throws \InvalidArgumentException for invalid header names or values
         */
        public function addHeader($headerLine)
        {
        }
    }
}
namespace Http\Message {
    /**
     * Cookie Value Object.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     *
     * @see http://tools.ietf.org/search/rfc6265
     */
    final class Cookie
    {
        /**
         * @param string         $name
         * @param string|null    $value
         * @param int|null       $maxAge
         * @param string|null    $domain
         * @param string|null    $path
         * @param bool           $secure
         * @param bool           $httpOnly
         * @param \DateTime|null $expires  Expires attribute is HTTP 1.0 only and should be avoided.
         *
         * @throws \InvalidArgumentException if name, value or max age is not valid
         */
        public function __construct($name, $value = null, $maxAge = null, $domain = null, $path = null, $secure = false, $httpOnly = false, ?\DateTime $expires = null)
        {
        }
        /**
         * Creates a new cookie without any attribute validation.
         *
         * @param string         $name
         * @param string|null    $value
         * @param int            $maxAge
         * @param string|null    $domain
         * @param string|null    $path
         * @param bool           $secure
         * @param bool           $httpOnly
         * @param \DateTime|null $expires  Expires attribute is HTTP 1.0 only and should be avoided.
         */
        public static function createWithoutValidation($name, $value = null, $maxAge = null, $domain = null, $path = null, $secure = false, $httpOnly = false, ?\DateTime $expires = null)
        {
        }
        /**
         * Returns the name.
         *
         * @return string
         */
        public function getName()
        {
        }
        /**
         * Returns the value.
         *
         * @return string|null
         */
        public function getValue()
        {
        }
        /**
         * Checks if there is a value.
         *
         * @return bool
         */
        public function hasValue()
        {
        }
        /**
         * Sets the value.
         *
         * @param string|null $value
         *
         * @return Cookie
         */
        public function withValue($value)
        {
        }
        /**
         * Returns the max age.
         *
         * @return int|null
         */
        public function getMaxAge()
        {
        }
        /**
         * Checks if there is a max age.
         *
         * @return bool
         */
        public function hasMaxAge()
        {
        }
        /**
         * Sets the max age.
         *
         * @param int|null $maxAge
         *
         * @return Cookie
         */
        public function withMaxAge($maxAge)
        {
        }
        /**
         * Returns the expiration time.
         *
         * @return \DateTime|null
         */
        public function getExpires()
        {
        }
        /**
         * Checks if there is an expiration time.
         *
         * @return bool
         */
        public function hasExpires()
        {
        }
        /**
         * Sets the expires.
         *
         * @return Cookie
         */
        public function withExpires(?\DateTime $expires = null)
        {
        }
        /**
         * Checks if the cookie is expired.
         *
         * @return bool
         */
        public function isExpired()
        {
        }
        /**
         * Returns the domain.
         *
         * @return string|null
         */
        public function getDomain()
        {
        }
        /**
         * Checks if there is a domain.
         *
         * @return bool
         */
        public function hasDomain()
        {
        }
        /**
         * Sets the domain.
         *
         * @param string|null $domain
         *
         * @return Cookie
         */
        public function withDomain($domain)
        {
        }
        /**
         * Checks whether this cookie is meant for this domain.
         *
         * @see http://tools.ietf.org/html/rfc6265#section-5.1.3
         *
         * @param string $domain
         *
         * @return bool
         */
        public function matchDomain($domain)
        {
        }
        /**
         * Returns the path.
         *
         * @return string
         */
        public function getPath()
        {
        }
        /**
         * Sets the path.
         *
         * @param string|null $path
         *
         * @return Cookie
         */
        public function withPath($path)
        {
        }
        /**
         * Checks whether this cookie is meant for this path.
         *
         * @see http://tools.ietf.org/html/rfc6265#section-5.1.4
         *
         * @param string $path
         *
         * @return bool
         */
        public function matchPath($path)
        {
        }
        /**
         * Checks whether this cookie may only be sent over HTTPS.
         *
         * @return bool
         */
        public function isSecure()
        {
        }
        /**
         * Sets whether this cookie should only be sent over HTTPS.
         *
         * @param bool $secure
         *
         * @return Cookie
         */
        public function withSecure($secure)
        {
        }
        /**
         * Check whether this cookie may not be accessed through Javascript.
         *
         * @return bool
         */
        public function isHttpOnly()
        {
        }
        /**
         * Sets whether this cookie may not be accessed through Javascript.
         *
         * @param bool $httpOnly
         *
         * @return Cookie
         */
        public function withHttpOnly($httpOnly)
        {
        }
        /**
         * Checks if this cookie represents the same cookie as $cookie.
         *
         * This does not compare the values, only name, domain and path.
         *
         * @return bool
         */
        public function match(self $cookie)
        {
        }
        /**
         * Validates cookie attributes.
         *
         * @return bool
         */
        public function isValid()
        {
        }
    }
    /**
     * Cookie Jar holds a set of Cookies.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class CookieJar implements \Countable, \IteratorAggregate
    {
        public function __construct()
        {
        }
        /**
         * Checks if there is a cookie.
         *
         * @return bool
         */
        public function hasCookie(\Http\Message\Cookie $cookie)
        {
        }
        /**
         * Adds a cookie.
         */
        public function addCookie(\Http\Message\Cookie $cookie)
        {
        }
        /**
         * Removes a cookie.
         */
        public function removeCookie(\Http\Message\Cookie $cookie)
        {
        }
        /**
         * Returns the cookies.
         *
         * @return Cookie[]
         */
        public function getCookies()
        {
        }
        /**
         * Returns all matching cookies.
         *
         * @return Cookie[]
         */
        public function getMatchingCookies(\Http\Message\Cookie $cookie)
        {
        }
        /**
         * Checks if there are cookies.
         *
         * @return bool
         */
        public function hasCookies()
        {
        }
        /**
         * Sets the cookies and removes any previous one.
         *
         * @param Cookie[] $cookies
         */
        public function setCookies(array $cookies)
        {
        }
        /**
         * Adds some cookies.
         *
         * @param Cookie[] $cookies
         */
        public function addCookies(array $cookies)
        {
        }
        /**
         * Removes some cookies.
         *
         * @param Cookie[] $cookies
         */
        public function removeCookies(array $cookies)
        {
        }
        /**
         * Removes cookies which match the given parameters.
         *
         * Null means that parameter should not be matched
         *
         * @param string|null $name
         * @param string|null $domain
         * @param string|null $path
         */
        public function removeMatchingCookies($name = null, $domain = null, $path = null)
        {
        }
        /**
         * Removes all cookies.
         */
        public function clear()
        {
        }
        #[\ReturnTypeWillChange]
        public function count()
        {
        }
        #[\ReturnTypeWillChange]
        public function getIterator()
        {
        }
    }
    final class CookieUtil
    {
        /**
         * @see https://github.com/symfony/symfony/blob/master/src/Symfony/Component/BrowserKit/Cookie.php
         *
         * @param string $dateValue
         *
         * @return \DateTime
         *
         * @throws UnexpectedValueException if we cannot parse the cookie date string
         */
        public static function parseDate($dateValue)
        {
        }
    }
}
namespace Http\Message\Decorator {
    /**
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    trait MessageDecorator
    {
        /**
         * @var MessageInterface
         */
        private $message;
        /**
         * Returns the decorated message.
         *
         * Since the underlying Message is immutable as well
         * exposing it is not an issue, because it's state cannot be altered
         */
        public function getMessage(): \Psr\Http\Message\MessageInterface
        {
        }
        public function getProtocolVersion(): string
        {
        }
        public function withProtocolVersion(string $version): \Psr\Http\Message\MessageInterface
        {
        }
        public function getHeaders(): array
        {
        }
        public function hasHeader(string $header): bool
        {
        }
        public function getHeader(string $header): array
        {
        }
        public function getHeaderLine(string $header): string
        {
        }
        public function withHeader(string $header, $value): \Psr\Http\Message\MessageInterface
        {
        }
        public function withAddedHeader(string $header, $value): \Psr\Http\Message\MessageInterface
        {
        }
        public function withoutHeader(string $header): \Psr\Http\Message\MessageInterface
        {
        }
        public function getBody(): \Psr\Http\Message\StreamInterface
        {
        }
        public function withBody(\Psr\Http\Message\StreamInterface $body): \Psr\Http\Message\MessageInterface
        {
        }
    }
    /**
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    trait RequestDecorator
    {
        use \Http\Message\Decorator\MessageDecorator {
            getMessage as getRequest;
        }
        /**
         * Exchanges the underlying request with another.
         */
        public function withRequest(\Psr\Http\Message\RequestInterface $request): \Psr\Http\Message\RequestInterface
        {
        }
        public function getRequestTarget(): string
        {
        }
        public function withRequestTarget(string $requestTarget): \Psr\Http\Message\RequestInterface
        {
        }
        public function getMethod(): string
        {
        }
        public function withMethod(string $method): \Psr\Http\Message\RequestInterface
        {
        }
        public function getUri(): \Psr\Http\Message\UriInterface
        {
        }
        public function withUri(\Psr\Http\Message\UriInterface $uri, bool $preserveHost = false): \Psr\Http\Message\RequestInterface
        {
        }
    }
    /**
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    trait ResponseDecorator
    {
        use \Http\Message\Decorator\MessageDecorator {
            getMessage as getResponse;
        }
        /**
         * Exchanges the underlying response with another.
         */
        public function withResponse(\Psr\Http\Message\ResponseInterface $response): \Psr\Http\Message\ResponseInterface
        {
        }
        public function getStatusCode(): int
        {
        }
        public function withStatus(int $code, string $reasonPhrase = ''): \Psr\Http\Message\ResponseInterface
        {
        }
        public function getReasonPhrase(): string
        {
        }
    }
    /**
     * Decorates a stream.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    trait StreamDecorator
    {
        /**
         * @var StreamInterface
         */
        protected $stream;
        public function __toString(): string
        {
        }
        public function close(): void
        {
        }
        public function detach()
        {
        }
        public function getSize(): ?int
        {
        }
        public function tell(): int
        {
        }
        public function eof(): bool
        {
        }
        public function isSeekable(): bool
        {
        }
        public function seek(int $offset, int $whence = SEEK_SET): void
        {
        }
        public function rewind(): void
        {
        }
        public function isWritable(): bool
        {
        }
        public function write(string $string): int
        {
        }
        public function isReadable(): bool
        {
        }
        public function read(int $length): string
        {
        }
        public function getContents(): string
        {
        }
        public function getMetadata(?string $key = null)
        {
        }
    }
}
namespace Http\Message\Encoding {
    /**
     * A filtered stream has a filter for filtering output and a filter for filtering input made to a underlying stream.
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     */
    abstract class FilteredStream implements \Psr\Http\Message\StreamInterface
    {
        use \Http\Message\Decorator\StreamDecorator {
            rewind as private doRewind;
            seek as private doSeek;
        }
        public const BUFFER_SIZE = 8192;
        /**
         * @var callable
         */
        protected $readFilterCallback;
        /**
         * @var resource
         *
         * @deprecated since version 1.5, will be removed in 2.0
         */
        protected $readFilter;
        /**
         * @var callable
         *
         * @deprecated since version 1.5, will be removed in 2.0
         */
        protected $writeFilterCallback;
        /**
         * @var resource
         *
         * @deprecated since version 1.5, will be removed in 2.0
         */
        protected $writeFilter;
        /**
         * Internal buffer.
         *
         * @var string
         */
        protected $buffer = '';
        /**
         * @param mixed|null $readFilterOptions
         * @param mixed|null $writeFilterOptions deprecated since 1.5, will be removed in 2.0
         */
        public function __construct(\Psr\Http\Message\StreamInterface $stream, $readFilterOptions = null, $writeFilterOptions = null)
        {
        }
        public function read(int $length): string
        {
        }
        public function eof(): bool
        {
        }
        /**
         * Buffer is filled by reading underlying stream.
         *
         * Callback is reading once more even if the stream is ended.
         * This allow to get last data in the PHP buffer otherwise this
         * bug is present : https://bugs.php.net/bug.php?id=48725
         */
        protected function fill(): void
        {
        }
        public function getContents(): string
        {
        }
        /**
         * Always returns null because we can't tell the size of a stream when we filter.
         */
        public function getSize(): ?int
        {
        }
        public function __toString(): string
        {
        }
        /**
         * Filtered streams are not seekable.
         *
         * We would need to buffer and process everything to allow seeking.
         */
        public function isSeekable(): bool
        {
        }
        /**
         * Filtered streams are not seekable and can thus not be rewound.
         */
        public function rewind(): void
        {
        }
        /**
         * Filtered streams are not seekable.
         */
        public function seek(int $offset, int $whence = SEEK_SET): void
        {
        }
        /**
         * Returns the read filter name.
         *
         * @deprecated since version 1.5, will be removed in 2.0
         */
        public function getReadFilter(): string
        {
        }
        /**
         * Returns the write filter name.
         */
        abstract protected function readFilter(): string;
        /**
         * Returns the write filter name.
         *
         * @deprecated since version 1.5, will be removed in 2.0
         */
        public function getWriteFilter(): string
        {
        }
        /**
         * Returns the write filter name.
         */
        abstract protected function writeFilter(): string;
    }
    /**
     * Transform a regular stream into a chunked one.
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     */
    class ChunkStream extends \Http\Message\Encoding\FilteredStream
    {
        protected function readFilter(): string
        {
        }
        protected function writeFilter(): string
        {
        }
        protected function fill(): void
        {
        }
    }
    /**
     * Stream compress (RFC 1950).
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     */
    class CompressStream extends \Http\Message\Encoding\FilteredStream
    {
        /**
         * @param int $level
         */
        public function __construct(\Psr\Http\Message\StreamInterface $stream, $level = -1)
        {
        }
        protected function readFilter(): string
        {
        }
        protected function writeFilter(): string
        {
        }
    }
    /**
     * Decorate a stream which is chunked.
     *
     * Allow to decode a chunked stream
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     */
    class DechunkStream extends \Http\Message\Encoding\FilteredStream
    {
        protected function readFilter(): string
        {
        }
        protected function writeFilter(): string
        {
        }
    }
    /**
     * Stream decompress (RFC 1950).
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     */
    class DecompressStream extends \Http\Message\Encoding\FilteredStream
    {
        /**
         * @param int $level
         */
        public function __construct(\Psr\Http\Message\StreamInterface $stream, $level = -1)
        {
        }
        protected function readFilter(): string
        {
        }
        protected function writeFilter(): string
        {
        }
    }
    /**
     * Stream deflate (RFC 1951).
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     */
    class DeflateStream extends \Http\Message\Encoding\FilteredStream
    {
        /**
         * @param int $level
         */
        public function __construct(\Psr\Http\Message\StreamInterface $stream, $level = -1)
        {
        }
        protected function readFilter(): string
        {
        }
        protected function writeFilter(): string
        {
        }
    }
}
namespace Http\Message\Encoding\Filter {
    /**
     * Userland implementation of the chunk stream filter.
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     */
    class Chunk extends \php_user_filter
    {
        public function filter($in, $out, &$consumed, $closing): int
        {
        }
    }
}
namespace Http\Message\Encoding {
    /**
     * Stream for decoding from gzip format (RFC 1952).
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     */
    class GzipDecodeStream extends \Http\Message\Encoding\FilteredStream
    {
        /**
         * @param int $level
         */
        public function __construct(\Psr\Http\Message\StreamInterface $stream, $level = -1)
        {
        }
        protected function readFilter(): string
        {
        }
        protected function writeFilter(): string
        {
        }
    }
    /**
     * Stream for encoding to gzip format (RFC 1952).
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     */
    class GzipEncodeStream extends \Http\Message\Encoding\FilteredStream
    {
        /**
         * @param int $level
         */
        public function __construct(\Psr\Http\Message\StreamInterface $stream, $level = -1)
        {
        }
        protected function readFilter(): string
        {
        }
        protected function writeFilter(): string
        {
        }
    }
    /**
     * Stream inflate (RFC 1951).
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     */
    class InflateStream extends \Http\Message\Encoding\FilteredStream
    {
        /**
         * @param int $level
         */
        public function __construct(\Psr\Http\Message\StreamInterface $stream, $level = -1)
        {
        }
        protected function readFilter(): string
        {
        }
        protected function writeFilter(): string
        {
        }
    }
}
namespace Http\Message {
    /**
     * An interface implemented by all HTTP message related exceptions.
     */
    interface Exception
    {
    }
}
namespace Http\Message\Exception {
    final class UnexpectedValueException extends \UnexpectedValueException implements \Http\Message\Exception
    {
    }
}
namespace Http\Message {
    /**
     * Formats a request and/or a response as a string.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     *
     * The formatResponseForRequest method will be added to this interface in the next major version, replacing the formatRequest method.
     * Meanwhile, callers SHOULD check the formatter for the existence of formatResponseForRequest and call that if available.
     *
     * @method string formatResponseForRequest(ResponseInterface $response, RequestInterface $request) Formats a response in context of its request.
     */
    interface Formatter
    {
        /**
         * Formats a request.
         *
         * @return string
         */
        public function formatRequest(\Psr\Http\Message\RequestInterface $request);
        /**
         * @deprecated since 1.13, use formatResponseForRequest() instead
         *
         * Formats a response.
         *
         * @return string
         */
        public function formatResponse(\Psr\Http\Message\ResponseInterface $response);
    }
}
namespace Http\Message\Formatter {
    /**
     * A formatter that prints a cURL command for HTTP requests.
     *
     * @author Tobias Nyholm <tobias.nyholm@gmail.com>
     */
    class CurlCommandFormatter implements \Http\Message\Formatter
    {
        public function formatRequest(\Psr\Http\Message\RequestInterface $request)
        {
        }
        public function formatResponse(\Psr\Http\Message\ResponseInterface $response)
        {
        }
        /**
         * Formats a response in context of its request.
         *
         * @return string
         */
        public function formatResponseForRequest(\Psr\Http\Message\ResponseInterface $response, \Psr\Http\Message\RequestInterface $request)
        {
        }
    }
    /**
     * A formatter that prints the complete HTTP message.
     *
     * @author Tobias Nyholm <tobias.nyholm@gmail.com>
     */
    class FullHttpMessageFormatter implements \Http\Message\Formatter
    {
        /**
         * @param int|null $maxBodyLength
         * @param string   $binaryDetectionRegex By default, this is all non-printable ASCII characters and <DEL> except for \t, \r, \n
         */
        public function __construct($maxBodyLength = 1000, string $binaryDetectionRegex = '/([\x00-\x09\x0C\x0E-\x1F\x7F])/')
        {
        }
        public function formatRequest(\Psr\Http\Message\RequestInterface $request)
        {
        }
        public function formatResponse(\Psr\Http\Message\ResponseInterface $response)
        {
        }
        /**
         * Formats a response in context of its request.
         *
         * @return string
         */
        public function formatResponseForRequest(\Psr\Http\Message\ResponseInterface $response, \Psr\Http\Message\RequestInterface $request)
        {
        }
    }
    /**
     * Normalize a request or a response into a string or an array.
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    class SimpleFormatter implements \Http\Message\Formatter
    {
        public function formatRequest(\Psr\Http\Message\RequestInterface $request)
        {
        }
        public function formatResponse(\Psr\Http\Message\ResponseInterface $response)
        {
        }
        /**
         * Formats a response in context of its request.
         *
         * @return string
         */
        public function formatResponseForRequest(\Psr\Http\Message\ResponseInterface $response, \Psr\Http\Message\RequestInterface $request)
        {
        }
    }
}
namespace Http\Message {
    /**
     * Factory for PSR-7 Request.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     *
     * @deprecated since version 1.1, use Psr\Http\Message\RequestFactoryInterface instead.
     */
    interface RequestFactory
    {
        /**
         * Creates a new PSR-7 request.
         *
         * @param string                               $method
         * @param string|UriInterface                  $uri
         * @param array                                $headers
         * @param resource|string|StreamInterface|null $body
         * @param string                               $protocolVersion
         *
         * @return RequestInterface
         */
        public function createRequest($method, $uri, array $headers = [], $body = null, $protocolVersion = '1.1');
    }
    /**
     * Factory for PSR-7 Response.
     *
     * This factory contract can be reused in Message and Server Message factories.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     *
     * @deprecated since version 1.1, use Psr\Http\Message\ResponseFactoryInterface instead.
     */
    interface ResponseFactory
    {
        /**
         * Creates a new PSR-7 response.
         *
         * @param int                                  $statusCode
         * @param string|null                          $reasonPhrase
         * @param array                                $headers
         * @param resource|string|StreamInterface|null $body
         * @param string                               $protocolVersion
         *
         * @return ResponseInterface
         */
        public function createResponse($statusCode = 200, $reasonPhrase = null, array $headers = [], $body = null, $protocolVersion = '1.1');
    }
    /**
     * Factory for PSR-7 Request and Response.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     *
     * @deprecated since version 1.1, use Psr\Http\Message\RequestFactoryInterface and Psr\Http\Message\ResponseFactoryInterface instead.
     */
    interface MessageFactory extends \Http\Message\RequestFactory, \Http\Message\ResponseFactory
    {
    }
}
namespace Http\Message\MessageFactory {
    /**
     * Creates Diactoros messages.
     *
     * @author GeLo <geloen.eric@gmail.com>
     *
     * @deprecated This will be removed in php-http/message2.0. Consider using the official Diactoros PSR-17 factory
     */
    final class DiactorosMessageFactory implements \Http\Message\MessageFactory
    {
        public function __construct()
        {
        }
        public function createRequest($method, $uri, array $headers = [], $body = null, $protocolVersion = '1.1')
        {
        }
        public function createResponse($statusCode = 200, $reasonPhrase = null, array $headers = [], $body = null, $protocolVersion = '1.1')
        {
        }
    }
    /**
     * Creates Guzzle messages.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     *
     * @deprecated This will be removed in php-http/message2.0. Consider using the official Guzzle PSR-17 factory
     */
    final class GuzzleMessageFactory implements \Http\Message\MessageFactory
    {
        public function createRequest($method, $uri, array $headers = [], $body = null, $protocolVersion = '1.1')
        {
        }
        public function createResponse($statusCode = 200, $reasonPhrase = null, array $headers = [], $body = null, $protocolVersion = '1.1')
        {
        }
    }
    /**
     * Creates Slim 3 messages.
     *
     * @author Mika Tuupola <tuupola@appelsiini.net>
     *
     * @deprecated This will be removed in php-http/message2.0. Consider using the official Slim PSR-17 factory
     */
    final class SlimMessageFactory implements \Http\Message\MessageFactory
    {
        public function __construct()
        {
        }
        public function createRequest($method, $uri, array $headers = [], $body = null, $protocolVersion = '1.1')
        {
        }
        public function createResponse($statusCode = 200, $reasonPhrase = null, array $headers = [], $body = null, $protocolVersion = '1.1')
        {
        }
    }
}
namespace Http\Message {
    /**
     * Match a request.
     *
     * PSR-7 equivalent of Symfony's RequestMatcher
     *
     * @see https://github.com/symfony/symfony/blob/master/src/Symfony/Component/HttpFoundation/RequestMatcherInterface.php
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     */
    interface RequestMatcher
    {
        /**
         * Decides whether the rule(s) implemented by the strategy matches the supplied request.
         *
         * @param RequestInterface $request The PSR7 request to check for a match
         *
         * @return bool true if the request matches, false otherwise
         */
        public function matches(\Psr\Http\Message\RequestInterface $request);
    }
}
namespace Http\Message\RequestMatcher {
    /**
     * Match a request with a callback.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class CallbackRequestMatcher implements \Http\Message\RequestMatcher
    {
        public function __construct(callable $callback)
        {
        }
        public function matches(\Psr\Http\Message\RequestInterface $request)
        {
        }
    }
    /**
     * Match a request with a regex on the uri.
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     *
     * @deprecated since version 1.2 and will be removed in 2.0. Use {@link RequestMatcher} instead.
     */
    final class RegexRequestMatcher implements \Http\Message\RequestMatcher
    {
        /**
         * @param string $regex
         */
        public function __construct($regex)
        {
        }
        public function matches(\Psr\Http\Message\RequestInterface $request)
        {
        }
    }
    /**
     * A port of the Symfony RequestMatcher for PSR-7.
     *
     * @author Fabien Potencier <fabien@symfony.com>
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     */
    final class RequestMatcher implements \Http\Message\RequestMatcher
    {
        /**
         * The regular expressions used for path or host must be specified without delimiter.
         * You do not need to escape the forward slash / to match it.
         *
         * @param string|null          $path    Regular expression for the path
         * @param string|null          $host    Regular expression for the hostname
         * @param string|string[]|null $methods Method or list of methods to match
         * @param string|string[]|null $schemes Scheme or list of schemes to match (e.g. http or https)
         */
        public function __construct($path = null, $host = null, $methods = [], $schemes = [])
        {
        }
        /**
         * @api
         */
        public function matches(\Psr\Http\Message\RequestInterface $request)
        {
        }
    }
}
namespace Http\Message\Stream {
    /**
     * Decorator to make any stream seekable.
     *
     * Internally it buffers an existing StreamInterface into a php://temp resource (or memory). By default it will use
     * 2 megabytes of memory before writing to a temporary disk file.
     *
     * Due to this, very large stream can suffer performance issue (i/o slowdown).
     */
    class BufferedStream implements \Psr\Http\Message\StreamInterface
    {
        /**
         * @param StreamInterface $stream        Decorated stream
         * @param bool            $useFileBuffer Whether to use a file buffer (write to a file, if data exceed a certain size)
         *                                       by default, set this to false to only use memory
         * @param int             $memoryBuffer  In conjunction with using file buffer, limit (in bytes) from which it begins to buffer
         *                                       the data in a file
         */
        public function __construct(\Psr\Http\Message\StreamInterface $stream, $useFileBuffer = true, $memoryBuffer = 2097152)
        {
        }
        public function __toString(): string
        {
        }
        public function close(): void
        {
        }
        public function detach()
        {
        }
        public function getSize(): ?int
        {
        }
        public function tell(): int
        {
        }
        public function eof(): bool
        {
        }
        public function isSeekable(): bool
        {
        }
        public function seek(int $offset, int $whence = SEEK_SET): void
        {
        }
        public function rewind(): void
        {
        }
        public function isWritable(): bool
        {
        }
        public function write(string $string): int
        {
        }
        public function isReadable(): bool
        {
        }
        public function read(int $length): string
        {
        }
        public function getContents(): string
        {
        }
        public function getMetadata(?string $key = null)
        {
        }
    }
}
namespace Http\Message {
    /**
     * Factory for PSR-7 Stream.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     *
     * @deprecated since version 1.1, use Psr\Http\Message\StreamFactoryInterface instead.
     */
    interface StreamFactory
    {
        /**
         * Creates a new PSR-7 stream.
         *
         * @param string|resource|StreamInterface|null $body
         *
         * @return StreamInterface
         *
         * @throws \InvalidArgumentException if the stream body is invalid
         * @throws \RuntimeException         if creating the stream from $body fails
         */
        public function createStream($body = null);
    }
}
namespace Http\Message\StreamFactory {
    /**
     * Creates Diactoros streams.
     *
     * @author Михаил Красильников <m.krasilnikov@yandex.ru>
     *
     * @deprecated This will be removed in php-http/message2.0. Consider using the official Diactoros PSR-17 factory
     */
    final class DiactorosStreamFactory implements \Http\Message\StreamFactory
    {
        public function createStream($body = null)
        {
        }
    }
    /**
     * Creates Guzzle streams.
     *
     * @author Михаил Красильников <m.krasilnikov@yandex.ru>
     *
     * @deprecated This will be removed in php-http/message2.0. Consider using the official Guzzle PSR-17 factory
     */
    final class GuzzleStreamFactory implements \Http\Message\StreamFactory
    {
        public function createStream($body = null)
        {
        }
    }
    /**
     * Creates Slim 3 streams.
     *
     * @author Mika Tuupola <tuupola@appelsiini.net>
     *
     * @deprecated This will be removed in php-http/message2.0. Consider using the official Slim PSR-17 factory
     */
    final class SlimStreamFactory implements \Http\Message\StreamFactory
    {
        public function createStream($body = null)
        {
        }
    }
}
namespace Http\Message {
    /**
     * Factory for PSR-7 URI.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     *
     * @deprecated since version 1.1, use Psr\Http\Message\UriFactoryInterface instead.
     */
    interface UriFactory
    {
        /**
         * Creates an PSR-7 URI.
         *
         * @param string|UriInterface $uri
         *
         * @return UriInterface
         *
         * @throws \InvalidArgumentException if the $uri argument can not be converted into a valid URI
         */
        public function createUri($uri);
    }
}
namespace Http\Message\UriFactory {
    /**
     * Creates Diactoros URI.
     *
     * @author David de Boer <david@ddeboer.nl>
     *
     * @deprecated This will be removed in php-http/message2.0. Consider using the official Diactoros PSR-17 factory
     */
    final class DiactorosUriFactory implements \Http\Message\UriFactory
    {
        public function createUri($uri)
        {
        }
    }
    /**
     * Creates Guzzle URI.
     *
     * @author David de Boer <david@ddeboer.nl>
     *
     * @deprecated This will be removed in php-http/message2.0. Consider using the official Guzzle PSR-17 factory
     */
    final class GuzzleUriFactory implements \Http\Message\UriFactory
    {
        public function createUri($uri)
        {
        }
    }
    /**
     * Creates Slim 3 URI.
     *
     * @author Mika Tuupola <tuupola@appelsiini.net>
     *
     * @deprecated This will be removed in php-http/message2.0. Consider using the official Slim PSR-17 factory
     */
    final class SlimUriFactory implements \Http\Message\UriFactory
    {
        public function createUri($uri)
        {
        }
    }
}
namespace Http\Promise {
    /**
     * A promise already fulfilled.
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     */
    final class FulfilledPromise implements \Http\Promise\Promise
    {
        /**
         * @param mixed $result
         */
        public function __construct($result)
        {
        }
        public function then(?callable $onFulfilled = null, ?callable $onRejected = null)
        {
        }
        public function getState()
        {
        }
        public function wait($unwrap = true)
        {
        }
    }
    /**
     * A rejected promise.
     *
     * @author Joel Wurtz <joel.wurtz@gmail.com>
     */
    final class RejectedPromise implements \Http\Promise\Promise
    {
        public function __construct(\Throwable $exception)
        {
        }
        public function then(?callable $onFulfilled = null, ?callable $onRejected = null)
        {
        }
        public function getState()
        {
        }
        public function wait($unwrap = true)
        {
        }
    }
}
namespace phpDocumentor\Reflection {
    /**
     * Interface for Api Elements
     */
    interface Element
    {
        /**
         * Returns the Fqsen of the element.
         */
        public function getFqsen(): \phpDocumentor\Reflection\Fqsen;
        /**
         * Returns the name of the element.
         */
        public function getName(): string;
    }
    /**
     * Interface for files processed by the ProjectFactory
     */
    interface File
    {
        /**
         * Returns the content of the file as a string.
         */
        public function getContents(): string;
        /**
         * Returns md5 hash of the file.
         */
        public function md5(): string;
        /**
         * Returns an relative path to the file.
         */
        public function path(): string;
    }
    /**
     * Value Object for Fqsen.
     *
     * @link https://github.com/phpDocumentor/fig-standards/blob/master/proposed/phpdoc-meta.md
     *
     * @psalm-immutable
     */
    final class Fqsen
    {
        /**
         * Initializes the object.
         *
         * @throws InvalidArgumentException when $fqsen is not matching the format.
         */
        public function __construct(string $fqsen)
        {
        }
        /**
         * converts this class to string.
         */
        public function __toString(): string
        {
        }
        /**
         * Returns the name of the element without path.
         */
        public function getName(): string
        {
        }
    }
    /**
     * The location where an element occurs within a file.
     *
     * @psalm-immutable
     */
    final class Location
    {
        /**
         * Initializes the location for an element using its line number in the file and optionally the column number.
         */
        public function __construct(int $lineNumber, int $columnNumber = 0)
        {
        }
        /**
         * Returns the line number that is covered by this location.
         */
        public function getLineNumber(): int
        {
        }
        /**
         * Returns the column number (character position on a line) for this location object.
         */
        public function getColumnNumber(): int
        {
        }
    }
    /**
     * Interface for project. Since the definition of a project can be different per factory this interface will be small.
     */
    interface Project
    {
        /**
         * Returns the name of the project.
         */
        public function getName(): string;
    }
    /**
     * Interface for project factories. A project factory shall convert a set of files
     * into an object implementing the Project interface.
     */
    interface ProjectFactory
    {
        /**
         * Creates a project from the set of files.
         *
         * @param File[] $files
         */
        public function create(string $name, array $files): \phpDocumentor\Reflection\Project;
    }
}
namespace phpDocumentor\Reflection\DocBlock {
    /**
     * Object representing to description for a DocBlock.
     *
     * A Description object can consist of plain text but can also include tags. A Description Formatter can then combine
     * a body template with sprintf-style placeholders together with formatted tags in order to reconstitute a complete
     * description text using the format that you would prefer.
     *
     * Because parsing a Description text can be a verbose process this is handled by the {@see DescriptionFactory}. It is
     * thus recommended to use that to create a Description object, like this:
     *
     *     $description = $descriptionFactory->create('This is a {@see Description}', $context);
     *
     * The description factory will interpret the given body and create a body template and list of tags from them, and pass
     * that onto the constructor if this class.
     *
     * > The $context variable is a class of type {@see \phpDocumentor\Reflection\Types\Context} and contains the namespace
     * > and the namespace aliases that apply to this DocBlock. These are used by the Factory to resolve and expand partial
     * > type names and FQSENs.
     *
     * If you do not want to use the DescriptionFactory you can pass a body template and tag listing like this:
     *
     *     $description = new Description(
     *         'This is a %1$s',
     *         [ new See(new Fqsen('\phpDocumentor\Reflection\DocBlock\Description')) ]
     *     );
     *
     * It is generally recommended to use the Factory as that will also apply escaping rules, while the Description object
     * is mainly responsible for rendering.
     *
     * @see DescriptionFactory to create a new Description.
     * @see Tags\Formatter for the formatting of the body and tags.
     */
    class Description
    {
        /**
         * Initializes a Description with its body (template) and a listing of the tags used in the body template.
         *
         * @param Tag[] $tags
         */
        public function __construct(string $bodyTemplate, array $tags = [])
        {
        }
        /**
         * Returns the body template.
         */
        public function getBodyTemplate(): string
        {
        }
        /**
         * Returns the tags for this DocBlock.
         *
         * @return Tag[]
         */
        public function getTags(): array
        {
        }
        /**
         * Renders this description as a string where the provided formatter will format the tags in the expected string
         * format.
         */
        public function render(?\phpDocumentor\Reflection\DocBlock\Tags\Formatter $formatter = null): string
        {
        }
        /**
         * Returns a plain string representation of this description.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Creates a new Description object given a body of text.
     *
     * Descriptions in phpDocumentor are somewhat complex entities as they can contain one or more tags inside their
     * body that can be replaced with a readable output. The replacing is done by passing a Formatter object to the
     * Description object's `render` method.
     *
     * In addition to the above does a Description support two types of escape sequences:
     *
     * 1. `{@}` to escape the `@` character to prevent it from being interpreted as part of a tag, i.e. `{{@}link}`
     * 2. `{}` to escape the `}` character, this can be used if you want to use the `}` character in the description
     *    of an inline tag.
     *
     * If a body consists of multiple lines then this factory will also remove any superfluous whitespace at the beginning
     * of each line while maintaining any indentation that is used. This will prevent formatting parsers from tripping
     * over unexpected spaces as can be observed with tag descriptions.
     */
    class DescriptionFactory
    {
        /**
         * Initializes this factory with the means to construct (inline) tags.
         */
        public function __construct(\phpDocumentor\Reflection\DocBlock\Tags\Factory\Factory $tagFactory)
        {
        }
        /**
         * Returns the parsed text of this description.
         */
        public function create(string $contents, ?\phpDocumentor\Reflection\Types\Context $context = null): \phpDocumentor\Reflection\DocBlock\Description
        {
        }
    }
    /**
     * Class used to find an example file's location based on a given ExampleDescriptor.
     */
    class ExampleFinder
    {
        /**
         * Attempts to find the example contents for the given descriptor.
         */
        public function find(\phpDocumentor\Reflection\DocBlock\Tags\Example $example): string
        {
        }
        /**
         * Registers the project's root directory where an 'examples' folder can be expected.
         */
        public function setSourceDirectory(string $directory = ''): void
        {
        }
        /**
         * Returns the project's root directory where an 'examples' folder can be expected.
         */
        public function getSourceDirectory(): string
        {
        }
        /**
         * Registers a series of directories that may contain examples.
         *
         * @param string[] $directories
         */
        public function setExampleDirectories(array $directories): void
        {
        }
        /**
         * Returns a series of directories that may contain examples.
         *
         * @return string[]
         */
        public function getExampleDirectories(): array
        {
        }
    }
    /**
     * Converts a DocBlock back from an object to a complete DocComment including Asterisks.
     */
    class Serializer
    {
        /** @var string The string to indent the comment with. */
        protected string $indentString = ' ';
        /** @var int The number of times the indent string is repeated. */
        protected int $indent = 0;
        /** @var bool Whether to indent the first line with the given indent amount and string. */
        protected bool $isFirstLineIndented = true;
        /** @var int|null The max length of a line. */
        protected ?int $lineLength = null;
        /** @var Formatter A custom tag formatter. */
        protected \phpDocumentor\Reflection\DocBlock\Tags\Formatter $tagFormatter;
        /**
         * Create a Serializer instance.
         *
         * @param int       $indent          The number of times the indent string is repeated.
         * @param string    $indentString    The string to indent the comment with.
         * @param bool      $indentFirstLine Whether to indent the first line.
         * @param int|null  $lineLength      The max length of a line or NULL to disable line wrapping.
         * @param Formatter $tagFormatter    A custom tag formatter, defaults to PassthroughFormatter.
         * @param string    $lineEnding      Line ending used in the output, by default \n is used.
         */
        public function __construct(int $indent = 0, string $indentString = ' ', bool $indentFirstLine = true, ?int $lineLength = null, ?\phpDocumentor\Reflection\DocBlock\Tags\Formatter $tagFormatter = null, string $lineEnding = "\n")
        {
        }
        /**
         * Generate a DocBlock comment.
         *
         * @param DocBlock $docblock The DocBlock to serialize.
         *
         * @return string The serialized doc block.
         */
        public function getDocComment(\phpDocumentor\Reflection\DocBlock $docblock): string
        {
        }
    }
}
namespace phpDocumentor\Reflection\DocBlock\Tags\Factory {
    interface Factory
    {
        /**
         * Factory method responsible for instantiating the correct sub type.
         *
         * @param string $tagLine The text for this tag, including description.
         *
         * @return Tag A new tag object.
         *
         * @throws InvalidArgumentException If an invalid tag line was presented.
         */
        public function create(string $tagLine, ?\phpDocumentor\Reflection\Types\Context $context = null): \phpDocumentor\Reflection\DocBlock\Tag;
    }
}
namespace phpDocumentor\Reflection\DocBlock {
    interface TagFactory extends \phpDocumentor\Reflection\DocBlock\Tags\Factory\Factory
    {
        /**
         * Adds a parameter to the service locator that can be injected in a tag's factory method.
         *
         * When calling a tag's "create" method we always check the signature for dependencies to inject. One way is to
         * typehint a parameter in the signature so that we can use that interface or class name to inject a dependency
         * (see {@see addService()} for more information on that).
         *
         * Another way is to check the name of the argument against the names in the Service Locator. With this method
         * you can add a variable that will be inserted when a tag's create method is not typehinted and has a matching
         * name.
         *
         * Be aware that there are two reserved names:
         *
         * - name, representing the name of the tag.
         * - body, representing the complete body of the tag.
         *
         * These parameters are injected at the last moment and will override any existing parameter with those names.
         *
         * @param mixed $value
         */
        public function addParameter(string $name, $value): void;
        /**
         * Registers a service with the Service Locator using the FQCN of the class or the alias, if provided.
         *
         * When calling a tag's "create" method we always check the signature for dependencies to inject. If a parameter
         * has a typehint then the ServiceLocator is queried to see if a Service is registered for that typehint.
         *
         * Because interfaces are regularly used as type-hints this method provides an alias parameter; if the FQCN of the
         * interface is passed as alias then every time that interface is requested the provided service will be returned.
         */
        public function addService(object $service): void;
        /**
         * Registers a handler for tags.
         *
         * If you want to use your own tags then you can use this method to instruct the TagFactory
         * to register the name of a tag with the FQCN of a 'Tag Handler'. The Tag handler should implement
         * the {@see Tag} interface (and thus the create method).
         *
         * @param string                    $tagName Name of tag to register a handler for. When registering a namespaced
         *                                   tag, the full name, along with a prefixing slash MUST be provided.
         * @param class-string<Tag>|Factory $handler FQCN of handler.
         *
         * @throws InvalidArgumentException If the tag name is not a string.
         * @throws InvalidArgumentException If the tag name is namespaced (contains backslashes) but
         *                                   does not start with a backslash.
         * @throws InvalidArgumentException If the handler is not a string.
         * @throws InvalidArgumentException If the handler is not an existing class.
         * @throws InvalidArgumentException If the handler does not implement the {@see Tag} interface.
         */
        public function registerTagHandler(string $tagName, $handler): void;
    }
    /**
     * Creates a Tag object given the contents of a tag.
     *
     * This Factory is capable of determining the appropriate class for a tag and instantiate it using its `create`
     * factory method. The `create` factory method of a Tag can have a variable number of arguments; this way you can
     * pass the dependencies that you need to construct a tag object.
     *
     * > Important: each parameter in addition to the body variable for the `create` method must default to null, otherwise
     * > it violates the constraint with the interface; it is recommended to use the {@see Assert::notNull()} method to
     * > verify that a dependency is actually passed.
     *
     * This Factory also features a Service Locator component that is used to pass the right dependencies to the
     * `create` method of a tag; each dependency should be registered as a service or as a parameter.
     *
     * When you want to use a Tag of your own with custom handling you need to call the `registerTagHandler` method, pass
     * the name of the tag and a Fully Qualified Class Name pointing to a class that implements the Tag interface.
     */
    final class StandardTagFactory implements \phpDocumentor\Reflection\DocBlock\TagFactory
    {
        /** PCRE regular expression matching a tag name. */
        public const REGEX_TAGNAME = '[\w\-\_\\\\:]+';
        /**
         * Initialize this tag factory with the means to resolve an FQSEN and optionally a list of tag handlers.
         *
         * If no tag handlers are provided than the default list in the {@see self::$tagHandlerMappings} property
         * is used.
         *
         * @see self::registerTagHandler() to add a new tag handler to the existing default list.
         *
         * @param array<class-string<Tag>> $tagHandlers
         */
        public function __construct(\phpDocumentor\Reflection\FqsenResolver $fqsenResolver, ?array $tagHandlers = null)
        {
        }
        public function create(string $tagLine, ?\phpDocumentor\Reflection\Types\Context $context = null): \phpDocumentor\Reflection\DocBlock\Tag
        {
        }
        /**
         * @param mixed $value
         */
        public function addParameter(string $name, $value): void
        {
        }
        public function addService(object $service, ?string $alias = null): void
        {
        }
        /** {@inheritDoc} */
        public function registerTagHandler(string $tagName, $handler): void
        {
        }
    }
    interface Tag
    {
        public function getName(): string;
        /**
         * @return Tag|mixed Class that implements Tag
         * @phpstan-return ?Tag
         */
        public static function create(string $body);
        public function render(?\phpDocumentor\Reflection\DocBlock\Tags\Formatter $formatter = null): string;
        public function __toString(): string;
    }
}
namespace phpDocumentor\Reflection\DocBlock\Tags\Factory {
    /**
     * @deprecated This contract is totally covered by Tag contract. Every class using StaticMethod also use Tag
     */
    interface StaticMethod
    {
        /**
         * @return mixed
         */
        public static function create(string $body);
    }
}
namespace phpDocumentor\Reflection\DocBlock\Tags {
    /**
     * Parses a tag definition for a DocBlock.
     */
    abstract class BaseTag implements \phpDocumentor\Reflection\DocBlock\Tag
    {
        /** @var string Name of the tag */
        protected string $name = '';
        /** @var Description|null Description of the tag. */
        protected ?\phpDocumentor\Reflection\DocBlock\Description $description = null;
        /**
         * Gets the name of this tag.
         *
         * @return string The name of this tag.
         */
        public function getName(): string
        {
        }
        public function getDescription(): ?\phpDocumentor\Reflection\DocBlock\Description
        {
        }
        public function render(?\phpDocumentor\Reflection\DocBlock\Tags\Formatter $formatter = null): string
        {
        }
    }
    /**
     * Reflection class for an {@}author tag in a Docblock.
     */
    final class Author extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /**
         * Initializes this tag with the author name and e-mail.
         */
        public function __construct(string $authorName, string $authorEmail)
        {
        }
        /**
         * Gets the author's name.
         *
         * @return string The author's name.
         */
        public function getAuthorName(): string
        {
        }
        /**
         * Returns the author's email.
         *
         * @return string The author's email.
         */
        public function getEmail(): string
        {
        }
        /**
         * Returns this tag in string form.
         */
        public function __toString(): string
        {
        }
        /**
         * Attempts to create a new Author object based on the tag body.
         */
        public static function create(string $body): ?self
        {
        }
    }
    /**
     * Reflection class for a @covers tag in a Docblock.
     */
    final class Covers extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /**
         * Initializes this tag.
         */
        public function __construct(\phpDocumentor\Reflection\Fqsen $refers, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        public static function create(string $body, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\FqsenResolver $resolver = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self
        {
        }
        /**
         * Returns the structural element this tag refers to.
         */
        public function getReference(): \phpDocumentor\Reflection\Fqsen
        {
        }
        /**
         * Returns a string representation of this tag.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Reflection class for a {@}deprecated tag in a Docblock.
     */
    final class Deprecated extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /**
         * PCRE regular expression matching a version vector.
         * Assumes the "x" modifier.
         */
        public const REGEX_VECTOR = '(?:
        # Normal release vectors.
        \d\S*
        |
        # VCS version vectors. Per PHPCS, they are expected to
        # follow the form of the VCS name, followed by ":", followed
        # by the version vector itself.
        # By convention, popular VCSes like CVS, SVN and GIT use "$"
        # around the actual version vector.
        [^\s\:]+\:\s*\$[^\$]+\$
    )';
        public function __construct(?string $version = null, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        /**
         * @return static
         */
        public static function create(?string $body, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self
        {
        }
        /**
         * Gets the version section of the tag.
         */
        public function getVersion(): ?string
        {
        }
        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Reflection class for a {@}example tag in a Docblock.
     */
    final class Example implements \phpDocumentor\Reflection\DocBlock\Tag, \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        public function __construct(string $filePath, bool $isURI, int $startingLine, int $lineCount, ?string $content)
        {
        }
        public function getContent(): string
        {
        }
        public function getDescription(): ?string
        {
        }
        public static function create(string $body): ?\phpDocumentor\Reflection\DocBlock\Tag
        {
        }
        /**
         * Returns the file path.
         *
         * @return string Path to a file to use as an example.
         *     May also be an absolute URI.
         */
        public function getFilePath(): string
        {
        }
        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string
        {
        }
        public function getStartingLine(): int
        {
        }
        public function getLineCount(): int
        {
        }
        public function getName(): string
        {
        }
        public function render(?\phpDocumentor\Reflection\DocBlock\Tags\Formatter $formatter = null): string
        {
        }
    }
    abstract class TagWithType extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag
    {
        /** @var ?Type */
        protected ?\phpDocumentor\Reflection\Type $type = null;
        /**
         * Returns the type section of the variable.
         */
        public function getType(): ?\phpDocumentor\Reflection\Type
        {
        }
        /**
         * @return string[]
         */
        protected static function extractTypeFromBody(string $body): array
        {
        }
        public function __toString(): string
        {
        }
    }
    /**
     * Reflection class for a {@}extends tag in a Docblock.
     */
    class Extends_ extends \phpDocumentor\Reflection\DocBlock\Tags\TagWithType
    {
        public function __construct(\phpDocumentor\Reflection\Type $type, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        /**
         * @deprecated Create using static factory is deprecated,
         *  this method should not be called directly by library consumers
         */
        public static function create(string $body): ?\phpDocumentor\Reflection\DocBlock\Tag
        {
        }
    }
}
namespace phpDocumentor\Reflection\DocBlock\Tags\Factory {
    /**
     * Factory class creating tags using phpstan's parser
     *
     * This class uses {@see PHPStanFactory} implementations to create tags
     * from the ast of the phpstan docblock parser.
     *
     * @internal This class is not part of the BC promise of this library.
     */
    class AbstractPHPStanFactory implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\Factory
    {
        public function __construct(\phpDocumentor\Reflection\DocBlock\Tags\Factory\PHPStanFactory ...$factories)
        {
        }
        public function create(string $tagLine, ?\phpDocumentor\Reflection\Types\Context $context = null): \phpDocumentor\Reflection\DocBlock\Tag
        {
        }
    }
    interface PHPStanFactory
    {
        public function create(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\DocBlock\Tag;
        public function supports(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): bool;
    }
    /**
     * @internal This class is not part of the BC promise of this library.
     */
    final class ExtendsFactory implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\PHPStanFactory
    {
        public function __construct(\phpDocumentor\Reflection\TypeResolver $typeResolver, \phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory)
        {
        }
        public function supports(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): bool
        {
        }
        public function create(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\DocBlock\Tag
        {
        }
    }
    /**
     * @internal This class is not part of the BC promise of this library.
     */
    final class ImplementsFactory implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\PHPStanFactory
    {
        public function __construct(\phpDocumentor\Reflection\TypeResolver $typeResolver, \phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory)
        {
        }
        public function supports(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): bool
        {
        }
        public function create(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\DocBlock\Tag
        {
        }
    }
    /**
     * @internal This class is not part of the BC promise of this library.
     */
    final class MethodFactory implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\PHPStanFactory
    {
        public function __construct(\phpDocumentor\Reflection\TypeResolver $typeResolver, \phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory)
        {
        }
        public function create(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\DocBlock\Tag
        {
        }
        public function supports(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): bool
        {
        }
    }
    /**
     * @internal This class is not part of the BC promise of this library.
     */
    final class MethodParameterFactory
    {
        /**
         * Formats the given default value to a string-able mixin
         *
         * @param mixed $defaultValue
         */
        public function format($defaultValue): string
        {
        }
    }
    /**
     * @internal This class is not part of the BC promise of this library.
     */
    final class ParamFactory implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\PHPStanFactory
    {
        public function __construct(\phpDocumentor\Reflection\TypeResolver $typeResolver, \phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory)
        {
        }
        public function create(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\DocBlock\Tag
        {
        }
        public function supports(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): bool
        {
        }
    }
    /**
     * @internal This class is not part of the BC promise of this library.
     */
    final class PropertyFactory implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\PHPStanFactory
    {
        public function __construct(\phpDocumentor\Reflection\TypeResolver $typeResolver, \phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory)
        {
        }
        public function create(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\DocBlock\Tag
        {
        }
        public function supports(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): bool
        {
        }
    }
    /**
     * @internal This class is not part of the BC promise of this library.
     */
    final class PropertyReadFactory implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\PHPStanFactory
    {
        public function __construct(\phpDocumentor\Reflection\TypeResolver $typeResolver, \phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory)
        {
        }
        public function create(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\DocBlock\Tag
        {
        }
        public function supports(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): bool
        {
        }
    }
    /**
     * @internal This class is not part of the BC promise of this library.
     */
    final class PropertyWriteFactory implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\PHPStanFactory
    {
        public function __construct(\phpDocumentor\Reflection\TypeResolver $typeResolver, \phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory)
        {
        }
        public function create(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\DocBlock\Tag
        {
        }
        public function supports(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): bool
        {
        }
    }
    /**
     * @internal This class is not part of the BC promise of this library.
     */
    final class ReturnFactory implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\PHPStanFactory
    {
        public function __construct(\phpDocumentor\Reflection\TypeResolver $typeResolver, \phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory)
        {
        }
        public function create(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\DocBlock\Tag
        {
        }
        public function supports(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): bool
        {
        }
    }
    /**
     * @internal This class is not part of the BC promise of this library.
     */
    final class TemplateExtendsFactory implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\PHPStanFactory
    {
        public function __construct(\phpDocumentor\Reflection\TypeResolver $typeResolver, \phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory)
        {
        }
        public function supports(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): bool
        {
        }
        public function create(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\DocBlock\Tag
        {
        }
    }
    /**
     * @internal This class is not part of the BC promise of this library.
     */
    final class TemplateFactory implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\PHPStanFactory
    {
        public function __construct(\phpDocumentor\Reflection\TypeResolver $typeResolver, \phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory)
        {
        }
        public function create(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\DocBlock\Tag
        {
        }
        public function supports(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): bool
        {
        }
    }
    /**
     * @internal This class is not part of the BC promise of this library.
     */
    final class TemplateImplementsFactory implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\PHPStanFactory
    {
        public function __construct(\phpDocumentor\Reflection\TypeResolver $typeResolver, \phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory)
        {
        }
        public function supports(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): bool
        {
        }
        public function create(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\DocBlock\Tag
        {
        }
    }
    /**
     * @internal This class is not part of the BC promise of this library.
     */
    final class VarFactory implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\PHPStanFactory
    {
        public function __construct(\phpDocumentor\Reflection\TypeResolver $typeResolver, \phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory)
        {
        }
        public function create(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\DocBlock\Tag
        {
        }
        public function supports(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode $node, \phpDocumentor\Reflection\Types\Context $context): bool
        {
        }
    }
}
namespace phpDocumentor\Reflection\DocBlock\Tags {
    interface Formatter
    {
        /**
         * Formats a tag into a string representation according to a specific format, such as Markdown.
         */
        public function format(\phpDocumentor\Reflection\DocBlock\Tag $tag): string;
    }
}
namespace phpDocumentor\Reflection\DocBlock\Tags\Formatter {
    class AlignFormatter implements \phpDocumentor\Reflection\DocBlock\Tags\Formatter
    {
        /** @var int The maximum tag name length. */
        protected int $maxLen = 0;
        /**
         * @param Tag[] $tags All tags that should later be aligned with the formatter.
         */
        public function __construct(array $tags)
        {
        }
        /**
         * Formats the given tag to return a simple plain text version.
         */
        public function format(\phpDocumentor\Reflection\DocBlock\Tag $tag): string
        {
        }
    }
    class PassthroughFormatter implements \phpDocumentor\Reflection\DocBlock\Tags\Formatter
    {
        /**
         * Formats the given tag to return a simple plain text version.
         */
        public function format(\phpDocumentor\Reflection\DocBlock\Tag $tag): string
        {
        }
    }
}
namespace phpDocumentor\Reflection\DocBlock\Tags {
    /**
     * Parses a tag definition for a DocBlock.
     */
    final class Generic extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /**
         * Parses a tag and populates the member variables.
         *
         * @param string      $name        Name of the tag.
         * @param Description $description The contents of the given tag.
         */
        public function __construct(string $name, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        /**
         * Creates a new tag that represents any unknown tag type.
         *
         * @return static
         */
        public static function create(string $body, string $name = '', ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self
        {
        }
        /**
         * Returns the tag as a serialized string
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Reflection class for a {@}implements tag in a Docblock.
     */
    class Implements_ extends \phpDocumentor\Reflection\DocBlock\Tags\TagWithType
    {
        public function __construct(\phpDocumentor\Reflection\Type $type, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        /**
         * @deprecated Create using static factory is deprecated,
         *  this method should not be called directly by library consumers
         */
        public static function create(string $body): ?\phpDocumentor\Reflection\DocBlock\Tag
        {
        }
    }
    /**
     * This class represents an exception during the tag creation
     *
     * Since the internals of the library are relaying on the correct syntax of a docblock
     * we cannot simply throw exceptions at all time because the exceptions will break the creation of a
     * docklock. Just silently ignore the exceptions is not an option because the user as an issue to fix.
     *
     * This tag holds that error information until a using application is able to display it. The object will just behave
     * like any normal tag. So the normal application flow will not break.
     */
    final class InvalidTag implements \phpDocumentor\Reflection\DocBlock\Tag
    {
        public function getException(): ?\Throwable
        {
        }
        public function getName(): string
        {
        }
        public static function create(string $body, string $name = ''): self
        {
        }
        public function withError(\Throwable $exception): self
        {
        }
        public function render(?\phpDocumentor\Reflection\DocBlock\Tags\Formatter $formatter = null): string
        {
        }
        public function __toString(): string
        {
        }
    }
    /**
     * Reflection class for a {@}link tag in a Docblock.
     */
    final class Link extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /**
         * Initializes a link to a URL.
         */
        public function __construct(string $link, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        public static function create(string $body, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self
        {
        }
        /**
         * Gets the link
         */
        public function getLink(): string
        {
        }
        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Reflection class for an {@}method in a Docblock.
     */
    final class Method extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /**
         * @param array<int, array<string, Type|string>> $arguments
         * @param MethodParameter[] $parameters
         * @phpstan-param array<int, array{name: string, type: Type}|string> $arguments
         */
        public function __construct(string $methodName, array $arguments = [], ?\phpDocumentor\Reflection\Type $returnType = null, bool $static = false, ?\phpDocumentor\Reflection\DocBlock\Description $description = null, bool $returnsReference = false, ?array $parameters = null)
        {
        }
        /**
         * @deprecated Create using static factory is deprecated,
         *  this method should not be called directly by library consumers
         */
        public static function create(string $body, ?\phpDocumentor\Reflection\TypeResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): ?self
        {
        }
        /**
         * Retrieves the method name.
         */
        public function getMethodName(): string
        {
        }
        /**
         * @deprecated Method deprecated, use {@see self::getParameters()}
         *
         * @return array<int, array<string, Type|string>>
         * @phpstan-return array<int, array{name: string, type: Type}>
         */
        public function getArguments(): array
        {
        }
        /** @return MethodParameter[] */
        public function getParameters(): array
        {
        }
        /**
         * Checks whether the method tag describes a static method or not.
         *
         * @return bool TRUE if the method declaration is for a static method, FALSE otherwise.
         */
        public function isStatic(): bool
        {
        }
        public function getReturnType(): \phpDocumentor\Reflection\Type
        {
        }
        public function returnsReference(): bool
        {
        }
        public function __toString(): string
        {
        }
    }
    final class MethodParameter
    {
        public const NO_DEFAULT_VALUE = '__NO_VALUE__';
        /**
         * @param mixed $defaultValue
         */
        public function __construct(string $name, \phpDocumentor\Reflection\Type $type, bool $isReference = false, bool $isVariadic = false, $defaultValue = self::NO_DEFAULT_VALUE)
        {
        }
        public function getName(): string
        {
        }
        public function getType(): \phpDocumentor\Reflection\Type
        {
        }
        public function isReference(): bool
        {
        }
        public function isVariadic(): bool
        {
        }
        public function getDefaultValue(): ?string
        {
        }
        public function __toString(): string
        {
        }
    }
    /**
     * Reflection class for a {@}mixin tag in a Docblock.
     */
    final class Mixin extends \phpDocumentor\Reflection\DocBlock\Tags\TagWithType implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        public function __construct(\phpDocumentor\Reflection\Type $type, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        public static function create(string $body, ?\phpDocumentor\Reflection\TypeResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self
        {
        }
    }
    /**
     * Reflection class for the {@}param tag in a Docblock.
     */
    final class Param extends \phpDocumentor\Reflection\DocBlock\Tags\TagWithType implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        public function __construct(?string $variableName, ?\phpDocumentor\Reflection\Type $type = null, bool $isVariadic = false, ?\phpDocumentor\Reflection\DocBlock\Description $description = null, bool $isReference = false)
        {
        }
        /**
         * @deprecated Create using static factory is deprecated,
         *  this method should not be called directly by library consumers
         */
        public static function create(string $body, ?\phpDocumentor\Reflection\TypeResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self
        {
        }
        /**
         * Returns the variable's name.
         */
        public function getVariableName(): ?string
        {
        }
        /**
         * Returns whether this tag is variadic.
         */
        public function isVariadic(): bool
        {
        }
        /**
         * Returns whether this tag is passed by reference.
         */
        public function isReference(): bool
        {
        }
        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Reflection class for a {@}property tag in a Docblock.
     */
    final class Property extends \phpDocumentor\Reflection\DocBlock\Tags\TagWithType implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        public function __construct(?string $variableName, ?\phpDocumentor\Reflection\Type $type = null, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        /**
         * @deprecated Create using static factory is deprecated,
         *  this method should not be called directly by library consumers
         */
        public static function create(string $body, ?\phpDocumentor\Reflection\TypeResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self
        {
        }
        /**
         * Returns the variable's name.
         */
        public function getVariableName(): ?string
        {
        }
        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Reflection class for a {@}property-read tag in a Docblock.
     */
    final class PropertyRead extends \phpDocumentor\Reflection\DocBlock\Tags\TagWithType implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        public function __construct(?string $variableName, ?\phpDocumentor\Reflection\Type $type = null, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        /**
         * @deprecated Create using static factory is deprecated,
         *  this method should not be called directly by library consumers
         */
        public static function create(string $body, ?\phpDocumentor\Reflection\TypeResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self
        {
        }
        /**
         * Returns the variable's name.
         */
        public function getVariableName(): ?string
        {
        }
        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Reflection class for a {@}property-write tag in a Docblock.
     */
    final class PropertyWrite extends \phpDocumentor\Reflection\DocBlock\Tags\TagWithType implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        public function __construct(?string $variableName, ?\phpDocumentor\Reflection\Type $type = null, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        /**
         * @deprecated Create using static factory is deprecated,
         *  this method should not be called directly by library consumers
         */
        public static function create(string $body, ?\phpDocumentor\Reflection\TypeResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self
        {
        }
        /**
         * Returns the variable's name.
         */
        public function getVariableName(): ?string
        {
        }
        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string
        {
        }
    }
}
namespace phpDocumentor\Reflection\DocBlock\Tags\Reference {
    /**
     * Interface for references in {@see \phpDocumentor\Reflection\DocBlock\Tags\See}
     */
    interface Reference
    {
        public function __toString(): string;
    }
    /**
     * Fqsen reference used by {@see \phpDocumentor\Reflection\DocBlock\Tags\See}
     */
    final class Fqsen implements \phpDocumentor\Reflection\DocBlock\Tags\Reference\Reference
    {
        public function __construct(\phpDocumentor\Reflection\Fqsen $fqsen)
        {
        }
        /**
         * @return string string representation of the referenced fqsen
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Url reference used by {@see \phpDocumentor\Reflection\DocBlock\Tags\See}
     */
    final class Url implements \phpDocumentor\Reflection\DocBlock\Tags\Reference\Reference
    {
        public function __construct(string $uri)
        {
        }
        public function __toString(): string
        {
        }
    }
}
namespace phpDocumentor\Reflection\DocBlock\Tags {
    /**
     * Reflection class for a {@}return tag in a Docblock.
     */
    final class Return_ extends \phpDocumentor\Reflection\DocBlock\Tags\TagWithType implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        public function __construct(\phpDocumentor\Reflection\Type $type, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        /**
         * @deprecated Create using static factory is deprecated,
         *  this method should not be called directly by library consumers
         */
        public static function create(string $body, ?\phpDocumentor\Reflection\TypeResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self
        {
        }
    }
    /**
     * Reflection class for an {@}see tag in a Docblock.
     */
    final class See extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /**
         * Initializes this tag.
         */
        public function __construct(\phpDocumentor\Reflection\DocBlock\Tags\Reference\Reference $refers, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        public static function create(string $body, ?\phpDocumentor\Reflection\FqsenResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self
        {
        }
        /**
         * Returns the ref of this tag.
         */
        public function getReference(): \phpDocumentor\Reflection\DocBlock\Tags\Reference\Reference
        {
        }
        /**
         * Returns a string representation of this tag.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Reflection class for a {@}since tag in a Docblock.
     */
    final class Since extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /**
         * PCRE regular expression matching a version vector.
         * Assumes the "x" modifier.
         */
        public const REGEX_VECTOR = '(?:
        # Normal release vectors.
        \d\S*
        |
        # VCS version vectors. Per PHPCS, they are expected to
        # follow the form of the VCS name, followed by ":", followed
        # by the version vector itself.
        # By convention, popular VCSes like CVS, SVN and GIT use "$"
        # around the actual version vector.
        [^\s\:]+\:\s*\$[^\$]+\$
    )';
        public function __construct(?string $version = null, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        public static function create(?string $body, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): ?self
        {
        }
        /**
         * Gets the version section of the tag.
         */
        public function getVersion(): ?string
        {
        }
        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Reflection class for a {@}source tag in a Docblock.
     */
    final class Source extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /**
         * @param int|string      $startingLine should be a to int convertible value
         * @param int|string|null $lineCount    should be a to int convertible value
         */
        public function __construct($startingLine, $lineCount = null, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        public static function create(string $body, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self
        {
        }
        /**
         * Gets the starting line.
         *
         * @return int The starting line, relative to the structural element's
         *     location.
         */
        public function getStartingLine(): int
        {
        }
        /**
         * Returns the number of lines.
         *
         * @return int|null The number of lines, relative to the starting line. NULL
         *     means "to the end".
         */
        public function getLineCount(): ?int
        {
        }
        public function __toString(): string
        {
        }
    }
    /**
     * Reflection class for a {@}template tag in a Docblock.
     */
    final class Template extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag
    {
        /** @param non-empty-string $templateName */
        public function __construct(string $templateName, ?\phpDocumentor\Reflection\Type $bound = null, ?\phpDocumentor\Reflection\Type $default = null, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        /**
         * @deprecated Create using static factory is deprecated,
         *  this method should not be called directly by library consumers
         */
        public static function create(string $body): ?\phpDocumentor\Reflection\DocBlock\Tag
        {
        }
        public function getTemplateName(): string
        {
        }
        public function getBound(): ?\phpDocumentor\Reflection\Type
        {
        }
        public function getDefault(): ?\phpDocumentor\Reflection\Type
        {
        }
        public function __toString(): string
        {
        }
    }
    /**
     * Reflection class for a {@}template-covariant tag in a Docblock.
     */
    final class TemplateCovariant extends \phpDocumentor\Reflection\DocBlock\Tags\TagWithType implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        public function __construct(\phpDocumentor\Reflection\Type $type, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        public static function create(string $body, ?\phpDocumentor\Reflection\TypeResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self
        {
        }
    }
    /**
     * Reflection class for a {@}template-extends tag in a Docblock.
     */
    final class TemplateExtends extends \phpDocumentor\Reflection\DocBlock\Tags\Extends_
    {
        public function __construct(\phpDocumentor\Reflection\Type $type, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
    }
    /**
     * Reflection class for a {@}template-implements tag in a Docblock.
     */
    final class TemplateImplements extends \phpDocumentor\Reflection\DocBlock\Tags\Implements_
    {
        public function __construct(\phpDocumentor\Reflection\Type $type, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
    }
    /**
     * Reflection class for a {@}throws tag in a Docblock.
     */
    final class Throws extends \phpDocumentor\Reflection\DocBlock\Tags\TagWithType implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        public function __construct(\phpDocumentor\Reflection\Type $type, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        public static function create(string $body, ?\phpDocumentor\Reflection\TypeResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self
        {
        }
    }
    /**
     * Reflection class for a {@}uses tag in a Docblock.
     */
    final class Uses extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /**
         * Initializes this tag.
         */
        public function __construct(\phpDocumentor\Reflection\Fqsen $refers, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        public static function create(string $body, ?\phpDocumentor\Reflection\FqsenResolver $resolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self
        {
        }
        /**
         * Returns the structural element this tag refers to.
         */
        public function getReference(): \phpDocumentor\Reflection\Fqsen
        {
        }
        /**
         * Returns a string representation of this tag.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Reflection class for a {@}var tag in a Docblock.
     */
    final class Var_ extends \phpDocumentor\Reflection\DocBlock\Tags\TagWithType implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        public function __construct(?string $variableName, ?\phpDocumentor\Reflection\Type $type = null, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        /**
         * @deprecated Create using static factory is deprecated,
         *  this method should not be called directly by library consumers
         */
        public static function create(string $body, ?\phpDocumentor\Reflection\TypeResolver $typeResolver = null, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): self
        {
        }
        /**
         * Returns the variable's name.
         */
        public function getVariableName(): ?string
        {
        }
        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Reflection class for a {@}version tag in a Docblock.
     */
    final class Version extends \phpDocumentor\Reflection\DocBlock\Tags\BaseTag implements \phpDocumentor\Reflection\DocBlock\Tags\Factory\StaticMethod
    {
        /**
         * PCRE regular expression matching a version vector.
         * Assumes the "x" modifier.
         */
        public const REGEX_VECTOR = '(?:
        # Normal release vectors.
        \d\S*
        |
        # VCS version vectors. Per PHPCS, they are expected to
        # follow the form of the VCS name, followed by ":", followed
        # by the version vector itself.
        # By convention, popular VCSes like CVS, SVN and GIT use "$"
        # around the actual version vector.
        [^\s\:]+\:\s*\$[^\$]+\$
    )';
        public function __construct(?string $version = null, ?\phpDocumentor\Reflection\DocBlock\Description $description = null)
        {
        }
        public static function create(?string $body, ?\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory = null, ?\phpDocumentor\Reflection\Types\Context $context = null): ?self
        {
        }
        /**
         * Gets the version section of the tag.
         */
        public function getVersion(): ?string
        {
        }
        /**
         * Returns a string representation for this tag.
         */
        public function __toString(): string
        {
        }
    }
}
namespace phpDocumentor\Reflection {
    final class DocBlock
    {
        /**
         * @param DocBlock\Tag[] $tags
         * @param Types\Context  $context  The context in which the DocBlock occurs.
         * @param Location       $location The location within the file that this DocBlock occurs in.
         */
        public function __construct(string $summary = '', ?\phpDocumentor\Reflection\DocBlock\Description $description = null, array $tags = [], ?\phpDocumentor\Reflection\Types\Context $context = null, ?\phpDocumentor\Reflection\Location $location = null, bool $isTemplateStart = false, bool $isTemplateEnd = false)
        {
        }
        public function getSummary(): string
        {
        }
        public function getDescription(): \phpDocumentor\Reflection\DocBlock\Description
        {
        }
        /**
         * Returns the current context.
         */
        public function getContext(): ?\phpDocumentor\Reflection\Types\Context
        {
        }
        /**
         * Returns the current location.
         */
        public function getLocation(): ?\phpDocumentor\Reflection\Location
        {
        }
        /**
         * Returns whether this DocBlock is the start of a Template section.
         *
         * A Docblock may serve as template for a series of subsequent DocBlocks. This is indicated by a special marker
         * (`#@+`) that is appended directly after the opening `/**` of a DocBlock.
         *
         * An example of such an opening is:
         *
         * ```
         * /**#@+
         *  * My DocBlock
         *  * /
         * ```
         *
         * The description and tags (not the summary!) are copied onto all subsequent DocBlocks and also applied to all
         * elements that follow until another DocBlock is found that contains the closing marker (`#@-`).
         *
         * @see self::isTemplateEnd() for the check whether a closing marker was provided.
         */
        public function isTemplateStart(): bool
        {
        }
        /**
         * Returns whether this DocBlock is the end of a Template section.
         *
         * @see self::isTemplateStart() for a more complete description of the Docblock Template functionality.
         */
        public function isTemplateEnd(): bool
        {
        }
        /**
         * Returns the tags for this DocBlock.
         *
         * @return Tag[]
         */
        public function getTags(): array
        {
        }
        /**
         * Returns an array of tags matching the given name. If no tags are found
         * an empty array is returned.
         *
         * @param string $name String to search by.
         *
         * @return Tag[]
         */
        public function getTagsByName(string $name): array
        {
        }
        /**
         * Returns an array of tags with type matching the given name. If no tags are found
         * an empty array is returned.
         *
         * @param string $name String to search by.
         *
         * @return TagWithType[]
         */
        public function getTagsWithTypeByName(string $name): array
        {
        }
        /**
         * Checks if a tag of a certain type is present in this DocBlock.
         *
         * @param string $name Tag name to check for.
         */
        public function hasTag(string $name): bool
        {
        }
        /**
         * Remove a tag from this DocBlock.
         *
         * @param Tag $tagToRemove The tag to remove.
         */
        public function removeTag(\phpDocumentor\Reflection\DocBlock\Tag $tagToRemove): void
        {
        }
    }
    // phpcs:ignore SlevomatCodingStandard.Classes.SuperfluousInterfaceNaming.SuperfluousSuffix
    interface DocBlockFactoryInterface
    {
        /**
         * Factory method for easy instantiation.
         *
         * @param array<string, class-string<Tag>> $additionalTags
         */
        public static function createInstance(array $additionalTags = []): self;
        /**
         * @param string|object $docblock
         */
        public function create($docblock, ?\phpDocumentor\Reflection\Types\Context $context = null, ?\phpDocumentor\Reflection\Location $location = null): \phpDocumentor\Reflection\DocBlock;
    }
    final class DocBlockFactory implements \phpDocumentor\Reflection\DocBlockFactoryInterface
    {
        /**
         * Initializes this factory with the required subcontractors.
         */
        public function __construct(\phpDocumentor\Reflection\DocBlock\DescriptionFactory $descriptionFactory, \phpDocumentor\Reflection\DocBlock\TagFactory $tagFactory)
        {
        }
        /**
         * Factory method for easy instantiation.
         *
         * @param array<string, class-string<Tag>|Factory> $additionalTags
         */
        public static function createInstance(array $additionalTags = []): \phpDocumentor\Reflection\DocBlockFactoryInterface
        {
        }
        /**
         * @param object|string $docblock A string containing the DocBlock to parse or an object supporting the
         *                                getDocComment method (such as a ReflectionClass object).
         */
        public function create($docblock, ?\phpDocumentor\Reflection\Types\Context $context = null, ?\phpDocumentor\Reflection\Location $location = null): \phpDocumentor\Reflection\DocBlock
        {
        }
        /**
         * @param class-string<Tag>|Factory $handler
         */
        public function registerTagHandler(string $tagName, $handler): void
        {
        }
    }
}
namespace phpDocumentor\Reflection\Exception {
    final class PcreException extends \InvalidArgumentException
    {
        public static function createFromPhpError(int $errorCode): self
        {
        }
    }
}
namespace phpDocumentor\Reflection {
    abstract class Utils
    {
        /**
         * Wrapper function for phps preg_split
         *
         * This function is inspired by {@link https://github.com/thecodingmachine/safe/blob/master/generated/pcre.php}. But
         * since this library is all about performance we decided to strip everything we don't need. Reducing the amount
         * of files that have to be loaded, etc.
         *
         * @param string $pattern The pattern to search for, as a string.
         * @param string $subject The input string.
         * @param int $limit If specified, then only substrings up to limit are returned with the
         *      rest of the string being placed in the last substring. A limit of -1 or 0 means "no limit".
         * @param int $flags flags can be any combination of the following flags (combined with the | bitwise operator):
         * *PREG_SPLIT_NO_EMPTY*
         *      If this flag is set, only non-empty pieces will be returned by preg_split().
         * *PREG_SPLIT_DELIM_CAPTURE*
         *      If this flag is set, parenthesized expression in the delimiter pattern will be captured
         *      and returned as well.
         * *PREG_SPLIT_OFFSET_CAPTURE*
         *      If this flag is set, for every occurring match the appendant string offset will also be returned.
         *      Note that this changes the return value in an array where every element is an array consisting of the
         *      matched string at offset 0 and its string offset into subject at offset 1.
         *
         * @return string[] Returns an array containing substrings of subject
         *                                                      split along boundaries matched by pattern
         *
         * @throws PcreException
         */
        public static function pregSplit(string $pattern, string $subject, int $limit = -1, int $flags = 0): array
        {
        }
    }
    /**
     * Resolver for Fqsen using Context information
     *
     * @psalm-immutable
     */
    class FqsenResolver
    {
        public function resolve(string $fqsen, ?\phpDocumentor\Reflection\Types\Context $context = null): \phpDocumentor\Reflection\Fqsen
        {
        }
    }
    /**
     * @psalm-immutable
     */
    interface Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string;
    }
    interface PseudoType extends \phpDocumentor\Reflection\Type
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type;
    }
}
namespace phpDocumentor\Reflection\PseudoTypes {
    /** @psalm-immutable */
    class ArrayShape implements \phpDocumentor\Reflection\PseudoType
    {
        public function __construct(\phpDocumentor\Reflection\PseudoTypes\ArrayShapeItem ...$items)
        {
        }
        /**
         * @return ArrayShapeItem[]
         */
        public function getItems(): array
        {
        }
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        public function __toString(): string
        {
        }
    }
    abstract class ShapeItem
    {
        public function __construct(?string $key, ?\phpDocumentor\Reflection\Type $value, bool $optional)
        {
        }
        public function getKey(): ?string
        {
        }
        public function getValue(): \phpDocumentor\Reflection\Type
        {
        }
        public function isOptional(): bool
        {
        }
        public function __toString(): string
        {
        }
    }
    class ArrayShapeItem extends \phpDocumentor\Reflection\PseudoTypes\ShapeItem
    {
    }
}
namespace phpDocumentor\Reflection\Types {
    /**
     * Value Object representing the type 'string'.
     *
     * @psalm-immutable
     */
    class String_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
}
namespace phpDocumentor\Reflection\PseudoTypes {
    /**
     * Value Object representing the type 'string'.
     *
     * @psalm-immutable
     */
    final class CallableString extends \phpDocumentor\Reflection\Types\String_ implements \phpDocumentor\Reflection\PseudoType
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /** @psalm-immutable */
    final class ConstExpression implements \phpDocumentor\Reflection\PseudoType
    {
        public function __construct(\phpDocumentor\Reflection\Type $owner, string $expression)
        {
        }
        public function getOwner(): \phpDocumentor\Reflection\Type
        {
        }
        public function getExpression(): string
        {
        }
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        public function __toString(): string
        {
        }
    }
}
namespace phpDocumentor\Reflection\Types {
    /**
     * Value Object representing a Boolean type.
     *
     * @psalm-immutable
     */
    class Boolean implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
}
namespace phpDocumentor\Reflection\PseudoTypes {
    /**
     * Value Object representing the PseudoType 'False', which is a Boolean type.
     *
     * @psalm-immutable
     */
    final class False_ extends \phpDocumentor\Reflection\Types\Boolean implements \phpDocumentor\Reflection\PseudoType
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        public function __toString(): string
        {
        }
    }
    /** @psalm-immutable */
    class FloatValue implements \phpDocumentor\Reflection\PseudoType
    {
        public function __construct(float $value)
        {
        }
        public function getValue(): float
        {
        }
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the type 'string'.
     *
     * @psalm-immutable
     */
    final class HtmlEscapedString extends \phpDocumentor\Reflection\Types\String_ implements \phpDocumentor\Reflection\PseudoType
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
}
namespace phpDocumentor\Reflection\Types {
    /**
     * Value object representing Integer type
     *
     * @psalm-immutable
     */
    class Integer implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
}
namespace phpDocumentor\Reflection\PseudoTypes {
    /**
     * Value Object representing the type 'int'.
     *
     * @psalm-immutable
     */
    final class IntegerRange extends \phpDocumentor\Reflection\Types\Integer implements \phpDocumentor\Reflection\PseudoType
    {
        public function __construct(string $minValue, string $maxValue)
        {
        }
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        public function getMinValue(): string
        {
        }
        public function getMaxValue(): string
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /** @psalm-immutable */
    final class IntegerValue implements \phpDocumentor\Reflection\PseudoType
    {
        public function __construct(int $value)
        {
        }
        public function getValue(): int
        {
        }
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        public function __toString(): string
        {
        }
    }
    /** @psalm-immutable */
    final class ListShape extends \phpDocumentor\Reflection\PseudoTypes\ArrayShape
    {
        public function __toString(): string
        {
        }
    }
    final class ListShapeItem extends \phpDocumentor\Reflection\PseudoTypes\ArrayShapeItem
    {
    }
}
namespace phpDocumentor\Reflection\Types {
    /**
     * Represents a list of values. This is an abstract class for Array_ and Collection.
     *
     * @psalm-immutable
     */
    abstract class AbstractList implements \phpDocumentor\Reflection\Type
    {
        /** @var Type */
        protected $valueType;
        /** @var Type|null */
        protected $keyType;
        /** @var Type */
        protected $defaultKeyType;
        /**
         * Initializes this representation of an array with the given Type.
         */
        public function __construct(?\phpDocumentor\Reflection\Type $valueType = null, ?\phpDocumentor\Reflection\Type $keyType = null)
        {
        }
        /**
         * Returns the type for the keys of this array.
         */
        public function getKeyType(): \phpDocumentor\Reflection\Type
        {
        }
        /**
         * Returns the type for the values of this array.
         */
        public function getValueType(): \phpDocumentor\Reflection\Type
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Represents an array type as described in the PSR-5, the PHPDoc Standard.
     *
     * An array can be represented in two forms:
     *
     * 1. Untyped (`array`), where the key and value type is unknown and hence classified as 'Mixed_'.
     * 2. Types (`string[]`), where the value type is provided by preceding an opening and closing square bracket with a
     *    type name.
     *
     * @psalm-immutable
     */
    class Array_ extends \phpDocumentor\Reflection\Types\AbstractList
    {
    }
}
namespace phpDocumentor\Reflection\PseudoTypes {
    /**
     * Value Object representing the type 'list'.
     *
     * @psalm-immutable
     */
    final class List_ extends \phpDocumentor\Reflection\Types\Array_ implements \phpDocumentor\Reflection\PseudoType
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        public function __construct(?\phpDocumentor\Reflection\Type $valueType = null)
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the type 'string'.
     *
     * @psalm-immutable
     */
    final class LiteralString extends \phpDocumentor\Reflection\Types\String_ implements \phpDocumentor\Reflection\PseudoType
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the type 'string'.
     *
     * @psalm-immutable
     */
    final class LowercaseString extends \phpDocumentor\Reflection\Types\String_ implements \phpDocumentor\Reflection\PseudoType
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the type 'int'.
     *
     * @psalm-immutable
     */
    final class NegativeInteger extends \phpDocumentor\Reflection\Types\Integer implements \phpDocumentor\Reflection\PseudoType
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the type 'non-empty-array'.
     *
     * @psalm-immutable
     */
    final class NonEmptyArray extends \phpDocumentor\Reflection\Types\Array_ implements \phpDocumentor\Reflection\PseudoType
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the type 'non-empty-list'.
     *
     * @psalm-immutable
     */
    final class NonEmptyList extends \phpDocumentor\Reflection\Types\Array_ implements \phpDocumentor\Reflection\PseudoType
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        public function __construct(?\phpDocumentor\Reflection\Type $valueType = null)
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the type 'string'.
     *
     * @psalm-immutable
     */
    final class NonEmptyLowercaseString extends \phpDocumentor\Reflection\Types\String_ implements \phpDocumentor\Reflection\PseudoType
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the type 'string'.
     *
     * @psalm-immutable
     */
    final class NonEmptyString extends \phpDocumentor\Reflection\Types\String_ implements \phpDocumentor\Reflection\PseudoType
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the type 'string'.
     *
     * @psalm-immutable
     */
    final class NumericString extends \phpDocumentor\Reflection\Types\String_ implements \phpDocumentor\Reflection\PseudoType
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
}
namespace phpDocumentor\Reflection\Types {
    /**
     * Base class for aggregated types like Compound and Intersection
     *
     * A Aggregated Type is not so much a special keyword or object reference but is a series of Types that are separated
     * using separator.
     *
     * @psalm-immutable
     * @template-implements IteratorAggregate<int, Type>
     */
    abstract class AggregatedType implements \phpDocumentor\Reflection\Type, \IteratorAggregate
    {
        /**
         * @param array<Type> $types
         */
        public function __construct(array $types, string $token)
        {
        }
        /**
         * Returns the type at the given index.
         */
        public function get(int $index): ?\phpDocumentor\Reflection\Type
        {
        }
        /**
         * Tests if this compound type has a type with the given index.
         */
        public function has(int $index): bool
        {
        }
        /**
         * Tests if this compound type contains the given type.
         */
        public function contains(\phpDocumentor\Reflection\Type $type): bool
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
        /**
         * @return ArrayIterator<int, Type>
         */
        public function getIterator(): \ArrayIterator
        {
        }
    }
}
namespace phpDocumentor\Reflection\PseudoTypes {
    /**
     * Value Object representing the 'numeric' pseudo-type, which is either a numeric-string, integer or float.
     *
     * @psalm-immutable
     */
    final class Numeric_ extends \phpDocumentor\Reflection\Types\AggregatedType implements \phpDocumentor\Reflection\PseudoType
    {
        public function __construct()
        {
        }
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /** @psalm-immutable */
    final class ObjectShape implements \phpDocumentor\Reflection\PseudoType
    {
        public function __construct(\phpDocumentor\Reflection\PseudoTypes\ObjectShapeItem ...$items)
        {
        }
        /**
         * @return ObjectShapeItem[]
         */
        public function getItems(): array
        {
        }
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        public function __toString(): string
        {
        }
    }
    final class ObjectShapeItem extends \phpDocumentor\Reflection\PseudoTypes\ShapeItem
    {
    }
    /**
     * Value Object representing the type 'int'.
     *
     * @psalm-immutable
     */
    final class PositiveInteger extends \phpDocumentor\Reflection\Types\Integer implements \phpDocumentor\Reflection\PseudoType
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /** @psalm-immutable */
    class StringValue implements \phpDocumentor\Reflection\PseudoType
    {
        public function __construct(string $value)
        {
        }
        public function getValue(): string
        {
        }
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the type 'string'.
     *
     * @psalm-immutable
     */
    final class TraitString extends \phpDocumentor\Reflection\Types\String_ implements \phpDocumentor\Reflection\PseudoType
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the PseudoType 'False', which is a Boolean type.
     *
     * @psalm-immutable
     */
    final class True_ extends \phpDocumentor\Reflection\Types\Boolean implements \phpDocumentor\Reflection\PseudoType
    {
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        public function __toString(): string
        {
        }
    }
}
namespace phpDocumentor\Reflection {
    final class TypeResolver
    {
        /**
         * Initializes this TypeResolver with the means to create and resolve Fqsen objects.
         */
        public function __construct(?\phpDocumentor\Reflection\FqsenResolver $fqsenResolver = null)
        {
        }
        /**
         * Analyzes the given type and returns the FQCN variant.
         *
         * When a type is provided this method checks whether it is not a keyword or
         * Fully Qualified Class Name. If so it will use the given namespace and
         * aliases to expand the type to a FQCN representation.
         *
         * This method only works as expected if the namespace and aliases are set;
         * no dynamic reflection is being performed here.
         *
         * @uses Context::getNamespace()        to determine with what to prefix the type name.
         * @uses Context::getNamespaceAliases() to check whether the first part of the relative type name should not be
         * replaced with another namespace.
         *
         * @param string $type The relative or absolute type.
         */
        public function resolve(string $type, ?\phpDocumentor\Reflection\Types\Context $context = null): \phpDocumentor\Reflection\Type
        {
        }
        public function createType(?\PHPStan\PhpDocParser\Ast\Type\TypeNode $type, \phpDocumentor\Reflection\Types\Context $context): \phpDocumentor\Reflection\Type
        {
        }
        /**
         * Adds a keyword to the list of Keywords and associates it with a specific Value Object.
         *
         * @psalm-param class-string<Type> $typeClassName
         */
        public function addKeyword(string $keyword, string $typeClassName): void
        {
        }
    }
}
namespace phpDocumentor\Reflection\Types {
    /**
     * Value Object representing a array-key Type.
     *
     * A array-key Type is the supertype (but not a union) of int and string.
     *
     * @psalm-immutable
     */
    final class ArrayKey extends \phpDocumentor\Reflection\Types\AggregatedType implements \phpDocumentor\Reflection\PseudoType
    {
        public function __construct()
        {
        }
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing a Callable parameters.
     *
     * @psalm-immutable
     */
    final class CallableParameter
    {
        public function __construct(\phpDocumentor\Reflection\Type $type, ?string $name = null, bool $isReference = false, bool $isVariadic = false, bool $isOptional = false)
        {
        }
        public function getName(): ?string
        {
        }
        public function getType(): \phpDocumentor\Reflection\Type
        {
        }
        public function isReference(): bool
        {
        }
        public function isVariadic(): bool
        {
        }
        public function isOptional(): bool
        {
        }
    }
    /**
     * Value Object representing a Callable type.
     *
     * @psalm-immutable
     */
    final class Callable_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * @param CallableParameter[] $parameters
         */
        public function __construct(array $parameters = [], ?\phpDocumentor\Reflection\Type $returnType = null)
        {
        }
        /** @return CallableParameter[] */
        public function getParameters(): array
        {
        }
        public function getReturnType(): ?\phpDocumentor\Reflection\Type
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the type 'string'.
     *
     * @psalm-immutable
     */
    final class ClassString extends \phpDocumentor\Reflection\Types\String_ implements \phpDocumentor\Reflection\PseudoType
    {
        /**
         * Initializes this representation of a class string with the given Fqsen.
         */
        public function __construct(?\phpDocumentor\Reflection\Fqsen $fqsen = null)
        {
        }
        public function underlyingType(): \phpDocumentor\Reflection\Type
        {
        }
        /**
         * Returns the FQSEN associated with this object.
         */
        public function getFqsen(): ?\phpDocumentor\Reflection\Fqsen
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Represents a collection type as described in the PSR-5, the PHPDoc Standard.
     *
     * A collection can be represented in two forms:
     *
     * 1. `ACollectionObject<aValueType>`
     * 2. `ACollectionObject<aValueType,aKeyType>`
     *
     * - ACollectionObject can be 'array' or an object that can act as an array
     * - aValueType and aKeyType can be any type expression
     *
     * @psalm-immutable
     */
    final class Collection extends \phpDocumentor\Reflection\Types\AbstractList
    {
        /**
         * Initializes this representation of an array with the given Type or Fqsen.
         */
        public function __construct(?\phpDocumentor\Reflection\Fqsen $fqsen, \phpDocumentor\Reflection\Type $valueType, ?\phpDocumentor\Reflection\Type $keyType = null)
        {
        }
        /**
         * Returns the FQSEN associated with this object.
         */
        public function getFqsen(): ?\phpDocumentor\Reflection\Fqsen
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing a Compound Type.
     *
     * A Compound Type is not so much a special keyword or object reference but is a series of Types that are separated
     * using an OR operator (`|`). This combination of types signifies that whatever is associated with this compound type
     * may contain a value with any of the given types.
     *
     * @psalm-immutable
     */
    final class Compound extends \phpDocumentor\Reflection\Types\AggregatedType
    {
        /**
         * Initializes a compound type (i.e. `string|int`) and tests if the provided types all implement the Type interface.
         *
         * @param array<Type> $types
         */
        public function __construct(array $types)
        {
        }
    }
    /**
     * Provides information about the Context in which the DocBlock occurs that receives this context.
     *
     * A DocBlock does not know of its own accord in which namespace it occurs and which namespace aliases are applicable
     * for the block of code in which it is in. This information is however necessary to resolve Class names in tags since
     * you can provide a short form or make use of namespace aliases.
     *
     * The phpDocumentor Reflection component knows how to create this class but if you use the DocBlock parser from your
     * own application it is possible to generate a Context class using the ContextFactory; this will analyze the file in
     * which an associated class resides for its namespace and imports.
     *
     * @see ContextFactory::createFromClassReflector()
     * @see ContextFactory::createForNamespace()
     *
     * @psalm-immutable
     */
    final class Context
    {
        /**
         * Initializes the new context and normalizes all passed namespaces to be in Qualified Namespace Name (QNN)
         * format (without a preceding `\`).
         *
         * @param string   $namespace        The namespace where this DocBlock resides in.
         * @param string[] $namespaceAliases List of namespace aliases => Fully Qualified Namespace.
         * @psalm-param array<string, string> $namespaceAliases
         */
        public function __construct(string $namespace, array $namespaceAliases = [])
        {
        }
        /**
         * Returns the Qualified Namespace Name (thus without `\` in front) where the associated element is in.
         */
        public function getNamespace(): string
        {
        }
        /**
         * Returns a list of Qualified Namespace Names (thus without `\` in front) that are imported, the keys represent
         * the alias for the imported Namespace.
         *
         * @return string[]
         * @psalm-return array<string, string>
         */
        public function getNamespaceAliases(): array
        {
        }
    }
    /**
     * Convenience class to create a Context for DocBlocks when not using the Reflection Component of phpDocumentor.
     *
     * For a DocBlock to be able to resolve types that use partial namespace names or rely on namespace imports we need to
     * provide a bit of context so that the DocBlock can read that and based on it decide how to resolve the types to
     * Fully Qualified names.
     *
     * @see Context for more information.
     */
    final class ContextFactory
    {
        /**
         * Build a Context given a Class Reflection.
         *
         * @see Context for more information on Contexts.
         */
        public function createFromReflector(\Reflector $reflector): \phpDocumentor\Reflection\Types\Context
        {
        }
        /**
         * Build a Context for a namespace in the provided file contents.
         *
         * @see Context for more information on Contexts.
         *
         * @param string $namespace    It does not matter if a `\` precedes the namespace name,
         * this method first normalizes.
         * @param string $fileContents The file's contents to retrieve the aliases from with the given namespace.
         */
        public function createForNamespace(string $namespace, string $fileContents): \phpDocumentor\Reflection\Types\Context
        {
        }
    }
    /**
     * Represents an expression type as described in the PSR-5, the PHPDoc Standard.
     *
     * @psalm-immutable
     */
    final class Expression implements \phpDocumentor\Reflection\Type
    {
        /**
         * Initializes this representation of an array with the given Type.
         */
        public function __construct(\phpDocumentor\Reflection\Type $valueType)
        {
        }
        /**
         * Returns the value for the keys of this array.
         */
        public function getValueType(): \phpDocumentor\Reflection\Type
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing a Float.
     *
     * @psalm-immutable
     */
    class Float_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the type 'string'.
     *
     * @psalm-immutable
     */
    final class InterfaceString implements \phpDocumentor\Reflection\Type
    {
        /**
         * Initializes this representation of a class string with the given Fqsen.
         */
        public function __construct(?\phpDocumentor\Reflection\Fqsen $fqsen = null)
        {
        }
        /**
         * Returns the FQSEN associated with this object.
         */
        public function getFqsen(): ?\phpDocumentor\Reflection\Fqsen
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing a Compound Type.
     *
     * A Intersection Type is not so much a special keyword or object reference but is a series of Types that are separated
     * using an AND operator (`&`). This combination of types signifies that whatever is associated with this Intersection
     * type may contain a value with any of the given types.
     *
     * @psalm-immutable
     */
    final class Intersection extends \phpDocumentor\Reflection\Types\AggregatedType
    {
        /**
         * Initializes a intersection type (i.e. `\A&\B`) and tests if the provided types all implement the Type interface.
         *
         * @param array<Type> $types
         */
        public function __construct(array $types)
        {
        }
    }
    /**
     * Value Object representing iterable type
     *
     * @psalm-immutable
     */
    final class Iterable_ extends \phpDocumentor\Reflection\Types\AbstractList
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing an unknown, or mixed, type.
     *
     * @psalm-immutable
     */
    final class Mixed_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the return-type 'never'.
     *
     * Never is generally only used when working with return types as it signifies that the method that only
     * ever throw or exit.
     *
     * @psalm-immutable
     */
    final class Never_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing a nullable type. The real type is wrapped.
     *
     * @psalm-immutable
     */
    final class Nullable implements \phpDocumentor\Reflection\Type
    {
        /**
         * Initialises this nullable type using the real type embedded
         */
        public function __construct(\phpDocumentor\Reflection\Type $realType)
        {
        }
        /**
         * Provide access to the actual type directly, if needed.
         */
        public function getActualType(): \phpDocumentor\Reflection\Type
        {
        }
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing a null value or type.
     *
     * @psalm-immutable
     */
    final class Null_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing an object.
     *
     * An object can be either typed or untyped. When an object is typed it means that it has an identifier, the FQSEN,
     * pointing to an element in PHP. Object types that are untyped do not refer to a specific class but represent objects
     * in general.
     *
     * @psalm-immutable
     */
    final class Object_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Initializes this object with an optional FQSEN, if not provided this object is considered 'untyped'.
         *
         * @throws InvalidArgumentException When provided $fqsen is not a valid type.
         */
        public function __construct(?\phpDocumentor\Reflection\Fqsen $fqsen = null)
        {
        }
        /**
         * Returns the FQSEN associated with this object.
         */
        public function getFqsen(): ?\phpDocumentor\Reflection\Fqsen
        {
        }
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the 'parent' type.
     *
     * Parent, as a Type, represents the parent class of class in which the associated element was defined.
     *
     * @psalm-immutable
     */
    final class Parent_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the 'resource' Type.
     *
     * @psalm-immutable
     */
    final class Resource_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the 'scalar' pseudo-type, which is either a string, integer, float or boolean.
     *
     * @psalm-immutable
     */
    final class Scalar implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the 'self' type.
     *
     * Self, as a Type, represents the class in which the associated element was defined.
     *
     * @psalm-immutable
     */
    final class Self_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the 'static' type.
     *
     * Self, as a Type, represents the class in which the associated element was called. This differs from self as self does
     * not take inheritance into account but static means that the return type is always that of the class of the called
     * element.
     *
     * See the documentation on late static binding in the PHP Documentation for more information on the difference between
     * static and self.
     *
     * @psalm-immutable
     */
    final class Static_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the '$this' pseudo-type.
     *
     * $this, as a Type, represents the instance of the class associated with the element as it was called. $this is
     * commonly used when documenting fluent interfaces since it represents that the same object is returned.
     *
     * @psalm-immutable
     */
    final class This implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
    /**
     * Value Object representing the return-type 'void'.
     *
     * Void is generally only used when working with return types as it signifies that the method intentionally does not
     * return any value.
     *
     * @psalm-immutable
     */
    final class Void_ implements \phpDocumentor\Reflection\Type
    {
        /**
         * Returns a rendered output of the Type as it would be used in a DocBlock.
         */
        public function __toString(): string
        {
        }
    }
}
namespace PHPMailer\PHPMailer {
    /**
     * Configure PHPMailer with DSN string.
     *
     * @see https://en.wikipedia.org/wiki/Data_source_name
     *
     * @author Oleg Voronkovich <oleg-voronkovich@yandex.ru>
     */
    class DSNConfigurator
    {
        /**
         * Create new PHPMailer instance configured by DSN.
         *
         * @param string $dsn        DSN
         * @param bool   $exceptions Should we throw external exceptions?
         *
         * @return PHPMailer
         */
        public static function mailer($dsn, $exceptions = null)
        {
        }
        /**
         * Configure PHPMailer instance with DSN string.
         *
         * @param PHPMailer $mailer PHPMailer instance
         * @param string    $dsn    DSN
         *
         * @return PHPMailer
         */
        public function configure(\PHPMailer\PHPMailer\PHPMailer $mailer, $dsn)
        {
        }
        /**
         * Parse a URL.
         * Wrapper for the built-in parse_url function to work around a bug in PHP 5.5.
         *
         * @param string $url URL
         *
         * @return array|false
         */
        protected function parseUrl($url)
        {
        }
    }
    /**
     * PHPMailer exception handler.
     *
     * @author Marcus Bointon <phpmailer@synchromedia.co.uk>
     */
    class Exception extends \Exception
    {
        /**
         * Prettify error message output.
         *
         * @return string
         */
        public function errorMessage()
        {
        }
    }
    /**
     * OAuthTokenProvider - OAuth2 token provider interface.
     * Provides base64 encoded OAuth2 auth strings for SMTP authentication.
     *
     * @see     OAuth
     * @see     SMTP::authenticate()
     *
     * @author  Peter Scopes (pdscopes)
     * @author  Marcus Bointon (Synchro/coolbru) <phpmailer@synchromedia.co.uk>
     */
    interface OAuthTokenProvider
    {
        /**
         * Generate a base64-encoded OAuth token ensuring that the access token has not expired.
         * The string to be base 64 encoded should be in the form:
         * "user=<user_email_address>\001auth=Bearer <access_token>\001\001"
         *
         * @return string
         */
        public function getOauth64();
    }
    /**
     * OAuth - OAuth2 authentication wrapper class.
     * Uses the oauth2-client package from the League of Extraordinary Packages.
     *
     * @see     https://oauth2-client.thephpleague.com
     *
     * @author  Marcus Bointon (Synchro/coolbru) <phpmailer@synchromedia.co.uk>
     */
    class OAuth implements \PHPMailer\PHPMailer\OAuthTokenProvider
    {
        /**
         * An instance of the League OAuth Client Provider.
         *
         * @var AbstractProvider
         */
        protected $provider;
        /**
         * The current OAuth access token.
         *
         * @var AccessToken
         */
        protected $oauthToken;
        /**
         * The user's email address, usually used as the login ID
         * and also the from address when sending email.
         *
         * @var string
         */
        protected $oauthUserEmail = '';
        /**
         * The client secret, generated in the app definition of the service you're connecting to.
         *
         * @var string
         */
        protected $oauthClientSecret = '';
        /**
         * The client ID, generated in the app definition of the service you're connecting to.
         *
         * @var string
         */
        protected $oauthClientId = '';
        /**
         * The refresh token, used to obtain new AccessTokens.
         *
         * @var string
         */
        protected $oauthRefreshToken = '';
        /**
         * OAuth constructor.
         *
         * @param array $options Associative array containing
         *                       `provider`, `userName`, `clientSecret`, `clientId` and `refreshToken` elements
         */
        public function __construct($options)
        {
        }
        /**
         * Get a new RefreshToken.
         *
         * @return RefreshToken
         */
        protected function getGrant()
        {
        }
        /**
         * Get a new AccessToken.
         *
         * @return AccessToken
         */
        protected function getToken()
        {
        }
        /**
         * Generate a base64-encoded OAuth token.
         *
         * @return string
         */
        public function getOauth64()
        {
        }
    }
    /**
     * PHPMailer - PHP email creation and transport class.
     *
     * @author Marcus Bointon (Synchro/coolbru) <phpmailer@synchromedia.co.uk>
     * @author Jim Jagielski (jimjag) <jimjag@gmail.com>
     * @author Andy Prevost (codeworxtech) <codeworxtech@users.sourceforge.net>
     * @author Brent R. Matzelle (original founder)
     */
    class PHPMailer
    {
        const CHARSET_ASCII = 'us-ascii';
        const CHARSET_ISO88591 = 'iso-8859-1';
        const CHARSET_UTF8 = 'utf-8';
        const CONTENT_TYPE_PLAINTEXT = 'text/plain';
        const CONTENT_TYPE_TEXT_CALENDAR = 'text/calendar';
        const CONTENT_TYPE_TEXT_HTML = 'text/html';
        const CONTENT_TYPE_MULTIPART_ALTERNATIVE = 'multipart/alternative';
        const CONTENT_TYPE_MULTIPART_MIXED = 'multipart/mixed';
        const CONTENT_TYPE_MULTIPART_RELATED = 'multipart/related';
        const ENCODING_7BIT = '7bit';
        const ENCODING_8BIT = '8bit';
        const ENCODING_BASE64 = 'base64';
        const ENCODING_BINARY = 'binary';
        const ENCODING_QUOTED_PRINTABLE = 'quoted-printable';
        const ENCRYPTION_STARTTLS = 'tls';
        const ENCRYPTION_SMTPS = 'ssl';
        const ICAL_METHOD_REQUEST = 'REQUEST';
        const ICAL_METHOD_PUBLISH = 'PUBLISH';
        const ICAL_METHOD_REPLY = 'REPLY';
        const ICAL_METHOD_ADD = 'ADD';
        const ICAL_METHOD_CANCEL = 'CANCEL';
        const ICAL_METHOD_REFRESH = 'REFRESH';
        const ICAL_METHOD_COUNTER = 'COUNTER';
        const ICAL_METHOD_DECLINECOUNTER = 'DECLINECOUNTER';
        /**
         * Email priority.
         * Options: null (default), 1 = High, 3 = Normal, 5 = low.
         * When null, the header is not set at all.
         *
         * @var int|null
         */
        public $Priority;
        /**
         * The character set of the message.
         *
         * @var string
         */
        public $CharSet = self::CHARSET_ISO88591;
        /**
         * The MIME Content-type of the message.
         *
         * @var string
         */
        public $ContentType = self::CONTENT_TYPE_PLAINTEXT;
        /**
         * The message encoding.
         * Options: "8bit", "7bit", "binary", "base64", and "quoted-printable".
         *
         * @var string
         */
        public $Encoding = self::ENCODING_8BIT;
        /**
         * Holds the most recent mailer error message.
         *
         * @var string
         */
        public $ErrorInfo = '';
        /**
         * The From email address for the message.
         *
         * @var string
         */
        public $From = '';
        /**
         * The From name of the message.
         *
         * @var string
         */
        public $FromName = '';
        /**
         * The envelope sender of the message.
         * This will usually be turned into a Return-Path header by the receiver,
         * and is the address that bounces will be sent to.
         * If not empty, will be passed via `-f` to sendmail or as the 'MAIL FROM' value over SMTP.
         *
         * @var string
         */
        public $Sender = '';
        /**
         * The Subject of the message.
         *
         * @var string
         */
        public $Subject = '';
        /**
         * An HTML or plain text message body.
         * If HTML then call isHTML(true).
         *
         * @var string
         */
        public $Body = '';
        /**
         * The plain-text message body.
         * This body can be read by mail clients that do not have HTML email
         * capability such as mutt & Eudora.
         * Clients that can read HTML will view the normal Body.
         *
         * @var string
         */
        public $AltBody = '';
        /**
         * An iCal message part body.
         * Only supported in simple alt or alt_inline message types
         * To generate iCal event structures, use classes like EasyPeasyICS or iCalcreator.
         *
         * @see https://kigkonsult.se/iCalcreator/
         *
         * @var string
         */
        public $Ical = '';
        /**
         * Value-array of "method" in Contenttype header "text/calendar"
         *
         * @var string[]
         */
        protected static $IcalMethods = [self::ICAL_METHOD_REQUEST, self::ICAL_METHOD_PUBLISH, self::ICAL_METHOD_REPLY, self::ICAL_METHOD_ADD, self::ICAL_METHOD_CANCEL, self::ICAL_METHOD_REFRESH, self::ICAL_METHOD_COUNTER, self::ICAL_METHOD_DECLINECOUNTER];
        /**
         * The complete compiled MIME message body.
         *
         * @var string
         */
        protected $MIMEBody = '';
        /**
         * The complete compiled MIME message headers.
         *
         * @var string
         */
        protected $MIMEHeader = '';
        /**
         * Extra headers that createHeader() doesn't fold in.
         *
         * @var string
         */
        protected $mailHeader = '';
        /**
         * Word-wrap the message body to this number of chars.
         * Set to 0 to not wrap. A useful value here is 78, for RFC2822 section 2.1.1 compliance.
         *
         * @see static::STD_LINE_LENGTH
         *
         * @var int
         */
        public $WordWrap = 0;
        /**
         * Which method to use to send mail.
         * Options: "mail", "sendmail", or "smtp".
         *
         * @var string
         */
        public $Mailer = 'mail';
        /**
         * The path to the sendmail program.
         *
         * @var string
         */
        public $Sendmail = '/usr/sbin/sendmail';
        /**
         * Whether mail() uses a fully sendmail-compatible MTA.
         * One which supports sendmail's "-oi -f" options.
         *
         * @var bool
         */
        public $UseSendmailOptions = true;
        /**
         * The email address that a reading confirmation should be sent to, also known as read receipt.
         *
         * @var string
         */
        public $ConfirmReadingTo = '';
        /**
         * The hostname to use in the Message-ID header and as default HELO string.
         * If empty, PHPMailer attempts to find one with, in order,
         * $_SERVER['SERVER_NAME'], gethostname(), php_uname('n'), or the value
         * 'localhost.localdomain'.
         *
         * @see PHPMailer::$Helo
         *
         * @var string
         */
        public $Hostname = '';
        /**
         * An ID to be used in the Message-ID header.
         * If empty, a unique id will be generated.
         * You can set your own, but it must be in the format "<id@domain>",
         * as defined in RFC5322 section 3.6.4 or it will be ignored.
         *
         * @see https://www.rfc-editor.org/rfc/rfc5322#section-3.6.4
         *
         * @var string
         */
        public $MessageID = '';
        /**
         * The message Date to be used in the Date header.
         * If empty, the current date will be added.
         *
         * @var string
         */
        public $MessageDate = '';
        /**
         * SMTP hosts.
         * Either a single hostname or multiple semicolon-delimited hostnames.
         * You can also specify a different port
         * for each host by using this format: [hostname:port]
         * (e.g. "smtp1.example.com:25;smtp2.example.com").
         * You can also specify encryption type, for example:
         * (e.g. "tls://smtp1.example.com:587;ssl://smtp2.example.com:465").
         * Hosts will be tried in order.
         *
         * @var string
         */
        public $Host = 'localhost';
        /**
         * The default SMTP server port.
         *
         * @var int
         */
        public $Port = 25;
        /**
         * The SMTP HELO/EHLO name used for the SMTP connection.
         * Default is $Hostname. If $Hostname is empty, PHPMailer attempts to find
         * one with the same method described above for $Hostname.
         *
         * @see PHPMailer::$Hostname
         *
         * @var string
         */
        public $Helo = '';
        /**
         * What kind of encryption to use on the SMTP connection.
         * Options: '', static::ENCRYPTION_STARTTLS, or static::ENCRYPTION_SMTPS.
         *
         * @var string
         */
        public $SMTPSecure = '';
        /**
         * Whether to enable TLS encryption automatically if a server supports it,
         * even if `SMTPSecure` is not set to 'tls'.
         * Be aware that in PHP >= 5.6 this requires that the server's certificates are valid.
         *
         * @var bool
         */
        public $SMTPAutoTLS = true;
        /**
         * Whether to use SMTP authentication.
         * Uses the Username and Password properties.
         *
         * @see PHPMailer::$Username
         * @see PHPMailer::$Password
         *
         * @var bool
         */
        public $SMTPAuth = false;
        /**
         * Options array passed to stream_context_create when connecting via SMTP.
         *
         * @var array
         */
        public $SMTPOptions = [];
        /**
         * SMTP username.
         *
         * @var string
         */
        public $Username = '';
        /**
         * SMTP password.
         *
         * @var string
         */
        public $Password = '';
        /**
         * SMTP authentication type. Options are CRAM-MD5, LOGIN, PLAIN, XOAUTH2.
         * If not specified, the first one from that list that the server supports will be selected.
         *
         * @var string
         */
        public $AuthType = '';
        /**
         * SMTP SMTPXClient command attributes
         *
         * @var array
         */
        protected $SMTPXClient = [];
        /**
         * An implementation of the PHPMailer OAuthTokenProvider interface.
         *
         * @var OAuthTokenProvider
         */
        protected $oauth;
        /**
         * The SMTP server timeout in seconds.
         * Default of 5 minutes (300sec) is from RFC2821 section 4.5.3.2.
         *
         * @var int
         */
        public $Timeout = 300;
        /**
         * Comma separated list of DSN notifications
         * 'NEVER' under no circumstances a DSN must be returned to the sender.
         *         If you use NEVER all other notifications will be ignored.
         * 'SUCCESS' will notify you when your mail has arrived at its destination.
         * 'FAILURE' will arrive if an error occurred during delivery.
         * 'DELAY'   will notify you if there is an unusual delay in delivery, but the actual
         *           delivery's outcome (success or failure) is not yet decided.
         *
         * @see https://www.rfc-editor.org/rfc/rfc3461.html#section-4.1 for more information about NOTIFY
         */
        public $dsn = '';
        /**
         * SMTP class debug output mode.
         * Debug output level.
         * Options:
         * @see SMTP::DEBUG_OFF: No output
         * @see SMTP::DEBUG_CLIENT: Client messages
         * @see SMTP::DEBUG_SERVER: Client and server messages
         * @see SMTP::DEBUG_CONNECTION: As SERVER plus connection status
         * @see SMTP::DEBUG_LOWLEVEL: Noisy, low-level data output, rarely needed
         *
         * @see SMTP::$do_debug
         *
         * @var int
         */
        public $SMTPDebug = 0;
        /**
         * How to handle debug output.
         * Options:
         * * `echo` Output plain-text as-is, appropriate for CLI
         * * `html` Output escaped, line breaks converted to `<br>`, appropriate for browser output
         * * `error_log` Output to error log as configured in php.ini
         * By default PHPMailer will use `echo` if run from a `cli` or `cli-server` SAPI, `html` otherwise.
         * Alternatively, you can provide a callable expecting two params: a message string and the debug level:
         *
         * ```php
         * $mail->Debugoutput = function($str, $level) {echo "debug level $level; message: $str";};
         * ```
         *
         * Alternatively, you can pass in an instance of a PSR-3 compatible logger, though only `debug`
         * level output is used:
         *
         * ```php
         * $mail->Debugoutput = new myPsr3Logger;
         * ```
         *
         * @see SMTP::$Debugoutput
         *
         * @var string|callable|\Psr\Log\LoggerInterface
         */
        public $Debugoutput = 'echo';
        /**
         * Whether to keep the SMTP connection open after each message.
         * If this is set to true then the connection will remain open after a send,
         * and closing the connection will require an explicit call to smtpClose().
         * It's a good idea to use this if you are sending multiple messages as it reduces overhead.
         * See the mailing list example for how to use it.
         *
         * @var bool
         */
        public $SMTPKeepAlive = false;
        /**
         * Whether to split multiple to addresses into multiple messages
         * or send them all in one message.
         * Only supported in `mail` and `sendmail` transports, not in SMTP.
         *
         * @var bool
         *
         * @deprecated 6.0.0 PHPMailer isn't a mailing list manager!
         */
        public $SingleTo = false;
        /**
         * Storage for addresses when SingleTo is enabled.
         *
         * @var array
         */
        protected $SingleToArray = [];
        /**
         * Whether to generate VERP addresses on send.
         * Only applicable when sending via SMTP.
         *
         * @see https://en.wikipedia.org/wiki/Variable_envelope_return_path
         * @see https://www.postfix.org/VERP_README.html Postfix VERP info
         *
         * @var bool
         */
        public $do_verp = false;
        /**
         * Whether to allow sending messages with an empty body.
         *
         * @var bool
         */
        public $AllowEmpty = false;
        /**
         * DKIM selector.
         *
         * @var string
         */
        public $DKIM_selector = '';
        /**
         * DKIM Identity.
         * Usually the email address used as the source of the email.
         *
         * @var string
         */
        public $DKIM_identity = '';
        /**
         * DKIM passphrase.
         * Used if your key is encrypted.
         *
         * @var string
         */
        public $DKIM_passphrase = '';
        /**
         * DKIM signing domain name.
         *
         * @example 'example.com'
         *
         * @var string
         */
        public $DKIM_domain = '';
        /**
         * DKIM Copy header field values for diagnostic use.
         *
         * @var bool
         */
        public $DKIM_copyHeaderFields = true;
        /**
         * DKIM Extra signing headers.
         *
         * @example ['List-Unsubscribe', 'List-Help']
         *
         * @var array
         */
        public $DKIM_extraHeaders = [];
        /**
         * DKIM private key file path.
         *
         * @var string
         */
        public $DKIM_private = '';
        /**
         * DKIM private key string.
         *
         * If set, takes precedence over `$DKIM_private`.
         *
         * @var string
         */
        public $DKIM_private_string = '';
        /**
         * Callback Action function name.
         *
         * The function that handles the result of the send email action.
         * It is called out by send() for each email sent.
         *
         * Value can be any php callable: https://www.php.net/is_callable
         *
         * Parameters:
         *   bool $result           result of the send action
         *   array   $to            email addresses of the recipients
         *   array   $cc            cc email addresses
         *   array   $bcc           bcc email addresses
         *   string  $subject       the subject
         *   string  $body          the email body
         *   string  $from          email address of sender
         *   string  $extra         extra information of possible use
         *                          "smtp_transaction_id' => last smtp transaction id
         *
         * @var string
         */
        public $action_function = '';
        /**
         * What to put in the X-Mailer header.
         * Options: An empty string for PHPMailer default, whitespace/null for none, or a string to use.
         *
         * @var string|null
         */
        public $XMailer = '';
        /**
         * Which validator to use by default when validating email addresses.
         * May be a callable to inject your own validator, but there are several built-in validators.
         * The default validator uses PHP's FILTER_VALIDATE_EMAIL filter_var option.
         *
         * @see PHPMailer::validateAddress()
         *
         * @var string|callable
         */
        public static $validator = 'php';
        /**
         * An instance of the SMTP sender class.
         *
         * @var SMTP
         */
        protected $smtp;
        /**
         * The array of 'to' names and addresses.
         *
         * @var array
         */
        protected $to = [];
        /**
         * The array of 'cc' names and addresses.
         *
         * @var array
         */
        protected $cc = [];
        /**
         * The array of 'bcc' names and addresses.
         *
         * @var array
         */
        protected $bcc = [];
        /**
         * The array of reply-to names and addresses.
         *
         * @var array
         */
        protected $ReplyTo = [];
        /**
         * An array of all kinds of addresses.
         * Includes all of $to, $cc, $bcc.
         *
         * @see PHPMailer::$to
         * @see PHPMailer::$cc
         * @see PHPMailer::$bcc
         *
         * @var array
         */
        protected $all_recipients = [];
        /**
         * An array of names and addresses queued for validation.
         * In send(), valid and non duplicate entries are moved to $all_recipients
         * and one of $to, $cc, or $bcc.
         * This array is used only for addresses with IDN.
         *
         * @see PHPMailer::$to
         * @see PHPMailer::$cc
         * @see PHPMailer::$bcc
         * @see PHPMailer::$all_recipients
         *
         * @var array
         */
        protected $RecipientsQueue = [];
        /**
         * An array of reply-to names and addresses queued for validation.
         * In send(), valid and non duplicate entries are moved to $ReplyTo.
         * This array is used only for addresses with IDN.
         *
         * @see PHPMailer::$ReplyTo
         *
         * @var array
         */
        protected $ReplyToQueue = [];
        /**
         * The array of attachments.
         *
         * @var array
         */
        protected $attachment = [];
        /**
         * The array of custom headers.
         *
         * @var array
         */
        protected $CustomHeader = [];
        /**
         * The most recent Message-ID (including angular brackets).
         *
         * @var string
         */
        protected $lastMessageID = '';
        /**
         * The message's MIME type.
         *
         * @var string
         */
        protected $message_type = '';
        /**
         * The array of MIME boundary strings.
         *
         * @var array
         */
        protected $boundary = [];
        /**
         * The array of available text strings for the current language.
         *
         * @var array
         */
        protected $language = [];
        /**
         * The number of errors encountered.
         *
         * @var int
         */
        protected $error_count = 0;
        /**
         * The S/MIME certificate file path.
         *
         * @var string
         */
        protected $sign_cert_file = '';
        /**
         * The S/MIME key file path.
         *
         * @var string
         */
        protected $sign_key_file = '';
        /**
         * The optional S/MIME extra certificates ("CA Chain") file path.
         *
         * @var string
         */
        protected $sign_extracerts_file = '';
        /**
         * The S/MIME password for the key.
         * Used only if the key is encrypted.
         *
         * @var string
         */
        protected $sign_key_pass = '';
        /**
         * Whether to throw exceptions for errors.
         *
         * @var bool
         */
        protected $exceptions = false;
        /**
         * Unique ID used for message ID and boundaries.
         *
         * @var string
         */
        protected $uniqueid = '';
        /**
         * The PHPMailer Version number.
         *
         * @var string
         */
        const VERSION = '6.9.3';
        /**
         * Error severity: message only, continue processing.
         *
         * @var int
         */
        const STOP_MESSAGE = 0;
        /**
         * Error severity: message, likely ok to continue processing.
         *
         * @var int
         */
        const STOP_CONTINUE = 1;
        /**
         * Error severity: message, plus full stop, critical error reached.
         *
         * @var int
         */
        const STOP_CRITICAL = 2;
        /**
         * The SMTP standard CRLF line break.
         * If you want to change line break format, change static::$LE, not this.
         */
        const CRLF = "\r\n";
        /**
         * "Folding White Space" a white space string used for line folding.
         */
        const FWS = ' ';
        /**
         * SMTP RFC standard line ending; Carriage Return, Line Feed.
         *
         * @var string
         */
        protected static $LE = self::CRLF;
        /**
         * The maximum line length supported by mail().
         *
         * Background: mail() will sometimes corrupt messages
         * with headers longer than 65 chars, see #818.
         *
         * @var int
         */
        const MAIL_MAX_LINE_LENGTH = 63;
        /**
         * The maximum line length allowed by RFC 2822 section 2.1.1.
         *
         * @var int
         */
        const MAX_LINE_LENGTH = 998;
        /**
         * The lower maximum line length allowed by RFC 2822 section 2.1.1.
         * This length does NOT include the line break
         * 76 means that lines will be 77 or 78 chars depending on whether
         * the line break format is LF or CRLF; both are valid.
         *
         * @var int
         */
        const STD_LINE_LENGTH = 76;
        /**
         * Constructor.
         *
         * @param bool $exceptions Should we throw external exceptions?
         */
        public function __construct($exceptions = null)
        {
        }
        /**
         * Destructor.
         */
        public function __destruct()
        {
        }
        /**
         * Output debugging info via a user-defined method.
         * Only generates output if debug output is enabled.
         *
         * @see PHPMailer::$Debugoutput
         * @see PHPMailer::$SMTPDebug
         *
         * @param string $str
         */
        protected function edebug($str)
        {
        }
        /**
         * Sets message type to HTML or plain.
         *
         * @param bool $isHtml True for HTML mode
         */
        public function isHTML($isHtml = true)
        {
        }
        /**
         * Send messages using SMTP.
         */
        public function isSMTP()
        {
        }
        /**
         * Send messages using PHP's mail() function.
         */
        public function isMail()
        {
        }
        /**
         * Send messages using $Sendmail.
         */
        public function isSendmail()
        {
        }
        /**
         * Send messages using qmail.
         */
        public function isQmail()
        {
        }
        /**
         * Add a "To" address.
         *
         * @param string $address The email address to send to
         * @param string $name
         *
         * @throws Exception
         *
         * @return bool true on success, false if address already used or invalid in some way
         */
        public function addAddress($address, $name = '')
        {
        }
        /**
         * Add a "CC" address.
         *
         * @param string $address The email address to send to
         * @param string $name
         *
         * @throws Exception
         *
         * @return bool true on success, false if address already used or invalid in some way
         */
        public function addCC($address, $name = '')
        {
        }
        /**
         * Add a "BCC" address.
         *
         * @param string $address The email address to send to
         * @param string $name
         *
         * @throws Exception
         *
         * @return bool true on success, false if address already used or invalid in some way
         */
        public function addBCC($address, $name = '')
        {
        }
        /**
         * Add a "Reply-To" address.
         *
         * @param string $address The email address to reply to
         * @param string $name
         *
         * @throws Exception
         *
         * @return bool true on success, false if address already used or invalid in some way
         */
        public function addReplyTo($address, $name = '')
        {
        }
        /**
         * Add an address to one of the recipient arrays or to the ReplyTo array. Because PHPMailer
         * can't validate addresses with an IDN without knowing the PHPMailer::$CharSet (that can still
         * be modified after calling this function), addition of such addresses is delayed until send().
         * Addresses that have been added already return false, but do not throw exceptions.
         *
         * @param string $kind    One of 'to', 'cc', 'bcc', or 'Reply-To'
         * @param string $address The email address
         * @param string $name    An optional username associated with the address
         *
         * @throws Exception
         *
         * @return bool true on success, false if address already used or invalid in some way
         */
        protected function addOrEnqueueAnAddress($kind, $address, $name)
        {
        }
        /**
         * Set the boundaries to use for delimiting MIME parts.
         * If you override this, ensure you set all 3 boundaries to unique values.
         * The default boundaries include a "=_" sequence which cannot occur in quoted-printable bodies,
         * as suggested by https://www.rfc-editor.org/rfc/rfc2045#section-6.7
         *
         * @return void
         */
        public function setBoundaries()
        {
        }
        /**
         * Add an address to one of the recipient arrays or to the ReplyTo array.
         * Addresses that have been added already return false, but do not throw exceptions.
         *
         * @param string $kind    One of 'to', 'cc', 'bcc', or 'ReplyTo'
         * @param string $address The email address to send, resp. to reply to
         * @param string $name
         *
         * @throws Exception
         *
         * @return bool true on success, false if address already used or invalid in some way
         */
        protected function addAnAddress($kind, $address, $name = '')
        {
        }
        /**
         * Parse and validate a string containing one or more RFC822-style comma-separated email addresses
         * of the form "display name <address>" into an array of name/address pairs.
         * Uses the imap_rfc822_parse_adrlist function if the IMAP extension is available.
         * Note that quotes in the name part are removed.
         *
         * @see https://www.andrew.cmu.edu/user/agreen1/testing/mrbs/web/Mail/RFC822.php A more careful implementation
         *
         * @param string $addrstr The address list string
         * @param bool   $useimap Whether to use the IMAP extension to parse the list
         * @param string $charset The charset to use when decoding the address list string.
         *
         * @return array
         */
        public static function parseAddresses($addrstr, $useimap = true, $charset = self::CHARSET_ISO88591)
        {
        }
        /**
         * Set the From and FromName properties.
         *
         * @param string $address
         * @param string $name
         * @param bool   $auto    Whether to also set the Sender address, defaults to true
         *
         * @throws Exception
         *
         * @return bool
         */
        public function setFrom($address, $name = '', $auto = true)
        {
        }
        /**
         * Return the Message-ID header of the last email.
         * Technically this is the value from the last time the headers were created,
         * but it's also the message ID of the last sent message except in
         * pathological cases.
         *
         * @return string
         */
        public function getLastMessageID()
        {
        }
        /**
         * Check that a string looks like an email address.
         * Validation patterns supported:
         * * `auto` Pick best pattern automatically;
         * * `pcre8` Use the squiloople.com pattern, requires PCRE > 8.0;
         * * `pcre` Use old PCRE implementation;
         * * `php` Use PHP built-in FILTER_VALIDATE_EMAIL;
         * * `html5` Use the pattern given by the HTML5 spec for 'email' type form input elements.
         * * `noregex` Don't use a regex: super fast, really dumb.
         * Alternatively you may pass in a callable to inject your own validator, for example:
         *
         * ```php
         * PHPMailer::validateAddress('user@example.com', function($address) {
         *     return (strpos($address, '@') !== false);
         * });
         * ```
         *
         * You can also set the PHPMailer::$validator static to a callable, allowing built-in methods to use your validator.
         *
         * @param string          $address       The email address to check
         * @param string|callable $patternselect Which pattern to use
         *
         * @return bool
         */
        public static function validateAddress($address, $patternselect = null)
        {
        }
        /**
         * Tells whether IDNs (Internationalized Domain Names) are supported or not. This requires the
         * `intl` and `mbstring` PHP extensions.
         *
         * @return bool `true` if required functions for IDN support are present
         */
        public static function idnSupported()
        {
        }
        /**
         * Converts IDN in given email address to its ASCII form, also known as punycode, if possible.
         * Important: Address must be passed in same encoding as currently set in PHPMailer::$CharSet.
         * This function silently returns unmodified address if:
         * - No conversion is necessary (i.e. domain name is not an IDN, or is already in ASCII form)
         * - Conversion to punycode is impossible (e.g. required PHP functions are not available)
         *   or fails for any reason (e.g. domain contains characters not allowed in an IDN).
         *
         * @see PHPMailer::$CharSet
         *
         * @param string $address The email address to convert
         *
         * @return string The encoded address in ASCII form
         */
        public function punyencodeAddress($address)
        {
        }
        /**
         * Create a message and send it.
         * Uses the sending method specified by $Mailer.
         *
         * @throws Exception
         *
         * @return bool false on error - See the ErrorInfo property for details of the error
         */
        public function send()
        {
        }
        /**
         * Prepare a message for sending.
         *
         * @throws Exception
         *
         * @return bool
         */
        public function preSend()
        {
        }
        /**
         * Actually send a message via the selected mechanism.
         *
         * @throws Exception
         *
         * @return bool
         */
        public function postSend()
        {
        }
        /**
         * Send mail using the $Sendmail program.
         *
         * @see PHPMailer::$Sendmail
         *
         * @param string $header The message headers
         * @param string $body   The message body
         *
         * @throws Exception
         *
         * @return bool
         */
        protected function sendmailSend($header, $body)
        {
        }
        /**
         * Fix CVE-2016-10033 and CVE-2016-10045 by disallowing potentially unsafe shell characters.
         * Note that escapeshellarg and escapeshellcmd are inadequate for our purposes, especially on Windows.
         *
         * @see https://github.com/PHPMailer/PHPMailer/issues/924 CVE-2016-10045 bug report
         *
         * @param string $string The string to be validated
         *
         * @return bool
         */
        protected static function isShellSafe($string)
        {
        }
        /**
         * Check whether a file path is of a permitted type.
         * Used to reject URLs and phar files from functions that access local file paths,
         * such as addAttachment.
         *
         * @param string $path A relative or absolute path to a file
         *
         * @return bool
         */
        protected static function isPermittedPath($path)
        {
        }
        /**
         * Check whether a file path is safe, accessible, and readable.
         *
         * @param string $path A relative or absolute path to a file
         *
         * @return bool
         */
        protected static function fileIsAccessible($path)
        {
        }
        /**
         * Send mail using the PHP mail() function.
         *
         * @see https://www.php.net/manual/en/book.mail.php
         *
         * @param string $header The message headers
         * @param string $body   The message body
         *
         * @throws Exception
         *
         * @return bool
         */
        protected function mailSend($header, $body)
        {
        }
        /**
         * Get an instance to use for SMTP operations.
         * Override this function to load your own SMTP implementation,
         * or set one with setSMTPInstance.
         *
         * @return SMTP
         */
        public function getSMTPInstance()
        {
        }
        /**
         * Provide an instance to use for SMTP operations.
         *
         * @return SMTP
         */
        public function setSMTPInstance(\PHPMailer\PHPMailer\SMTP $smtp)
        {
        }
        /**
         * Provide SMTP XCLIENT attributes
         *
         * @param string $name  Attribute name
         * @param ?string $value Attribute value
         *
         * @return bool
         */
        public function setSMTPXclientAttribute($name, $value)
        {
        }
        /**
         * Get SMTP XCLIENT attributes
         *
         * @return array
         */
        public function getSMTPXclientAttributes()
        {
        }
        /**
         * Send mail via SMTP.
         * Returns false if there is a bad MAIL FROM, RCPT, or DATA input.
         *
         * @see PHPMailer::setSMTPInstance() to use a different class.
         *
         * @uses \PHPMailer\PHPMailer\SMTP
         *
         * @param string $header The message headers
         * @param string $body   The message body
         *
         * @throws Exception
         *
         * @return bool
         */
        protected function smtpSend($header, $body)
        {
        }
        /**
         * Initiate a connection to an SMTP server.
         * Returns false if the operation failed.
         *
         * @param array $options An array of options compatible with stream_context_create()
         *
         * @throws Exception
         *
         * @uses \PHPMailer\PHPMailer\SMTP
         *
         * @return bool
         */
        public function smtpConnect($options = null)
        {
        }
        /**
         * Close the active SMTP session if one exists.
         */
        public function smtpClose()
        {
        }
        /**
         * Set the language for error messages.
         * The default language is English.
         *
         * @param string $langcode  ISO 639-1 2-character language code (e.g. French is "fr")
         *                          Optionally, the language code can be enhanced with a 4-character
         *                          script annotation and/or a 2-character country annotation.
         * @param string $lang_path Path to the language file directory, with trailing separator (slash)
         *                          Do not set this from user input!
         *
         * @return bool Returns true if the requested language was loaded, false otherwise.
         */
        public function setLanguage($langcode = 'en', $lang_path = '')
        {
        }
        /**
         * Get the array of strings for the current language.
         *
         * @return array
         */
        public function getTranslations()
        {
        }
        /**
         * Create recipient headers.
         *
         * @param string $type
         * @param array  $addr An array of recipients,
         *                     where each recipient is a 2-element indexed array with element 0 containing an address
         *                     and element 1 containing a name, like:
         *                     [['joe@example.com', 'Joe User'], ['zoe@example.com', 'Zoe User']]
         *
         * @return string
         */
        public function addrAppend($type, $addr)
        {
        }
        /**
         * Format an address for use in a message header.
         *
         * @param array $addr A 2-element indexed array, element 0 containing an address, element 1 containing a name like
         *                    ['joe@example.com', 'Joe User']
         *
         * @return string
         */
        public function addrFormat($addr)
        {
        }
        /**
         * Word-wrap message.
         * For use with mailers that do not automatically perform wrapping
         * and for quoted-printable encoded messages.
         * Original written by philippe.
         *
         * @param string $message The message to wrap
         * @param int    $length  The line length to wrap to
         * @param bool   $qp_mode Whether to run in Quoted-Printable mode
         *
         * @return string
         */
        public function wrapText($message, $length, $qp_mode = false)
        {
        }
        /**
         * Find the last character boundary prior to $maxLength in a utf-8
         * quoted-printable encoded string.
         * Original written by Colin Brown.
         *
         * @param string $encodedText utf-8 QP text
         * @param int    $maxLength   Find the last character boundary prior to this length
         *
         * @return int
         */
        public function utf8CharBoundary($encodedText, $maxLength)
        {
        }
        /**
         * Apply word wrapping to the message body.
         * Wraps the message body to the number of chars set in the WordWrap property.
         * You should only do this to plain-text bodies as wrapping HTML tags may break them.
         * This is called automatically by createBody(), so you don't need to call it yourself.
         */
        public function setWordWrap()
        {
        }
        /**
         * Assemble message headers.
         *
         * @return string The assembled headers
         */
        public function createHeader()
        {
        }
        /**
         * Get the message MIME type headers.
         *
         * @return string
         */
        public function getMailMIME()
        {
        }
        /**
         * Returns the whole MIME message.
         * Includes complete headers and body.
         * Only valid post preSend().
         *
         * @see PHPMailer::preSend()
         *
         * @return string
         */
        public function getSentMIMEMessage()
        {
        }
        /**
         * Create a unique ID to use for boundaries.
         *
         * @return string
         */
        protected function generateId()
        {
        }
        /**
         * Assemble the message body.
         * Returns an empty string on failure.
         *
         * @throws Exception
         *
         * @return string The assembled message body
         */
        public function createBody()
        {
        }
        /**
         * Get the boundaries that this message will use
         * @return array
         */
        public function getBoundaries()
        {
        }
        /**
         * Return the start of a message boundary.
         *
         * @param string $boundary
         * @param string $charSet
         * @param string $contentType
         * @param string $encoding
         *
         * @return string
         */
        protected function getBoundary($boundary, $charSet, $contentType, $encoding)
        {
        }
        /**
         * Return the end of a message boundary.
         *
         * @param string $boundary
         *
         * @return string
         */
        protected function endBoundary($boundary)
        {
        }
        /**
         * Set the message type.
         * PHPMailer only supports some preset message types, not arbitrary MIME structures.
         */
        protected function setMessageType()
        {
        }
        /**
         * Format a header line.
         *
         * @param string     $name
         * @param string|int $value
         *
         * @return string
         */
        public function headerLine($name, $value)
        {
        }
        /**
         * Return a formatted mail line.
         *
         * @param string $value
         *
         * @return string
         */
        public function textLine($value)
        {
        }
        /**
         * Add an attachment from a path on the filesystem.
         * Never use a user-supplied path to a file!
         * Returns false if the file could not be found or read.
         * Explicitly *does not* support passing URLs; PHPMailer is not an HTTP client.
         * If you need to do that, fetch the resource yourself and pass it in via a local file or string.
         *
         * @param string $path        Path to the attachment
         * @param string $name        Overrides the attachment name
         * @param string $encoding    File encoding (see $Encoding)
         * @param string $type        MIME type, e.g. `image/jpeg`; determined automatically from $path if not specified
         * @param string $disposition Disposition to use
         *
         * @throws Exception
         *
         * @return bool
         */
        public function addAttachment($path, $name = '', $encoding = self::ENCODING_BASE64, $type = '', $disposition = 'attachment')
        {
        }
        /**
         * Return the array of attachments.
         *
         * @return array
         */
        public function getAttachments()
        {
        }
        /**
         * Attach all file, string, and binary attachments to the message.
         * Returns an empty string on failure.
         *
         * @param string $disposition_type
         * @param string $boundary
         *
         * @throws Exception
         *
         * @return string
         */
        protected function attachAll($disposition_type, $boundary)
        {
        }
        /**
         * Encode a file attachment in requested format.
         * Returns an empty string on failure.
         *
         * @param string $path     The full path to the file
         * @param string $encoding The encoding to use; one of 'base64', '7bit', '8bit', 'binary', 'quoted-printable'
         *
         * @return string
         */
        protected function encodeFile($path, $encoding = self::ENCODING_BASE64)
        {
        }
        /**
         * Encode a string in requested format.
         * Returns an empty string on failure.
         *
         * @param string $str      The text to encode
         * @param string $encoding The encoding to use; one of 'base64', '7bit', '8bit', 'binary', 'quoted-printable'
         *
         * @throws Exception
         *
         * @return string
         */
        public function encodeString($str, $encoding = self::ENCODING_BASE64)
        {
        }
        /**
         * Encode a header value (not including its label) optimally.
         * Picks shortest of Q, B, or none. Result includes folding if needed.
         * See RFC822 definitions for phrase, comment and text positions.
         *
         * @param string $str      The header value to encode
         * @param string $position What context the string will be used in
         *
         * @return string
         */
        public function encodeHeader($str, $position = 'text')
        {
        }
        /**
         * Check if a string contains multi-byte characters.
         *
         * @param string $str multi-byte text to wrap encode
         *
         * @return bool
         */
        public function hasMultiBytes($str)
        {
        }
        /**
         * Does a string contain any 8-bit chars (in any charset)?
         *
         * @param string $text
         *
         * @return bool
         */
        public function has8bitChars($text)
        {
        }
        /**
         * Encode and wrap long multibyte strings for mail headers
         * without breaking lines within a character.
         * Adapted from a function by paravoid.
         *
         * @see https://www.php.net/manual/en/function.mb-encode-mimeheader.php#60283
         *
         * @param string $str       multi-byte text to wrap encode
         * @param string $linebreak string to use as linefeed/end-of-line
         *
         * @return string
         */
        public function base64EncodeWrapMB($str, $linebreak = null)
        {
        }
        /**
         * Encode a string in quoted-printable format.
         * According to RFC2045 section 6.7.
         *
         * @param string $string The text to encode
         *
         * @return string
         */
        public function encodeQP($string)
        {
        }
        /**
         * Encode a string using Q encoding.
         *
         * @see https://www.rfc-editor.org/rfc/rfc2047#section-4.2
         *
         * @param string $str      the text to encode
         * @param string $position Where the text is going to be used, see the RFC for what that means
         *
         * @return string
         */
        public function encodeQ($str, $position = 'text')
        {
        }
        /**
         * Add a string or binary attachment (non-filesystem).
         * This method can be used to attach ascii or binary data,
         * such as a BLOB record from a database.
         *
         * @param string $string      String attachment data
         * @param string $filename    Name of the attachment
         * @param string $encoding    File encoding (see $Encoding)
         * @param string $type        File extension (MIME) type
         * @param string $disposition Disposition to use
         *
         * @throws Exception
         *
         * @return bool True on successfully adding an attachment
         */
        public function addStringAttachment($string, $filename, $encoding = self::ENCODING_BASE64, $type = '', $disposition = 'attachment')
        {
        }
        /**
         * Add an embedded (inline) attachment from a file.
         * This can include images, sounds, and just about any other document type.
         * These differ from 'regular' attachments in that they are intended to be
         * displayed inline with the message, not just attached for download.
         * This is used in HTML messages that embed the images
         * the HTML refers to using the `$cid` value in `img` tags, for example `<img src="cid:mylogo">`.
         * Never use a user-supplied path to a file!
         *
         * @param string $path        Path to the attachment
         * @param string $cid         Content ID of the attachment; Use this to reference
         *                            the content when using an embedded image in HTML
         * @param string $name        Overrides the attachment filename
         * @param string $encoding    File encoding (see $Encoding) defaults to `base64`
         * @param string $type        File MIME type (by default mapped from the `$path` filename's extension)
         * @param string $disposition Disposition to use: `inline` (default) or `attachment`
         *                            (unlikely you want this – {@see `addAttachment()`} instead)
         *
         * @return bool True on successfully adding an attachment
         * @throws Exception
         *
         */
        public function addEmbeddedImage($path, $cid, $name = '', $encoding = self::ENCODING_BASE64, $type = '', $disposition = 'inline')
        {
        }
        /**
         * Add an embedded stringified attachment.
         * This can include images, sounds, and just about any other document type.
         * If your filename doesn't contain an extension, be sure to set the $type to an appropriate MIME type.
         *
         * @param string $string      The attachment binary data
         * @param string $cid         Content ID of the attachment; Use this to reference
         *                            the content when using an embedded image in HTML
         * @param string $name        A filename for the attachment. If this contains an extension,
         *                            PHPMailer will attempt to set a MIME type for the attachment.
         *                            For example 'file.jpg' would get an 'image/jpeg' MIME type.
         * @param string $encoding    File encoding (see $Encoding), defaults to 'base64'
         * @param string $type        MIME type - will be used in preference to any automatically derived type
         * @param string $disposition Disposition to use
         *
         * @throws Exception
         *
         * @return bool True on successfully adding an attachment
         */
        public function addStringEmbeddedImage($string, $cid, $name = '', $encoding = self::ENCODING_BASE64, $type = '', $disposition = 'inline')
        {
        }
        /**
         * Validate encodings.
         *
         * @param string $encoding
         *
         * @return bool
         */
        protected function validateEncoding($encoding)
        {
        }
        /**
         * Check if an embedded attachment is present with this cid.
         *
         * @param string $cid
         *
         * @return bool
         */
        protected function cidExists($cid)
        {
        }
        /**
         * Check if an inline attachment is present.
         *
         * @return bool
         */
        public function inlineImageExists()
        {
        }
        /**
         * Check if an attachment (non-inline) is present.
         *
         * @return bool
         */
        public function attachmentExists()
        {
        }
        /**
         * Check if this message has an alternative body set.
         *
         * @return bool
         */
        public function alternativeExists()
        {
        }
        /**
         * Clear queued addresses of given kind.
         *
         * @param string $kind 'to', 'cc', or 'bcc'
         */
        public function clearQueuedAddresses($kind)
        {
        }
        /**
         * Clear all To recipients.
         */
        public function clearAddresses()
        {
        }
        /**
         * Clear all CC recipients.
         */
        public function clearCCs()
        {
        }
        /**
         * Clear all BCC recipients.
         */
        public function clearBCCs()
        {
        }
        /**
         * Clear all ReplyTo recipients.
         */
        public function clearReplyTos()
        {
        }
        /**
         * Clear all recipient types.
         */
        public function clearAllRecipients()
        {
        }
        /**
         * Clear all filesystem, string, and binary attachments.
         */
        public function clearAttachments()
        {
        }
        /**
         * Clear all custom headers.
         */
        public function clearCustomHeaders()
        {
        }
        /**
         * Clear a specific custom header by name or name and value.
         * $name value can be overloaded to contain
         * both header name and value (name:value).
         *
         * @param string      $name  Custom header name
         * @param string|null $value Header value
         *
         * @return bool True if a header was replaced successfully
         */
        public function clearCustomHeader($name, $value = null)
        {
        }
        /**
         * Replace a custom header.
         * $name value can be overloaded to contain
         * both header name and value (name:value).
         *
         * @param string      $name  Custom header name
         * @param string|null $value Header value
         *
         * @return bool True if a header was replaced successfully
         * @throws Exception
         */
        public function replaceCustomHeader($name, $value = null)
        {
        }
        /**
         * Add an error message to the error container.
         *
         * @param string $msg
         */
        protected function setError($msg)
        {
        }
        /**
         * Return an RFC 822 formatted date.
         *
         * @return string
         */
        public static function rfcDate()
        {
        }
        /**
         * Get the server hostname.
         * Returns 'localhost.localdomain' if unknown.
         *
         * @return string
         */
        protected function serverHostname()
        {
        }
        /**
         * Validate whether a string contains a valid value to use as a hostname or IP address.
         * IPv6 addresses must include [], e.g. `[::1]`, not just `::1`.
         *
         * @param string $host The host name or IP address to check
         *
         * @return bool
         */
        public static function isValidHost($host)
        {
        }
        /**
         * Get an error message in the current language.
         *
         * @param string $key
         *
         * @return string
         */
        protected function lang($key)
        {
        }
        /**
         * Check if an error occurred.
         *
         * @return bool True if an error did occur
         */
        public function isError()
        {
        }
        /**
         * Add a custom header.
         * $name value can be overloaded to contain
         * both header name and value (name:value).
         *
         * @param string      $name  Custom header name
         * @param string|null $value Header value
         *
         * @return bool True if a header was set successfully
         * @throws Exception
         */
        public function addCustomHeader($name, $value = null)
        {
        }
        /**
         * Returns all custom headers.
         *
         * @return array
         */
        public function getCustomHeaders()
        {
        }
        /**
         * Create a message body from an HTML string.
         * Automatically inlines images and creates a plain-text version by converting the HTML,
         * overwriting any existing values in Body and AltBody.
         * Do not source $message content from user input!
         * $basedir is prepended when handling relative URLs, e.g. <img src="/images/a.png"> and must not be empty
         * will look for an image file in $basedir/images/a.png and convert it to inline.
         * If you don't provide a $basedir, relative paths will be left untouched (and thus probably break in email)
         * Converts data-uri images into embedded attachments.
         * If you don't want to apply these transformations to your HTML, just set Body and AltBody directly.
         *
         * @param string        $message  HTML message string
         * @param string        $basedir  Absolute path to a base directory to prepend to relative paths to images
         * @param bool|callable $advanced Whether to use the internal HTML to text converter
         *                                or your own custom converter
         * @return string The transformed message body
         *
         * @throws Exception
         *
         * @see PHPMailer::html2text()
         */
        public function msgHTML($message, $basedir = '', $advanced = false)
        {
        }
        /**
         * Convert an HTML string into plain text.
         * This is used by msgHTML().
         * Note - older versions of this function used a bundled advanced converter
         * which was removed for license reasons in #232.
         * Example usage:
         *
         * ```php
         * //Use default conversion
         * $plain = $mail->html2text($html);
         * //Use your own custom converter
         * $plain = $mail->html2text($html, function($html) {
         *     $converter = new MyHtml2text($html);
         *     return $converter->get_text();
         * });
         * ```
         *
         * @param string        $html     The HTML text to convert
         * @param bool|callable $advanced Any boolean value to use the internal converter,
         *                                or provide your own callable for custom conversion.
         *                                *Never* pass user-supplied data into this parameter
         *
         * @return string
         */
        public function html2text($html, $advanced = false)
        {
        }
        /**
         * Get the MIME type for a file extension.
         *
         * @param string $ext File extension
         *
         * @return string MIME type of file
         */
        public static function _mime_types($ext = '')
        {
        }
        /**
         * Map a file name to a MIME type.
         * Defaults to 'application/octet-stream', i.e.. arbitrary binary data.
         *
         * @param string $filename A file name or full path, does not need to exist as a file
         *
         * @return string
         */
        public static function filenameToType($filename)
        {
        }
        /**
         * Multi-byte-safe pathinfo replacement.
         * Drop-in replacement for pathinfo(), but multibyte- and cross-platform-safe.
         *
         * @see https://www.php.net/manual/en/function.pathinfo.php#107461
         *
         * @param string     $path    A filename or path, does not need to exist as a file
         * @param int|string $options Either a PATHINFO_* constant,
         *                            or a string name to return only the specified piece
         *
         * @return string|array
         */
        public static function mb_pathinfo($path, $options = null)
        {
        }
        /**
         * Set or reset instance properties.
         * You should avoid this function - it's more verbose, less efficient, more error-prone and
         * harder to debug than setting properties directly.
         * Usage Example:
         * `$mail->set('SMTPSecure', static::ENCRYPTION_STARTTLS);`
         *   is the same as:
         * `$mail->SMTPSecure = static::ENCRYPTION_STARTTLS;`.
         *
         * @param string $name  The property name to set
         * @param mixed  $value The value to set the property to
         *
         * @return bool
         */
        public function set($name, $value = '')
        {
        }
        /**
         * Strip newlines to prevent header injection.
         *
         * @param string $str
         *
         * @return string
         */
        public function secureHeader($str)
        {
        }
        /**
         * Normalize line breaks in a string.
         * Converts UNIX LF, Mac CR and Windows CRLF line breaks into a single line break format.
         * Defaults to CRLF (for message bodies) and preserves consecutive breaks.
         *
         * @param string $text
         * @param string $breaktype What kind of line break to use; defaults to static::$LE
         *
         * @return string
         */
        public static function normalizeBreaks($text, $breaktype = null)
        {
        }
        /**
         * Remove trailing whitespace from a string.
         *
         * @param string $text
         *
         * @return string The text to remove whitespace from
         */
        public static function stripTrailingWSP($text)
        {
        }
        /**
         * Strip trailing line breaks from a string.
         *
         * @param string $text
         *
         * @return string The text to remove breaks from
         */
        public static function stripTrailingBreaks($text)
        {
        }
        /**
         * Return the current line break format string.
         *
         * @return string
         */
        public static function getLE()
        {
        }
        /**
         * Set the line break format string, e.g. "\r\n".
         *
         * @param string $le
         */
        protected static function setLE($le)
        {
        }
        /**
         * Set the public and private key files and password for S/MIME signing.
         *
         * @param string $cert_filename
         * @param string $key_filename
         * @param string $key_pass            Password for private key
         * @param string $extracerts_filename Optional path to chain certificate
         */
        public function sign($cert_filename, $key_filename, $key_pass, $extracerts_filename = '')
        {
        }
        /**
         * Quoted-Printable-encode a DKIM header.
         *
         * @param string $txt
         *
         * @return string
         */
        public function DKIM_QP($txt)
        {
        }
        /**
         * Generate a DKIM signature.
         *
         * @param string $signHeader
         *
         * @throws Exception
         *
         * @return string The DKIM signature value
         */
        public function DKIM_Sign($signHeader)
        {
        }
        /**
         * Generate a DKIM canonicalization header.
         * Uses the 'relaxed' algorithm from RFC6376 section 3.4.2.
         * Canonicalized headers should *always* use CRLF, regardless of mailer setting.
         *
         * @see https://www.rfc-editor.org/rfc/rfc6376#section-3.4.2
         *
         * @param string $signHeader Header
         *
         * @return string
         */
        public function DKIM_HeaderC($signHeader)
        {
        }
        /**
         * Generate a DKIM canonicalization body.
         * Uses the 'simple' algorithm from RFC6376 section 3.4.3.
         * Canonicalized bodies should *always* use CRLF, regardless of mailer setting.
         *
         * @see https://www.rfc-editor.org/rfc/rfc6376#section-3.4.3
         *
         * @param string $body Message Body
         *
         * @return string
         */
        public function DKIM_BodyC($body)
        {
        }
        /**
         * Create the DKIM header and body in a new message header.
         *
         * @param string $headers_line Header lines
         * @param string $subject      Subject
         * @param string $body         Body
         *
         * @throws Exception
         *
         * @return string
         */
        public function DKIM_Add($headers_line, $subject, $body)
        {
        }
        /**
         * Detect if a string contains a line longer than the maximum line length
         * allowed by RFC 2822 section 2.1.1.
         *
         * @param string $str
         *
         * @return bool
         */
        public static function hasLineLongerThanMax($str)
        {
        }
        /**
         * If a string contains any "special" characters, double-quote the name,
         * and escape any double quotes with a backslash.
         *
         * @param string $str
         *
         * @return string
         *
         * @see RFC822 3.4.1
         */
        public static function quotedString($str)
        {
        }
        /**
         * Allows for public read access to 'to' property.
         * Before the send() call, queued addresses (i.e. with IDN) are not yet included.
         *
         * @return array
         */
        public function getToAddresses()
        {
        }
        /**
         * Allows for public read access to 'cc' property.
         * Before the send() call, queued addresses (i.e. with IDN) are not yet included.
         *
         * @return array
         */
        public function getCcAddresses()
        {
        }
        /**
         * Allows for public read access to 'bcc' property.
         * Before the send() call, queued addresses (i.e. with IDN) are not yet included.
         *
         * @return array
         */
        public function getBccAddresses()
        {
        }
        /**
         * Allows for public read access to 'ReplyTo' property.
         * Before the send() call, queued addresses (i.e. with IDN) are not yet included.
         *
         * @return array
         */
        public function getReplyToAddresses()
        {
        }
        /**
         * Allows for public read access to 'all_recipients' property.
         * Before the send() call, queued addresses (i.e. with IDN) are not yet included.
         *
         * @return array
         */
        public function getAllRecipientAddresses()
        {
        }
        /**
         * Perform a callback.
         *
         * @param bool   $isSent
         * @param array  $to
         * @param array  $cc
         * @param array  $bcc
         * @param string $subject
         * @param string $body
         * @param string $from
         * @param array  $extra
         */
        protected function doCallback($isSent, $to, $cc, $bcc, $subject, $body, $from, $extra)
        {
        }
        /**
         * Get the OAuthTokenProvider instance.
         *
         * @return OAuthTokenProvider
         */
        public function getOAuth()
        {
        }
        /**
         * Set an OAuthTokenProvider instance.
         */
        public function setOAuth(\PHPMailer\PHPMailer\OAuthTokenProvider $oauth)
        {
        }
    }
    /**
     * PHPMailer POP-Before-SMTP Authentication Class.
     * Specifically for PHPMailer to use for RFC1939 POP-before-SMTP authentication.
     * 1) This class does not support APOP authentication.
     * 2) Opening and closing lots of POP3 connections can be quite slow. If you need
     *   to send a batch of emails then just perform the authentication once at the start,
     *   and then loop through your mail sending script. Providing this process doesn't
     *   take longer than the verification period lasts on your POP3 server, you should be fine.
     * 3) This is really ancient technology; you should only need to use it to talk to very old systems.
     * 4) This POP3 class is deliberately lightweight and incomplete, implementing just
     *   enough to do authentication.
     *   If you want a more complete class there are other POP3 classes for PHP available.
     *
     * @author Richard Davey (original author) <rich@corephp.co.uk>
     * @author Marcus Bointon (Synchro/coolbru) <phpmailer@synchromedia.co.uk>
     * @author Jim Jagielski (jimjag) <jimjag@gmail.com>
     * @author Andy Prevost (codeworxtech) <codeworxtech@users.sourceforge.net>
     */
    class POP3
    {
        /**
         * The POP3 PHPMailer Version number.
         *
         * @var string
         */
        const VERSION = '6.9.3';
        /**
         * Default POP3 port number.
         *
         * @var int
         */
        const DEFAULT_PORT = 110;
        /**
         * Default timeout in seconds.
         *
         * @var int
         */
        const DEFAULT_TIMEOUT = 30;
        /**
         * POP3 class debug output mode.
         * Debug output level.
         * Options:
         * @see POP3::DEBUG_OFF: No output
         * @see POP3::DEBUG_SERVER: Server messages, connection/server errors
         * @see POP3::DEBUG_CLIENT: Client and Server messages, connection/server errors
         *
         * @var int
         */
        public $do_debug = self::DEBUG_OFF;
        /**
         * POP3 mail server hostname.
         *
         * @var string
         */
        public $host;
        /**
         * POP3 port number.
         *
         * @var int
         */
        public $port;
        /**
         * POP3 Timeout Value in seconds.
         *
         * @var int
         */
        public $tval;
        /**
         * POP3 username.
         *
         * @var string
         */
        public $username;
        /**
         * POP3 password.
         *
         * @var string
         */
        public $password;
        /**
         * Resource handle for the POP3 connection socket.
         *
         * @var resource
         */
        protected $pop_conn;
        /**
         * Are we connected?
         *
         * @var bool
         */
        protected $connected = false;
        /**
         * Error container.
         *
         * @var array
         */
        protected $errors = [];
        /**
         * Line break constant.
         */
        const LE = "\r\n";
        /**
         * Debug level for no output.
         *
         * @var int
         */
        const DEBUG_OFF = 0;
        /**
         * Debug level to show server -> client messages
         * also shows clients connection errors or errors from server
         *
         * @var int
         */
        const DEBUG_SERVER = 1;
        /**
         * Debug level to show client -> server and server -> client messages.
         *
         * @var int
         */
        const DEBUG_CLIENT = 2;
        /**
         * Simple static wrapper for all-in-one POP before SMTP.
         *
         * @param string   $host        The hostname to connect to
         * @param int|bool $port        The port number to connect to
         * @param int|bool $timeout     The timeout value
         * @param string   $username
         * @param string   $password
         * @param int      $debug_level
         *
         * @return bool
         */
        public static function popBeforeSmtp($host, $port = false, $timeout = false, $username = '', $password = '', $debug_level = 0)
        {
        }
        /**
         * Authenticate with a POP3 server.
         * A connect, login, disconnect sequence
         * appropriate for POP-before SMTP authorisation.
         *
         * @param string   $host        The hostname to connect to
         * @param int|bool $port        The port number to connect to
         * @param int|bool $timeout     The timeout value
         * @param string   $username
         * @param string   $password
         * @param int      $debug_level
         *
         * @return bool
         */
        public function authorise($host, $port = false, $timeout = false, $username = '', $password = '', $debug_level = 0)
        {
        }
        /**
         * Connect to a POP3 server.
         *
         * @param string   $host
         * @param int|bool $port
         * @param int      $tval
         *
         * @return bool
         */
        public function connect($host, $port = false, $tval = 30)
        {
        }
        /**
         * Log in to the POP3 server.
         * Does not support APOP (RFC 2828, 4949).
         *
         * @param string $username
         * @param string $password
         *
         * @return bool
         */
        public function login($username = '', $password = '')
        {
        }
        /**
         * Disconnect from the POP3 server.
         */
        public function disconnect()
        {
        }
        /**
         * Get a response from the POP3 server.
         *
         * @param int $size The maximum number of bytes to retrieve
         *
         * @return string
         */
        protected function getResponse($size = 128)
        {
        }
        /**
         * Send raw data to the POP3 server.
         *
         * @param string $string
         *
         * @return int
         */
        protected function sendString($string)
        {
        }
        /**
         * Checks the POP3 server response.
         * Looks for for +OK or -ERR.
         *
         * @param string $string
         *
         * @return bool
         */
        protected function checkResponse($string)
        {
        }
        /**
         * Add an error to the internal error store.
         * Also display debug output if it's enabled.
         *
         * @param string $error
         */
        protected function setError($error)
        {
        }
        /**
         * Get an array of error messages, if any.
         *
         * @return array
         */
        public function getErrors()
        {
        }
        /**
         * POP3 connection error handler.
         *
         * @param int    $errno
         * @param string $errstr
         * @param string $errfile
         * @param int    $errline
         */
        protected function catchWarning($errno, $errstr, $errfile, $errline)
        {
        }
    }
    /**
     * PHPMailer RFC821 SMTP email transport class.
     * Implements RFC 821 SMTP commands and provides some utility methods for sending mail to an SMTP server.
     *
     * @author Chris Ryan
     * @author Marcus Bointon <phpmailer@synchromedia.co.uk>
     */
    class SMTP
    {
        /**
         * The PHPMailer SMTP version number.
         *
         * @var string
         */
        const VERSION = '6.9.3';
        /**
         * SMTP line break constant.
         *
         * @var string
         */
        const LE = "\r\n";
        /**
         * The SMTP port to use if one is not specified.
         *
         * @var int
         */
        const DEFAULT_PORT = 25;
        /**
         * The SMTPs port to use if one is not specified.
         *
         * @var int
         */
        const DEFAULT_SECURE_PORT = 465;
        /**
         * The maximum line length allowed by RFC 5321 section 4.5.3.1.6,
         * *excluding* a trailing CRLF break.
         *
         * @see https://www.rfc-editor.org/rfc/rfc5321#section-4.5.3.1.6
         *
         * @var int
         */
        const MAX_LINE_LENGTH = 998;
        /**
         * The maximum line length allowed for replies in RFC 5321 section 4.5.3.1.5,
         * *including* a trailing CRLF line break.
         *
         * @see https://www.rfc-editor.org/rfc/rfc5321#section-4.5.3.1.5
         *
         * @var int
         */
        const MAX_REPLY_LENGTH = 512;
        /**
         * Debug level for no output.
         *
         * @var int
         */
        const DEBUG_OFF = 0;
        /**
         * Debug level to show client -> server messages.
         *
         * @var int
         */
        const DEBUG_CLIENT = 1;
        /**
         * Debug level to show client -> server and server -> client messages.
         *
         * @var int
         */
        const DEBUG_SERVER = 2;
        /**
         * Debug level to show connection status, client -> server and server -> client messages.
         *
         * @var int
         */
        const DEBUG_CONNECTION = 3;
        /**
         * Debug level to show all messages.
         *
         * @var int
         */
        const DEBUG_LOWLEVEL = 4;
        /**
         * Debug output level.
         * Options:
         * * self::DEBUG_OFF (`0`) No debug output, default
         * * self::DEBUG_CLIENT (`1`) Client commands
         * * self::DEBUG_SERVER (`2`) Client commands and server responses
         * * self::DEBUG_CONNECTION (`3`) As DEBUG_SERVER plus connection status
         * * self::DEBUG_LOWLEVEL (`4`) Low-level data output, all messages.
         *
         * @var int
         */
        public $do_debug = self::DEBUG_OFF;
        /**
         * How to handle debug output.
         * Options:
         * * `echo` Output plain-text as-is, appropriate for CLI
         * * `html` Output escaped, line breaks converted to `<br>`, appropriate for browser output
         * * `error_log` Output to error log as configured in php.ini
         * Alternatively, you can provide a callable expecting two params: a message string and the debug level:
         *
         * ```php
         * $smtp->Debugoutput = function($str, $level) {echo "debug level $level; message: $str";};
         * ```
         *
         * Alternatively, you can pass in an instance of a PSR-3 compatible logger, though only `debug`
         * level output is used:
         *
         * ```php
         * $mail->Debugoutput = new myPsr3Logger;
         * ```
         *
         * @var string|callable|\Psr\Log\LoggerInterface
         */
        public $Debugoutput = 'echo';
        /**
         * Whether to use VERP.
         *
         * @see https://en.wikipedia.org/wiki/Variable_envelope_return_path
         * @see https://www.postfix.org/VERP_README.html Info on VERP
         *
         * @var bool
         */
        public $do_verp = false;
        /**
         * The timeout value for connection, in seconds.
         * Default of 5 minutes (300sec) is from RFC2821 section 4.5.3.2.
         * This needs to be quite high to function correctly with hosts using greetdelay as an anti-spam measure.
         *
         * @see https://www.rfc-editor.org/rfc/rfc2821#section-4.5.3.2
         *
         * @var int
         */
        public $Timeout = 300;
        /**
         * How long to wait for commands to complete, in seconds.
         * Default of 5 minutes (300sec) is from RFC2821 section 4.5.3.2.
         *
         * @var int
         */
        public $Timelimit = 300;
        /**
         * Patterns to extract an SMTP transaction id from reply to a DATA command.
         * The first capture group in each regex will be used as the ID.
         * MS ESMTP returns the message ID, which may not be correct for internal tracking.
         *
         * @var string[]
         */
        protected $smtp_transaction_id_patterns = ['exim' => '/[\d]{3} OK id=(.*)/', 'sendmail' => '/[\d]{3} 2\.0\.0 (.*) Message/', 'postfix' => '/[\d]{3} 2\.0\.0 Ok: queued as (.*)/', 'Microsoft_ESMTP' => '/[0-9]{3} 2\.[\d]\.0 (.*)@(?:.*) Queued mail for delivery/', 'Amazon_SES' => '/[\d]{3} Ok (.*)/', 'SendGrid' => '/[\d]{3} Ok: queued as (.*)/', 'CampaignMonitor' => '/[\d]{3} 2\.0\.0 OK:([a-zA-Z\d]{48})/', 'Haraka' => '/[\d]{3} Message Queued \((.*)\)/', 'ZoneMTA' => '/[\d]{3} Message queued as (.*)/', 'Mailjet' => '/[\d]{3} OK queued as (.*)/'];
        /**
         * Allowed SMTP XCLIENT attributes.
         * Must be allowed by the SMTP server. EHLO response is not checked.
         *
         * @see https://www.postfix.org/XCLIENT_README.html
         *
         * @var array
         */
        public static $xclient_allowed_attributes = ['NAME', 'ADDR', 'PORT', 'PROTO', 'HELO', 'LOGIN', 'DESTADDR', 'DESTPORT'];
        /**
         * The last transaction ID issued in response to a DATA command,
         * if one was detected.
         *
         * @var string|bool|null
         */
        protected $last_smtp_transaction_id;
        /**
         * The socket for the server connection.
         *
         * @var ?resource
         */
        protected $smtp_conn;
        /**
         * Error information, if any, for the last SMTP command.
         *
         * @var array
         */
        protected $error = ['error' => '', 'detail' => '', 'smtp_code' => '', 'smtp_code_ex' => ''];
        /**
         * The reply the server sent to us for HELO.
         * If null, no HELO string has yet been received.
         *
         * @var string|null
         */
        protected $helo_rply;
        /**
         * The set of SMTP extensions sent in reply to EHLO command.
         * Indexes of the array are extension names.
         * Value at index 'HELO' or 'EHLO' (according to command that was sent)
         * represents the server name. In case of HELO it is the only element of the array.
         * Other values can be boolean TRUE or an array containing extension options.
         * If null, no HELO/EHLO string has yet been received.
         *
         * @var array|null
         */
        protected $server_caps;
        /**
         * The most recent reply received from the server.
         *
         * @var string
         */
        protected $last_reply = '';
        /**
         * Output debugging info via a user-selected method.
         *
         * @param string $str   Debug string to output
         * @param int    $level The debug level of this message; see DEBUG_* constants
         *
         * @see SMTP::$Debugoutput
         * @see SMTP::$do_debug
         */
        protected function edebug($str, $level = 0)
        {
        }
        /**
         * Connect to an SMTP server.
         *
         * @param string $host    SMTP server IP or host name
         * @param int    $port    The port number to connect to
         * @param int    $timeout How long to wait for the connection to open
         * @param array  $options An array of options for stream_context_create()
         *
         * @return bool
         */
        public function connect($host, $port = null, $timeout = 30, $options = [])
        {
        }
        /**
         * Create connection to the SMTP server.
         *
         * @param string $host    SMTP server IP or host name
         * @param int    $port    The port number to connect to
         * @param int    $timeout How long to wait for the connection to open
         * @param array  $options An array of options for stream_context_create()
         *
         * @return false|resource
         */
        protected function getSMTPConnection($host, $port = null, $timeout = 30, $options = [])
        {
        }
        /**
         * Initiate a TLS (encrypted) session.
         *
         * @return bool
         */
        public function startTLS()
        {
        }
        /**
         * Perform SMTP authentication.
         * Must be run after hello().
         *
         * @see    hello()
         *
         * @param string $username The user name
         * @param string $password The password
         * @param string $authtype The auth type (CRAM-MD5, PLAIN, LOGIN, XOAUTH2)
         * @param OAuthTokenProvider $OAuth An optional OAuthTokenProvider instance for XOAUTH2 authentication
         *
         * @return bool True if successfully authenticated
         */
        public function authenticate($username, $password, $authtype = null, $OAuth = null)
        {
        }
        /**
         * Calculate an MD5 HMAC hash.
         * Works like hash_hmac('md5', $data, $key)
         * in case that function is not available.
         *
         * @param string $data The data to hash
         * @param string $key  The key to hash with
         *
         * @return string
         */
        protected function hmac($data, $key)
        {
        }
        /**
         * Check connection state.
         *
         * @return bool True if connected
         */
        public function connected()
        {
        }
        /**
         * Close the socket and clean up the state of the class.
         * Don't use this function without first trying to use QUIT.
         *
         * @see quit()
         */
        public function close()
        {
        }
        /**
         * Send an SMTP DATA command.
         * Issues a data command and sends the msg_data to the server,
         * finalizing the mail transaction. $msg_data is the message
         * that is to be sent with the headers. Each header needs to be
         * on a single line followed by a <CRLF> with the message headers
         * and the message body being separated by an additional <CRLF>.
         * Implements RFC 821: DATA <CRLF>.
         *
         * @param string $msg_data Message data to send
         *
         * @return bool
         */
        public function data($msg_data)
        {
        }
        /**
         * Send an SMTP HELO or EHLO command.
         * Used to identify the sending server to the receiving server.
         * This makes sure that client and server are in a known state.
         * Implements RFC 821: HELO <SP> <domain> <CRLF>
         * and RFC 2821 EHLO.
         *
         * @param string $host The host name or IP to connect to
         *
         * @return bool
         */
        public function hello($host = '')
        {
        }
        /**
         * Send an SMTP HELO or EHLO command.
         * Low-level implementation used by hello().
         *
         * @param string $hello The HELO string
         * @param string $host  The hostname to say we are
         *
         * @return bool
         *
         * @see hello()
         */
        protected function sendHello($hello, $host)
        {
        }
        /**
         * Parse a reply to HELO/EHLO command to discover server extensions.
         * In case of HELO, the only parameter that can be discovered is a server name.
         *
         * @param string $type `HELO` or `EHLO`
         */
        protected function parseHelloFields($type)
        {
        }
        /**
         * Send an SMTP MAIL command.
         * Starts a mail transaction from the email address specified in
         * $from. Returns true if successful or false otherwise. If True
         * the mail transaction is started and then one or more recipient
         * commands may be called followed by a data command.
         * Implements RFC 821: MAIL <SP> FROM:<reverse-path> <CRLF>.
         *
         * @param string $from Source address of this message
         *
         * @return bool
         */
        public function mail($from)
        {
        }
        /**
         * Send an SMTP QUIT command.
         * Closes the socket if there is no error or the $close_on_error argument is true.
         * Implements from RFC 821: QUIT <CRLF>.
         *
         * @param bool $close_on_error Should the connection close if an error occurs?
         *
         * @return bool
         */
        public function quit($close_on_error = true)
        {
        }
        /**
         * Send an SMTP RCPT command.
         * Sets the TO argument to $toaddr.
         * Returns true if the recipient was accepted false if it was rejected.
         * Implements from RFC 821: RCPT <SP> TO:<forward-path> <CRLF>.
         *
         * @param string $address The address the message is being sent to
         * @param string $dsn     Comma separated list of DSN notifications. NEVER, SUCCESS, FAILURE
         *                        or DELAY. If you specify NEVER all other notifications are ignored.
         *
         * @return bool
         */
        public function recipient($address, $dsn = '')
        {
        }
        /**
         * Send SMTP XCLIENT command to server and check its return code.
         *
         * @return bool True on success
         */
        public function xclient(array $vars)
        {
        }
        /**
         * Send an SMTP RSET command.
         * Abort any transaction that is currently in progress.
         * Implements RFC 821: RSET <CRLF>.
         *
         * @return bool True on success
         */
        public function reset()
        {
        }
        /**
         * Send a command to an SMTP server and check its return code.
         *
         * @param string    $command       The command name - not sent to the server
         * @param string    $commandstring The actual command to send
         * @param int|array $expect        One or more expected integer success codes
         *
         * @return bool True on success
         */
        protected function sendCommand($command, $commandstring, $expect)
        {
        }
        /**
         * Send an SMTP SAML command.
         * Starts a mail transaction from the email address specified in $from.
         * Returns true if successful or false otherwise. If True
         * the mail transaction is started and then one or more recipient
         * commands may be called followed by a data command. This command
         * will send the message to the users terminal if they are logged
         * in and send them an email.
         * Implements RFC 821: SAML <SP> FROM:<reverse-path> <CRLF>.
         *
         * @param string $from The address the message is from
         *
         * @return bool
         */
        public function sendAndMail($from)
        {
        }
        /**
         * Send an SMTP VRFY command.
         *
         * @param string $name The name to verify
         *
         * @return bool
         */
        public function verify($name)
        {
        }
        /**
         * Send an SMTP NOOP command.
         * Used to keep keep-alives alive, doesn't actually do anything.
         *
         * @return bool
         */
        public function noop()
        {
        }
        /**
         * Send an SMTP TURN command.
         * This is an optional command for SMTP that this class does not support.
         * This method is here to make the RFC821 Definition complete for this class
         * and _may_ be implemented in future.
         * Implements from RFC 821: TURN <CRLF>.
         *
         * @return bool
         */
        public function turn()
        {
        }
        /**
         * Send raw data to the server.
         *
         * @param string $data    The data to send
         * @param string $command Optionally, the command this is part of, used only for controlling debug output
         *
         * @return int|bool The number of bytes sent to the server or false on error
         */
        public function client_send($data, $command = '')
        {
        }
        /**
         * Get the latest error.
         *
         * @return array
         */
        public function getError()
        {
        }
        /**
         * Get SMTP extensions available on the server.
         *
         * @return array|null
         */
        public function getServerExtList()
        {
        }
        /**
         * Get metadata about the SMTP server from its HELO/EHLO response.
         * The method works in three ways, dependent on argument value and current state:
         *   1. HELO/EHLO has not been sent - returns null and populates $this->error.
         *   2. HELO has been sent -
         *     $name == 'HELO': returns server name
         *     $name == 'EHLO': returns boolean false
         *     $name == any other string: returns null and populates $this->error
         *   3. EHLO has been sent -
         *     $name == 'HELO'|'EHLO': returns the server name
         *     $name == any other string: if extension $name exists, returns True
         *       or its options (e.g. AUTH mechanisms supported). Otherwise returns False.
         *
         * @param string $name Name of SMTP extension or 'HELO'|'EHLO'
         *
         * @return string|bool|null
         */
        public function getServerExt($name)
        {
        }
        /**
         * Get the last reply from the server.
         *
         * @return string
         */
        public function getLastReply()
        {
        }
        /**
         * Read the SMTP server's response.
         * Either before eof or socket timeout occurs on the operation.
         * With SMTP we can tell if we have more lines to read if the
         * 4th character is '-' symbol. If it is a space then we don't
         * need to read anything else.
         *
         * @return string
         */
        protected function get_lines()
        {
        }
        /**
         * Enable or disable VERP address generation.
         *
         * @param bool $enabled
         */
        public function setVerp($enabled = false)
        {
        }
        /**
         * Get VERP address generation mode.
         *
         * @return bool
         */
        public function getVerp()
        {
        }
        /**
         * Set error messages and codes.
         *
         * @param string $message      The error message
         * @param string $detail       Further detail on the error
         * @param string $smtp_code    An associated SMTP error code
         * @param string $smtp_code_ex Extended SMTP code
         */
        protected function setError($message, $detail = '', $smtp_code = '', $smtp_code_ex = '')
        {
        }
        /**
         * Set debug output method.
         *
         * @param string|callable $method The name of the mechanism to use for debugging output, or a callable to handle it
         */
        public function setDebugOutput($method = 'echo')
        {
        }
        /**
         * Get debug output method.
         *
         * @return string
         */
        public function getDebugOutput()
        {
        }
        /**
         * Set debug output level.
         *
         * @param int $level
         */
        public function setDebugLevel($level = 0)
        {
        }
        /**
         * Get debug output level.
         *
         * @return int
         */
        public function getDebugLevel()
        {
        }
        /**
         * Set SMTP timeout.
         *
         * @param int $timeout The timeout duration in seconds
         */
        public function setTimeout($timeout = 0)
        {
        }
        /**
         * Get SMTP timeout.
         *
         * @return int
         */
        public function getTimeout()
        {
        }
        /**
         * Reports an error number and string.
         *
         * @param int    $errno   The error number returned by PHP
         * @param string $errmsg  The error message returned by PHP
         * @param string $errfile The file the error occurred in
         * @param int    $errline The line number the error occurred on
         */
        protected function errorHandler($errno, $errmsg, $errfile = '', $errline = 0)
        {
        }
        /**
         * Extract and return the ID of the last SMTP transaction based on
         * a list of patterns provided in SMTP::$smtp_transaction_id_patterns.
         * Relies on the host providing the ID in response to a DATA command.
         * If no reply has been received yet, it will return null.
         * If no pattern was matched, it will return false.
         *
         * @return bool|string|null
         */
        protected function recordLastTransactionID()
        {
        }
        /**
         * Get the queue/transaction ID of the last SMTP transaction
         * If no reply has been received yet, it will return null.
         * If no pattern was matched, it will return false.
         *
         * @return bool|string|null
         *
         * @see recordLastTransactionID()
         */
        public function getLastTransactionID()
        {
        }
    }
}
namespace phpseclib3\Common\Functions {
    /**
     * Common String Functions
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Strings
    {
        /**
         * String Shift
         *
         * Inspired by array_shift
         *
         * @param string $string
         * @param int $index
         * @return string
         */
        public static function shift(&$string, $index = 1)
        {
        }
        /**
         * String Pop
         *
         * Inspired by array_pop
         *
         * @param string $string
         * @param int $index
         * @return string
         */
        public static function pop(&$string, $index = 1)
        {
        }
        /**
         * Parse SSH2-style string
         *
         * Returns either an array or a boolean if $data is malformed.
         *
         * Valid characters for $format are as follows:
         *
         * C = byte
         * b = boolean (true/false)
         * N = uint32
         * Q = uint64
         * s = string
         * i = mpint
         * L = name-list
         *
         * uint64 is not supported.
         *
         * @param string $format
         * @param string $data
         * @return mixed
         */
        public static function unpackSSH2($format, &$data)
        {
        }
        /**
         * Create SSH2-style string
         *
         * @param string $format
         * @param string|int|float|array|bool ...$elements
         * @return string
         */
        public static function packSSH2($format, ...$elements)
        {
        }
        /**
         * Convert binary data into bits
         *
         * bin2hex / hex2bin refer to base-256 encoded data as binary, whilst
         * decbin / bindec refer to base-2 encoded data as binary. For the purposes
         * of this function, bin refers to base-256 encoded data whilst bits refers
         * to base-2 encoded data
         *
         * @param string $x
         * @return string
         */
        public static function bits2bin($x)
        {
        }
        /**
         * Convert bits to binary data
         *
         * @param string $x
         * @return string
         */
        public static function bin2bits($x, $trim = true)
        {
        }
        /**
         * Switch Endianness Bit Order
         *
         * @param string $x
         * @return string
         */
        public static function switchEndianness($x)
        {
        }
        /**
         * Increment the current string
         *
         * @param string $var
         * @return string
         */
        public static function increment_str(&$var)
        {
        }
        /**
         * Find whether the type of a variable is string (or could be converted to one)
         *
         * @param mixed $var
         * @return bool
         * @psalm-assert-if-true string|\Stringable $var
         */
        public static function is_stringable($var)
        {
        }
        /**
         * Constant Time Base64-decoding
         *
         * ParagoneIE\ConstantTime doesn't use libsodium if it's available so we'll do so
         * ourselves. see https://github.com/paragonie/constant_time_encoding/issues/39
         *
         * @param string $data
         * @return string
         */
        public static function base64_decode($data)
        {
        }
        /**
         * Constant Time Base64-decoding (URL safe)
         *
         * @param string $data
         * @return string
         */
        public static function base64url_decode($data)
        {
        }
        /**
         * Constant Time Base64-encoding
         *
         * @param string $data
         * @return string
         */
        public static function base64_encode($data)
        {
        }
        /**
         * Constant Time Base64-encoding (URL safe)
         *
         * @param string $data
         * @return string
         */
        public static function base64url_encode($data)
        {
        }
        /**
         * Constant Time Hex Decoder
         *
         * @param string $data
         * @return string
         */
        public static function hex2bin($data)
        {
        }
        /**
         * Constant Time Hex Encoder
         *
         * @param string $data
         * @return string
         */
        public static function bin2hex($data)
        {
        }
    }
}
namespace phpseclib3\Crypt\Common {
    /**
     * Base Class for all \phpseclib3\Crypt\* cipher classes
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     * @author  Hans-Juergen Petrich <petrich@tronic-media.com>
     */
    abstract class SymmetricKey
    {
        /**
         * Encrypt / decrypt using the Counter mode.
         *
         * Set to -1 since that's what Crypt/Random.php uses to index the CTR mode.
         *
         * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Counter_.28CTR.29
         * @see \phpseclib3\Crypt\Common\SymmetricKey::encrypt()
         * @see \phpseclib3\Crypt\Common\SymmetricKey::decrypt()
         */
        const MODE_CTR = -1;
        /**
         * Encrypt / decrypt using the Electronic Code Book mode.
         *
         * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29
         * @see \phpseclib3\Crypt\Common\SymmetricKey::encrypt()
         * @see \phpseclib3\Crypt\Common\SymmetricKey::decrypt()
         */
        const MODE_ECB = 1;
        /**
         * Encrypt / decrypt using the Code Book Chaining mode.
         *
         * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29
         * @see \phpseclib3\Crypt\Common\SymmetricKey::encrypt()
         * @see \phpseclib3\Crypt\Common\SymmetricKey::decrypt()
         */
        const MODE_CBC = 2;
        /**
         * Encrypt / decrypt using the Cipher Feedback mode.
         *
         * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher_feedback_.28CFB.29
         * @see \phpseclib3\Crypt\Common\SymmetricKey::encrypt()
         * @see \phpseclib3\Crypt\Common\SymmetricKey::decrypt()
         */
        const MODE_CFB = 3;
        /**
         * Encrypt / decrypt using the Cipher Feedback mode (8bit)
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::encrypt()
         * @see \phpseclib3\Crypt\Common\SymmetricKey::decrypt()
         */
        const MODE_CFB8 = 7;
        /**
         * Encrypt / decrypt using the Output Feedback mode (8bit)
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::encrypt()
         * @see \phpseclib3\Crypt\Common\SymmetricKey::decrypt()
         */
        const MODE_OFB8 = 8;
        /**
         * Encrypt / decrypt using the Output Feedback mode.
         *
         * @link http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Output_feedback_.28OFB.29
         * @see \phpseclib3\Crypt\Common\SymmetricKey::encrypt()
         * @see \phpseclib3\Crypt\Common\SymmetricKey::decrypt()
         */
        const MODE_OFB = 4;
        /**
         * Encrypt / decrypt using Galois/Counter mode.
         *
         * @link https://en.wikipedia.org/wiki/Galois/Counter_Mode
         * @see \phpseclib3\Crypt\Common\SymmetricKey::encrypt()
         * @see \phpseclib3\Crypt\Common\SymmetricKey::decrypt()
         */
        const MODE_GCM = 5;
        /**
         * Encrypt / decrypt using streaming mode.
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::encrypt()
         * @see \phpseclib3\Crypt\Common\SymmetricKey::decrypt()
         */
        const MODE_STREAM = 6;
        /**
         * Mode Map
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::__construct()
         */
        const MODE_MAP = ['ctr' => self::MODE_CTR, 'ecb' => self::MODE_ECB, 'cbc' => self::MODE_CBC, 'cfb' => self::MODE_CFB, 'cfb8' => self::MODE_CFB8, 'ofb' => self::MODE_OFB, 'ofb8' => self::MODE_OFB8, 'gcm' => self::MODE_GCM, 'stream' => self::MODE_STREAM];
        /**
         * Base value for the internal implementation $engine switch
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::__construct()
         */
        const ENGINE_INTERNAL = 1;
        /**
         * Base value for the eval() implementation $engine switch
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::__construct()
         */
        const ENGINE_EVAL = 2;
        /**
         * Base value for the mcrypt implementation $engine switch
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::__construct()
         */
        const ENGINE_MCRYPT = 3;
        /**
         * Base value for the openssl implementation $engine switch
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::__construct()
         */
        const ENGINE_OPENSSL = 4;
        /**
         * Base value for the libsodium implementation $engine switch
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::__construct()
         */
        const ENGINE_LIBSODIUM = 5;
        /**
         * Base value for the openssl / gcm implementation $engine switch
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::__construct()
         */
        const ENGINE_OPENSSL_GCM = 6;
        /**
         * Engine Reverse Map
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::getEngine()
         */
        const ENGINE_MAP = [self::ENGINE_INTERNAL => 'PHP', self::ENGINE_EVAL => 'Eval', self::ENGINE_MCRYPT => 'mcrypt', self::ENGINE_OPENSSL => 'OpenSSL', self::ENGINE_LIBSODIUM => 'libsodium', self::ENGINE_OPENSSL_GCM => 'OpenSSL (GCM)'];
        /**
         * The Encryption Mode
         *
         * @see self::__construct()
         * @var int
         */
        protected $mode;
        /**
         * The Block Length of the block cipher
         *
         * @var int
         */
        protected $block_size = 16;
        /**
         * The Key
         *
         * @see self::setKey()
         * @var string
         */
        protected $key = false;
        /**
         * HMAC Key
         *
         * @see self::setupGCM()
         * @var ?string
         */
        protected $hKey = false;
        /**
         * The Initialization Vector
         *
         * @see self::setIV()
         * @var string
         */
        protected $iv = false;
        /**
         * A "sliding" Initialization Vector
         *
         * @see self::enableContinuousBuffer()
         * @see self::clearBuffers()
         * @var string
         */
        protected $encryptIV;
        /**
         * A "sliding" Initialization Vector
         *
         * @see self::enableContinuousBuffer()
         * @see self::clearBuffers()
         * @var string
         */
        protected $decryptIV;
        /**
         * Continuous Buffer status
         *
         * @see self::enableContinuousBuffer()
         * @var bool
         */
        protected $continuousBuffer = false;
        /**
         * Encryption buffer for CTR, OFB and CFB modes
         *
         * @see self::encrypt()
         * @see self::clearBuffers()
         * @var array
         */
        protected $enbuffer;
        /**
         * Decryption buffer for CTR, OFB and CFB modes
         *
         * @see self::decrypt()
         * @see self::clearBuffers()
         * @var array
         */
        protected $debuffer;
        /**
         * Optimizing value while CFB-encrypting
         *
         * Only relevant if $continuousBuffer enabled
         * and $engine == self::ENGINE_MCRYPT
         *
         * It's faster to re-init $enmcrypt if
         * $buffer bytes > $cfb_init_len than
         * using the $ecb resource furthermore.
         *
         * This value depends of the chosen cipher
         * and the time it would be needed for it's
         * initialization [by mcrypt_generic_init()]
         * which, typically, depends on the complexity
         * on its internaly Key-expanding algorithm.
         *
         * @see self::encrypt()
         * @var int
         */
        protected $cfb_init_len = 600;
        /**
         * Does internal cipher state need to be (re)initialized?
         *
         * @see self::setKey()
         * @see self::setIV()
         * @see self::disableContinuousBuffer()
         * @var bool
         */
        protected $changed = true;
        /**
         * Does Eval engie need to be (re)initialized?
         *
         * @see self::setup()
         * @var bool
         */
        protected $nonIVChanged = true;
        /**
         * Holds which crypt engine internaly should be use,
         * which will be determined automatically on __construct()
         *
         * Currently available $engines are:
         * - self::ENGINE_LIBSODIUM   (very fast, php-extension: libsodium, extension_loaded('libsodium') required)
         * - self::ENGINE_OPENSSL_GCM (very fast, php-extension: openssl, extension_loaded('openssl') required)
         * - self::ENGINE_OPENSSL     (very fast, php-extension: openssl, extension_loaded('openssl') required)
         * - self::ENGINE_MCRYPT      (fast, php-extension: mcrypt, extension_loaded('mcrypt') required)
         * - self::ENGINE_EVAL        (medium, pure php-engine, no php-extension required)
         * - self::ENGINE_INTERNAL    (slower, pure php-engine, no php-extension required)
         *
         * @see self::setEngine()
         * @see self::encrypt()
         * @see self::decrypt()
         * @var int
         */
        protected $engine;
        /**
         * The mcrypt specific name of the cipher
         *
         * Only used if $engine == self::ENGINE_MCRYPT
         *
         * @link http://www.php.net/mcrypt_module_open
         * @link http://www.php.net/mcrypt_list_algorithms
         * @see self::setupMcrypt()
         * @var string
         */
        protected $cipher_name_mcrypt;
        /**
         * The openssl specific name of the cipher
         *
         * Only used if $engine == self::ENGINE_OPENSSL
         *
         * @link http://www.php.net/openssl-get-cipher-methods
         * @var string
         */
        protected $cipher_name_openssl;
        /**
         * The openssl specific name of the cipher in ECB mode
         *
         * If OpenSSL does not support the mode we're trying to use (CTR)
         * it can still be emulated with ECB mode.
         *
         * @link http://www.php.net/openssl-get-cipher-methods
         * @var string
         */
        protected $cipher_name_openssl_ecb;
        /**
         * The name of the performance-optimized callback function
         *
         * Used by encrypt() / decrypt()
         * only if $engine == self::ENGINE_INTERNAL
         *
         * @see self::encrypt()
         * @see self::decrypt()
         * @see self::setupInlineCrypt()
         * @var Callback
         */
        protected $inline_crypt;
        /**
         * Has the key length explicitly been set or should it be derived from the key, itself?
         *
         * @see self::setKeyLength()
         * @var bool
         */
        protected $explicit_key_length = false;
        /**
         * Additional authenticated data
         *
         * @var string
         */
        protected $aad = '';
        /**
         * Authentication Tag produced after a round of encryption
         *
         * @var string
         */
        protected $newtag = false;
        /**
         * Authentication Tag to be verified during decryption
         *
         * @var string
         */
        protected $oldtag = false;
        /**
         * Flag for using regular vs "safe" intval
         *
         * @see self::initialize_static_variables()
         * @var boolean
         */
        protected static $use_reg_intval;
        /**
         * Poly1305 Key
         *
         * @see self::setPoly1305Key()
         * @see self::poly1305()
         * @var string
         */
        protected $poly1305Key;
        /**
         * Poly1305 Flag
         *
         * @see self::setPoly1305Key()
         * @see self::enablePoly1305()
         * @var boolean
         */
        protected $usePoly1305 = false;
        /**
         * Nonce
         *
         * Only used with GCM. We could re-use setIV() but nonce's can be of a different length and
         * toggling between GCM and other modes could be more complicated if we re-used setIV()
         *
         * @see self::setNonce()
         * @var string
         */
        protected $nonce = false;
        /**
         * Default Constructor.
         *
         * $mode could be:
         *
         * - ecb
         *
         * - cbc
         *
         * - ctr
         *
         * - cfb
         *
         * - cfb8
         *
         * - ofb
         *
         * - ofb8
         *
         * - gcm
         *
         * @param string $mode
         * @throws BadModeException if an invalid / unsupported mode is provided
         */
        public function __construct($mode)
        {
        }
        /**
         * Initialize static variables
         */
        protected static function initialize_static_variables()
        {
        }
        /**
         * Sets the initialization vector.
         *
         * setIV() is not required when ecb or gcm modes are being used.
         *
         * {@internal Can be overwritten by a sub class, but does not have to be}
         *
         * @param string $iv
         * @throws \LengthException if the IV length isn't equal to the block size
         * @throws \BadMethodCallException if an IV is provided when one shouldn't be
         */
        public function setIV($iv)
        {
        }
        /**
         * Enables Poly1305 mode.
         *
         * Once enabled Poly1305 cannot be disabled.
         *
         * @throws \BadMethodCallException if Poly1305 is enabled whilst in GCM mode
         */
        public function enablePoly1305()
        {
        }
        /**
         * Enables Poly1305 mode.
         *
         * Once enabled Poly1305 cannot be disabled. If $key is not passed then an attempt to call createPoly1305Key
         * will be made.
         *
         * @param string $key optional
         * @throws \LengthException if the key isn't long enough
         * @throws \BadMethodCallException if Poly1305 is enabled whilst in GCM mode
         */
        public function setPoly1305Key($key = null)
        {
        }
        /**
         * Sets the nonce.
         *
         * setNonce() is only required when gcm is used
         *
         * @param string $nonce
         * @throws \BadMethodCallException if an nonce is provided when one shouldn't be
         */
        public function setNonce($nonce)
        {
        }
        /**
         * Sets additional authenticated data
         *
         * setAAD() is only used by gcm or in poly1305 mode
         *
         * @param string $aad
         * @throws \BadMethodCallException if mode isn't GCM or if poly1305 isn't being utilized
         */
        public function setAAD($aad)
        {
        }
        /**
         * Returns whether or not the algorithm uses an IV
         *
         * @return bool
         */
        public function usesIV()
        {
        }
        /**
         * Returns whether or not the algorithm uses a nonce
         *
         * @return bool
         */
        public function usesNonce()
        {
        }
        /**
         * Returns the current key length in bits
         *
         * @return int
         */
        public function getKeyLength()
        {
        }
        /**
         * Returns the current block length in bits
         *
         * @return int
         */
        public function getBlockLength()
        {
        }
        /**
         * Returns the current block length in bytes
         *
         * @return int
         */
        public function getBlockLengthInBytes()
        {
        }
        /**
         * Sets the key length.
         *
         * Keys with explicitly set lengths need to be treated accordingly
         *
         * @param int $length
         */
        public function setKeyLength($length)
        {
        }
        /**
         * Sets the key.
         *
         * The min/max length(s) of the key depends on the cipher which is used.
         * If the key not fits the length(s) of the cipher it will paded with null bytes
         * up to the closest valid key length.  If the key is more than max length,
         * we trim the excess bits.
         *
         * If the key is not explicitly set, it'll be assumed to be all null bytes.
         *
         * {@internal Could, but not must, extend by the child Crypt_* class}
         *
         * @param string $key
         */
        public function setKey($key)
        {
        }
        /**
         * Sets the password.
         *
         * Depending on what $method is set to, setPassword()'s (optional) parameters are as follows:
         *     {@link http://en.wikipedia.org/wiki/PBKDF2 pbkdf2} or pbkdf1:
         *         $hash, $salt, $count, $dkLen
         *
         *         Where $hash (default = sha1) currently supports the following hashes: see: Crypt/Hash.php
         *     {@link https://en.wikipedia.org/wiki/Bcrypt bcypt}:
         *         $salt, $rounds, $keylen
         *
         *         This is a modified version of bcrypt used by OpenSSH.
         *
         * {@internal Could, but not must, extend by the child Crypt_* class}
         *
         * @see Crypt/Hash.php
         * @param string $password
         * @param string $method
         * @param int|string ...$func_args
         * @throws \LengthException if pbkdf1 is being used and the derived key length exceeds the hash length
         * @throws \RuntimeException if bcrypt is being used and a salt isn't provided
         * @return bool
         */
        public function setPassword($password, $method = 'pbkdf2', ...$func_args)
        {
        }
        /**
         * Encrypts a message.
         *
         * $plaintext will be padded with additional bytes such that it's length is a multiple of the block size. Other cipher
         * implementations may or may not pad in the same manner.  Other common approaches to padding and the reasons why it's
         * necessary are discussed in the following
         * URL:
         *
         * {@link http://www.di-mgt.com.au/cryptopad.html http://www.di-mgt.com.au/cryptopad.html}
         *
         * An alternative to padding is to, separately, send the length of the file.  This is what SSH, in fact, does.
         * strlen($plaintext) will still need to be a multiple of the block size, however, arbitrary values can be added to make it that
         * length.
         *
         * {@internal Could, but not must, extend by the child Crypt_* class}
         *
         * @see self::decrypt()
         * @param string $plaintext
         * @return string $ciphertext
         */
        public function encrypt($plaintext)
        {
        }
        /**
         * Decrypts a message.
         *
         * If strlen($ciphertext) is not a multiple of the block size, null bytes will be added to the end of the string until
         * it is.
         *
         * {@internal Could, but not must, extend by the child Crypt_* class}
         *
         * @see self::encrypt()
         * @param string $ciphertext
         * @return string $plaintext
         * @throws \LengthException if we're inside a block cipher and the ciphertext length is not a multiple of the block size
         */
        public function decrypt($ciphertext)
        {
        }
        /**
         * Get the authentication tag
         *
         * Only used in GCM or Poly1305 mode
         *
         * @see self::encrypt()
         * @param int $length optional
         * @return string
         * @throws \LengthException if $length isn't of a sufficient length
         * @throws \RuntimeException if GCM mode isn't being used
         */
        public function getTag($length = 16)
        {
        }
        /**
         * Sets the authentication tag
         *
         * Only used in GCM mode
         *
         * @see self::decrypt()
         * @param string $tag
         * @throws \LengthException if $length isn't of a sufficient length
         * @throws \RuntimeException if GCM mode isn't being used
         */
        public function setTag($tag)
        {
        }
        /**
         * Get the IV
         *
         * mcrypt requires an IV even if ECB is used
         *
         * @see self::encrypt()
         * @see self::decrypt()
         * @param string $iv
         * @return string
         */
        protected function getIV($iv)
        {
        }
        /**
         * phpseclib <-> OpenSSL Mode Mapper
         *
         * May need to be overwritten by classes extending this one in some cases
         *
         * @return string
         */
        protected function openssl_translate_mode()
        {
        }
        /**
         * Pad "packets".
         *
         * Block ciphers working by encrypting between their specified [$this->]block_size at a time
         * If you ever need to encrypt or decrypt something that isn't of the proper length, it becomes necessary to
         * pad the input so that it is of the proper length.
         *
         * Padding is enabled by default.  Sometimes, however, it is undesirable to pad strings.  Such is the case in SSH,
         * where "packets" are padded with random bytes before being encrypted.  Unpad these packets and you risk stripping
         * away characters that shouldn't be stripped away. (SSH knows how many bytes are added because the length is
         * transmitted separately)
         *
         * @see self::disablePadding()
         */
        public function enablePadding()
        {
        }
        /**
         * Do not pad packets.
         *
         * @see self::enablePadding()
         */
        public function disablePadding()
        {
        }
        /**
         * Treat consecutive "packets" as if they are a continuous buffer.
         *
         * Say you have a 32-byte plaintext $plaintext.  Using the default behavior, the two following code snippets
         * will yield different outputs:
         *
         * <code>
         *    echo $rijndael->encrypt(substr($plaintext,  0, 16));
         *    echo $rijndael->encrypt(substr($plaintext, 16, 16));
         * </code>
         * <code>
         *    echo $rijndael->encrypt($plaintext);
         * </code>
         *
         * The solution is to enable the continuous buffer.  Although this will resolve the above discrepancy, it creates
         * another, as demonstrated with the following:
         *
         * <code>
         *    $rijndael->encrypt(substr($plaintext, 0, 16));
         *    echo $rijndael->decrypt($rijndael->encrypt(substr($plaintext, 16, 16)));
         * </code>
         * <code>
         *    echo $rijndael->decrypt($rijndael->encrypt(substr($plaintext, 16, 16)));
         * </code>
         *
         * With the continuous buffer disabled, these would yield the same output.  With it enabled, they yield different
         * outputs.  The reason is due to the fact that the initialization vector's change after every encryption /
         * decryption round when the continuous buffer is enabled.  When it's disabled, they remain constant.
         *
         * Put another way, when the continuous buffer is enabled, the state of the \phpseclib3\Crypt\*() object changes after each
         * encryption / decryption round, whereas otherwise, it'd remain constant.  For this reason, it's recommended that
         * continuous buffers not be used.  They do offer better security and are, in fact, sometimes required (SSH uses them),
         * however, they are also less intuitive and more likely to cause you problems.
         *
         * {@internal Could, but not must, extend by the child Crypt_* class}
         *
         * @see self::disableContinuousBuffer()
         */
        public function enableContinuousBuffer()
        {
        }
        /**
         * Treat consecutive packets as if they are a discontinuous buffer.
         *
         * The default behavior.
         *
         * {@internal Could, but not must, extend by the child Crypt_* class}
         *
         * @see self::enableContinuousBuffer()
         */
        public function disableContinuousBuffer()
        {
        }
        /**
         * Test for engine validity
         *
         * @see self::__construct()
         * @param int $engine
         * @return bool
         */
        protected function isValidEngineHelper($engine)
        {
        }
        /**
         * Test for engine validity
         *
         * @see self::__construct()
         * @param string $engine
         * @return bool
         */
        public function isValidEngine($engine)
        {
        }
        /**
         * Sets the preferred crypt engine
         *
         * Currently, $engine could be:
         *
         * - libsodium[very fast]
         *
         * - OpenSSL  [very fast]
         *
         * - mcrypt   [fast]
         *
         * - Eval     [slow]
         *
         * - PHP      [slowest]
         *
         * If the preferred crypt engine is not available the fastest available one will be used
         *
         * @see self::__construct()
         * @param string $engine
         */
        public function setPreferredEngine($engine)
        {
        }
        /**
         * Returns the engine currently being utilized
         *
         * @see self::setEngine()
         */
        public function getEngine()
        {
        }
        /**
         * Sets the engine as appropriate
         *
         * @see self::__construct()
         */
        protected function setEngine()
        {
        }
        /**
         * Encrypts a block
         *
         * Note: Must be extended by the child \phpseclib3\Crypt\* class
         *
         * @param string $in
         * @return string
         */
        abstract protected function encryptBlock($in);
        /**
         * Decrypts a block
         *
         * Note: Must be extended by the child \phpseclib3\Crypt\* class
         *
         * @param string $in
         * @return string
         */
        abstract protected function decryptBlock($in);
        /**
         * Setup the key (expansion)
         *
         * Only used if $engine == self::ENGINE_INTERNAL
         *
         * Note: Must extend by the child \phpseclib3\Crypt\* class
         *
         * @see self::setup()
         */
        abstract protected function setupKey();
        /**
         * Setup the self::ENGINE_INTERNAL $engine
         *
         * (re)init, if necessary, the internal cipher $engine and flush all $buffers
         * Used (only) if $engine == self::ENGINE_INTERNAL
         *
         * _setup() will be called each time if $changed === true
         * typically this happens when using one or more of following public methods:
         *
         * - setKey()
         *
         * - setIV()
         *
         * - disableContinuousBuffer()
         *
         * - First run of encrypt() / decrypt() with no init-settings
         *
         * {@internal setup() is always called before en/decryption.}
         *
         * {@internal Could, but not must, extend by the child Crypt_* class}
         *
         * @see self::setKey()
         * @see self::setIV()
         * @see self::disableContinuousBuffer()
         */
        protected function setup()
        {
        }
        /**
         * Pads a string
         *
         * Pads a string using the RSA PKCS padding standards so that its length is a multiple of the blocksize.
         * $this->block_size - (strlen($text) % $this->block_size) bytes are added, each of which is equal to
         * chr($this->block_size - (strlen($text) % $this->block_size)
         *
         * If padding is disabled and $text is not a multiple of the blocksize, the string will be padded regardless
         * and padding will, hence forth, be enabled.
         *
         * @see self::unpad()
         * @param string $text
         * @throws \LengthException if padding is disabled and the plaintext's length is not a multiple of the block size
         * @return string
         */
        protected function pad($text)
        {
        }
        /**
         * Unpads a string.
         *
         * If padding is enabled and the reported padding length is invalid the encryption key will be assumed to be wrong
         * and false will be returned.
         *
         * @see self::pad()
         * @param string $text
         * @throws \LengthException if the ciphertext's length is not a multiple of the block size
         * @return string
         */
        protected function unpad($text)
        {
        }
        /**
         * Setup the performance-optimized function for de/encrypt()
         *
         * Stores the created (or existing) callback function-name
         * in $this->inline_crypt
         *
         * Internally for phpseclib developers:
         *
         *     _setupInlineCrypt() would be called only if:
         *
         *     - $this->engine === self::ENGINE_EVAL
         *
         *     - each time on _setup(), after(!) _setupKey()
         *
         *
         *     This ensures that _setupInlineCrypt() has always a
         *     full ready2go initializated internal cipher $engine state
         *     where, for example, the keys already expanded,
         *     keys/block_size calculated and such.
         *
         *     It is, each time if called, the responsibility of _setupInlineCrypt():
         *
         *     - to set $this->inline_crypt to a valid and fully working callback function
         *       as a (faster) replacement for encrypt() / decrypt()
         *
         *     - NOT to create unlimited callback functions (for memory reasons!)
         *       no matter how often _setupInlineCrypt() would be called. At some
         *       point of amount they must be generic re-useable.
         *
         *     - the code of _setupInlineCrypt() it self,
         *       and the generated callback code,
         *       must be, in following order:
         *       - 100% safe
         *       - 100% compatible to encrypt()/decrypt()
         *       - using only php5+ features/lang-constructs/php-extensions if
         *         compatibility (down to php4) or fallback is provided
         *       - readable/maintainable/understandable/commented and... not-cryptic-styled-code :-)
         *       - >= 10% faster than encrypt()/decrypt() [which is, by the way,
         *         the reason for the existence of _setupInlineCrypt() :-)]
         *       - memory-nice
         *       - short (as good as possible)
         *
         * Note: - _setupInlineCrypt() is using _createInlineCryptFunction() to create the full callback function code.
         *       - In case of using inline crypting, _setupInlineCrypt() must extend by the child \phpseclib3\Crypt\* class.
         *       - The following variable names are reserved:
         *         - $_*  (all variable names prefixed with an underscore)
         *         - $self (object reference to it self. Do not use $this, but $self instead)
         *         - $in (the content of $in has to en/decrypt by the generated code)
         *       - The callback function should not use the 'return' statement, but en/decrypt'ing the content of $in only
         *
         * {@internal If a Crypt_* class providing inline crypting it must extend _setupInlineCrypt()}
         *
         * @see self::setup()
         * @see self::createInlineCryptFunction()
         * @see self::encrypt()
         * @see self::decrypt()
         */
        //protected function setupInlineCrypt();
        /**
         * Creates the performance-optimized function for en/decrypt()
         *
         * Internally for phpseclib developers:
         *
         *    _createInlineCryptFunction():
         *
         *    - merge the $cipher_code [setup'ed by _setupInlineCrypt()]
         *      with the current [$this->]mode of operation code
         *
         *    - create the $inline function, which called by encrypt() / decrypt()
         *      as its replacement to speed up the en/decryption operations.
         *
         *    - return the name of the created $inline callback function
         *
         *    - used to speed up en/decryption
         *
         *
         *
         *    The main reason why can speed up things [up to 50%] this way are:
         *
         *    - using variables more effective then regular.
         *      (ie no use of expensive arrays but integers $k_0, $k_1 ...
         *      or even, for example, the pure $key[] values hardcoded)
         *
         *    - avoiding 1000's of function calls of ie _encryptBlock()
         *      but inlining the crypt operations.
         *      in the mode of operation for() loop.
         *
         *    - full loop unroll the (sometimes key-dependent) rounds
         *      avoiding this way ++$i counters and runtime-if's etc...
         *
         *    The basic code architectur of the generated $inline en/decrypt()
         *    lambda function, in pseudo php, is:
         *
         *    <code>
         *    +----------------------------------------------------------------------------------------------+
         *    | callback $inline = create_function:                                                          |
         *    | lambda_function_0001_crypt_ECB($action, $text)                                               |
         *    | {                                                                                            |
         *    |     INSERT PHP CODE OF:                                                                      |
         *    |     $cipher_code['init_crypt'];                  // general init code.                       |
         *    |                                                  // ie: $sbox'es declarations used for       |
         *    |                                                  //     encrypt and decrypt'ing.             |
         *    |                                                                                              |
         *    |     switch ($action) {                                                                       |
         *    |         case 'encrypt':                                                                      |
         *    |             INSERT PHP CODE OF:                                                              |
         *    |             $cipher_code['init_encrypt'];       // encrypt sepcific init code.               |
         *    |                                                    ie: specified $key or $box                |
         *    |                                                        declarations for encrypt'ing.         |
         *    |                                                                                              |
         *    |             foreach ($ciphertext) {                                                          |
         *    |                 $in = $block_size of $ciphertext;                                            |
         *    |                                                                                              |
         *    |                 INSERT PHP CODE OF:                                                          |
         *    |                 $cipher_code['encrypt_block'];  // encrypt's (string) $in, which is always:  |
         *    |                                                 // strlen($in) == $this->block_size          |
         *    |                                                 // here comes the cipher algorithm in action |
         *    |                                                 // for encryption.                           |
         *    |                                                 // $cipher_code['encrypt_block'] has to      |
         *    |                                                 // encrypt the content of the $in variable   |
         *    |                                                                                              |
         *    |                 $plaintext .= $in;                                                           |
         *    |             }                                                                                |
         *    |             return $plaintext;                                                               |
         *    |                                                                                              |
         *    |         case 'decrypt':                                                                      |
         *    |             INSERT PHP CODE OF:                                                              |
         *    |             $cipher_code['init_decrypt'];       // decrypt sepcific init code                |
         *    |                                                    ie: specified $key or $box                |
         *    |                                                        declarations for decrypt'ing.         |
         *    |             foreach ($plaintext) {                                                           |
         *    |                 $in = $block_size of $plaintext;                                             |
         *    |                                                                                              |
         *    |                 INSERT PHP CODE OF:                                                          |
         *    |                 $cipher_code['decrypt_block'];  // decrypt's (string) $in, which is always   |
         *    |                                                 // strlen($in) == $this->block_size          |
         *    |                                                 // here comes the cipher algorithm in action |
         *    |                                                 // for decryption.                           |
         *    |                                                 // $cipher_code['decrypt_block'] has to      |
         *    |                                                 // decrypt the content of the $in variable   |
         *    |                 $ciphertext .= $in;                                                          |
         *    |             }                                                                                |
         *    |             return $ciphertext;                                                              |
         *    |     }                                                                                        |
         *    | }                                                                                            |
         *    +----------------------------------------------------------------------------------------------+
         *    </code>
         *
         *    See also the \phpseclib3\Crypt\*::_setupInlineCrypt()'s for
         *    productive inline $cipher_code's how they works.
         *
         *    Structure of:
         *    <code>
         *    $cipher_code = [
         *        'init_crypt'    => (string) '', // optional
         *        'init_encrypt'  => (string) '', // optional
         *        'init_decrypt'  => (string) '', // optional
         *        'encrypt_block' => (string) '', // required
         *        'decrypt_block' => (string) ''  // required
         *    ];
         *    </code>
         *
         * @see self::setupInlineCrypt()
         * @see self::encrypt()
         * @see self::decrypt()
         * @param array $cipher_code
         * @return string (the name of the created callback function)
         */
        protected function createInlineCryptFunction($cipher_code)
        {
        }
        /**
         * Convert float to int
         *
         * On ARM CPUs converting floats to ints doesn't always work
         *
         * @param string $x
         * @return int
         */
        protected static function safe_intval($x)
        {
        }
        /**
         * eval()'able string for in-line float to int
         *
         * @return string
         */
        protected static function safe_intval_inline()
        {
        }
        /**
         * NULL pads a string to be a multiple of 128
         *
         * @see self::decrypt()
         * @see self::encrypt()
         * @see self::setupGCM()
         * @param string $str
         * @return string
         */
        protected static function nullPad128($str)
        {
        }
        /**
         * Calculates Poly1305 MAC
         *
         * On my system ChaCha20, with libsodium, takes 0.5s. With this custom Poly1305 implementation
         * it takes 1.2s.
         *
         * @see self::decrypt()
         * @see self::encrypt()
         * @param string $text
         * @return string
         */
        protected function poly1305($text)
        {
        }
        /**
         * Return the mode
         *
         * You can do $obj instanceof AES or whatever to get the cipher but you can't do that to get the mode
         *
         * @return string
         */
        public function getMode()
        {
        }
        /**
         * Is the continuous buffer enabled?
         *
         * @return boolean
         */
        public function continuousBufferEnabled()
        {
        }
    }
    /**
     * Base Class for all block cipher classes
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class BlockCipher extends \phpseclib3\Crypt\Common\SymmetricKey
    {
    }
}
namespace phpseclib3\Crypt {
    /**
     * Pure-PHP implementation of Rijndael.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class Rijndael extends \phpseclib3\Crypt\Common\BlockCipher
    {
        /**
         * The mcrypt specific name of the cipher
         *
         * Mcrypt is useable for 128/192/256-bit $block_size/$key_length. For 160/224 not.
         * \phpseclib3\Crypt\Rijndael determines automatically whether mcrypt is useable
         * or not for the current $block_size/$key_length.
         * In case of, $cipher_name_mcrypt will be set dynamically at run time accordingly.
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::cipher_name_mcrypt
         * @see \phpseclib3\Crypt\Common\SymmetricKey::engine
         * @see self::isValidEngine()
         * @var string
         */
        protected $cipher_name_mcrypt = 'rijndael-128';
        /**
         * The Key Length (in bytes)
         *
         * {@internal The max value is 256 / 8 = 32, the min value is 128 / 8 = 16.  Exists in conjunction with $Nk
         *    because the encryption / decryption / key schedule creation requires this number and not $key_length.  We could
         *    derive this from $key_length or vice versa, but that'd mean we'd have to do multiple shift operations, so in lieu
         *    of that, we'll just precompute it once.}
         *
         * @see self::setKeyLength()
         * @var int
         */
        protected $key_length = 16;
        /**
         * Default Constructor.
         *
         * @param string $mode
         * @throws \InvalidArgumentException if an invalid / unsupported mode is provided
         */
        public function __construct($mode)
        {
        }
        /**
         * Sets the key length.
         *
         * Valid key lengths are 128, 160, 192, 224, and 256.
         *
         * Note: phpseclib extends Rijndael (and AES) for using 160- and 224-bit keys but they are officially not defined
         *       and the most (if not all) implementations are not able using 160/224-bit keys but round/pad them up to
         *       192/256 bits as, for example, mcrypt will do.
         *
         *       That said, if you want be compatible with other Rijndael and AES implementations,
         *       you should not setKeyLength(160) or setKeyLength(224).
         *
         * Additional: In case of 160- and 224-bit keys, phpseclib will/can, for that reason, not use
         *             the mcrypt php extension, even if available.
         *             This results then in slower encryption.
         *
         * @throws \LengthException if the key length is invalid
         * @param int $length
         */
        public function setKeyLength($length)
        {
        }
        /**
         * Sets the key.
         *
         * Rijndael supports five different key lengths
         *
         * @see setKeyLength()
         * @param string $key
         * @throws \LengthException if the key length isn't supported
         */
        public function setKey($key)
        {
        }
        /**
         * Sets the block length
         *
         * Valid block lengths are 128, 160, 192, 224, and 256.
         *
         * @param int $length
         */
        public function setBlockLength($length)
        {
        }
        /**
         * Test for engine validity
         *
         * This is mainly just a wrapper to set things up for \phpseclib3\Crypt\Common\SymmetricKey::isValidEngine()
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::__construct()
         * @param int $engine
         * @return bool
         */
        protected function isValidEngineHelper($engine)
        {
        }
        /**
         * Encrypts a block
         *
         * @param string $in
         * @return string
         */
        protected function encryptBlock($in)
        {
        }
        /**
         * Decrypts a block
         *
         * @param string $in
         * @return string
         */
        protected function decryptBlock($in)
        {
        }
        /**
         * Setup the self::ENGINE_INTERNAL $engine
         *
         * (re)init, if necessary, the internal cipher $engine and flush all $buffers
         * Used (only) if $engine == self::ENGINE_INTERNAL
         *
         * _setup() will be called each time if $changed === true
         * typically this happens when using one or more of following public methods:
         *
         * - setKey()
         *
         * - setIV()
         *
         * - disableContinuousBuffer()
         *
         * - First run of encrypt() / decrypt() with no init-settings
         *
         * {@internal setup() is always called before en/decryption.}
         *
         * {@internal Could, but not must, extend by the child Crypt_* class}
         *
         * @see self::setKey()
         * @see self::setIV()
         * @see self::disableContinuousBuffer()
         */
        protected function setup()
        {
        }
        /**
         * Setup the key (expansion)
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::setupKey()
         */
        protected function setupKey()
        {
        }
        /**
         * Provides the mixColumns and sboxes tables
         *
         * @see self::encryptBlock()
         * @see self::setupInlineCrypt()
         * @see self::subWord()
         * @return array &$tables
         */
        protected function &getTables()
        {
        }
        /**
         * Provides the inverse mixColumns and inverse sboxes tables
         *
         * @see self::decryptBlock()
         * @see self::setupInlineCrypt()
         * @see self::setupKey()
         * @return array &$tables
         */
        protected function &getInvTables()
        {
        }
        /**
         * Setup the performance-optimized function for de/encrypt()
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::setupInlineCrypt()
         */
        protected function setupInlineCrypt()
        {
        }
        /**
         * Encrypts a message.
         *
         * @see self::decrypt()
         * @see parent::encrypt()
         * @param string $plaintext
         * @return string
         */
        public function encrypt($plaintext)
        {
        }
        /**
         * Decrypts a message.
         *
         * @see self::encrypt()
         * @see parent::decrypt()
         * @param string $ciphertext
         * @return string
         */
        public function decrypt($ciphertext)
        {
        }
    }
    /**
     * Pure-PHP implementation of AES.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class AES extends \phpseclib3\Crypt\Rijndael
    {
        /**
         * Dummy function
         *
         * Since \phpseclib3\Crypt\AES extends \phpseclib3\Crypt\Rijndael, this function is, technically, available, but it doesn't do anything.
         *
         * @see \phpseclib3\Crypt\Rijndael::setBlockLength()
         * @param int $length
         * @throws \BadMethodCallException anytime it's called
         */
        public function setBlockLength($length)
        {
        }
        /**
         * Sets the key length
         *
         * Valid key lengths are 128, 192, and 256.  Set the link to bool(false) to disable a fixed key length
         *
         * @see \phpseclib3\Crypt\Rijndael:setKeyLength()
         * @param int $length
         * @throws \LengthException if the key length isn't supported
         */
        public function setKeyLength($length)
        {
        }
        /**
         * Sets the key.
         *
         * Rijndael supports five different key lengths, AES only supports three.
         *
         * @see \phpseclib3\Crypt\Rijndael:setKey()
         * @see setKeyLength()
         * @param string $key
         * @throws \LengthException if the key length isn't supported
         */
        public function setKey($key)
        {
        }
    }
    /**
     * Pure-PHP implementation of Blowfish.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     * @author  Hans-Juergen Petrich <petrich@tronic-media.com>
     */
    class Blowfish extends \phpseclib3\Crypt\Common\BlockCipher
    {
        /**
         * Block Length of the cipher
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::block_size
         * @var int
         */
        protected $block_size = 8;
        /**
         * The mcrypt specific name of the cipher
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::cipher_name_mcrypt
         * @var string
         */
        protected $cipher_name_mcrypt = 'blowfish';
        /**
         * Optimizing value while CFB-encrypting
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::cfb_init_len
         * @var int
         */
        protected $cfb_init_len = 500;
        /**
         * The Key Length (in bytes)
         * {@internal The max value is 256 / 8 = 32, the min value is 128 / 8 = 16.  Exists in conjunction with $Nk
         *    because the encryption / decryption / key schedule creation requires this number and not $key_length.  We could
         *    derive this from $key_length or vice versa, but that'd mean we'd have to do multiple shift operations, so in lieu
         *    of that, we'll just precompute it once.}
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::setKeyLength()
         * @var int
         */
        protected $key_length = 16;
        /**
         * Default Constructor.
         *
         * @param string $mode
         * @throws \InvalidArgumentException if an invalid / unsupported mode is provided
         */
        public function __construct($mode)
        {
        }
        /**
         * Sets the key length.
         *
         * Key lengths can be between 32 and 448 bits.
         *
         * @param int $length
         */
        public function setKeyLength($length)
        {
        }
        /**
         * Test for engine validity
         *
         * This is mainly just a wrapper to set things up for \phpseclib3\Crypt\Common\SymmetricKey::isValidEngine()
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::isValidEngine()
         * @param int $engine
         * @return bool
         */
        protected function isValidEngineHelper($engine)
        {
        }
        /**
         * Setup the key (expansion)
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::_setupKey()
         */
        protected function setupKey()
        {
        }
        /**
         * Initialize Static Variables
         */
        protected static function initialize_static_variables()
        {
        }
        /**
         * Performs OpenSSH-style bcrypt
         *
         * @param string $pass
         * @param string $salt
         * @param int $keylen
         * @param int $rounds
         * @access public
         * @return string
         */
        public static function bcrypt_pbkdf($pass, $salt, $keylen, $rounds)
        {
        }
        /**
         * Encrypts a block
         *
         * @param string $in
         * @return string
         */
        protected function encryptBlock($in)
        {
        }
        /**
         * Decrypts a block
         *
         * @param string $in
         * @return string
         */
        protected function decryptBlock($in)
        {
        }
        /**
         * Setup the performance-optimized function for de/encrypt()
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::_setupInlineCrypt()
         */
        protected function setupInlineCrypt()
        {
        }
    }
}
namespace phpseclib3\Crypt\Common {
    /**
     * Base Class for all stream cipher classes
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class StreamCipher extends \phpseclib3\Crypt\Common\SymmetricKey
    {
        /**
         * Block Length of the cipher
         *
         * Stream ciphers do not have a block size
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::block_size
         * @var int
         */
        protected $block_size = 0;
        /**
         * Default Constructor.
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::__construct()
         * @return StreamCipher
         */
        public function __construct()
        {
        }
        /**
         * Stream ciphers not use an IV
         *
         * @return bool
         */
        public function usesIV()
        {
        }
    }
}
namespace phpseclib3\Crypt {
    /**
     * Pure-PHP implementation of Salsa20.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class Salsa20 extends \phpseclib3\Crypt\Common\StreamCipher
    {
        /**
         * Part 1 of the state
         *
         * @var string|false
         */
        protected $p1 = false;
        /**
         * Part 2 of the state
         *
         * @var string|false
         */
        protected $p2 = false;
        /**
         * Key Length (in bytes)
         *
         * @var int
         */
        protected $key_length = 32;
        // = 256 bits
        /**
         * @see \phpseclib3\Crypt\Salsa20::crypt()
         */
        const ENCRYPT = 0;
        /**
         * @see \phpseclib3\Crypt\Salsa20::crypt()
         */
        const DECRYPT = 1;
        /**
         * Encryption buffer for continuous mode
         *
         * @var array
         */
        protected $enbuffer;
        /**
         * Decryption buffer for continuous mode
         *
         * @var array
         */
        protected $debuffer;
        /**
         * Counter
         *
         * @var int
         */
        protected $counter = 0;
        /**
         * Using Generated Poly1305 Key
         *
         * @var boolean
         */
        protected $usingGeneratedPoly1305Key = false;
        /**
         * Salsa20 uses a nonce
         *
         * @return bool
         */
        public function usesNonce()
        {
        }
        /**
         * Sets the key.
         *
         * @param string $key
         * @throws \LengthException if the key length isn't supported
         */
        public function setKey($key)
        {
        }
        /**
         * Sets the nonce.
         *
         * @param string $nonce
         */
        public function setNonce($nonce)
        {
        }
        /**
         * Sets the counter.
         *
         * @param int $counter
         */
        public function setCounter($counter)
        {
        }
        /**
         * Creates a Poly1305 key using the method discussed in RFC8439
         *
         * See https://tools.ietf.org/html/rfc8439#section-2.6.1
         */
        protected function createPoly1305Key()
        {
        }
        /**
         * Setup the self::ENGINE_INTERNAL $engine
         *
         * (re)init, if necessary, the internal cipher $engine
         *
         * _setup() will be called each time if $changed === true
         * typically this happens when using one or more of following public methods:
         *
         * - setKey()
         *
         * - setNonce()
         *
         * - First run of encrypt() / decrypt() with no init-settings
         *
         * @see self::setKey()
         * @see self::setNonce()
         * @see self::disableContinuousBuffer()
         */
        protected function setup()
        {
        }
        /**
         * Setup the key (expansion)
         */
        protected function setupKey()
        {
        }
        /**
         * Encrypts a message.
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::decrypt()
         * @see self::crypt()
         * @param string $plaintext
         * @return string $ciphertext
         */
        public function encrypt($plaintext)
        {
        }
        /**
         * Decrypts a message.
         *
         * $this->decrypt($this->encrypt($plaintext)) == $this->encrypt($this->encrypt($plaintext)).
         * At least if the continuous buffer is disabled.
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::encrypt()
         * @see self::crypt()
         * @param string $ciphertext
         * @return string $plaintext
         */
        public function decrypt($ciphertext)
        {
        }
        /**
         * Encrypts a block
         *
         * @param string $in
         */
        protected function encryptBlock($in)
        {
        }
        /**
         * Decrypts a block
         *
         * @param string $in
         */
        protected function decryptBlock($in)
        {
        }
        /**
         * Left Rotate
         *
         * @param int $x
         * @param int $n
         * @return int
         */
        protected static function leftRotate($x, $n)
        {
        }
        /**
         * The quarterround function
         *
         * @param int $a
         * @param int $b
         * @param int $c
         * @param int $d
         */
        protected static function quarterRound(&$a, &$b, &$c, &$d)
        {
        }
        /**
         * The doubleround function
         *
         * @param int $x0 (by reference)
         * @param int $x1 (by reference)
         * @param int $x2 (by reference)
         * @param int $x3 (by reference)
         * @param int $x4 (by reference)
         * @param int $x5 (by reference)
         * @param int $x6 (by reference)
         * @param int $x7 (by reference)
         * @param int $x8 (by reference)
         * @param int $x9 (by reference)
         * @param int $x10 (by reference)
         * @param int $x11 (by reference)
         * @param int $x12 (by reference)
         * @param int $x13 (by reference)
         * @param int $x14 (by reference)
         * @param int $x15 (by reference)
         */
        protected static function doubleRound(&$x0, &$x1, &$x2, &$x3, &$x4, &$x5, &$x6, &$x7, &$x8, &$x9, &$x10, &$x11, &$x12, &$x13, &$x14, &$x15)
        {
        }
        /**
         * The Salsa20 hash function function
         *
         * @param string $x
         */
        protected static function salsa20($x)
        {
        }
        /**
         * Calculates Poly1305 MAC
         *
         * @see self::decrypt()
         * @see self::encrypt()
         * @param string $ciphertext
         * @return string
         */
        protected function poly1305($ciphertext)
        {
        }
    }
    /**
     * Pure-PHP implementation of ChaCha20.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class ChaCha20 extends \phpseclib3\Crypt\Salsa20
    {
        /**
         * The OpenSSL specific name of the cipher
         *
         * @var string
         */
        protected $cipher_name_openssl = 'chacha20';
        /**
         * Test for engine validity
         *
         * This is mainly just a wrapper to set things up for \phpseclib3\Crypt\Common\SymmetricKey::isValidEngine()
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::__construct()
         * @param int $engine
         * @return bool
         */
        protected function isValidEngineHelper($engine)
        {
        }
        /**
         * Encrypts a message.
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::decrypt()
         * @see self::crypt()
         * @param string $plaintext
         * @return string $ciphertext
         */
        public function encrypt($plaintext)
        {
        }
        /**
         * Decrypts a message.
         *
         * $this->decrypt($this->encrypt($plaintext)) == $this->encrypt($this->encrypt($plaintext)).
         * At least if the continuous buffer is disabled.
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::encrypt()
         * @see self::crypt()
         * @param string $ciphertext
         * @return string $plaintext
         */
        public function decrypt($ciphertext)
        {
        }
        /**
         * Sets the nonce.
         *
         * @param string $nonce
         */
        public function setNonce($nonce)
        {
        }
        /**
         * Setup the self::ENGINE_INTERNAL $engine
         *
         * (re)init, if necessary, the internal cipher $engine
         *
         * _setup() will be called each time if $changed === true
         * typically this happens when using one or more of following public methods:
         *
         * - setKey()
         *
         * - setNonce()
         *
         * - First run of encrypt() / decrypt() with no init-settings
         *
         * @see self::setKey()
         * @see self::setNonce()
         * @see self::disableContinuousBuffer()
         */
        protected function setup()
        {
        }
        /**
         * The quarterround function
         *
         * @param int $a
         * @param int $b
         * @param int $c
         * @param int $d
         */
        protected static function quarterRound(&$a, &$b, &$c, &$d)
        {
        }
        /**
         * The doubleround function
         *
         * @param int $x0 (by reference)
         * @param int $x1 (by reference)
         * @param int $x2 (by reference)
         * @param int $x3 (by reference)
         * @param int $x4 (by reference)
         * @param int $x5 (by reference)
         * @param int $x6 (by reference)
         * @param int $x7 (by reference)
         * @param int $x8 (by reference)
         * @param int $x9 (by reference)
         * @param int $x10 (by reference)
         * @param int $x11 (by reference)
         * @param int $x12 (by reference)
         * @param int $x13 (by reference)
         * @param int $x14 (by reference)
         * @param int $x15 (by reference)
         */
        protected static function doubleRound(&$x0, &$x1, &$x2, &$x3, &$x4, &$x5, &$x6, &$x7, &$x8, &$x9, &$x10, &$x11, &$x12, &$x13, &$x14, &$x15)
        {
        }
        /**
         * The Salsa20 hash function function
         *
         * On my laptop this loop unrolled / function dereferenced version of parent::salsa20 encrypts 1mb of text in
         * 0.65s vs the 0.85s that it takes with the parent method.
         *
         * If we were free to assume that the host OS would always be 64-bits then the if condition in leftRotate could
         * be eliminated and we could knock this done to 0.60s.
         *
         * For comparison purposes, RC4 takes 0.16s and AES in CTR mode with the Eval engine takes 0.48s.
         * AES in CTR mode with the PHP engine takes 1.19s. Salsa20 / ChaCha20 do not benefit as much from the Eval
         * approach due to the fact that there are a lot less variables to de-reference, fewer loops to unroll, etc
         *
         * @param string $x
         */
        protected static function salsa20($x)
        {
        }
    }
}
namespace phpseclib3\Crypt\Common {
    /**
     * Base Class for all asymmetric cipher classes
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class AsymmetricKey
    {
        /**
         * Precomputed Zero
         *
         * @var BigInteger
         */
        protected static $zero;
        /**
         * Precomputed One
         *
         * @var BigInteger
         */
        protected static $one;
        /**
         * Format of the loaded key
         *
         * @var string
         */
        protected $format;
        /**
         * Hash function
         *
         * @var Hash
         */
        protected $hash;
        /**
         * Available Engines
         *
         * @var boolean[]
         */
        protected static $engines = [];
        /**
         * @param string $type
         * @return array|string
         */
        abstract public function toString($type, array $options = []);
        /**
         * The constructor
         */
        protected function __construct()
        {
        }
        /**
         * Initialize static variables
         */
        protected static function initialize_static_variables()
        {
        }
        /**
         * Load the key
         *
         * @param string $key
         * @param string $password optional
         * @return PublicKey|PrivateKey
         */
        public static function load($key, $password = false)
        {
        }
        /**
         * Loads a private key
         *
         * @return PrivateKey
         * @param string|array $key
         * @param string $password optional
         */
        public static function loadPrivateKey($key, $password = '')
        {
        }
        /**
         * Loads a public key
         *
         * @return PublicKey
         * @param string|array $key
         */
        public static function loadPublicKey($key)
        {
        }
        /**
         * Loads parameters
         *
         * @return AsymmetricKey
         * @param string|array $key
         */
        public static function loadParameters($key)
        {
        }
        /**
         * Load the key, assuming a specific format
         *
         * @param string $type
         * @param string $key
         * @param string $password optional
         * @return static
         */
        public static function loadFormat($type, $key, $password = false)
        {
        }
        /**
         * Loads a private key
         *
         * @return PrivateKey
         * @param string $type
         * @param string $key
         * @param string $password optional
         */
        public static function loadPrivateKeyFormat($type, $key, $password = false)
        {
        }
        /**
         * Loads a public key
         *
         * @return PublicKey
         * @param string $type
         * @param string $key
         */
        public static function loadPublicKeyFormat($type, $key)
        {
        }
        /**
         * Loads parameters
         *
         * @return AsymmetricKey
         * @param string $type
         * @param string|array $key
         */
        public static function loadParametersFormat($type, $key)
        {
        }
        /**
         * Validate Plugin
         *
         * @param string $format
         * @param string $type
         * @param string $method optional
         * @return mixed
         */
        protected static function validatePlugin($format, $type, $method = null)
        {
        }
        /**
         * Returns a list of supported formats.
         *
         * @return array
         */
        public static function getSupportedKeyFormats()
        {
        }
        /**
         * Add a fileformat plugin
         *
         * The plugin needs to either already be loaded or be auto-loadable.
         * Loading a plugin whose shortname overwrite an existing shortname will overwrite the old plugin.
         *
         * @see self::load()
         * @param string $fullname
         * @return bool
         */
        public static function addFileFormat($fullname)
        {
        }
        /**
         * Returns the format of the loaded key.
         *
         * If the key that was loaded wasn't in a valid or if the key was auto-generated
         * with RSA::createKey() then this will throw an exception.
         *
         * @see self::load()
         * @return mixed
         */
        public function getLoadedFormat()
        {
        }
        /**
         * Returns the key's comment
         *
         * Not all key formats support comments. If you want to set a comment use toString()
         *
         * @return null|string
         */
        public function getComment()
        {
        }
        /**
         * Tests engine validity
         *
         */
        public static function useBestEngine()
        {
        }
        /**
         * Flag to use internal engine only (useful for unit testing)
         *
         */
        public static function useInternalEngine()
        {
        }
        /**
         * __toString() magic method
         *
         * @return string
         */
        public function __toString()
        {
        }
        /**
         * Determines which hashing function should be used
         *
         * @param string $hash
         */
        public function withHash($hash)
        {
        }
        /**
         * Returns the hash algorithm currently being used
         *
         */
        public function getHash()
        {
        }
        /**
         * Compute the pseudorandom k for signature generation,
         * using the process specified for deterministic DSA.
         *
         * @param string $h1
         * @return string
         */
        protected function computek($h1)
        {
        }
        /**
         * Bit String to Integer
         *
         * @param string $in
         * @return BigInteger
         */
        protected function bits2int($in)
        {
        }
    }
}
namespace phpseclib3\Crypt\Common\Formats\Keys {
    /**
     * JSON Web Key Formatted Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class JWK
    {
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Wrap a key appropriately
         *
         * @return string
         */
        protected static function wrapKey(array $key, array $options)
        {
        }
    }
    /**
     * OpenSSH Formatted RSA Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class OpenSSH
    {
        /**
         * Default comment
         *
         * @var string
         */
        protected static $comment = 'phpseclib-generated-key';
        /**
         * Binary key flag
         *
         * @var bool
         */
        protected static $binary = false;
        /**
         * Sets the default comment
         *
         * @param string $comment
         */
        public static function setComment($comment)
        {
        }
        /**
         * Break a public or private key down into its constituent components
         *
         * $type can be either ssh-dss or ssh-rsa
         *
         * @param string $key
         * @param string $password
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Toggle between binary and printable keys
         *
         * Printable keys are what are generated by default. These are the ones that go in
         * $HOME/.ssh/authorized_key.
         *
         * @param bool $enabled
         */
        public static function setBinaryOutput($enabled)
        {
        }
        /**
         * Wrap a private key appropriately
         *
         * @param string $publicKey
         * @param string $privateKey
         * @param string $password
         * @param array $options
         * @return string
         */
        protected static function wrapPrivateKey($publicKey, $privateKey, $password, $options)
        {
        }
    }
    /**
     * PKCS1 Formatted Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PKCS
    {
        /**
         * Auto-detect the format
         */
        const MODE_ANY = 0;
        /**
         * Require base64-encoded PEM's be supplied
         */
        const MODE_PEM = 1;
        /**
         * Require raw DER's be supplied
         */
        const MODE_DER = 2;
        /**#@-*/
        /**
         * Is the key a base-64 encoded PEM, DER or should it be auto-detected?
         *
         * @var int
         */
        protected static $format = self::MODE_ANY;
        /**
         * Require base64-encoded PEM's be supplied
         *
         */
        public static function requirePEM()
        {
        }
        /**
         * Require raw DER's be supplied
         *
         */
        public static function requireDER()
        {
        }
        /**
         * Accept any format and auto detect the format
         *
         * This is the default setting
         *
         */
        public static function requireAny()
        {
        }
    }
    /**
     * PKCS1 Formatted Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PKCS1 extends \phpseclib3\Crypt\Common\Formats\Keys\PKCS
    {
        /**
         * Sets the default encryption algorithm
         *
         * @param string $algo
         */
        public static function setEncryptionAlgorithm($algo)
        {
        }
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        protected static function load($key, $password)
        {
        }
        /**
         * Wrap a private key appropriately
         *
         * @param string $key
         * @param string $type
         * @param string $password
         * @param array $options optional
         * @return string
         */
        protected static function wrapPrivateKey($key, $type, $password, array $options = [])
        {
        }
        /**
         * Wrap a public key appropriately
         *
         * @param string $key
         * @param string $type
         * @return string
         */
        protected static function wrapPublicKey($key, $type)
        {
        }
    }
    /**
     * PKCS#8 Formatted Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PKCS8 extends \phpseclib3\Crypt\Common\Formats\Keys\PKCS
    {
        /**
         * Sets the default encryption algorithm
         *
         * @param string $algo
         */
        public static function setEncryptionAlgorithm($algo)
        {
        }
        /**
         * Sets the default encryption algorithm for PBES2
         *
         * @param string $algo
         */
        public static function setEncryptionScheme($algo)
        {
        }
        /**
         * Sets the iteration count
         *
         * @param int $count
         */
        public static function setIterationCount($count)
        {
        }
        /**
         * Sets the PRF for PBES2
         *
         * @param string $algo
         */
        public static function setPRF($algo)
        {
        }
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        protected static function load($key, $password = '')
        {
        }
        /**
         * Toggle between binary (DER) and printable (PEM) keys
         *
         * Printable keys are what are generated by default.
         *
         * @param bool $enabled
         */
        public static function setBinaryOutput($enabled)
        {
        }
        /**
         * Wrap a private key appropriately
         *
         * @param string $key
         * @param string $attr
         * @param mixed $params
         * @param string $password
         * @param string $oid optional
         * @param string $publicKey optional
         * @param array $options optional
         * @return string
         */
        protected static function wrapPrivateKey($key, $attr, $params, $password, $oid = null, $publicKey = '', array $options = [])
        {
        }
        /**
         * Wrap a public key appropriately
         *
         * @param string $key
         * @param mixed $params
         * @param string $oid
         * @return string
         */
        protected static function wrapPublicKey($key, $params, $oid = null, array $options = [])
        {
        }
        /**
         * Returns the encryption parameters used by the key
         *
         * @param string $key
         * @return array
         */
        public static function extractEncryptionAlgorithm($key)
        {
        }
    }
    /**
     * PuTTY Formatted Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PuTTY
    {
        /**
         * Sets the default comment
         *
         * @param string $comment
         */
        public static function setComment($comment)
        {
        }
        /**
         * Sets the default version
         *
         * @param int $version
         */
        public static function setVersion($version)
        {
        }
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password
         * @return array
         */
        public static function load($key, $password)
        {
        }
        /**
         * Wrap a private key appropriately
         *
         * @param string $public
         * @param string $private
         * @param string $type
         * @param string $password
         * @param array $options optional
         * @return string
         */
        protected static function wrapPrivateKey($public, $private, $type, $password, array $options = [])
        {
        }
        /**
         * Wrap a public key appropriately
         *
         * This is basically the format described in RFC 4716 (https://tools.ietf.org/html/rfc4716)
         *
         * @param string $key
         * @param string $type
         * @return string
         */
        protected static function wrapPublicKey($key, $type)
        {
        }
    }
}
namespace phpseclib3\Crypt\Common\Formats\Signature {
    /**
     * Raw Signature Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Raw
    {
        /**
         * Loads a signature
         *
         * @param array $sig
         * @return array|bool
         */
        public static function load($sig)
        {
        }
        /**
         * Returns a signature in the appropriate format
         *
         * @param BigInteger $r
         * @param BigInteger $s
         * @return string
         */
        public static function save(\phpseclib3\Math\BigInteger $r, \phpseclib3\Math\BigInteger $s)
        {
        }
    }
}
namespace phpseclib3\Crypt\Common {
    /**
     * PrivateKey interface
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    interface PrivateKey
    {
        public function sign($message);
        //public function decrypt($ciphertext);
        public function getPublicKey();
        public function toString($type, array $options = []);
        /**
         * @param string|false $password
         * @return mixed
         */
        public function withPassword($password = false);
    }
    /**
     * PublicKey interface
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    interface PublicKey
    {
        public function verify($message, $signature);
        //public function encrypt($plaintext);
        public function toString($type, array $options = []);
        public function getFingerprint($algorithm);
    }
}
namespace phpseclib3\Crypt\Common\Traits {
    /**
     * Fingerprint Trait for Private Keys
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    trait Fingerprint
    {
        /**
         * Returns the public key's fingerprint
         *
         * The public key's fingerprint is returned, which is equivalent to running `ssh-keygen -lf rsa.pub`. If there is
         * no public key currently loaded, false is returned.
         * Example output (md5): "c1:b1:30:29:d7:b8:de:6c:97:77:10:d7:46:41:63:87" (as specified by RFC 4716)
         *
         * @param string $algorithm The hashing algorithm to be used. Valid options are 'md5' and 'sha256'. False is returned
         * for invalid values.
         * @return mixed
         */
        public function getFingerprint($algorithm = 'md5')
        {
        }
    }
    /**
     * Password Protected Trait for Private Keys
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    trait PasswordProtected
    {
        /**
         * Password
         *
         * @var string|bool
         */
        private $password = false;
        /**
         * Sets the password
         *
         * Private keys can be encrypted with a password.  To unset the password, pass in the empty string or false.
         * Or rather, pass in $password such that empty($password) && !is_string($password) is true.
         *
         * @see self::createKey()
         * @see self::load()
         * @param string|bool $password
         */
        public function withPassword($password = false)
        {
        }
    }
}
namespace phpseclib3\Crypt {
    /**
     * Pure-PHP implementation of DES.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class DES extends \phpseclib3\Crypt\Common\BlockCipher
    {
        /**
         * Contains $keys[self::ENCRYPT]
         *
         * @see \phpseclib3\Crypt\DES::setupKey()
         * @see \phpseclib3\Crypt\DES::processBlock()
         */
        const ENCRYPT = 0;
        /**
         * Contains $keys[self::DECRYPT]
         *
         * @see \phpseclib3\Crypt\DES::setupKey()
         * @see \phpseclib3\Crypt\DES::processBlock()
         */
        const DECRYPT = 1;
        /**
         * Block Length of the cipher
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::block_size
         * @var int
         */
        protected $block_size = 8;
        /**
         * Key Length (in bytes)
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::setKeyLength()
         * @var int
         */
        protected $key_length = 8;
        /**
         * The mcrypt specific name of the cipher
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::cipher_name_mcrypt
         * @var string
         */
        protected $cipher_name_mcrypt = 'des';
        /**
         * The OpenSSL names of the cipher / modes
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::openssl_mode_names
         * @var array
         */
        protected $openssl_mode_names = [self::MODE_ECB => 'des-ecb', self::MODE_CBC => 'des-cbc', self::MODE_CFB => 'des-cfb', self::MODE_OFB => 'des-ofb'];
        /**
         * Optimizing value while CFB-encrypting
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::cfb_init_len
         * @var int
         */
        protected $cfb_init_len = 500;
        /**
         * Switch for DES/3DES encryption
         *
         * Used only if $engine == self::ENGINE_INTERNAL
         *
         * @see self::setupKey()
         * @see self::processBlock()
         * @var int
         */
        protected $des_rounds = 1;
        /**
         * max possible size of $key
         *
         * @see self::setKey()
         * @var string
         */
        protected $key_length_max = 8;
        /**
         * Shuffle table.
         *
         * For each byte value index, the entry holds an 8-byte string
         * with each byte containing all bits in the same state as the
         * corresponding bit in the index value.
         *
         * @see self::processBlock()
         * @see self::setupKey()
         * @var array
         */
        protected static $shuffle = ["\x00\x00\x00\x00\x00\x00\x00\x00", "\x00\x00\x00\x00\x00\x00\x00\xff", "\x00\x00\x00\x00\x00\x00\xff\x00", "\x00\x00\x00\x00\x00\x00\xff\xff", "\x00\x00\x00\x00\x00\xff\x00\x00", "\x00\x00\x00\x00\x00\xff\x00\xff", "\x00\x00\x00\x00\x00\xff\xff\x00", "\x00\x00\x00\x00\x00\xff\xff\xff", "\x00\x00\x00\x00\xff\x00\x00\x00", "\x00\x00\x00\x00\xff\x00\x00\xff", "\x00\x00\x00\x00\xff\x00\xff\x00", "\x00\x00\x00\x00\xff\x00\xff\xff", "\x00\x00\x00\x00\xff\xff\x00\x00", "\x00\x00\x00\x00\xff\xff\x00\xff", "\x00\x00\x00\x00\xff\xff\xff\x00", "\x00\x00\x00\x00\xff\xff\xff\xff", "\x00\x00\x00\xff\x00\x00\x00\x00", "\x00\x00\x00\xff\x00\x00\x00\xff", "\x00\x00\x00\xff\x00\x00\xff\x00", "\x00\x00\x00\xff\x00\x00\xff\xff", "\x00\x00\x00\xff\x00\xff\x00\x00", "\x00\x00\x00\xff\x00\xff\x00\xff", "\x00\x00\x00\xff\x00\xff\xff\x00", "\x00\x00\x00\xff\x00\xff\xff\xff", "\x00\x00\x00\xff\xff\x00\x00\x00", "\x00\x00\x00\xff\xff\x00\x00\xff", "\x00\x00\x00\xff\xff\x00\xff\x00", "\x00\x00\x00\xff\xff\x00\xff\xff", "\x00\x00\x00\xff\xff\xff\x00\x00", "\x00\x00\x00\xff\xff\xff\x00\xff", "\x00\x00\x00\xff\xff\xff\xff\x00", "\x00\x00\x00\xff\xff\xff\xff\xff", "\x00\x00\xff\x00\x00\x00\x00\x00", "\x00\x00\xff\x00\x00\x00\x00\xff", "\x00\x00\xff\x00\x00\x00\xff\x00", "\x00\x00\xff\x00\x00\x00\xff\xff", "\x00\x00\xff\x00\x00\xff\x00\x00", "\x00\x00\xff\x00\x00\xff\x00\xff", "\x00\x00\xff\x00\x00\xff\xff\x00", "\x00\x00\xff\x00\x00\xff\xff\xff", "\x00\x00\xff\x00\xff\x00\x00\x00", "\x00\x00\xff\x00\xff\x00\x00\xff", "\x00\x00\xff\x00\xff\x00\xff\x00", "\x00\x00\xff\x00\xff\x00\xff\xff", "\x00\x00\xff\x00\xff\xff\x00\x00", "\x00\x00\xff\x00\xff\xff\x00\xff", "\x00\x00\xff\x00\xff\xff\xff\x00", "\x00\x00\xff\x00\xff\xff\xff\xff", "\x00\x00\xff\xff\x00\x00\x00\x00", "\x00\x00\xff\xff\x00\x00\x00\xff", "\x00\x00\xff\xff\x00\x00\xff\x00", "\x00\x00\xff\xff\x00\x00\xff\xff", "\x00\x00\xff\xff\x00\xff\x00\x00", "\x00\x00\xff\xff\x00\xff\x00\xff", "\x00\x00\xff\xff\x00\xff\xff\x00", "\x00\x00\xff\xff\x00\xff\xff\xff", "\x00\x00\xff\xff\xff\x00\x00\x00", "\x00\x00\xff\xff\xff\x00\x00\xff", "\x00\x00\xff\xff\xff\x00\xff\x00", "\x00\x00\xff\xff\xff\x00\xff\xff", "\x00\x00\xff\xff\xff\xff\x00\x00", "\x00\x00\xff\xff\xff\xff\x00\xff", "\x00\x00\xff\xff\xff\xff\xff\x00", "\x00\x00\xff\xff\xff\xff\xff\xff", "\x00\xff\x00\x00\x00\x00\x00\x00", "\x00\xff\x00\x00\x00\x00\x00\xff", "\x00\xff\x00\x00\x00\x00\xff\x00", "\x00\xff\x00\x00\x00\x00\xff\xff", "\x00\xff\x00\x00\x00\xff\x00\x00", "\x00\xff\x00\x00\x00\xff\x00\xff", "\x00\xff\x00\x00\x00\xff\xff\x00", "\x00\xff\x00\x00\x00\xff\xff\xff", "\x00\xff\x00\x00\xff\x00\x00\x00", "\x00\xff\x00\x00\xff\x00\x00\xff", "\x00\xff\x00\x00\xff\x00\xff\x00", "\x00\xff\x00\x00\xff\x00\xff\xff", "\x00\xff\x00\x00\xff\xff\x00\x00", "\x00\xff\x00\x00\xff\xff\x00\xff", "\x00\xff\x00\x00\xff\xff\xff\x00", "\x00\xff\x00\x00\xff\xff\xff\xff", "\x00\xff\x00\xff\x00\x00\x00\x00", "\x00\xff\x00\xff\x00\x00\x00\xff", "\x00\xff\x00\xff\x00\x00\xff\x00", "\x00\xff\x00\xff\x00\x00\xff\xff", "\x00\xff\x00\xff\x00\xff\x00\x00", "\x00\xff\x00\xff\x00\xff\x00\xff", "\x00\xff\x00\xff\x00\xff\xff\x00", "\x00\xff\x00\xff\x00\xff\xff\xff", "\x00\xff\x00\xff\xff\x00\x00\x00", "\x00\xff\x00\xff\xff\x00\x00\xff", "\x00\xff\x00\xff\xff\x00\xff\x00", "\x00\xff\x00\xff\xff\x00\xff\xff", "\x00\xff\x00\xff\xff\xff\x00\x00", "\x00\xff\x00\xff\xff\xff\x00\xff", "\x00\xff\x00\xff\xff\xff\xff\x00", "\x00\xff\x00\xff\xff\xff\xff\xff", "\x00\xff\xff\x00\x00\x00\x00\x00", "\x00\xff\xff\x00\x00\x00\x00\xff", "\x00\xff\xff\x00\x00\x00\xff\x00", "\x00\xff\xff\x00\x00\x00\xff\xff", "\x00\xff\xff\x00\x00\xff\x00\x00", "\x00\xff\xff\x00\x00\xff\x00\xff", "\x00\xff\xff\x00\x00\xff\xff\x00", "\x00\xff\xff\x00\x00\xff\xff\xff", "\x00\xff\xff\x00\xff\x00\x00\x00", "\x00\xff\xff\x00\xff\x00\x00\xff", "\x00\xff\xff\x00\xff\x00\xff\x00", "\x00\xff\xff\x00\xff\x00\xff\xff", "\x00\xff\xff\x00\xff\xff\x00\x00", "\x00\xff\xff\x00\xff\xff\x00\xff", "\x00\xff\xff\x00\xff\xff\xff\x00", "\x00\xff\xff\x00\xff\xff\xff\xff", "\x00\xff\xff\xff\x00\x00\x00\x00", "\x00\xff\xff\xff\x00\x00\x00\xff", "\x00\xff\xff\xff\x00\x00\xff\x00", "\x00\xff\xff\xff\x00\x00\xff\xff", "\x00\xff\xff\xff\x00\xff\x00\x00", "\x00\xff\xff\xff\x00\xff\x00\xff", "\x00\xff\xff\xff\x00\xff\xff\x00", "\x00\xff\xff\xff\x00\xff\xff\xff", "\x00\xff\xff\xff\xff\x00\x00\x00", "\x00\xff\xff\xff\xff\x00\x00\xff", "\x00\xff\xff\xff\xff\x00\xff\x00", "\x00\xff\xff\xff\xff\x00\xff\xff", "\x00\xff\xff\xff\xff\xff\x00\x00", "\x00\xff\xff\xff\xff\xff\x00\xff", "\x00\xff\xff\xff\xff\xff\xff\x00", "\x00\xff\xff\xff\xff\xff\xff\xff", "\xff\x00\x00\x00\x00\x00\x00\x00", "\xff\x00\x00\x00\x00\x00\x00\xff", "\xff\x00\x00\x00\x00\x00\xff\x00", "\xff\x00\x00\x00\x00\x00\xff\xff", "\xff\x00\x00\x00\x00\xff\x00\x00", "\xff\x00\x00\x00\x00\xff\x00\xff", "\xff\x00\x00\x00\x00\xff\xff\x00", "\xff\x00\x00\x00\x00\xff\xff\xff", "\xff\x00\x00\x00\xff\x00\x00\x00", "\xff\x00\x00\x00\xff\x00\x00\xff", "\xff\x00\x00\x00\xff\x00\xff\x00", "\xff\x00\x00\x00\xff\x00\xff\xff", "\xff\x00\x00\x00\xff\xff\x00\x00", "\xff\x00\x00\x00\xff\xff\x00\xff", "\xff\x00\x00\x00\xff\xff\xff\x00", "\xff\x00\x00\x00\xff\xff\xff\xff", "\xff\x00\x00\xff\x00\x00\x00\x00", "\xff\x00\x00\xff\x00\x00\x00\xff", "\xff\x00\x00\xff\x00\x00\xff\x00", "\xff\x00\x00\xff\x00\x00\xff\xff", "\xff\x00\x00\xff\x00\xff\x00\x00", "\xff\x00\x00\xff\x00\xff\x00\xff", "\xff\x00\x00\xff\x00\xff\xff\x00", "\xff\x00\x00\xff\x00\xff\xff\xff", "\xff\x00\x00\xff\xff\x00\x00\x00", "\xff\x00\x00\xff\xff\x00\x00\xff", "\xff\x00\x00\xff\xff\x00\xff\x00", "\xff\x00\x00\xff\xff\x00\xff\xff", "\xff\x00\x00\xff\xff\xff\x00\x00", "\xff\x00\x00\xff\xff\xff\x00\xff", "\xff\x00\x00\xff\xff\xff\xff\x00", "\xff\x00\x00\xff\xff\xff\xff\xff", "\xff\x00\xff\x00\x00\x00\x00\x00", "\xff\x00\xff\x00\x00\x00\x00\xff", "\xff\x00\xff\x00\x00\x00\xff\x00", "\xff\x00\xff\x00\x00\x00\xff\xff", "\xff\x00\xff\x00\x00\xff\x00\x00", "\xff\x00\xff\x00\x00\xff\x00\xff", "\xff\x00\xff\x00\x00\xff\xff\x00", "\xff\x00\xff\x00\x00\xff\xff\xff", "\xff\x00\xff\x00\xff\x00\x00\x00", "\xff\x00\xff\x00\xff\x00\x00\xff", "\xff\x00\xff\x00\xff\x00\xff\x00", "\xff\x00\xff\x00\xff\x00\xff\xff", "\xff\x00\xff\x00\xff\xff\x00\x00", "\xff\x00\xff\x00\xff\xff\x00\xff", "\xff\x00\xff\x00\xff\xff\xff\x00", "\xff\x00\xff\x00\xff\xff\xff\xff", "\xff\x00\xff\xff\x00\x00\x00\x00", "\xff\x00\xff\xff\x00\x00\x00\xff", "\xff\x00\xff\xff\x00\x00\xff\x00", "\xff\x00\xff\xff\x00\x00\xff\xff", "\xff\x00\xff\xff\x00\xff\x00\x00", "\xff\x00\xff\xff\x00\xff\x00\xff", "\xff\x00\xff\xff\x00\xff\xff\x00", "\xff\x00\xff\xff\x00\xff\xff\xff", "\xff\x00\xff\xff\xff\x00\x00\x00", "\xff\x00\xff\xff\xff\x00\x00\xff", "\xff\x00\xff\xff\xff\x00\xff\x00", "\xff\x00\xff\xff\xff\x00\xff\xff", "\xff\x00\xff\xff\xff\xff\x00\x00", "\xff\x00\xff\xff\xff\xff\x00\xff", "\xff\x00\xff\xff\xff\xff\xff\x00", "\xff\x00\xff\xff\xff\xff\xff\xff", "\xff\xff\x00\x00\x00\x00\x00\x00", "\xff\xff\x00\x00\x00\x00\x00\xff", "\xff\xff\x00\x00\x00\x00\xff\x00", "\xff\xff\x00\x00\x00\x00\xff\xff", "\xff\xff\x00\x00\x00\xff\x00\x00", "\xff\xff\x00\x00\x00\xff\x00\xff", "\xff\xff\x00\x00\x00\xff\xff\x00", "\xff\xff\x00\x00\x00\xff\xff\xff", "\xff\xff\x00\x00\xff\x00\x00\x00", "\xff\xff\x00\x00\xff\x00\x00\xff", "\xff\xff\x00\x00\xff\x00\xff\x00", "\xff\xff\x00\x00\xff\x00\xff\xff", "\xff\xff\x00\x00\xff\xff\x00\x00", "\xff\xff\x00\x00\xff\xff\x00\xff", "\xff\xff\x00\x00\xff\xff\xff\x00", "\xff\xff\x00\x00\xff\xff\xff\xff", "\xff\xff\x00\xff\x00\x00\x00\x00", "\xff\xff\x00\xff\x00\x00\x00\xff", "\xff\xff\x00\xff\x00\x00\xff\x00", "\xff\xff\x00\xff\x00\x00\xff\xff", "\xff\xff\x00\xff\x00\xff\x00\x00", "\xff\xff\x00\xff\x00\xff\x00\xff", "\xff\xff\x00\xff\x00\xff\xff\x00", "\xff\xff\x00\xff\x00\xff\xff\xff", "\xff\xff\x00\xff\xff\x00\x00\x00", "\xff\xff\x00\xff\xff\x00\x00\xff", "\xff\xff\x00\xff\xff\x00\xff\x00", "\xff\xff\x00\xff\xff\x00\xff\xff", "\xff\xff\x00\xff\xff\xff\x00\x00", "\xff\xff\x00\xff\xff\xff\x00\xff", "\xff\xff\x00\xff\xff\xff\xff\x00", "\xff\xff\x00\xff\xff\xff\xff\xff", "\xff\xff\xff\x00\x00\x00\x00\x00", "\xff\xff\xff\x00\x00\x00\x00\xff", "\xff\xff\xff\x00\x00\x00\xff\x00", "\xff\xff\xff\x00\x00\x00\xff\xff", "\xff\xff\xff\x00\x00\xff\x00\x00", "\xff\xff\xff\x00\x00\xff\x00\xff", "\xff\xff\xff\x00\x00\xff\xff\x00", "\xff\xff\xff\x00\x00\xff\xff\xff", "\xff\xff\xff\x00\xff\x00\x00\x00", "\xff\xff\xff\x00\xff\x00\x00\xff", "\xff\xff\xff\x00\xff\x00\xff\x00", "\xff\xff\xff\x00\xff\x00\xff\xff", "\xff\xff\xff\x00\xff\xff\x00\x00", "\xff\xff\xff\x00\xff\xff\x00\xff", "\xff\xff\xff\x00\xff\xff\xff\x00", "\xff\xff\xff\x00\xff\xff\xff\xff", "\xff\xff\xff\xff\x00\x00\x00\x00", "\xff\xff\xff\xff\x00\x00\x00\xff", "\xff\xff\xff\xff\x00\x00\xff\x00", "\xff\xff\xff\xff\x00\x00\xff\xff", "\xff\xff\xff\xff\x00\xff\x00\x00", "\xff\xff\xff\xff\x00\xff\x00\xff", "\xff\xff\xff\xff\x00\xff\xff\x00", "\xff\xff\xff\xff\x00\xff\xff\xff", "\xff\xff\xff\xff\xff\x00\x00\x00", "\xff\xff\xff\xff\xff\x00\x00\xff", "\xff\xff\xff\xff\xff\x00\xff\x00", "\xff\xff\xff\xff\xff\x00\xff\xff", "\xff\xff\xff\xff\xff\xff\x00\x00", "\xff\xff\xff\xff\xff\xff\x00\xff", "\xff\xff\xff\xff\xff\xff\xff\x00", "\xff\xff\xff\xff\xff\xff\xff\xff"];
        /**
         * IP mapping helper table.
         *
         * Indexing this table with each source byte performs the initial bit permutation.
         *
         * @var array
         */
        protected static $ipmap = [0x0, 0x10, 0x1, 0x11, 0x20, 0x30, 0x21, 0x31, 0x2, 0x12, 0x3, 0x13, 0x22, 0x32, 0x23, 0x33, 0x40, 0x50, 0x41, 0x51, 0x60, 0x70, 0x61, 0x71, 0x42, 0x52, 0x43, 0x53, 0x62, 0x72, 0x63, 0x73, 0x4, 0x14, 0x5, 0x15, 0x24, 0x34, 0x25, 0x35, 0x6, 0x16, 0x7, 0x17, 0x26, 0x36, 0x27, 0x37, 0x44, 0x54, 0x45, 0x55, 0x64, 0x74, 0x65, 0x75, 0x46, 0x56, 0x47, 0x57, 0x66, 0x76, 0x67, 0x77, 0x80, 0x90, 0x81, 0x91, 0xa0, 0xb0, 0xa1, 0xb1, 0x82, 0x92, 0x83, 0x93, 0xa2, 0xb2, 0xa3, 0xb3, 0xc0, 0xd0, 0xc1, 0xd1, 0xe0, 0xf0, 0xe1, 0xf1, 0xc2, 0xd2, 0xc3, 0xd3, 0xe2, 0xf2, 0xe3, 0xf3, 0x84, 0x94, 0x85, 0x95, 0xa4, 0xb4, 0xa5, 0xb5, 0x86, 0x96, 0x87, 0x97, 0xa6, 0xb6, 0xa7, 0xb7, 0xc4, 0xd4, 0xc5, 0xd5, 0xe4, 0xf4, 0xe5, 0xf5, 0xc6, 0xd6, 0xc7, 0xd7, 0xe6, 0xf6, 0xe7, 0xf7, 0x8, 0x18, 0x9, 0x19, 0x28, 0x38, 0x29, 0x39, 0xa, 0x1a, 0xb, 0x1b, 0x2a, 0x3a, 0x2b, 0x3b, 0x48, 0x58, 0x49, 0x59, 0x68, 0x78, 0x69, 0x79, 0x4a, 0x5a, 0x4b, 0x5b, 0x6a, 0x7a, 0x6b, 0x7b, 0xc, 0x1c, 0xd, 0x1d, 0x2c, 0x3c, 0x2d, 0x3d, 0xe, 0x1e, 0xf, 0x1f, 0x2e, 0x3e, 0x2f, 0x3f, 0x4c, 0x5c, 0x4d, 0x5d, 0x6c, 0x7c, 0x6d, 0x7d, 0x4e, 0x5e, 0x4f, 0x5f, 0x6e, 0x7e, 0x6f, 0x7f, 0x88, 0x98, 0x89, 0x99, 0xa8, 0xb8, 0xa9, 0xb9, 0x8a, 0x9a, 0x8b, 0x9b, 0xaa, 0xba, 0xab, 0xbb, 0xc8, 0xd8, 0xc9, 0xd9, 0xe8, 0xf8, 0xe9, 0xf9, 0xca, 0xda, 0xcb, 0xdb, 0xea, 0xfa, 0xeb, 0xfb, 0x8c, 0x9c, 0x8d, 0x9d, 0xac, 0xbc, 0xad, 0xbd, 0x8e, 0x9e, 0x8f, 0x9f, 0xae, 0xbe, 0xaf, 0xbf, 0xcc, 0xdc, 0xcd, 0xdd, 0xec, 0xfc, 0xed, 0xfd, 0xce, 0xde, 0xcf, 0xdf, 0xee, 0xfe, 0xef, 0xff];
        /**
         * Inverse IP mapping helper table.
         * Indexing this table with a byte value reverses the bit order.
         *
         * @var array
         */
        protected static $invipmap = [0x0, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 0x8, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 0x4, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 0xc, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 0x2, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 0xa, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 0x6, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 0xe, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 0x1, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 0x9, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 0x5, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 0xd, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 0x3, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 0xb, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 0x7, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 0xf, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff];
        /**
         * Pre-permuted S-box1
         *
         * Each box ($sbox1-$sbox8) has been vectorized, then each value pre-permuted using the
         * P table: concatenation can then be replaced by exclusive ORs.
         *
         * @var array
         */
        protected static $sbox1 = [0x808200, 0x0, 0x8000, 0x808202, 0x808002, 0x8202, 0x2, 0x8000, 0x200, 0x808200, 0x808202, 0x200, 0x800202, 0x808002, 0x800000, 0x2, 0x202, 0x800200, 0x800200, 0x8200, 0x8200, 0x808000, 0x808000, 0x800202, 0x8002, 0x800002, 0x800002, 0x8002, 0x0, 0x202, 0x8202, 0x800000, 0x8000, 0x808202, 0x2, 0x808000, 0x808200, 0x800000, 0x800000, 0x200, 0x808002, 0x8000, 0x8200, 0x800002, 0x200, 0x2, 0x800202, 0x8202, 0x808202, 0x8002, 0x808000, 0x800202, 0x800002, 0x202, 0x8202, 0x808200, 0x202, 0x800200, 0x800200, 0x0, 0x8002, 0x8200, 0x0, 0x808002];
        /**
         * Pre-permuted S-box2
         *
         * @var array
         */
        protected static $sbox2 = [0x40084010, 0x40004000, 0x4000, 0x84010, 0x80000, 0x10, 0x40080010, 0x40004010, 0x40000010, 0x40084010, 0x40084000, 0x40000000, 0x40004000, 0x80000, 0x10, 0x40080010, 0x84000, 0x80010, 0x40004010, 0x0, 0x40000000, 0x4000, 0x84010, 0x40080000, 0x80010, 0x40000010, 0x0, 0x84000, 0x4010, 0x40084000, 0x40080000, 0x4010, 0x0, 0x84010, 0x40080010, 0x80000, 0x40004010, 0x40080000, 0x40084000, 0x4000, 0x40080000, 0x40004000, 0x10, 0x40084010, 0x84010, 0x10, 0x4000, 0x40000000, 0x4010, 0x40084000, 0x80000, 0x40000010, 0x80010, 0x40004010, 0x40000010, 0x80010, 0x84000, 0x0, 0x40004000, 0x4010, 0x40000000, 0x40080010, 0x40084010, 0x84000];
        /**
         * Pre-permuted S-box3
         *
         * @var array
         */
        protected static $sbox3 = [0x104, 0x4010100, 0x0, 0x4010004, 0x4000100, 0x0, 0x10104, 0x4000100, 0x10004, 0x4000004, 0x4000004, 0x10000, 0x4010104, 0x10004, 0x4010000, 0x104, 0x4000000, 0x4, 0x4010100, 0x100, 0x10100, 0x4010000, 0x4010004, 0x10104, 0x4000104, 0x10100, 0x10000, 0x4000104, 0x4, 0x4010104, 0x100, 0x4000000, 0x4010100, 0x4000000, 0x10004, 0x104, 0x10000, 0x4010100, 0x4000100, 0x0, 0x100, 0x10004, 0x4010104, 0x4000100, 0x4000004, 0x100, 0x0, 0x4010004, 0x4000104, 0x10000, 0x4000000, 0x4010104, 0x4, 0x10104, 0x10100, 0x4000004, 0x4010000, 0x4000104, 0x104, 0x4010000, 0x10104, 0x4, 0x4010004, 0x10100];
        /**
         * Pre-permuted S-box4
         *
         * @var array
         */
        protected static $sbox4 = [0x80401000, 0x80001040, 0x80001040, 0x40, 0x401040, 0x80400040, 0x80400000, 0x80001000, 0x0, 0x401000, 0x401000, 0x80401040, 0x80000040, 0x0, 0x400040, 0x80400000, 0x80000000, 0x1000, 0x400000, 0x80401000, 0x40, 0x400000, 0x80001000, 0x1040, 0x80400040, 0x80000000, 0x1040, 0x400040, 0x1000, 0x401040, 0x80401040, 0x80000040, 0x400040, 0x80400000, 0x401000, 0x80401040, 0x80000040, 0x0, 0x0, 0x401000, 0x1040, 0x400040, 0x80400040, 0x80000000, 0x80401000, 0x80001040, 0x80001040, 0x40, 0x80401040, 0x80000040, 0x80000000, 0x1000, 0x80400000, 0x80001000, 0x401040, 0x80400040, 0x80001000, 0x1040, 0x400000, 0x80401000, 0x40, 0x400000, 0x1000, 0x401040];
        /**
         * Pre-permuted S-box5
         *
         * @var array
         */
        protected static $sbox5 = [0x80, 0x1040080, 0x1040000, 0x21000080, 0x40000, 0x80, 0x20000000, 0x1040000, 0x20040080, 0x40000, 0x1000080, 0x20040080, 0x21000080, 0x21040000, 0x40080, 0x20000000, 0x1000000, 0x20040000, 0x20040000, 0x0, 0x20000080, 0x21040080, 0x21040080, 0x1000080, 0x21040000, 0x20000080, 0x0, 0x21000000, 0x1040080, 0x1000000, 0x21000000, 0x40080, 0x40000, 0x21000080, 0x80, 0x1000000, 0x20000000, 0x1040000, 0x21000080, 0x20040080, 0x1000080, 0x20000000, 0x21040000, 0x1040080, 0x20040080, 0x80, 0x1000000, 0x21040000, 0x21040080, 0x40080, 0x21000000, 0x21040080, 0x1040000, 0x0, 0x20040000, 0x21000000, 0x40080, 0x1000080, 0x20000080, 0x40000, 0x0, 0x20040000, 0x1040080, 0x20000080];
        /**
         * Pre-permuted S-box6
         *
         * @var array
         */
        protected static $sbox6 = [0x10000008, 0x10200000, 0x2000, 0x10202008, 0x10200000, 0x8, 0x10202008, 0x200000, 0x10002000, 0x202008, 0x200000, 0x10000008, 0x200008, 0x10002000, 0x10000000, 0x2008, 0x0, 0x200008, 0x10002008, 0x2000, 0x202000, 0x10002008, 0x8, 0x10200008, 0x10200008, 0x0, 0x202008, 0x10202000, 0x2008, 0x202000, 0x10202000, 0x10000000, 0x10002000, 0x8, 0x10200008, 0x202000, 0x10202008, 0x200000, 0x2008, 0x10000008, 0x200000, 0x10002000, 0x10000000, 0x2008, 0x10000008, 0x10202008, 0x202000, 0x10200000, 0x202008, 0x10202000, 0x0, 0x10200008, 0x8, 0x2000, 0x10200000, 0x202008, 0x2000, 0x200008, 0x10002008, 0x0, 0x10202000, 0x10000000, 0x200008, 0x10002008];
        /**
         * Pre-permuted S-box7
         *
         * @var array
         */
        protected static $sbox7 = [0x100000, 0x2100001, 0x2000401, 0x0, 0x400, 0x2000401, 0x100401, 0x2100400, 0x2100401, 0x100000, 0x0, 0x2000001, 0x1, 0x2000000, 0x2100001, 0x401, 0x2000400, 0x100401, 0x100001, 0x2000400, 0x2000001, 0x2100000, 0x2100400, 0x100001, 0x2100000, 0x400, 0x401, 0x2100401, 0x100400, 0x1, 0x2000000, 0x100400, 0x2000000, 0x100400, 0x100000, 0x2000401, 0x2000401, 0x2100001, 0x2100001, 0x1, 0x100001, 0x2000000, 0x2000400, 0x100000, 0x2100400, 0x401, 0x100401, 0x2100400, 0x401, 0x2000001, 0x2100401, 0x2100000, 0x100400, 0x0, 0x1, 0x2100401, 0x0, 0x100401, 0x2100000, 0x400, 0x2000001, 0x2000400, 0x400, 0x100001];
        /**
         * Pre-permuted S-box8
         *
         * @var array
         */
        protected static $sbox8 = [0x8000820, 0x800, 0x20000, 0x8020820, 0x8000000, 0x8000820, 0x20, 0x8000000, 0x20020, 0x8020000, 0x8020820, 0x20800, 0x8020800, 0x20820, 0x800, 0x20, 0x8020000, 0x8000020, 0x8000800, 0x820, 0x20800, 0x20020, 0x8020020, 0x8020800, 0x820, 0x0, 0x0, 0x8020020, 0x8000020, 0x8000800, 0x20820, 0x20000, 0x20820, 0x20000, 0x8020800, 0x800, 0x20, 0x8020020, 0x800, 0x20820, 0x8000800, 0x20, 0x8000020, 0x8020000, 0x8020020, 0x8000000, 0x20000, 0x8000820, 0x0, 0x8020820, 0x20020, 0x8000020, 0x8020000, 0x8000800, 0x8000820, 0x0, 0x8020820, 0x20800, 0x20800, 0x820, 0x820, 0x20020, 0x8000000, 0x8020800];
        /**
         * Default Constructor.
         *
         * @param string $mode
         * @throws BadModeException if an invalid / unsupported mode is provided
         */
        public function __construct($mode)
        {
        }
        /**
         * Test for engine validity
         *
         * This is mainly just a wrapper to set things up for \phpseclib3\Crypt\Common\SymmetricKey::isValidEngine()
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::isValidEngine()
         * @param int $engine
         * @return bool
         */
        protected function isValidEngineHelper($engine)
        {
        }
        /**
         * Sets the key.
         *
         * Keys must be 64-bits long or 8 bytes long.
         *
         * DES also requires that every eighth bit be a parity bit, however, we'll ignore that.
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::setKey()
         * @param string $key
         */
        public function setKey($key)
        {
        }
        /**
         * Encrypts a block
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::encryptBlock()
         * @see \phpseclib3\Crypt\Common\SymmetricKey::encrypt()
         * @see self::encrypt()
         * @param string $in
         * @return string
         */
        protected function encryptBlock($in)
        {
        }
        /**
         * Decrypts a block
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::decryptBlock()
         * @see \phpseclib3\Crypt\Common\SymmetricKey::decrypt()
         * @see self::decrypt()
         * @param string $in
         * @return string
         */
        protected function decryptBlock($in)
        {
        }
        /**
         * Creates the key schedule
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::setupKey()
         */
        protected function setupKey()
        {
        }
        /**
         * Setup the performance-optimized function for de/encrypt()
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::setupInlineCrypt()
         */
        protected function setupInlineCrypt()
        {
        }
    }
}
namespace phpseclib3\Crypt\DH\Formats\Keys {
    /**
     * "PKCS1" Formatted DH Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PKCS1 extends \phpseclib3\Crypt\Common\Formats\Keys\PKCS1
    {
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert EC parameters to the appropriate format
         *
         * @return string
         */
        public static function saveParameters(\phpseclib3\Math\BigInteger $prime, \phpseclib3\Math\BigInteger $base, array $options = [])
        {
        }
    }
    /**
     * PKCS#8 Formatted DH Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PKCS8 extends \phpseclib3\Crypt\Common\Formats\Keys\PKCS8
    {
        /**
         * OID Name
         *
         * @var string
         */
        const OID_NAME = 'dhKeyAgreement';
        /**
         * OID Value
         *
         * @var string
         */
        const OID_VALUE = '1.2.840.113549.1.3.1';
        /**
         * Child OIDs loaded
         *
         * @var bool
         */
        protected static $childOIDsLoaded = false;
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $prime
         * @param BigInteger $base
         * @param BigInteger $privateKey
         * @param BigInteger $publicKey
         * @param string $password optional
         * @param array $options optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $prime, \phpseclib3\Math\BigInteger $base, \phpseclib3\Math\BigInteger $privateKey, \phpseclib3\Math\BigInteger $publicKey, $password = '', array $options = [])
        {
        }
        /**
         * Convert a public key to the appropriate format
         *
         * @param BigInteger $prime
         * @param BigInteger $base
         * @param BigInteger $publicKey
         * @param array $options optional
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Math\BigInteger $prime, \phpseclib3\Math\BigInteger $base, \phpseclib3\Math\BigInteger $publicKey, array $options = [])
        {
        }
    }
}
namespace phpseclib3\Crypt {
    /**
     * Pure-PHP (EC)DH implementation
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class DH extends \phpseclib3\Crypt\Common\AsymmetricKey
    {
        /**
         * Algorithm Name
         *
         * @var string
         */
        const ALGORITHM = 'DH';
        /**
         * DH prime
         *
         * @var BigInteger
         */
        protected $prime;
        /**
         * DH Base
         *
         * Prime divisor of p-1
         *
         * @var BigInteger
         */
        protected $base;
        /**
         * Public Key
         *
         * @var BigInteger
         */
        protected $publicKey;
        /**
         * Create DH parameters
         *
         * This method is a bit polymorphic. It can take any of the following:
         *  - two BigInteger's (prime and base)
         *  - an integer representing the size of the prime in bits (the base is assumed to be 2)
         *  - a string (eg. diffie-hellman-group14-sha1)
         *
         * @return Parameters
         */
        public static function createParameters(...$args)
        {
        }
        /**
         * Create public / private key pair.
         *
         * The rationale for the second parameter is described in http://tools.ietf.org/html/rfc4419#section-6.2 :
         *
         * "To increase the speed of the key exchange, both client and server may
         *  reduce the size of their private exponents.  It should be at least
         *  twice as long as the key material that is generated from the shared
         *  secret.  For more details, see the paper by van Oorschot and Wiener
         *  [VAN-OORSCHOT]."
         *
         * $length is in bits
         *
         * @param Parameters $params
         * @param int $length optional
         * @return PrivateKey
         */
        public static function createKey(\phpseclib3\Crypt\DH\Parameters $params, $length = 0)
        {
        }
        /**
         * Compute Shared Secret
         *
         * @param PrivateKey|EC $private
         * @param PublicKey|BigInteger|string $public
         * @return mixed
         */
        public static function computeSecret($private, $public)
        {
        }
        /**
         * Load the key
         *
         * @param string $key
         * @param string $password optional
         * @return AsymmetricKey
         */
        public static function load($key, $password = false)
        {
        }
        /**
         * OnLoad Handler
         *
         * @return bool
         */
        protected static function onLoad(array $components)
        {
        }
        /**
         * Determines which hashing function should be used
         *
         * @param string $hash
         */
        public function withHash($hash)
        {
        }
        /**
         * Returns the hash algorithm currently being used
         *
         */
        public function getHash()
        {
        }
        /**
         * Returns the parameters
         *
         * A public / private key is only returned if the currently loaded "key" contains an x or y
         * value.
         *
         * @see self::getPublicKey()
         * @return mixed
         */
        public function getParameters()
        {
        }
    }
}
namespace phpseclib3\Crypt\DH {
    /**
     * DH Parameters
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    final class Parameters extends \phpseclib3\Crypt\DH
    {
        /**
         * Returns the parameters
         *
         * @param string $type
         * @param array $options optional
         * @return string
         */
        public function toString($type = 'PKCS1', array $options = [])
        {
        }
    }
    /**
     * DH Private Key
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    final class PrivateKey extends \phpseclib3\Crypt\DH
    {
        use \phpseclib3\Crypt\Common\Traits\PasswordProtected;
        /**
         * Returns the public key
         *
         * @return PublicKey
         */
        public function getPublicKey()
        {
        }
        /**
         * Returns the private key
         *
         * @param string $type
         * @param array $options optional
         * @return string
         */
        public function toString($type, array $options = [])
        {
        }
    }
    /**
     * DH Public Key
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    final class PublicKey extends \phpseclib3\Crypt\DH
    {
        use \phpseclib3\Crypt\Common\Traits\Fingerprint;
        /**
         * Returns the public key
         *
         * @param string $type
         * @param array $options optional
         * @return string
         */
        public function toString($type, array $options = [])
        {
        }
        /**
         * Returns the public key as a BigInteger
         *
         * @return \phpseclib3\Math\BigInteger
         */
        public function toBigInteger()
        {
        }
    }
}
namespace phpseclib3\Crypt\DSA\Formats\Keys {
    /**
     * OpenSSH Formatted DSA Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class OpenSSH extends \phpseclib3\Crypt\Common\Formats\Keys\OpenSSH
    {
        /**
         * Supported Key Types
         *
         * @var array
         */
        protected static $types = ['ssh-dss'];
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert a public key to the appropriate format
         *
         * @param BigInteger $p
         * @param BigInteger $q
         * @param BigInteger $g
         * @param BigInteger $y
         * @param array $options optional
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Math\BigInteger $p, \phpseclib3\Math\BigInteger $q, \phpseclib3\Math\BigInteger $g, \phpseclib3\Math\BigInteger $y, array $options = [])
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $p
         * @param BigInteger $q
         * @param BigInteger $g
         * @param BigInteger $y
         * @param BigInteger $x
         * @param string $password optional
         * @param array $options optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $p, \phpseclib3\Math\BigInteger $q, \phpseclib3\Math\BigInteger $g, \phpseclib3\Math\BigInteger $y, \phpseclib3\Math\BigInteger $x, $password = '', array $options = [])
        {
        }
    }
    /**
     * PKCS#1 Formatted DSA Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PKCS1 extends \phpseclib3\Crypt\Common\Formats\Keys\PKCS1
    {
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert DSA parameters to the appropriate format
         *
         * @param BigInteger $p
         * @param BigInteger $q
         * @param BigInteger $g
         * @return string
         */
        public static function saveParameters(\phpseclib3\Math\BigInteger $p, \phpseclib3\Math\BigInteger $q, \phpseclib3\Math\BigInteger $g)
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $p
         * @param BigInteger $q
         * @param BigInteger $g
         * @param BigInteger $y
         * @param BigInteger $x
         * @param string $password optional
         * @param array $options optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $p, \phpseclib3\Math\BigInteger $q, \phpseclib3\Math\BigInteger $g, \phpseclib3\Math\BigInteger $y, \phpseclib3\Math\BigInteger $x, $password = '', array $options = [])
        {
        }
        /**
         * Convert a public key to the appropriate format
         *
         * @param BigInteger $p
         * @param BigInteger $q
         * @param BigInteger $g
         * @param BigInteger $y
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Math\BigInteger $p, \phpseclib3\Math\BigInteger $q, \phpseclib3\Math\BigInteger $g, \phpseclib3\Math\BigInteger $y)
        {
        }
    }
    /**
     * PKCS#8 Formatted DSA Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PKCS8 extends \phpseclib3\Crypt\Common\Formats\Keys\PKCS8
    {
        /**
         * OID Name
         *
         * @var string
         */
        const OID_NAME = 'id-dsa';
        /**
         * OID Value
         *
         * @var string
         */
        const OID_VALUE = '1.2.840.10040.4.1';
        /**
         * Child OIDs loaded
         *
         * @var bool
         */
        protected static $childOIDsLoaded = false;
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $p
         * @param BigInteger $q
         * @param BigInteger $g
         * @param BigInteger $y
         * @param BigInteger $x
         * @param string $password optional
         * @param array $options optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $p, \phpseclib3\Math\BigInteger $q, \phpseclib3\Math\BigInteger $g, \phpseclib3\Math\BigInteger $y, \phpseclib3\Math\BigInteger $x, $password = '', array $options = [])
        {
        }
        /**
         * Convert a public key to the appropriate format
         *
         * @param BigInteger $p
         * @param BigInteger $q
         * @param BigInteger $g
         * @param BigInteger $y
         * @param array $options optional
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Math\BigInteger $p, \phpseclib3\Math\BigInteger $q, \phpseclib3\Math\BigInteger $g, \phpseclib3\Math\BigInteger $y, array $options = [])
        {
        }
    }
    /**
     * PuTTY Formatted DSA Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PuTTY extends \phpseclib3\Crypt\Common\Formats\Keys\PuTTY
    {
        /**
         * Public Handler
         *
         * @var string
         */
        const PUBLIC_HANDLER = 'phpseclib3\Crypt\DSA\Formats\Keys\OpenSSH';
        /**
         * Algorithm Identifier
         *
         * @var array
         */
        protected static $types = ['ssh-dss'];
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $p
         * @param BigInteger $q
         * @param BigInteger $g
         * @param BigInteger $y
         * @param BigInteger $x
         * @param string $password optional
         * @param array $options optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $p, \phpseclib3\Math\BigInteger $q, \phpseclib3\Math\BigInteger $g, \phpseclib3\Math\BigInteger $y, \phpseclib3\Math\BigInteger $x, $password = false, array $options = [])
        {
        }
        /**
         * Convert a public key to the appropriate format
         *
         * @param BigInteger $p
         * @param BigInteger $q
         * @param BigInteger $g
         * @param BigInteger $y
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Math\BigInteger $p, \phpseclib3\Math\BigInteger $q, \phpseclib3\Math\BigInteger $g, \phpseclib3\Math\BigInteger $y)
        {
        }
    }
    /**
     * Raw DSA Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Raw
    {
        /**
         * Break a public or private key down into its constituent components
         *
         * @param array $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $p
         * @param BigInteger $q
         * @param BigInteger $g
         * @param BigInteger $y
         * @param BigInteger $x
         * @param string $password optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $p, \phpseclib3\Math\BigInteger $q, \phpseclib3\Math\BigInteger $g, \phpseclib3\Math\BigInteger $y, \phpseclib3\Math\BigInteger $x, $password = '')
        {
        }
        /**
         * Convert a public key to the appropriate format
         *
         * @param BigInteger $p
         * @param BigInteger $q
         * @param BigInteger $g
         * @param BigInteger $y
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Math\BigInteger $p, \phpseclib3\Math\BigInteger $q, \phpseclib3\Math\BigInteger $g, \phpseclib3\Math\BigInteger $y)
        {
        }
    }
    /**
     * XML Formatted DSA Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class XML
    {
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert a public key to the appropriate format
         *
         * See https://www.w3.org/TR/xmldsig-core/#sec-DSAKeyValue
         *
         * @param BigInteger $p
         * @param BigInteger $q
         * @param BigInteger $g
         * @param BigInteger $y
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Math\BigInteger $p, \phpseclib3\Math\BigInteger $q, \phpseclib3\Math\BigInteger $g, \phpseclib3\Math\BigInteger $y)
        {
        }
    }
}
namespace phpseclib3\Crypt\DSA\Formats\Signature {
    /**
     * ASN1 Signature Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class ASN1
    {
        /**
         * Loads a signature
         *
         * @param string $sig
         * @return array|bool
         */
        public static function load($sig)
        {
        }
        /**
         * Returns a signature in the appropriate format
         *
         * @param BigInteger $r
         * @param BigInteger $s
         * @return string
         */
        public static function save(\phpseclib3\Math\BigInteger $r, \phpseclib3\Math\BigInteger $s)
        {
        }
    }
    /**
     * Raw DSA Signature Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Raw extends \phpseclib3\Crypt\Common\Formats\Signature\Raw
    {
    }
    /**
     * SSH2 Signature Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class SSH2
    {
        /**
         * Loads a signature
         *
         * @param string $sig
         * @return mixed
         */
        public static function load($sig)
        {
        }
        /**
         * Returns a signature in the appropriate format
         *
         * @param BigInteger $r
         * @param BigInteger $s
         * @return string
         */
        public static function save(\phpseclib3\Math\BigInteger $r, \phpseclib3\Math\BigInteger $s)
        {
        }
    }
}
namespace phpseclib3\Crypt {
    /**
     * Pure-PHP FIPS 186-4 compliant implementation of DSA.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class DSA extends \phpseclib3\Crypt\Common\AsymmetricKey
    {
        /**
         * Algorithm Name
         *
         * @var string
         */
        const ALGORITHM = 'DSA';
        /**
         * DSA Prime P
         *
         * @var BigInteger
         */
        protected $p;
        /**
         * DSA Group Order q
         *
         * Prime divisor of p-1
         *
         * @var BigInteger
         */
        protected $q;
        /**
         * DSA Group Generator G
         *
         * @var BigInteger
         */
        protected $g;
        /**
         * DSA public key value y
         *
         * @var BigInteger
         */
        protected $y;
        /**
         * Signature Format
         *
         * @var string
         */
        protected $sigFormat;
        /**
         * Signature Format (Short)
         *
         * @var string
         */
        protected $shortFormat;
        /**
         * Create DSA parameters
         *
         * @param int $L
         * @param int $N
         * @return DSA|bool
         */
        public static function createParameters($L = 2048, $N = 224)
        {
        }
        /**
         * Create public / private key pair.
         *
         * This method is a bit polymorphic. It can take a DSA/Parameters object, L / N as two distinct parameters or
         * no parameters (at which point L and N will be generated with this method)
         *
         * Returns the private key, from which the publickey can be extracted
         *
         * @param int[] ...$args
         * @return PrivateKey
         */
        public static function createKey(...$args)
        {
        }
        /**
         * OnLoad Handler
         *
         * @return bool
         */
        protected static function onLoad(array $components)
        {
        }
        /**
         * Constructor
         *
         * PublicKey and PrivateKey objects can only be created from abstract RSA class
         */
        protected function __construct()
        {
        }
        /**
         * Returns the key size
         *
         * More specifically, this L (the length of DSA Prime P) and N (the length of DSA Group Order q)
         *
         * @return array
         */
        public function getLength()
        {
        }
        /**
         * Returns the current engine being used
         *
         * @see self::useInternalEngine()
         * @see self::useBestEngine()
         * @return string
         */
        public function getEngine()
        {
        }
        /**
         * Returns the parameters
         *
         * A public / private key is only returned if the currently loaded "key" contains an x or y
         * value.
         *
         * @see self::getPublicKey()
         * @return mixed
         */
        public function getParameters()
        {
        }
        /**
         * Determines the signature padding mode
         *
         * Valid values are: ASN1, SSH2, Raw
         *
         * @param string $format
         */
        public function withSignatureFormat($format)
        {
        }
        /**
         * Returns the signature format currently being used
         *
         */
        public function getSignatureFormat()
        {
        }
    }
}
namespace phpseclib3\Crypt\DSA {
    /**
     * DSA Parameters
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    final class Parameters extends \phpseclib3\Crypt\DSA
    {
        /**
         * Returns the parameters
         *
         * @param string $type
         * @param array $options optional
         * @return string
         */
        public function toString($type = 'PKCS1', array $options = [])
        {
        }
    }
    /**
     * DSA Private Key
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    final class PrivateKey extends \phpseclib3\Crypt\DSA implements \phpseclib3\Crypt\Common\PrivateKey
    {
        use \phpseclib3\Crypt\Common\Traits\PasswordProtected;
        /**
         * Returns the public key
         *
         * If you do "openssl rsa -in private.rsa -pubout -outform PEM" you get a PKCS8 formatted key
         * that contains a publicKeyAlgorithm AlgorithmIdentifier and a publicKey BIT STRING.
         * An AlgorithmIdentifier contains an OID and a parameters field. With RSA public keys this
         * parameters field is NULL. With DSA PKCS8 public keys it is not - it contains the p, q and g
         * variables. The publicKey BIT STRING contains, simply, the y variable. This can be verified
         * by getting a DSA PKCS8 public key:
         *
         * "openssl dsa -in private.dsa -pubout -outform PEM"
         *
         * ie. just swap out rsa with dsa in the rsa command above.
         *
         * A PKCS1 public key corresponds to the publicKey portion of the PKCS8 key. In the case of RSA
         * the publicKey portion /is/ the key. In the case of DSA it is not. You cannot verify a signature
         * without the parameters and the PKCS1 DSA public key format does not include the parameters.
         *
         * @see self::getPrivateKey()
         * @return mixed
         */
        public function getPublicKey()
        {
        }
        /**
         * Create a signature
         *
         * @see self::verify()
         * @param string $message
         * @return mixed
         */
        public function sign($message)
        {
        }
        /**
         * Returns the private key
         *
         * @param string $type
         * @param array $options optional
         * @return string
         */
        public function toString($type, array $options = [])
        {
        }
    }
    /**
     * DSA Public Key
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    final class PublicKey extends \phpseclib3\Crypt\DSA implements \phpseclib3\Crypt\Common\PublicKey
    {
        use \phpseclib3\Crypt\Common\Traits\Fingerprint;
        /**
         * Verify a signature
         *
         * @see self::verify()
         * @param string $message
         * @param string $signature
         * @return mixed
         */
        public function verify($message, $signature)
        {
        }
        /**
         * Returns the public key
         *
         * @param string $type
         * @param array $options optional
         * @return string
         */
        public function toString($type, array $options = [])
        {
        }
    }
}
namespace phpseclib3\Crypt\EC\BaseCurves {
    /**
     * Base
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Base
    {
        /**
         * The Order
         *
         * @var BigInteger
         */
        protected $order;
        /**
         * Finite Field Integer factory
         *
         * @var FiniteField\Integer
         */
        protected $factory;
        /**
         * Returns a random integer
         *
         * @return object
         */
        public function randomInteger()
        {
        }
        /**
         * Converts a BigInteger to a FiniteField\Integer integer
         *
         * @return object
         */
        public function convertInteger(\phpseclib3\Math\BigInteger $x)
        {
        }
        /**
         * Returns the length, in bytes, of the modulo
         *
         * @return integer
         */
        public function getLengthInBytes()
        {
        }
        /**
         * Returns the length, in bits, of the modulo
         *
         * @return integer
         */
        public function getLength()
        {
        }
        /**
         * Multiply a point on the curve by a scalar
         *
         * Uses the montgomery ladder technique as described here:
         *
         * https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#Montgomery_ladder
         * https://github.com/phpecc/phpecc/issues/16#issuecomment-59176772
         *
         * @return array
         */
        public function multiplyPoint(array $p, \phpseclib3\Math\BigInteger $d)
        {
        }
        /**
         * Creates a random scalar multiplier
         *
         * @return BigInteger
         */
        public function createRandomMultiplier()
        {
        }
        /**
         * Performs range check
         */
        public function rangeCheck(\phpseclib3\Math\BigInteger $x)
        {
        }
        /**
         * Sets the Order
         */
        public function setOrder(\phpseclib3\Math\BigInteger $order)
        {
        }
        /**
         * Returns the Order
         *
         * @return BigInteger
         */
        public function getOrder()
        {
        }
        /**
         * Use a custom defined modular reduction function
         *
         * @return object
         */
        public function setReduction(callable $func)
        {
        }
        /**
         * Returns the affine point
         *
         * @return object[]
         */
        public function convertToAffine(array $p)
        {
        }
        /**
         * Converts an affine point to a jacobian coordinate
         *
         * @return object[]
         */
        public function convertToInternal(array $p)
        {
        }
        /**
         * Negates a point
         *
         * @return object[]
         */
        public function negatePoint(array $p)
        {
        }
        /**
         * Multiply and Add Points
         *
         * @return int[]
         */
        public function multiplyAddPoints(array $points, array $scalars)
        {
        }
    }
    /**
     * Curves over y^2 + x*y = x^3 + a*x^2 + b
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class Binary extends \phpseclib3\Crypt\EC\BaseCurves\Base
    {
        /**
         * Binary Field Integer factory
         *
         * @var BinaryField
         */
        protected $factory;
        /**
         * Cofficient for x^1
         *
         * @var object
         */
        protected $a;
        /**
         * Cofficient for x^0
         *
         * @var object
         */
        protected $b;
        /**
         * Base Point
         *
         * @var object
         */
        protected $p;
        /**
         * The number one over the specified finite field
         *
         * @var object
         */
        protected $one;
        /**
         * The modulo
         *
         * @var BigInteger
         */
        protected $modulo;
        /**
         * The Order
         *
         * @var BigInteger
         */
        protected $order;
        /**
         * Sets the modulo
         */
        public function setModulo(...$modulo)
        {
        }
        /**
         * Set coefficients a and b
         *
         * @param string $a
         * @param string $b
         */
        public function setCoefficients($a, $b)
        {
        }
        /**
         * Set x and y coordinates for the base point
         *
         * @param string|BinaryInteger $x
         * @param string|BinaryInteger $y
         */
        public function setBasePoint($x, $y)
        {
        }
        /**
         * Retrieve the base point as an array
         *
         * @return array
         */
        public function getBasePoint()
        {
        }
        /**
         * Adds two points on the curve
         *
         * @return FiniteField[]
         */
        public function addPoint(array $p, array $q)
        {
        }
        /**
         * Doubles a point on a curve
         *
         * @return FiniteField[]
         */
        public function doublePoint(array $p)
        {
        }
        /**
         * Returns the X coordinate and the derived Y coordinate
         *
         * Not supported because it is covered by patents.
         * Quoting https://www.openssl.org/docs/man1.1.0/apps/ecparam.html ,
         *
         * "Due to patent issues the compressed option is disabled by default for binary curves
         *  and can be enabled by defining the preprocessor macro OPENSSL_EC_BIN_PT_COMP at
         *  compile time."
         *
         * @return array
         */
        public function derivePoint($m)
        {
        }
        /**
         * Tests whether or not the x / y values satisfy the equation
         *
         * @return boolean
         */
        public function verifyPoint(array $p)
        {
        }
        /**
         * Returns the modulo
         *
         * @return BigInteger
         */
        public function getModulo()
        {
        }
        /**
         * Returns the a coefficient
         *
         * @return \phpseclib3\Math\PrimeField\Integer
         */
        public function getA()
        {
        }
        /**
         * Returns the a coefficient
         *
         * @return \phpseclib3\Math\PrimeField\Integer
         */
        public function getB()
        {
        }
        /**
         * Returns the affine point
         *
         * A Jacobian Coordinate is of the form (x, y, z).
         * To convert a Jacobian Coordinate to an Affine Point
         * you do (x / z^2, y / z^3)
         *
         * @return \phpseclib3\Math\PrimeField\Integer[]
         */
        public function convertToAffine(array $p)
        {
        }
        /**
         * Converts an affine point to a jacobian coordinate
         *
         * @return \phpseclib3\Math\PrimeField\Integer[]
         */
        public function convertToInternal(array $p)
        {
        }
    }
    /**
     * Curves over y^2 = x^3 + a*x + b
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class Prime extends \phpseclib3\Crypt\EC\BaseCurves\Base
    {
        /**
         * Prime Field Integer factory
         *
         * @var \phpseclib3\Math\PrimeFields
         */
        protected $factory;
        /**
         * Cofficient for x^1
         *
         * @var object
         */
        protected $a;
        /**
         * Cofficient for x^0
         *
         * @var object
         */
        protected $b;
        /**
         * Base Point
         *
         * @var object
         */
        protected $p;
        /**
         * The number one over the specified finite field
         *
         * @var object
         */
        protected $one;
        /**
         * The number two over the specified finite field
         *
         * @var object
         */
        protected $two;
        /**
         * The number three over the specified finite field
         *
         * @var object
         */
        protected $three;
        /**
         * The number four over the specified finite field
         *
         * @var object
         */
        protected $four;
        /**
         * The number eight over the specified finite field
         *
         * @var object
         */
        protected $eight;
        /**
         * The modulo
         *
         * @var BigInteger
         */
        protected $modulo;
        /**
         * The Order
         *
         * @var BigInteger
         */
        protected $order;
        /**
         * Sets the modulo
         */
        public function setModulo(\phpseclib3\Math\BigInteger $modulo)
        {
        }
        /**
         * Set coefficients a and b
         */
        public function setCoefficients(\phpseclib3\Math\BigInteger $a, \phpseclib3\Math\BigInteger $b)
        {
        }
        /**
         * Set x and y coordinates for the base point
         *
         * @param BigInteger|PrimeInteger $x
         * @param BigInteger|PrimeInteger $y
         * @return PrimeInteger[]
         */
        public function setBasePoint($x, $y)
        {
        }
        /**
         * Retrieve the base point as an array
         *
         * @return array
         */
        public function getBasePoint()
        {
        }
        /**
         * Adds two "fresh" jacobian form on the curve
         *
         * @return FiniteField[]
         */
        protected function jacobianAddPointMixedXY(array $p, array $q)
        {
        }
        /**
         * Adds one "fresh" jacobian form on the curve
         *
         * The second parameter should be the "fresh" one
         *
         * @return FiniteField[]
         */
        protected function jacobianAddPointMixedX(array $p, array $q)
        {
        }
        /**
         * Adds two jacobian coordinates on the curve
         *
         * @return FiniteField[]
         */
        protected function jacobianAddPoint(array $p, array $q)
        {
        }
        /**
         * Adds two points on the curve
         *
         * @return FiniteField[]
         */
        public function addPoint(array $p, array $q)
        {
        }
        /**
         * Returns the numerator and denominator of the slope
         *
         * @return FiniteField[]
         */
        protected function doublePointHelper(array $p)
        {
        }
        /**
         * Doubles a jacobian coordinate on the curve
         *
         * @return FiniteField[]
         */
        protected function jacobianDoublePoint(array $p)
        {
        }
        /**
         * Doubles a "fresh" jacobian coordinate on the curve
         *
         * @return FiniteField[]
         */
        protected function jacobianDoublePointMixed(array $p)
        {
        }
        /**
         * Doubles a point on a curve
         *
         * @return FiniteField[]
         */
        public function doublePoint(array $p)
        {
        }
        /**
         * Returns the X coordinate and the derived Y coordinate
         *
         * @return array
         */
        public function derivePoint($m)
        {
        }
        /**
         * Tests whether or not the x / y values satisfy the equation
         *
         * @return boolean
         */
        public function verifyPoint(array $p)
        {
        }
        /**
         * Returns the modulo
         *
         * @return BigInteger
         */
        public function getModulo()
        {
        }
        /**
         * Returns the a coefficient
         *
         * @return PrimeInteger
         */
        public function getA()
        {
        }
        /**
         * Returns the a coefficient
         *
         * @return PrimeInteger
         */
        public function getB()
        {
        }
        /**
         * Multiply and Add Points
         *
         * Adapted from:
         * https://github.com/indutny/elliptic/blob/725bd91/lib/elliptic/curve/base.js#L125
         *
         * @return int[]
         */
        public function multiplyAddPoints(array $points, array $scalars)
        {
        }
        /**
         * Returns the affine point
         *
         * A Jacobian Coordinate is of the form (x, y, z).
         * To convert a Jacobian Coordinate to an Affine Point
         * you do (x / z^2, y / z^3)
         *
         * @return \phpseclib3\Math\PrimeField\Integer[]
         */
        public function convertToAffine(array $p)
        {
        }
        /**
         * Converts an affine point to a jacobian coordinate
         *
         * @return \phpseclib3\Math\PrimeField\Integer[]
         */
        public function convertToInternal(array $p)
        {
        }
    }
    /**
     * Curves over y^2 = x^3 + b
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class KoblitzPrime extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        /**
         * Basis
         *
         * @var list<array{a: BigInteger, b: BigInteger}>
         */
        protected $basis;
        /**
         * Beta
         *
         * @var PrimeField\Integer
         */
        protected $beta;
        // don't overwrite setCoefficients() with one that only accepts one parameter so that
        // one might be able to switch between KoblitzPrime and Prime more easily (for benchmarking
        // purposes).
        /**
         * Multiply and Add Points
         *
         * Uses a efficiently computable endomorphism to achieve a slight speedup
         *
         * Adapted from:
         * https://github.com/indutny/elliptic/blob/725bd91/lib/elliptic/curve/short.js#L219
         *
         * @return int[]
         */
        public function multiplyAddPoints(array $points, array $scalars)
        {
        }
        /**
         * Returns the numerator and denominator of the slope
         *
         * @return FiniteField[]
         */
        protected function doublePointHelper(array $p)
        {
        }
        /**
         * Doubles a jacobian coordinate on the curve
         *
         * See http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l
         *
         * @return FiniteField[]
         */
        protected function jacobianDoublePoint(array $p)
        {
        }
        /**
         * Doubles a "fresh" jacobian coordinate on the curve
         *
         * See http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-mdbl-2007-bl
         *
         * @return FiniteField[]
         */
        protected function jacobianDoublePointMixed(array $p)
        {
        }
        /**
         * Tests whether or not the x / y values satisfy the equation
         *
         * @return boolean
         */
        public function verifyPoint(array $p)
        {
        }
        /**
         * Calculates the parameters needed from the Euclidean algorithm as discussed at
         * http://diamond.boisestate.edu/~liljanab/MATH308/GuideToECC.pdf#page=148
         *
         * @param BigInteger $u
         * @param BigInteger $v
         * @return BigInteger[]
         */
        protected static function extendedGCD(\phpseclib3\Math\BigInteger $u, \phpseclib3\Math\BigInteger $v)
        {
        }
    }
    /**
     * Curves over y^2 = x^3 + a*x + x
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class Montgomery extends \phpseclib3\Crypt\EC\BaseCurves\Base
    {
        /**
         * Prime Field Integer factory
         *
         * @var PrimeField
         */
        protected $factory;
        /**
         * Cofficient for x
         *
         * @var object
         */
        protected $a;
        /**
         * Constant used for point doubling
         *
         * @var object
         */
        protected $a24;
        /**
         * The Number Zero
         *
         * @var object
         */
        protected $zero;
        /**
         * The Number One
         *
         * @var object
         */
        protected $one;
        /**
         * Base Point
         *
         * @var object
         */
        protected $p;
        /**
         * The modulo
         *
         * @var BigInteger
         */
        protected $modulo;
        /**
         * The Order
         *
         * @var BigInteger
         */
        protected $order;
        /**
         * Sets the modulo
         */
        public function setModulo(\phpseclib3\Math\BigInteger $modulo)
        {
        }
        /**
         * Set coefficients a
         */
        public function setCoefficients(\phpseclib3\Math\BigInteger $a)
        {
        }
        /**
         * Set x and y coordinates for the base point
         *
         * @param BigInteger|PrimeInteger $x
         * @param BigInteger|PrimeInteger $y
         * @return PrimeInteger[]
         */
        public function setBasePoint($x, $y)
        {
        }
        /**
         * Retrieve the base point as an array
         *
         * @return array
         */
        public function getBasePoint()
        {
        }
        /**
         * Multiply a point on the curve by a scalar
         *
         * Uses the montgomery ladder technique as described here:
         *
         * https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#Montgomery_ladder
         * https://github.com/phpecc/phpecc/issues/16#issuecomment-59176772
         *
         * @return array
         */
        public function multiplyPoint(array $p, \phpseclib3\Math\BigInteger $d)
        {
        }
        /**
         * Converts an affine point to an XZ coordinate
         *
         * From https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html
         *
         * XZ coordinates represent x y as X Z satsfying the following equations:
         *
         *   x=X/Z
         *
         * @return \phpseclib3\Math\PrimeField\Integer[]
         */
        public function convertToInternal(array $p)
        {
        }
        /**
         * Returns the affine point
         *
         * @return \phpseclib3\Math\PrimeField\Integer[]
         */
        public function convertToAffine(array $p)
        {
        }
    }
    /**
     * Curves over a*x^2 + y^2 = 1 + d*x^2*y^2
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class TwistedEdwards extends \phpseclib3\Crypt\EC\BaseCurves\Base
    {
        /**
         * The modulo
         *
         * @var BigInteger
         */
        protected $modulo;
        /**
         * Cofficient for x^2
         *
         * @var object
         */
        protected $a;
        /**
         * Cofficient for x^2*y^2
         *
         * @var object
         */
        protected $d;
        /**
         * Base Point
         *
         * @var object[]
         */
        protected $p;
        /**
         * The number zero over the specified finite field
         *
         * @var object
         */
        protected $zero;
        /**
         * The number one over the specified finite field
         *
         * @var object
         */
        protected $one;
        /**
         * The number two over the specified finite field
         *
         * @var object
         */
        protected $two;
        /**
         * Sets the modulo
         */
        public function setModulo(\phpseclib3\Math\BigInteger $modulo)
        {
        }
        /**
         * Set coefficients a and b
         */
        public function setCoefficients(\phpseclib3\Math\BigInteger $a, \phpseclib3\Math\BigInteger $d)
        {
        }
        /**
         * Set x and y coordinates for the base point
         */
        public function setBasePoint($x, $y)
        {
        }
        /**
         * Returns the a coefficient
         *
         * @return PrimeInteger
         */
        public function getA()
        {
        }
        /**
         * Returns the a coefficient
         *
         * @return PrimeInteger
         */
        public function getD()
        {
        }
        /**
         * Retrieve the base point as an array
         *
         * @return array
         */
        public function getBasePoint()
        {
        }
        /**
         * Returns the affine point
         *
         * @return PrimeField\Integer[]
         */
        public function convertToAffine(array $p)
        {
        }
        /**
         * Returns the modulo
         *
         * @return BigInteger
         */
        public function getModulo()
        {
        }
        /**
         * Tests whether or not the x / y values satisfy the equation
         *
         * @return boolean
         */
        public function verifyPoint(array $p)
        {
        }
    }
}
namespace phpseclib3\Crypt\EC\Curves {
    class brainpoolP160r1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class brainpoolP160t1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class brainpoolP192r1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class brainpoolP192t1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class brainpoolP224r1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class brainpoolP224t1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class brainpoolP256r1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class brainpoolP256t1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class brainpoolP320r1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class brainpoolP320t1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class brainpoolP384r1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class brainpoolP384t1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class brainpoolP512r1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class brainpoolP512t1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class Curve25519 extends \phpseclib3\Crypt\EC\BaseCurves\Montgomery
    {
        public function __construct()
        {
        }
        /**
         * Multiply a point on the curve by a scalar
         *
         * Modifies the scalar as described at https://tools.ietf.org/html/rfc7748#page-8
         *
         * @return array
         */
        public function multiplyPoint(array $p, \phpseclib3\Math\BigInteger $d)
        {
        }
        /**
         * Creates a random scalar multiplier
         *
         * @return BigInteger
         */
        public function createRandomMultiplier()
        {
        }
        /**
         * Performs range check
         */
        public function rangeCheck(\phpseclib3\Math\BigInteger $x)
        {
        }
    }
    class Curve448 extends \phpseclib3\Crypt\EC\BaseCurves\Montgomery
    {
        public function __construct()
        {
        }
        /**
         * Multiply a point on the curve by a scalar
         *
         * Modifies the scalar as described at https://tools.ietf.org/html/rfc7748#page-8
         *
         * @return array
         */
        public function multiplyPoint(array $p, \phpseclib3\Math\BigInteger $d)
        {
        }
        /**
         * Creates a random scalar multiplier
         *
         * @return BigInteger
         */
        public function createRandomMultiplier()
        {
        }
        /**
         * Performs range check
         */
        public function rangeCheck(\phpseclib3\Math\BigInteger $x)
        {
        }
    }
    class Ed25519 extends \phpseclib3\Crypt\EC\BaseCurves\TwistedEdwards
    {
        const HASH = 'sha512';
        /*
          Per https://tools.ietf.org/html/rfc8032#page-6 EdDSA has several parameters, one of which is b:
        
          2.   An integer b with 2^(b-1) > p.  EdDSA public keys have exactly b
               bits, and EdDSA signatures have exactly 2*b bits.  b is
               recommended to be a multiple of 8, so public key and signature
               lengths are an integral number of octets.
        
          SIZE corresponds to b
        */
        const SIZE = 32;
        public function __construct()
        {
        }
        /**
         * Recover X from Y
         *
         * Implements steps 2-4 at https://tools.ietf.org/html/rfc8032#section-5.1.3
         *
         * Used by EC\Keys\Common.php
         *
         * @param BigInteger $y
         * @param boolean $sign
         * @return object[]
         */
        public function recoverX(\phpseclib3\Math\BigInteger $y, $sign)
        {
        }
        /**
         * Extract Secret Scalar
         *
         * Implements steps 1-3 at https://tools.ietf.org/html/rfc8032#section-5.1.5
         *
         * Used by the various key handlers
         *
         * @param string $str
         * @return array
         */
        public function extractSecret($str)
        {
        }
        /**
         * Encode a point as a string
         *
         * @param array $point
         * @return string
         */
        public function encodePoint($point)
        {
        }
        /**
         * Creates a random scalar multiplier
         *
         * @return \phpseclib3\Math\PrimeField\Integer
         */
        public function createRandomMultiplier()
        {
        }
        /**
         * Converts an affine point to an extended homogeneous coordinate
         *
         * From https://tools.ietf.org/html/rfc8032#section-5.1.4 :
         *
         * A point (x,y) is represented in extended homogeneous coordinates (X, Y, Z, T),
         * with x = X/Z, y = Y/Z, x * y = T/Z.
         *
         * @return \phpseclib3\Math\PrimeField\Integer[]
         */
        public function convertToInternal(array $p)
        {
        }
        /**
         * Doubles a point on a curve
         *
         * @return FiniteField[]
         */
        public function doublePoint(array $p)
        {
        }
        /**
         * Adds two points on the curve
         *
         * @return FiniteField[]
         */
        public function addPoint(array $p, array $q)
        {
        }
    }
    class Ed448 extends \phpseclib3\Crypt\EC\BaseCurves\TwistedEdwards
    {
        const HASH = 'shake256-912';
        const SIZE = 57;
        public function __construct()
        {
        }
        /**
         * Recover X from Y
         *
         * Implements steps 2-4 at https://tools.ietf.org/html/rfc8032#section-5.2.3
         *
         * Used by EC\Keys\Common.php
         *
         * @param BigInteger $y
         * @param boolean $sign
         * @return object[]
         */
        public function recoverX(\phpseclib3\Math\BigInteger $y, $sign)
        {
        }
        /**
         * Extract Secret Scalar
         *
         * Implements steps 1-3 at https://tools.ietf.org/html/rfc8032#section-5.2.5
         *
         * Used by the various key handlers
         *
         * @param string $str
         * @return array
         */
        public function extractSecret($str)
        {
        }
        /**
         * Encode a point as a string
         *
         * @param array $point
         * @return string
         */
        public function encodePoint($point)
        {
        }
        /**
         * Creates a random scalar multiplier
         *
         * @return \phpseclib3\Math\PrimeField\Integer
         */
        public function createRandomMultiplier()
        {
        }
        /**
         * Converts an affine point to an extended homogeneous coordinate
         *
         * From https://tools.ietf.org/html/rfc8032#section-5.2.4 :
         *
         * A point (x,y) is represented in extended homogeneous coordinates (X, Y, Z, T),
         * with x = X/Z, y = Y/Z, x * y = T/Z.
         *
         * @return \phpseclib3\Math\PrimeField\Integer[]
         */
        public function convertToInternal(array $p)
        {
        }
        /**
         * Doubles a point on a curve
         *
         * @return FiniteField[]
         */
        public function doublePoint(array $p)
        {
        }
        /**
         * Adds two points on the curve
         *
         * @return FiniteField[]
         */
        public function addPoint(array $p, array $q)
        {
        }
    }
    class sect233r1 extends \phpseclib3\Crypt\EC\BaseCurves\Binary
    {
        public function __construct()
        {
        }
    }
    final class nistb233 extends \phpseclib3\Crypt\EC\Curves\sect233r1
    {
    }
    class sect409r1 extends \phpseclib3\Crypt\EC\BaseCurves\Binary
    {
        public function __construct()
        {
        }
    }
    final class nistb409 extends \phpseclib3\Crypt\EC\Curves\sect409r1
    {
    }
    class sect163k1 extends \phpseclib3\Crypt\EC\BaseCurves\Binary
    {
        public function __construct()
        {
        }
    }
    final class nistk163 extends \phpseclib3\Crypt\EC\Curves\sect163k1
    {
    }
    class sect233k1 extends \phpseclib3\Crypt\EC\BaseCurves\Binary
    {
        public function __construct()
        {
        }
    }
    final class nistk233 extends \phpseclib3\Crypt\EC\Curves\sect233k1
    {
    }
    class sect283k1 extends \phpseclib3\Crypt\EC\BaseCurves\Binary
    {
        public function __construct()
        {
        }
    }
    final class nistk283 extends \phpseclib3\Crypt\EC\Curves\sect283k1
    {
    }
    class sect409k1 extends \phpseclib3\Crypt\EC\BaseCurves\Binary
    {
        public function __construct()
        {
        }
    }
    final class nistk409 extends \phpseclib3\Crypt\EC\Curves\sect409k1
    {
    }
    class secp192r1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    final class nistp192 extends \phpseclib3\Crypt\EC\Curves\secp192r1
    {
    }
    class secp224r1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    final class nistp224 extends \phpseclib3\Crypt\EC\Curves\secp224r1
    {
    }
    class secp256r1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    final class nistp256 extends \phpseclib3\Crypt\EC\Curves\secp256r1
    {
    }
    class secp384r1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    final class nistp384 extends \phpseclib3\Crypt\EC\Curves\secp384r1
    {
    }
    class secp521r1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    final class nistp521 extends \phpseclib3\Crypt\EC\Curves\secp521r1
    {
    }
    class sect571k1 extends \phpseclib3\Crypt\EC\BaseCurves\Binary
    {
        public function __construct()
        {
        }
    }
    final class nistt571 extends \phpseclib3\Crypt\EC\Curves\sect571k1
    {
    }
    final class prime192v1 extends \phpseclib3\Crypt\EC\Curves\secp192r1
    {
    }
    class prime192v2 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class prime192v3 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class prime239v1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class prime239v2 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class prime239v3 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    final class prime256v1 extends \phpseclib3\Crypt\EC\Curves\secp256r1
    {
    }
    class secp112r1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class secp112r2 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class secp128r1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class secp128r2 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class secp160k1 extends \phpseclib3\Crypt\EC\BaseCurves\KoblitzPrime
    {
        public function __construct()
        {
        }
    }
    class secp160r1 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class secp160r2 extends \phpseclib3\Crypt\EC\BaseCurves\Prime
    {
        public function __construct()
        {
        }
    }
    class secp192k1 extends \phpseclib3\Crypt\EC\BaseCurves\KoblitzPrime
    {
        public function __construct()
        {
        }
    }
    class secp224k1 extends \phpseclib3\Crypt\EC\BaseCurves\KoblitzPrime
    {
        public function __construct()
        {
        }
    }
    //class secp256k1 extends Prime
    class secp256k1 extends \phpseclib3\Crypt\EC\BaseCurves\KoblitzPrime
    {
        public function __construct()
        {
        }
    }
    class sect113r1 extends \phpseclib3\Crypt\EC\BaseCurves\Binary
    {
        public function __construct()
        {
        }
    }
    class sect113r2 extends \phpseclib3\Crypt\EC\BaseCurves\Binary
    {
        public function __construct()
        {
        }
    }
    class sect131r1 extends \phpseclib3\Crypt\EC\BaseCurves\Binary
    {
        public function __construct()
        {
        }
    }
    class sect131r2 extends \phpseclib3\Crypt\EC\BaseCurves\Binary
    {
        public function __construct()
        {
        }
    }
    class sect163r1 extends \phpseclib3\Crypt\EC\BaseCurves\Binary
    {
        public function __construct()
        {
        }
    }
    class sect163r2 extends \phpseclib3\Crypt\EC\BaseCurves\Binary
    {
        public function __construct()
        {
        }
    }
    class sect193r1 extends \phpseclib3\Crypt\EC\BaseCurves\Binary
    {
        public function __construct()
        {
        }
    }
    class sect193r2 extends \phpseclib3\Crypt\EC\BaseCurves\Binary
    {
        public function __construct()
        {
        }
    }
    class sect239k1 extends \phpseclib3\Crypt\EC\BaseCurves\Binary
    {
        public function __construct()
        {
        }
    }
    class sect283r1 extends \phpseclib3\Crypt\EC\BaseCurves\Binary
    {
        public function __construct()
        {
        }
    }
    class sect571r1 extends \phpseclib3\Crypt\EC\BaseCurves\Binary
    {
        public function __construct()
        {
        }
    }
}
namespace phpseclib3\Crypt\EC\Formats\Keys {
    /**
     * Generic EC Key Parsing Helper functions
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    trait Common
    {
        /**
         * Curve OIDs
         *
         * @var array
         */
        private static $curveOIDs = [];
        /**
         * Child OIDs loaded
         *
         * @var bool
         */
        protected static $childOIDsLoaded = false;
        /**
         * Use Named Curves
         *
         * @var bool
         */
        private static $useNamedCurves = true;
        /**
         * Initialize static variables
         */
        private static function initialize_static_variables()
        {
        }
        /**
         * Explicitly set the curve
         *
         * If the key contains an implicit curve phpseclib needs the curve
         * to be explicitly provided
         *
         * @param BaseCurve $curve
         */
        public static function setImplicitCurve(\phpseclib3\Crypt\EC\BaseCurves\Base $curve)
        {
        }
        /**
         * Returns an instance of \phpseclib3\Crypt\EC\BaseCurves\Base based
         * on the curve parameters
         *
         * @param array $params
         * @return BaseCurve|false
         */
        protected static function loadCurveByParam(array $params)
        {
        }
        /**
         * Extract points from a string
         *
         * Supports both compressed and uncompressed points
         *
         * @param string $str
         * @param BaseCurve $curve
         * @return object[]
         */
        public static function extractPoint($str, \phpseclib3\Crypt\EC\BaseCurves\Base $curve)
        {
        }
        /**
         * Encode Parameters
         *
         * @todo Maybe at some point this could be moved to __toString() for each of the curves?
         * @param BaseCurve $curve
         * @param bool $returnArray optional
         * @param array $options optional
         * @return string|false
         */
        private static function encodeParameters(\phpseclib3\Crypt\EC\BaseCurves\Base $curve, $returnArray = false, array $options = [])
        {
        }
        /**
         * Use Specified Curve
         *
         * A specified curve has all the coefficients, the base points, etc, explicitely included.
         * A specified curve is a more verbose way of representing a curve
         */
        public static function useSpecifiedCurve()
        {
        }
        /**
         * Use Named Curve
         *
         * A named curve does not include any parameters. It is up to the EC parameters to
         * know what the coefficients, the base points, etc, are from the name of the curve.
         * A named curve is a more concise way of representing a curve
         */
        public static function useNamedCurve()
        {
        }
    }
    /**
     * JWK Formatted EC Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class JWK extends \phpseclib3\Crypt\Common\Formats\Keys\JWK
    {
        use \phpseclib3\Crypt\EC\Formats\Keys\Common;
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert an EC public key to the appropriate format
         *
         * @param BaseCurve $curve
         * @param \phpseclib3\Math\Common\FiniteField\Integer[] $publicKey
         * @param array $options optional
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Crypt\EC\BaseCurves\Base $curve, array $publicKey, array $options = [])
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $privateKey
         * @param Ed25519 $curve
         * @param \phpseclib3\Math\Common\FiniteField\Integer[] $publicKey
         * @param string $secret optional
         * @param string $password optional
         * @param array $options optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $privateKey, \phpseclib3\Crypt\EC\BaseCurves\Base $curve, array $publicKey, $secret = null, $password = '', array $options = [])
        {
        }
    }
    /**
     * libsodium Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class libsodium
    {
        use \phpseclib3\Crypt\EC\Formats\Keys\Common;
        /**
         * Is invisible flag
         *
         */
        const IS_INVISIBLE = true;
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert an EC public key to the appropriate format
         *
         * @param Ed25519 $curve
         * @param \phpseclib3\Math\Common\FiniteField\Integer[] $publicKey
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Crypt\EC\Curves\Ed25519 $curve, array $publicKey)
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $privateKey
         * @param Ed25519 $curve
         * @param \phpseclib3\Math\Common\FiniteField\Integer[] $publicKey
         * @param string $secret optional
         * @param string $password optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $privateKey, \phpseclib3\Crypt\EC\Curves\Ed25519 $curve, array $publicKey, $secret = null, $password = '')
        {
        }
    }
    /**
     * Montgomery Curve Private Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class MontgomeryPrivate
    {
        /**
         * Is invisible flag
         *
         */
        const IS_INVISIBLE = true;
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert an EC public key to the appropriate format
         *
         * @param MontgomeryCurve $curve
         * @param \phpseclib3\Math\Common\FiniteField\Integer[] $publicKey
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Crypt\EC\BaseCurves\Montgomery $curve, array $publicKey)
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $privateKey
         * @param MontgomeryCurve $curve
         * @param \phpseclib3\Math\Common\FiniteField\Integer[] $publicKey
         * @param string $secret optional
         * @param string $password optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $privateKey, \phpseclib3\Crypt\EC\BaseCurves\Montgomery $curve, array $publicKey, $secret = null, $password = '')
        {
        }
    }
    /**
     * Montgomery Public Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class MontgomeryPublic
    {
        /**
         * Is invisible flag
         *
         */
        const IS_INVISIBLE = true;
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert an EC public key to the appropriate format
         *
         * @param MontgomeryCurve $curve
         * @param \phpseclib3\Math\Common\FiniteField\Integer[] $publicKey
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Crypt\EC\BaseCurves\Montgomery $curve, array $publicKey)
        {
        }
    }
    /**
     * OpenSSH Formatted EC Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class OpenSSH extends \phpseclib3\Crypt\Common\Formats\Keys\OpenSSH
    {
        use \phpseclib3\Crypt\EC\Formats\Keys\Common;
        /**
         * Supported Key Types
         *
         * @var array
         */
        protected static $types = ['ecdsa-sha2-nistp256', 'ecdsa-sha2-nistp384', 'ecdsa-sha2-nistp521', 'ssh-ed25519'];
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert an EC public key to the appropriate format
         *
         * @param BaseCurve $curve
         * @param \phpseclib3\Math\Common\FiniteField\Integer[] $publicKey
         * @param array $options optional
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Crypt\EC\BaseCurves\Base $curve, array $publicKey, array $options = [])
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $privateKey
         * @param Ed25519 $curve
         * @param \phpseclib3\Math\Common\FiniteField\Integer[] $publicKey
         * @param string $secret optional
         * @param string $password optional
         * @param array $options optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $privateKey, \phpseclib3\Crypt\EC\BaseCurves\Base $curve, array $publicKey, $secret = null, $password = '', array $options = [])
        {
        }
    }
    /**
     * "PKCS1" (RFC5915) Formatted EC Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PKCS1 extends \phpseclib3\Crypt\Common\Formats\Keys\PKCS1
    {
        use \phpseclib3\Crypt\EC\Formats\Keys\Common;
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert EC parameters to the appropriate format
         *
         * @return string
         */
        public static function saveParameters(\phpseclib3\Crypt\EC\BaseCurves\Base $curve, array $options = [])
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $privateKey
         * @param BaseCurve $curve
         * @param \phpseclib3\Math\Common\FiniteField\Integer[] $publicKey
         * @param string $secret optional
         * @param string $password optional
         * @param array $options optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $privateKey, \phpseclib3\Crypt\EC\BaseCurves\Base $curve, array $publicKey, $secret = null, $password = '', array $options = [])
        {
        }
    }
    /**
     * PKCS#8 Formatted EC Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PKCS8 extends \phpseclib3\Crypt\Common\Formats\Keys\PKCS8
    {
        use \phpseclib3\Crypt\EC\Formats\Keys\Common;
        /**
         * OID Name
         *
         * @var array
         */
        const OID_NAME = ['id-ecPublicKey', 'id-Ed25519', 'id-Ed448'];
        /**
         * OID Value
         *
         * @var string
         */
        const OID_VALUE = ['1.2.840.10045.2.1', '1.3.101.112', '1.3.101.113'];
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert an EC public key to the appropriate format
         *
         * @param BaseCurve $curve
         * @param \phpseclib3\Math\Common\FiniteField\Integer[] $publicKey
         * @param array $options optional
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Crypt\EC\BaseCurves\Base $curve, array $publicKey, array $options = [])
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $privateKey
         * @param BaseCurve $curve
         * @param \phpseclib3\Math\Common\FiniteField\Integer[] $publicKey
         * @param string $secret optional
         * @param string $password optional
         * @param array $options optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $privateKey, \phpseclib3\Crypt\EC\BaseCurves\Base $curve, array $publicKey, $secret = null, $password = '', array $options = [])
        {
        }
    }
    /**
     * PuTTY Formatted EC Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PuTTY extends \phpseclib3\Crypt\Common\Formats\Keys\PuTTY
    {
        use \phpseclib3\Crypt\EC\Formats\Keys\Common;
        /**
         * Public Handler
         *
         * @var string
         */
        const PUBLIC_HANDLER = 'phpseclib3\Crypt\EC\Formats\Keys\OpenSSH';
        /**
         * Supported Key Types
         *
         * @var array
         */
        protected static $types = ['ecdsa-sha2-nistp256', 'ecdsa-sha2-nistp384', 'ecdsa-sha2-nistp521', 'ssh-ed25519'];
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $privateKey
         * @param BaseCurve $curve
         * @param \phpseclib3\Math\Common\FiniteField\Integer[] $publicKey
         * @param string $secret optional
         * @param string $password optional
         * @param array $options optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $privateKey, \phpseclib3\Crypt\EC\BaseCurves\Base $curve, array $publicKey, $secret = null, $password = false, array $options = [])
        {
        }
        /**
         * Convert an EC public key to the appropriate format
         *
         * @param BaseCurve $curve
         * @param \phpseclib3\Math\Common\FiniteField[] $publicKey
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Crypt\EC\BaseCurves\Base $curve, array $publicKey)
        {
        }
    }
    /**
     * XML Formatted EC Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class XML
    {
        use \phpseclib3\Crypt\EC\Formats\Keys\Common;
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Sets the namespace. dsig11 is the most common one.
         *
         * Set to null to unset. Used only for creating public keys.
         *
         * @param string $namespace
         */
        public static function setNamespace($namespace)
        {
        }
        /**
         * Uses the XML syntax specified in https://tools.ietf.org/html/rfc4050
         */
        public static function enableRFC4050Syntax()
        {
        }
        /**
         * Uses the XML syntax specified in https://www.w3.org/TR/xmldsig-core/#sec-ECParameters
         */
        public static function disableRFC4050Syntax()
        {
        }
        /**
         * Convert a public key to the appropriate format
         *
         * @param BaseCurve $curve
         * @param \phpseclib3\Math\Common\FiniteField\Integer[] $publicKey
         * @param array $options optional
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Crypt\EC\BaseCurves\Base $curve, array $publicKey, array $options = [])
        {
        }
    }
}
namespace phpseclib3\Crypt\EC\Formats\Signature {
    /**
     * ASN1 Signature Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class ASN1
    {
        /**
         * Loads a signature
         *
         * @param string $sig
         * @return array
         */
        public static function load($sig)
        {
        }
        /**
         * Returns a signature in the appropriate format
         *
         * @param BigInteger $r
         * @param BigInteger $s
         * @return string
         */
        public static function save(\phpseclib3\Math\BigInteger $r, \phpseclib3\Math\BigInteger $s)
        {
        }
    }
    /**
     * ASN1 Signature Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class IEEE
    {
        /**
         * Loads a signature
         *
         * @param string $sig
         * @return array
         */
        public static function load($sig)
        {
        }
        /**
         * Returns a signature in the appropriate format
         *
         * @param BigInteger $r
         * @param BigInteger $s
         * @param string $curve
         * @param int $length
         * @return string
         */
        public static function save(\phpseclib3\Math\BigInteger $r, \phpseclib3\Math\BigInteger $s, $curve, $length)
        {
        }
    }
    /**
     * Raw DSA Signature Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Raw extends \phpseclib3\Crypt\Common\Formats\Signature\Raw
    {
    }
    /**
     * SSH2 Signature Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class SSH2
    {
        /**
         * Loads a signature
         *
         * @param string $sig
         * @return mixed
         */
        public static function load($sig)
        {
        }
        /**
         * Returns a signature in the appropriate format
         *
         * @param BigInteger $r
         * @param BigInteger $s
         * @param string $curve
         * @return string
         */
        public static function save(\phpseclib3\Math\BigInteger $r, \phpseclib3\Math\BigInteger $s, $curve)
        {
        }
    }
}
namespace phpseclib3\Crypt {
    /**
     * Pure-PHP implementation of EC.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class EC extends \phpseclib3\Crypt\Common\AsymmetricKey
    {
        /**
         * Algorithm Name
         *
         * @var string
         */
        const ALGORITHM = 'EC';
        /**
         * Public Key QA
         *
         * @var object[]
         */
        protected $QA;
        /**
         * Curve
         *
         * @var EC\BaseCurves\Base
         */
        protected $curve;
        /**
         * Signature Format
         *
         * @var string
         */
        protected $format;
        /**
         * Signature Format (Short)
         *
         * @var string
         */
        protected $shortFormat;
        /**
         * Curve Order
         *
         * Used for deterministic ECDSA
         *
         * @var BigInteger
         */
        protected $q;
        /**
         * Alias for the private key
         *
         * Used for deterministic ECDSA. AsymmetricKey expects $x. I don't like x because
         * with x you have x * the base point yielding an (x, y)-coordinate that is the
         * public key. But the x is different depending on which side of the equal sign
         * you're on. It's less ambiguous if you do dA * base point = (x, y)-coordinate.
         *
         * @var BigInteger
         */
        protected $x;
        /**
         * Context
         *
         * @var string
         */
        protected $context;
        /**
         * Signature Format
         *
         * @var string
         */
        protected $sigFormat;
        /**
         * Create public / private key pair.
         *
         * @param string $curve
         * @return PrivateKey
         */
        public static function createKey($curve)
        {
        }
        /**
         * OnLoad Handler
         *
         * @return bool
         */
        protected static function onLoad(array $components)
        {
        }
        /**
         * Constructor
         *
         * PublicKey and PrivateKey objects can only be created from abstract RSA class
         */
        protected function __construct()
        {
        }
        /**
         * Returns the curve
         *
         * Returns a string if it's a named curve, an array if not
         *
         * @return string|array
         */
        public function getCurve()
        {
        }
        /**
         * Returns the key size
         *
         * Quoting https://tools.ietf.org/html/rfc5656#section-2,
         *
         * "The size of a set of elliptic curve domain parameters on a prime
         *  curve is defined as the number of bits in the binary representation
         *  of the field order, commonly denoted by p.  Size on a
         *  characteristic-2 curve is defined as the number of bits in the binary
         *  representation of the field, commonly denoted by m.  A set of
         *  elliptic curve domain parameters defines a group of order n generated
         *  by a base point P"
         *
         * @return int
         */
        public function getLength()
        {
        }
        /**
         * Returns the current engine being used
         *
         * @see self::useInternalEngine()
         * @see self::useBestEngine()
         * @return string
         */
        public function getEngine()
        {
        }
        /**
         * Returns the public key coordinates as a string
         *
         * Used by ECDH
         *
         * @return string
         */
        public function getEncodedCoordinates()
        {
        }
        /**
         * Returns the parameters
         *
         * @see self::getPublicKey()
         * @param string $type optional
         * @return mixed
         */
        public function getParameters($type = 'PKCS1')
        {
        }
        /**
         * Determines the signature padding mode
         *
         * Valid values are: ASN1, SSH2, Raw
         *
         * @param string $format
         */
        public function withSignatureFormat($format)
        {
        }
        /**
         * Returns the signature format currently being used
         *
         */
        public function getSignatureFormat()
        {
        }
        /**
         * Sets the context
         *
         * Used by Ed25519 / Ed448.
         *
         * @see self::sign()
         * @see self::verify()
         * @param string $context optional
         */
        public function withContext($context = null)
        {
        }
        /**
         * Returns the signature format currently being used
         *
         */
        public function getContext()
        {
        }
        /**
         * Determines which hashing function should be used
         *
         * @param string $hash
         */
        public function withHash($hash)
        {
        }
        /**
         * __toString() magic method
         *
         * @return string
         */
        public function __toString()
        {
        }
    }
}
namespace phpseclib3\Crypt\EC {
    /**
     * EC Parameters
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    final class Parameters extends \phpseclib3\Crypt\EC
    {
        /**
         * Returns the parameters
         *
         * @param string $type
         * @param array $options optional
         * @return string
         */
        public function toString($type = 'PKCS1', array $options = [])
        {
        }
    }
    /**
     * EC Private Key
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    final class PrivateKey extends \phpseclib3\Crypt\EC implements \phpseclib3\Crypt\Common\PrivateKey
    {
        use \phpseclib3\Crypt\Common\Traits\PasswordProtected;
        /**
         * Multiplies an encoded point by the private key
         *
         * Used by ECDH
         *
         * @param string $coordinates
         * @return string
         */
        public function multiply($coordinates)
        {
        }
        /**
         * Create a signature
         *
         * @see self::verify()
         * @param string $message
         * @return mixed
         */
        public function sign($message)
        {
        }
        /**
         * Returns the private key
         *
         * @param string $type
         * @param array $options optional
         * @return string
         */
        public function toString($type, array $options = [])
        {
        }
        /**
         * Returns the public key
         *
         * @see self::getPrivateKey()
         * @return mixed
         */
        public function getPublicKey()
        {
        }
    }
    /**
     * EC Public Key
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    final class PublicKey extends \phpseclib3\Crypt\EC implements \phpseclib3\Crypt\Common\PublicKey
    {
        use \phpseclib3\Crypt\Common\Traits\Fingerprint;
        /**
         * Verify a signature
         *
         * @see self::verify()
         * @param string $message
         * @param string $signature
         * @return mixed
         */
        public function verify($message, $signature)
        {
        }
        /**
         * Returns the public key
         *
         * @param string $type
         * @param array $options optional
         * @return string
         */
        public function toString($type, array $options = [])
        {
        }
    }
}
namespace phpseclib3\Crypt {
    /**
     * @author  Jim Wigginton <terrafrost@php.net>
     * @author  Andreas Fischer <bantu@phpbb.com>
     */
    class Hash
    {
        /**
         * Padding Types
         *
         */
        const PADDING_KECCAK = 1;
        /**
         * Padding Types
         *
         */
        const PADDING_SHA3 = 2;
        /**
         * Padding Types
         *
         */
        const PADDING_SHAKE = 3;
        /**#@-*/
        /**
         * Default Constructor.
         *
         * @param string $hash
         */
        public function __construct($hash = 'sha256')
        {
        }
        /**
         * Sets the key for HMACs
         *
         * Keys can be of any length.
         *
         * @param string $key
         */
        public function setKey($key = false)
        {
        }
        /**
         * Sets the nonce for UMACs
         *
         * Keys can be of any length.
         *
         * @param string $nonce
         */
        public function setNonce($nonce = false)
        {
        }
        /**
         * Gets the hash function.
         *
         * As set by the constructor or by the setHash() method.
         *
         * @return string
         */
        public function getHash()
        {
        }
        /**
         * Sets the hash function.
         *
         * @param string $hash
         */
        public function setHash($hash)
        {
        }
        /**
         * Compute the Hash / HMAC / UMAC.
         *
         * @param string $text
         * @return string
         */
        public function hash($text)
        {
        }
        /**
         * Returns the hash length (in bits)
         *
         * @return int
         */
        public function getLength()
        {
        }
        /**
         * Returns the hash length (in bytes)
         *
         * @return int
         */
        public function getLengthInBytes()
        {
        }
        /**
         * Returns the block length (in bits)
         *
         * @return int
         */
        public function getBlockLength()
        {
        }
        /**
         * Returns the block length (in bytes)
         *
         * @return int
         */
        public function getBlockLengthInBytes()
        {
        }
        /**
         *  __toString() magic method
         */
        public function __toString()
        {
        }
    }
    /**
     * PublicKeyLoader
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PublicKeyLoader
    {
        /**
         * Loads a public or private key
         *
         * @return AsymmetricKey
         * @param string|array $key
         * @param string $password optional
         */
        public static function load($key, $password = false)
        {
        }
        /**
         * Loads a private key
         *
         * @return PrivateKey
         * @param string|array $key
         * @param string $password optional
         */
        public static function loadPrivateKey($key, $password = false)
        {
        }
        /**
         * Loads a public key
         *
         * @return PublicKey
         * @param string|array $key
         */
        public static function loadPublicKey($key)
        {
        }
        /**
         * Loads parameters
         *
         * @return AsymmetricKey
         * @param string|array $key
         */
        public static function loadParameters($key)
        {
        }
    }
    /**
     * Pure-PHP Random Number Generator
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Random
    {
        /**
         * Generate a random string.
         *
         * Although microoptimizations are generally discouraged as they impair readability this function is ripe with
         * microoptimizations because this function has the potential of being called a huge number of times.
         * eg. for RSA key generation.
         *
         * @param int $length
         * @throws \RuntimeException if a symmetric cipher is needed but not loaded
         * @return string
         */
        public static function string($length)
        {
        }
    }
    /**
     * Pure-PHP implementation of RC2.
     *
     */
    class RC2 extends \phpseclib3\Crypt\Common\BlockCipher
    {
        /**
         * Block Length of the cipher
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::block_size
         * @var int
         */
        protected $block_size = 8;
        /**
         * The Key
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::key
         * @see self::setKey()
         * @var string
         */
        protected $key;
        /**
         * Key Length (in bytes)
         *
         * @see \phpseclib3\Crypt\RC2::setKeyLength()
         * @var int
         */
        protected $key_length = 16;
        // = 128 bits
        /**
         * The mcrypt specific name of the cipher
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::cipher_name_mcrypt
         * @var string
         */
        protected $cipher_name_mcrypt = 'rc2';
        /**
         * Optimizing value while CFB-encrypting
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::cfb_init_len
         * @var int
         */
        protected $cfb_init_len = 500;
        /**
         * Default Constructor.
         *
         * @param string $mode
         * @throws \InvalidArgumentException if an invalid / unsupported mode is provided
         */
        public function __construct($mode)
        {
        }
        /**
         * Test for engine validity
         *
         * This is mainly just a wrapper to set things up for \phpseclib3\Crypt\Common\SymmetricKey::isValidEngine()
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::__construct()
         * @param int $engine
         * @return bool
         */
        protected function isValidEngineHelper($engine)
        {
        }
        /**
         * Sets the key length.
         *
         * Valid key lengths are 8 to 1024.
         * Calling this function after setting the key has no effect until the next
         *  \phpseclib3\Crypt\RC2::setKey() call.
         *
         * @param int $length in bits
         * @throws \LengthException if the key length isn't supported
         */
        public function setKeyLength($length)
        {
        }
        /**
         * Returns the current key length
         *
         * @return int
         */
        public function getKeyLength()
        {
        }
        /**
         * Sets the key.
         *
         * Keys can be of any length. RC2, itself, uses 8 to 1024 bit keys (eg.
         * strlen($key) <= 128), however, we only use the first 128 bytes if $key
         * has more then 128 bytes in it, and set $key to a single null byte if
         * it is empty.
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::setKey()
         * @param string $key
         * @param int|boolean $t1 optional Effective key length in bits.
         * @throws \LengthException if the key length isn't supported
         */
        public function setKey($key, $t1 = false)
        {
        }
        /**
         * Encrypts a message.
         *
         * Mostly a wrapper for \phpseclib3\Crypt\Common\SymmetricKey::encrypt, with some additional OpenSSL handling code
         *
         * @see self::decrypt()
         * @param string $plaintext
         * @return string $ciphertext
         */
        public function encrypt($plaintext)
        {
        }
        /**
         * Decrypts a message.
         *
         * Mostly a wrapper for \phpseclib3\Crypt\Common\SymmetricKey::decrypt, with some additional OpenSSL handling code
         *
         * @see self::encrypt()
         * @param string $ciphertext
         * @return string $plaintext
         */
        public function decrypt($ciphertext)
        {
        }
        /**
         * Encrypts a block
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::encryptBlock()
         * @see \phpseclib3\Crypt\Common\SymmetricKey::encrypt()
         * @param string $in
         * @return string
         */
        protected function encryptBlock($in)
        {
        }
        /**
         * Decrypts a block
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::decryptBlock()
         * @see \phpseclib3\Crypt\Common\SymmetricKey::decrypt()
         * @param string $in
         * @return string
         */
        protected function decryptBlock($in)
        {
        }
        /**
         * Creates the key schedule
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::setupKey()
         */
        protected function setupKey()
        {
        }
        /**
         * Setup the performance-optimized function for de/encrypt()
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::setupInlineCrypt()
         */
        protected function setupInlineCrypt()
        {
        }
    }
    /**
     * Pure-PHP implementation of RC4.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class RC4 extends \phpseclib3\Crypt\Common\StreamCipher
    {
        /**
         * @see \phpseclib3\Crypt\RC4::_crypt()
         */
        const ENCRYPT = 0;
        /**
         * @see \phpseclib3\Crypt\RC4::_crypt()
         */
        const DECRYPT = 1;
        /**
         * Key Length (in bytes)
         *
         * @see \phpseclib3\Crypt\RC4::setKeyLength()
         * @var int
         */
        protected $key_length = 128;
        // = 1024 bits
        /**
         * The mcrypt specific name of the cipher
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::cipher_name_mcrypt
         * @var string
         */
        protected $cipher_name_mcrypt = 'arcfour';
        /**
         * The Key
         *
         * @see self::setKey()
         * @var string
         */
        protected $key;
        /**
         * Test for engine validity
         *
         * This is mainly just a wrapper to set things up for \phpseclib3\Crypt\Common\SymmetricKey::isValidEngine()
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::__construct()
         * @param int $engine
         * @return bool
         */
        protected function isValidEngineHelper($engine)
        {
        }
        /**
         * Sets the key length
         *
         * Keys can be between 1 and 256 bytes long.
         *
         * @param int $length
         * @throws \LengthException if the key length is invalid
         */
        public function setKeyLength($length)
        {
        }
        /**
         * Sets the key length
         *
         * Keys can be between 1 and 256 bytes long.
         *
         * @param string $key
         */
        public function setKey($key)
        {
        }
        /**
         * Encrypts a message.
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::decrypt()
         * @see self::crypt()
         * @param string $plaintext
         * @return string $ciphertext
         */
        public function encrypt($plaintext)
        {
        }
        /**
         * Decrypts a message.
         *
         * $this->decrypt($this->encrypt($plaintext)) == $this->encrypt($this->encrypt($plaintext)).
         * At least if the continuous buffer is disabled.
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::encrypt()
         * @see self::crypt()
         * @param string $ciphertext
         * @return string $plaintext
         */
        public function decrypt($ciphertext)
        {
        }
        /**
         * Encrypts a block
         *
         * @param string $in
         */
        protected function encryptBlock($in)
        {
        }
        /**
         * Decrypts a block
         *
         * @param string $in
         */
        protected function decryptBlock($in)
        {
        }
        /**
         * Setup the key (expansion)
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::_setupKey()
         */
        protected function setupKey()
        {
        }
    }
}
namespace phpseclib3\Crypt\RSA\Formats\Keys {
    /**
     * JWK Formatted RSA Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class JWK extends \phpseclib3\Crypt\Common\Formats\Keys\JWK
    {
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $n
         * @param BigInteger $e
         * @param BigInteger $d
         * @param array $primes
         * @param array $exponents
         * @param array $coefficients
         * @param string $password optional
         * @param array $options optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $n, \phpseclib3\Math\BigInteger $e, \phpseclib3\Math\BigInteger $d, array $primes, array $exponents, array $coefficients, $password = '', array $options = [])
        {
        }
        /**
         * Convert a public key to the appropriate format
         *
         * @param BigInteger $n
         * @param BigInteger $e
         * @param array $options optional
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Math\BigInteger $n, \phpseclib3\Math\BigInteger $e, array $options = [])
        {
        }
    }
    /**
     * Microsoft BLOB Formatted RSA Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class MSBLOB
    {
        /**
         * Public/Private Key Pair
         *
         */
        const PRIVATEKEYBLOB = 0x7;
        /**
         * Public Key
         *
         */
        const PUBLICKEYBLOB = 0x6;
        /**
         * Public Key
         *
         */
        const PUBLICKEYBLOBEX = 0xa;
        /**
         * RSA public key exchange algorithm
         *
         */
        const CALG_RSA_KEYX = 0xa400;
        /**
         * RSA public key exchange algorithm
         *
         */
        const CALG_RSA_SIGN = 0x2400;
        /**
         * Public Key
         *
         */
        const RSA1 = 0x31415352;
        /**
         * Private Key
         *
         */
        const RSA2 = 0x32415352;
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $n
         * @param BigInteger $e
         * @param BigInteger $d
         * @param array $primes
         * @param array $exponents
         * @param array $coefficients
         * @param string $password optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $n, \phpseclib3\Math\BigInteger $e, \phpseclib3\Math\BigInteger $d, array $primes, array $exponents, array $coefficients, $password = '')
        {
        }
        /**
         * Convert a public key to the appropriate format
         *
         * @param BigInteger $n
         * @param BigInteger $e
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Math\BigInteger $n, \phpseclib3\Math\BigInteger $e)
        {
        }
    }
    /**
     * OpenSSH Formatted RSA Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class OpenSSH extends \phpseclib3\Crypt\Common\Formats\Keys\OpenSSH
    {
        /**
         * Supported Key Types
         *
         * @var array
         */
        protected static $types = ['ssh-rsa'];
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert a public key to the appropriate format
         *
         * @param BigInteger $n
         * @param BigInteger $e
         * @param array $options optional
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Math\BigInteger $n, \phpseclib3\Math\BigInteger $e, array $options = [])
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $n
         * @param BigInteger $e
         * @param BigInteger $d
         * @param array $primes
         * @param array $exponents
         * @param array $coefficients
         * @param string $password optional
         * @param array $options optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $n, \phpseclib3\Math\BigInteger $e, \phpseclib3\Math\BigInteger $d, array $primes, array $exponents, array $coefficients, $password = '', array $options = [])
        {
        }
    }
    /**
     * PKCS#1 Formatted RSA Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PKCS1 extends \phpseclib3\Crypt\Common\Formats\Keys\PKCS1
    {
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $n
         * @param BigInteger $e
         * @param BigInteger $d
         * @param array $primes
         * @param array $exponents
         * @param array $coefficients
         * @param string $password optional
         * @param array $options optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $n, \phpseclib3\Math\BigInteger $e, \phpseclib3\Math\BigInteger $d, array $primes, array $exponents, array $coefficients, $password = '', array $options = [])
        {
        }
        /**
         * Convert a public key to the appropriate format
         *
         * @param BigInteger $n
         * @param BigInteger $e
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Math\BigInteger $n, \phpseclib3\Math\BigInteger $e)
        {
        }
    }
    /**
     * PKCS#8 Formatted RSA Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PKCS8 extends \phpseclib3\Crypt\Common\Formats\Keys\PKCS8
    {
        /**
         * OID Name
         *
         * @var string
         */
        const OID_NAME = 'rsaEncryption';
        /**
         * OID Value
         *
         * @var string
         */
        const OID_VALUE = '1.2.840.113549.1.1.1';
        /**
         * Child OIDs loaded
         *
         * @var bool
         */
        protected static $childOIDsLoaded = false;
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $n
         * @param BigInteger $e
         * @param BigInteger $d
         * @param array $primes
         * @param array $exponents
         * @param array $coefficients
         * @param string $password optional
         * @param array $options optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $n, \phpseclib3\Math\BigInteger $e, \phpseclib3\Math\BigInteger $d, array $primes, array $exponents, array $coefficients, $password = '', array $options = [])
        {
        }
        /**
         * Convert a public key to the appropriate format
         *
         * @param BigInteger $n
         * @param BigInteger $e
         * @param array $options optional
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Math\BigInteger $n, \phpseclib3\Math\BigInteger $e, array $options = [])
        {
        }
    }
    /**
     * PKCS#8 Formatted RSA-PSS Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PSS extends \phpseclib3\Crypt\Common\Formats\Keys\PKCS8
    {
        /**
         * OID Name
         *
         * @var string
         */
        const OID_NAME = 'id-RSASSA-PSS';
        /**
         * OID Value
         *
         * @var string
         */
        const OID_VALUE = '1.2.840.113549.1.1.10';
        /**
         * Child OIDs loaded
         *
         * @var bool
         */
        protected static $childOIDsLoaded = false;
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $n
         * @param BigInteger $e
         * @param BigInteger $d
         * @param array $primes
         * @param array $exponents
         * @param array $coefficients
         * @param string $password optional
         * @param array $options optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $n, \phpseclib3\Math\BigInteger $e, \phpseclib3\Math\BigInteger $d, array $primes, array $exponents, array $coefficients, $password = '', array $options = [])
        {
        }
        /**
         * Convert a public key to the appropriate format
         *
         * @param BigInteger $n
         * @param BigInteger $e
         * @param array $options optional
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Math\BigInteger $n, \phpseclib3\Math\BigInteger $e, array $options = [])
        {
        }
        /**
         * Encodes PSS parameters
         *
         * @param array $options
         * @return string
         */
        public static function savePSSParams(array $options)
        {
        }
    }
    /**
     * PuTTY Formatted RSA Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PuTTY extends \phpseclib3\Crypt\Common\Formats\Keys\PuTTY
    {
        /**
         * Public Handler
         *
         * @var string
         */
        const PUBLIC_HANDLER = 'phpseclib3\Crypt\RSA\Formats\Keys\OpenSSH';
        /**
         * Algorithm Identifier
         *
         * @var array
         */
        protected static $types = ['ssh-rsa'];
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $n
         * @param BigInteger $e
         * @param BigInteger $d
         * @param array $primes
         * @param array $exponents
         * @param array $coefficients
         * @param string $password optional
         * @param array $options optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $n, \phpseclib3\Math\BigInteger $e, \phpseclib3\Math\BigInteger $d, array $primes, array $exponents, array $coefficients, $password = '', array $options = [])
        {
        }
        /**
         * Convert a public key to the appropriate format
         *
         * @param BigInteger $n
         * @param BigInteger $e
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Math\BigInteger $n, \phpseclib3\Math\BigInteger $e)
        {
        }
    }
    /**
     * Raw RSA Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Raw
    {
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $n
         * @param BigInteger $e
         * @param BigInteger $d
         * @param array $primes
         * @param array $exponents
         * @param array $coefficients
         * @param string $password optional
         * @param array $options optional
         * @return array
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $n, \phpseclib3\Math\BigInteger $e, \phpseclib3\Math\BigInteger $d, array $primes, array $exponents, array $coefficients, $password = '', array $options = [])
        {
        }
        /**
         * Convert a public key to the appropriate format
         *
         * @param BigInteger $n
         * @param BigInteger $e
         * @return array
         */
        public static function savePublicKey(\phpseclib3\Math\BigInteger $n, \phpseclib3\Math\BigInteger $e)
        {
        }
    }
    /**
     * XML Formatted RSA Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class XML
    {
        /**
         * Break a public or private key down into its constituent components
         *
         * @param string $key
         * @param string $password optional
         * @return array
         */
        public static function load($key, $password = '')
        {
        }
        /**
         * Convert a private key to the appropriate format.
         *
         * @param BigInteger $n
         * @param BigInteger $e
         * @param BigInteger $d
         * @param array $primes
         * @param array $exponents
         * @param array $coefficients
         * @param string $password optional
         * @return string
         */
        public static function savePrivateKey(\phpseclib3\Math\BigInteger $n, \phpseclib3\Math\BigInteger $e, \phpseclib3\Math\BigInteger $d, array $primes, array $exponents, array $coefficients, $password = '')
        {
        }
        /**
         * Convert a public key to the appropriate format
         *
         * @param BigInteger $n
         * @param BigInteger $e
         * @return string
         */
        public static function savePublicKey(\phpseclib3\Math\BigInteger $n, \phpseclib3\Math\BigInteger $e)
        {
        }
    }
}
namespace phpseclib3\Crypt {
    /**
     * Pure-PHP PKCS#1 compliant implementation of RSA.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class RSA extends \phpseclib3\Crypt\Common\AsymmetricKey
    {
        /**
         * Algorithm Name
         *
         * @var string
         */
        const ALGORITHM = 'RSA';
        /**
         * Use {@link http://en.wikipedia.org/wiki/Optimal_Asymmetric_Encryption_Padding Optimal Asymmetric Encryption Padding}
         * (OAEP) for encryption / decryption.
         *
         * Uses sha256 by default
         *
         * @see self::setHash()
         * @see self::setMGFHash()
         * @see self::encrypt()
         * @see self::decrypt()
         */
        const ENCRYPTION_OAEP = 1;
        /**
         * Use PKCS#1 padding.
         *
         * Although self::PADDING_OAEP / self::PADDING_PSS  offers more security, including PKCS#1 padding is necessary for purposes of backwards
         * compatibility with protocols (like SSH-1) written before OAEP's introduction.
         *
         * @see self::encrypt()
         * @see self::decrypt()
         */
        const ENCRYPTION_PKCS1 = 2;
        /**
         * Do not use any padding
         *
         * Although this method is not recommended it can none-the-less sometimes be useful if you're trying to decrypt some legacy
         * stuff, if you're trying to diagnose why an encrypted message isn't decrypting, etc.
         *
         * @see self::encrypt()
         * @see self::decrypt()
         */
        const ENCRYPTION_NONE = 4;
        /**
         * Use the Probabilistic Signature Scheme for signing
         *
         * Uses sha256 and 0 as the salt length
         *
         * @see self::setSaltLength()
         * @see self::setMGFHash()
         * @see self::setHash()
         * @see self::sign()
         * @see self::verify()
         * @see self::setHash()
         */
        const SIGNATURE_PSS = 16;
        /**
         * Use a relaxed version of PKCS#1 padding for signature verification
         *
         * @see self::sign()
         * @see self::verify()
         * @see self::setHash()
         */
        const SIGNATURE_RELAXED_PKCS1 = 32;
        /**
         * Use PKCS#1 padding for signature verification
         *
         * @see self::sign()
         * @see self::verify()
         * @see self::setHash()
         */
        const SIGNATURE_PKCS1 = 64;
        /**
         * Encryption padding mode
         *
         * @var int
         */
        protected $encryptionPadding = self::ENCRYPTION_OAEP;
        /**
         * Signature padding mode
         *
         * @var int
         */
        protected $signaturePadding = self::SIGNATURE_PSS;
        /**
         * Length of hash function output
         *
         * @var int
         */
        protected $hLen;
        /**
         * Length of salt
         *
         * @var int
         */
        protected $sLen;
        /**
         * Label
         *
         * @var string
         */
        protected $label = '';
        /**
         * Hash function for the Mask Generation Function
         *
         * @var Hash
         */
        protected $mgfHash;
        /**
         * Length of MGF hash function output
         *
         * @var int
         */
        protected $mgfHLen;
        /**
         * Modulus (ie. n)
         *
         * @var Math\BigInteger
         */
        protected $modulus;
        /**
         * Modulus length
         *
         * @var Math\BigInteger
         */
        protected $k;
        /**
         * Exponent (ie. e or d)
         *
         * @var Math\BigInteger
         */
        protected $exponent;
        /**
         * Enable Blinding?
         *
         * @var bool
         */
        protected static $enableBlinding = true;
        /**
         * OpenSSL configuration file name.
         *
         * @see self::createKey()
         * @var ?string
         */
        protected static $configFile;
        /**
         * Public Exponent
         *
         * @var Math\BigInteger
         */
        protected $publicExponent;
        /**
         * Sets the public exponent for key generation
         *
         * This will be 65537 unless changed.
         *
         * @param int $val
         */
        public static function setExponent($val)
        {
        }
        /**
         * Sets the smallest prime number in bits. Used for key generation
         *
         * This will be 4096 unless changed.
         *
         * @param int $val
         */
        public static function setSmallestPrime($val)
        {
        }
        /**
         * Sets the OpenSSL config file path
         *
         * Set to the empty string to use the default config file
         *
         * @param string $val
         */
        public static function setOpenSSLConfigPath($val)
        {
        }
        /**
         * Create a private key
         *
         * The public key can be extracted from the private key
         *
         * @return PrivateKey
         * @param int $bits
         */
        public static function createKey($bits = 2048)
        {
        }
        /**
         * OnLoad Handler
         *
         * @return bool
         */
        protected static function onLoad(array $components)
        {
        }
        /**
         * Initialize static variables
         */
        protected static function initialize_static_variables()
        {
        }
        /**
         * Constructor
         *
         * PublicKey and PrivateKey objects can only be created from abstract RSA class
         */
        protected function __construct()
        {
        }
        /**
         * Integer-to-Octet-String primitive
         *
         * See {@link http://tools.ietf.org/html/rfc3447#section-4.1 RFC3447#section-4.1}.
         *
         * @param bool|Math\BigInteger $x
         * @param int $xLen
         * @return bool|string
         */
        protected function i2osp($x, $xLen)
        {
        }
        /**
         * Octet-String-to-Integer primitive
         *
         * See {@link http://tools.ietf.org/html/rfc3447#section-4.2 RFC3447#section-4.2}.
         *
         * @param string $x
         * @return Math\BigInteger
         */
        protected function os2ip($x)
        {
        }
        /**
         * EMSA-PKCS1-V1_5-ENCODE
         *
         * See {@link http://tools.ietf.org/html/rfc3447#section-9.2 RFC3447#section-9.2}.
         *
         * @param string $m
         * @param int $emLen
         * @throws \LengthException if the intended encoded message length is too short
         * @return string
         */
        protected function emsa_pkcs1_v1_5_encode($m, $emLen)
        {
        }
        /**
         * EMSA-PKCS1-V1_5-ENCODE (without NULL)
         *
         * Quoting https://tools.ietf.org/html/rfc8017#page-65,
         *
         * "The parameters field associated with id-sha1, id-sha224, id-sha256,
         *  id-sha384, id-sha512, id-sha512/224, and id-sha512/256 should
         *  generally be omitted, but if present, it shall have a value of type
         *  NULL"
         *
         * @param string $m
         * @param int $emLen
         * @return string
         */
        protected function emsa_pkcs1_v1_5_encode_without_null($m, $emLen)
        {
        }
        /**
         * MGF1
         *
         * See {@link http://tools.ietf.org/html/rfc3447#appendix-B.2.1 RFC3447#appendix-B.2.1}.
         *
         * @param string $mgfSeed
         * @param int $maskLen
         * @return string
         */
        protected function mgf1($mgfSeed, $maskLen)
        {
        }
        /**
         * Returns the key size
         *
         * More specifically, this returns the size of the modulo in bits.
         *
         * @return int
         */
        public function getLength()
        {
        }
        /**
         * Determines which hashing function should be used
         *
         * Used with signature production / verification and (if the encryption mode is self::PADDING_OAEP) encryption and
         * decryption.
         *
         * @param string $hash
         */
        public function withHash($hash)
        {
        }
        /**
         * Determines which hashing function should be used for the mask generation function
         *
         * The mask generation function is used by self::PADDING_OAEP and self::PADDING_PSS and although it's
         * best if Hash and MGFHash are set to the same thing this is not a requirement.
         *
         * @param string $hash
         */
        public function withMGFHash($hash)
        {
        }
        /**
         * Returns the MGF hash algorithm currently being used
         *
         */
        public function getMGFHash()
        {
        }
        /**
         * Determines the salt length
         *
         * Used by RSA::PADDING_PSS
         *
         * To quote from {@link http://tools.ietf.org/html/rfc3447#page-38 RFC3447#page-38}:
         *
         *    Typical salt lengths in octets are hLen (the length of the output
         *    of the hash function Hash) and 0.
         *
         * @param int $sLen
         */
        public function withSaltLength($sLen)
        {
        }
        /**
         * Returns the salt length currently being used
         *
         */
        public function getSaltLength()
        {
        }
        /**
         * Determines the label
         *
         * Used by RSA::PADDING_OAEP
         *
         * To quote from {@link http://tools.ietf.org/html/rfc3447#page-17 RFC3447#page-17}:
         *
         *    Both the encryption and the decryption operations of RSAES-OAEP take
         *    the value of a label L as input.  In this version of PKCS #1, L is
         *    the empty string; other uses of the label are outside the scope of
         *    this document.
         *
         * @param string $label
         */
        public function withLabel($label)
        {
        }
        /**
         * Returns the label currently being used
         *
         */
        public function getLabel()
        {
        }
        /**
         * Determines the padding modes
         *
         * Example: $key->withPadding(RSA::ENCRYPTION_PKCS1 | RSA::SIGNATURE_PKCS1);
         *
         * @param int $padding
         */
        public function withPadding($padding)
        {
        }
        /**
         * Returns the padding currently being used
         *
         */
        public function getPadding()
        {
        }
        /**
         * Returns the current engine being used
         *
         * OpenSSL is only used in this class (and it's subclasses) for key generation
         * Even then it depends on the parameters you're using. It's not used for
         * multi-prime RSA nor is it used if the key length is outside of the range
         * supported by OpenSSL
         *
         * @see self::useInternalEngine()
         * @see self::useBestEngine()
         * @return string
         */
        public function getEngine()
        {
        }
        /**
         * Enable RSA Blinding
         *
         */
        public static function enableBlinding()
        {
        }
        /**
         * Disable RSA Blinding
         *
         */
        public static function disableBlinding()
        {
        }
    }
}
namespace phpseclib3\Crypt\RSA {
    /**
     * Raw RSA Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    final class PrivateKey extends \phpseclib3\Crypt\RSA implements \phpseclib3\Crypt\Common\PrivateKey
    {
        use \phpseclib3\Crypt\Common\Traits\PasswordProtected;
        /**
         * Create a signature
         *
         * @see self::verify()
         * @param string $message
         * @return string
         */
        public function sign($message)
        {
        }
        /**
         * Decryption
         *
         * @see self::encrypt()
         * @param string $ciphertext
         * @return bool|string
         */
        public function decrypt($ciphertext)
        {
        }
        /**
         * Returns the public key
         *
         * @return mixed
         */
        public function getPublicKey()
        {
        }
        /**
         * Returns the private key
         *
         * @param string $type
         * @param array $options optional
         * @return string
         */
        public function toString($type, array $options = [])
        {
        }
    }
    /**
     * Raw RSA Key Handler
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    final class PublicKey extends \phpseclib3\Crypt\RSA implements \phpseclib3\Crypt\Common\PublicKey
    {
        use \phpseclib3\Crypt\Common\Traits\Fingerprint;
        /**
         * Verifies a signature
         *
         * @see self::sign()
         * @param string $message
         * @param string $signature
         * @return bool
         */
        public function verify($message, $signature)
        {
        }
        /**
         * Encryption
         *
         * Both self::PADDING_OAEP and self::PADDING_PKCS1 both place limits on how long $plaintext can be.
         * If $plaintext exceeds those limits it will be broken up so that it does and the resultant ciphertext's will
         * be concatenated together.
         *
         * @see self::decrypt()
         * @param string $plaintext
         * @return bool|string
         * @throws \LengthException if the RSA modulus is too short
         */
        public function encrypt($plaintext)
        {
        }
        /**
         * Returns the public key
         *
         * The public key is only returned under two circumstances - if the private key had the public key embedded within it
         * or if the public key was set via setPublicKey().  If the currently loaded key is supposed to be the public key this
         * function won't return it since this library, for the most part, doesn't distinguish between public and private keys.
         *
         * @param string $type
         * @param array $options optional
         * @return mixed
         */
        public function toString($type, array $options = [])
        {
        }
        /**
         * Converts a public key to a private key
         *
         * @return RSA
         */
        public function asPrivateKey()
        {
        }
    }
}
namespace phpseclib3\Crypt {
    /**
     * Pure-PHP implementation of Triple DES.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class TripleDES extends \phpseclib3\Crypt\DES
    {
        /**
         * Encrypt / decrypt using inner chaining
         *
         * Inner chaining is used by SSH-1 and is generally considered to be less secure then outer chaining (self::MODE_CBC3).
         */
        const MODE_3CBC = -2;
        /**
         * Encrypt / decrypt using outer chaining
         *
         * Outer chaining is used by SSH-2 and when the mode is set to \phpseclib3\Crypt\Common\BlockCipher::MODE_CBC.
         */
        const MODE_CBC3 = self::MODE_CBC;
        /**
         * Key Length (in bytes)
         *
         * @see \phpseclib3\Crypt\TripleDES::setKeyLength()
         * @var int
         */
        protected $key_length = 24;
        /**
         * The mcrypt specific name of the cipher
         *
         * @see \phpseclib3\Crypt\DES::cipher_name_mcrypt
         * @see \phpseclib3\Crypt\Common\SymmetricKey::cipher_name_mcrypt
         * @var string
         */
        protected $cipher_name_mcrypt = 'tripledes';
        /**
         * Optimizing value while CFB-encrypting
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::cfb_init_len
         * @var int
         */
        protected $cfb_init_len = 750;
        /**
         * max possible size of $key
         *
         * @see self::setKey()
         * @see \phpseclib3\Crypt\DES::setKey()
         * @var string
         */
        protected $key_length_max = 24;
        /**
         * Default Constructor.
         *
         * Determines whether or not the mcrypt or OpenSSL extensions should be used.
         *
         * $mode could be:
         *
         * - ecb
         *
         * - cbc
         *
         * - ctr
         *
         * - cfb
         *
         * - ofb
         *
         * - 3cbc
         *
         * - cbc3 (same as cbc)
         *
         * @see \phpseclib3\Crypt\DES::__construct()
         * @see \phpseclib3\Crypt\Common\SymmetricKey::__construct()
         * @param string $mode
         */
        public function __construct($mode)
        {
        }
        /**
         * Test for engine validity
         *
         * This is mainly just a wrapper to set things up for \phpseclib3\Crypt\Common\SymmetricKey::isValidEngine()
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::__construct()
         * @param int $engine
         * @return bool
         */
        protected function isValidEngineHelper($engine)
        {
        }
        /**
         * Sets the initialization vector.
         *
         * SetIV is not required when \phpseclib3\Crypt\Common\SymmetricKey::MODE_ECB is being used.
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::setIV()
         * @param string $iv
         */
        public function setIV($iv)
        {
        }
        /**
         * Sets the key length.
         *
         * Valid key lengths are 128 and 192 bits.
         *
         * If you want to use a 64-bit key use DES.php
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey:setKeyLength()
         * @throws \LengthException if the key length is invalid
         * @param int $length
         */
        public function setKeyLength($length)
        {
        }
        /**
         * Sets the key.
         *
         * Triple DES can use 128-bit (eg. strlen($key) == 16) or 192-bit (eg. strlen($key) == 24) keys.
         *
         * DES also requires that every eighth bit be a parity bit, however, we'll ignore that.
         *
         * @see \phpseclib3\Crypt\DES::setKey()
         * @see \phpseclib3\Crypt\Common\SymmetricKey::setKey()
         * @throws \LengthException if the key length is invalid
         * @param string $key
         */
        public function setKey($key)
        {
        }
        /**
         * Encrypts a message.
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::encrypt()
         * @param string $plaintext
         * @return string $cipertext
         */
        public function encrypt($plaintext)
        {
        }
        /**
         * Decrypts a message.
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::decrypt()
         * @param string $ciphertext
         * @return string $plaintext
         */
        public function decrypt($ciphertext)
        {
        }
        /**
         * Treat consecutive "packets" as if they are a continuous buffer.
         *
         * Say you have a 16-byte plaintext $plaintext.  Using the default behavior, the two following code snippets
         * will yield different outputs:
         *
         * <code>
         *    echo $des->encrypt(substr($plaintext, 0, 8));
         *    echo $des->encrypt(substr($plaintext, 8, 8));
         * </code>
         * <code>
         *    echo $des->encrypt($plaintext);
         * </code>
         *
         * The solution is to enable the continuous buffer.  Although this will resolve the above discrepancy, it creates
         * another, as demonstrated with the following:
         *
         * <code>
         *    $des->encrypt(substr($plaintext, 0, 8));
         *    echo $des->decrypt($des->encrypt(substr($plaintext, 8, 8)));
         * </code>
         * <code>
         *    echo $des->decrypt($des->encrypt(substr($plaintext, 8, 8)));
         * </code>
         *
         * With the continuous buffer disabled, these would yield the same output.  With it enabled, they yield different
         * outputs.  The reason is due to the fact that the initialization vector's change after every encryption /
         * decryption round when the continuous buffer is enabled.  When it's disabled, they remain constant.
         *
         * Put another way, when the continuous buffer is enabled, the state of the \phpseclib3\Crypt\DES() object changes after each
         * encryption / decryption round, whereas otherwise, it'd remain constant.  For this reason, it's recommended that
         * continuous buffers not be used.  They do offer better security and are, in fact, sometimes required (SSH uses them),
         * however, they are also less intuitive and more likely to cause you problems.
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::enableContinuousBuffer()
         * @see self::disableContinuousBuffer()
         */
        public function enableContinuousBuffer()
        {
        }
        /**
         * Treat consecutive packets as if they are a discontinuous buffer.
         *
         * The default behavior.
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::disableContinuousBuffer()
         * @see self::enableContinuousBuffer()
         */
        public function disableContinuousBuffer()
        {
        }
        /**
         * Creates the key schedule
         *
         * @see \phpseclib3\Crypt\DES::setupKey()
         * @see \phpseclib3\Crypt\Common\SymmetricKey::setupKey()
         */
        protected function setupKey()
        {
        }
        /**
         * Sets the internal crypt engine
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::__construct()
         * @see \phpseclib3\Crypt\Common\SymmetricKey::setPreferredEngine()
         * @param int $engine
         */
        public function setPreferredEngine($engine)
        {
        }
    }
    /**
     * Pure-PHP implementation of Twofish.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     * @author  Hans-Juergen Petrich <petrich@tronic-media.com>
     */
    class Twofish extends \phpseclib3\Crypt\Common\BlockCipher
    {
        /**
         * The mcrypt specific name of the cipher
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::cipher_name_mcrypt
         * @var string
         */
        protected $cipher_name_mcrypt = 'twofish';
        /**
         * Optimizing value while CFB-encrypting
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::cfb_init_len
         * @var int
         */
        protected $cfb_init_len = 800;
        /**
         * The Key Length (in bytes)
         *
         * @see Crypt_Twofish::setKeyLength()
         * @var int
         */
        protected $key_length = 16;
        /**
         * Default Constructor.
         *
         * @param string $mode
         * @throws BadModeException if an invalid / unsupported mode is provided
         */
        public function __construct($mode)
        {
        }
        /**
         * Initialize Static Variables
         */
        protected static function initialize_static_variables()
        {
        }
        /**
         * Sets the key length.
         *
         * Valid key lengths are 128, 192 or 256 bits
         *
         * @param int $length
         */
        public function setKeyLength($length)
        {
        }
        /**
         * Sets the key.
         *
         * Rijndael supports five different key lengths
         *
         * @see setKeyLength()
         * @param string $key
         * @throws \LengthException if the key length isn't supported
         */
        public function setKey($key)
        {
        }
        /**
         * Setup the key (expansion)
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::_setupKey()
         */
        protected function setupKey()
        {
        }
        /**
         * Encrypts a block
         *
         * @param string $in
         * @return string
         */
        protected function encryptBlock($in)
        {
        }
        /**
         * Decrypts a block
         *
         * @param string $in
         * @return string
         */
        protected function decryptBlock($in)
        {
        }
        /**
         * Setup the performance-optimized function for de/encrypt()
         *
         * @see \phpseclib3\Crypt\Common\SymmetricKey::_setupInlineCrypt()
         */
        protected function setupInlineCrypt()
        {
        }
    }
}
namespace phpseclib3\Exception {
    /**
     * BadConfigurationException
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class BadConfigurationException extends \RuntimeException
    {
    }
    /**
     * BadDecryptionException
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class BadDecryptionException extends \RuntimeException
    {
    }
    /**
     * BadModeException
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class BadModeException extends \RuntimeException
    {
    }
    /**
     * ConnectionClosedException
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class ConnectionClosedException extends \RuntimeException
    {
    }
    /**
     * FileNotFoundException
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class FileNotFoundException extends \RuntimeException
    {
    }
    /**
     * InconsistentSetupException
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class InconsistentSetupException extends \RuntimeException
    {
    }
    /**
     * InsufficientSetupException
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class InsufficientSetupException extends \RuntimeException
    {
    }
    /**
     * Indicates an absent or malformed packet length header
     */
    class InvalidPacketLengthException extends \phpseclib3\Exception\ConnectionClosedException
    {
    }
    /**
     * NoKeyLoadedException
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class NoKeyLoadedException extends \RuntimeException
    {
    }
    /**
     * NoSupportedAlgorithmsException
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class NoSupportedAlgorithmsException extends \RuntimeException
    {
    }
    /**
     * Indicates a timeout awaiting server response
     */
    class TimeoutException extends \RuntimeException
    {
    }
    /**
     * UnableToConnectException
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class UnableToConnectException extends \RuntimeException
    {
    }
    /**
     * UnsupportedAlgorithmException
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class UnsupportedAlgorithmException extends \RuntimeException
    {
    }
    /**
     * UnsupportedCurveException
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class UnsupportedCurveException extends \RuntimeException
    {
    }
    /**
     * UnsupportedFormatException
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class UnsupportedFormatException extends \RuntimeException
    {
    }
    /**
     * UnsupportedOperationException
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class UnsupportedOperationException extends \RuntimeException
    {
    }
}
namespace phpseclib3\File {
    /**
     * Pure-PHP ANSI Decoder
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class ANSI
    {
        /**
         * Default Constructor.
         *
         * @return ANSI
         */
        public function __construct()
        {
        }
        /**
         * Set terminal width and height
         *
         * Resets the screen as well
         *
         * @param int $x
         * @param int $y
         */
        public function setDimensions($x, $y)
        {
        }
        /**
         * Set the number of lines that should be logged past the terminal height
         *
         * @param int $history
         */
        public function setHistory($history)
        {
        }
        /**
         * Load a string
         *
         * @param string $source
         */
        public function loadString($source)
        {
        }
        /**
         * Appdend a string
         *
         * @param string $source
         */
        public function appendString($source)
        {
        }
        /**
         * Returns the current screen
         *
         * @return string
         */
        public function getScreen()
        {
        }
        /**
         * Returns the current screen and the x previous lines
         *
         * @return string
         */
        public function getHistory()
        {
        }
    }
}
namespace phpseclib3\File\ASN1 {
    /**
     * ASN.1 Raw Element
     *
     * An ASN.1 ANY mapping will return an ASN1\Element object. Use of this object
     * will also bypass the normal encoding rules in ASN1::encodeDER()
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class Element
    {
        /**
         * Raw element value
         *
         * @var string
         */
        public $element;
        /**
         * Constructor
         *
         * @param string $encoded
         * @return Element
         */
        public function __construct($encoded)
        {
        }
    }
}
namespace phpseclib3\File\ASN1\Maps {
    /**
     * AccessDescription
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class AccessDescription
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['accessMethod' => ['type' => \phpseclib3\File\ASN1::TYPE_OBJECT_IDENTIFIER], 'accessLocation' => \phpseclib3\File\ASN1\Maps\GeneralName::MAP]];
    }
    /**
     * AdministrationDomainName
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class AdministrationDomainName
    {
        const MAP = [
            'type' => \phpseclib3\File\ASN1::TYPE_CHOICE,
            // if class isn't present it's assumed to be \phpseclib3\File\ASN1::CLASS_UNIVERSAL or
            // (if constant is present) \phpseclib3\File\ASN1::CLASS_CONTEXT_SPECIFIC
            'class' => \phpseclib3\File\ASN1::CLASS_APPLICATION,
            'cast' => 2,
            'children' => ['numeric' => ['type' => \phpseclib3\File\ASN1::TYPE_NUMERIC_STRING], 'printable' => ['type' => \phpseclib3\File\ASN1::TYPE_PRINTABLE_STRING]],
        ];
    }
    /**
     * AlgorithmIdentifier
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class AlgorithmIdentifier
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['algorithm' => ['type' => \phpseclib3\File\ASN1::TYPE_OBJECT_IDENTIFIER], 'parameters' => ['type' => \phpseclib3\File\ASN1::TYPE_ANY, 'optional' => true]]];
    }
    /**
     * AnotherName
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class AnotherName
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['type-id' => ['type' => \phpseclib3\File\ASN1::TYPE_OBJECT_IDENTIFIER], 'value' => ['type' => \phpseclib3\File\ASN1::TYPE_ANY, 'constant' => 0, 'optional' => true, 'explicit' => true]]];
    }
    /**
     * Attribute
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Attribute
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['type' => \phpseclib3\File\ASN1\Maps\AttributeType::MAP, 'value' => ['type' => \phpseclib3\File\ASN1::TYPE_SET, 'min' => 1, 'max' => -1, 'children' => \phpseclib3\File\ASN1\Maps\AttributeValue::MAP]]];
    }
    /**
     * Attributes
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Attributes
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SET, 'min' => 1, 'max' => -1, 'children' => \phpseclib3\File\ASN1\Maps\Attribute::MAP];
    }
    /**
     * AttributeType
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class AttributeType
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_OBJECT_IDENTIFIER];
    }
    /**
     * AttributeTypeAndValue
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class AttributeTypeAndValue
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['type' => \phpseclib3\File\ASN1\Maps\AttributeType::MAP, 'value' => \phpseclib3\File\ASN1\Maps\AttributeValue::MAP]];
    }
    /**
     * AttributeValue
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class AttributeValue
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_ANY];
    }
    /**
     * AuthorityInfoAccessSyntax
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class AuthorityInfoAccessSyntax
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'min' => 1, 'max' => -1, 'children' => \phpseclib3\File\ASN1\Maps\AccessDescription::MAP];
    }
    /**
     * AuthorityKeyIdentifier
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class AuthorityKeyIdentifier
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['keyIdentifier' => ['constant' => 0, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\KeyIdentifier::MAP, 'authorityCertIssuer' => ['constant' => 1, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\GeneralNames::MAP, 'authorityCertSerialNumber' => ['constant' => 2, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\CertificateSerialNumber::MAP]];
    }
    /**
     * BaseDistance
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class BaseDistance
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER];
    }
    /**
     * BasicConstraints
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class BasicConstraints
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['cA' => ['type' => \phpseclib3\File\ASN1::TYPE_BOOLEAN, 'optional' => true, 'default' => false], 'pathLenConstraint' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER, 'optional' => true]]];
    }
    /**
     * BuiltInDomainDefinedAttribute
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class BuiltInDomainDefinedAttribute
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['type' => ['type' => \phpseclib3\File\ASN1::TYPE_PRINTABLE_STRING], 'value' => ['type' => \phpseclib3\File\ASN1::TYPE_PRINTABLE_STRING]]];
    }
    /**
     * BuiltInDomainDefinedAttributes
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class BuiltInDomainDefinedAttributes
    {
        const MAP = [
            'type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE,
            'min' => 1,
            'max' => 4,
            // ub-domain-defined-attributes
            'children' => \phpseclib3\File\ASN1\Maps\BuiltInDomainDefinedAttribute::MAP,
        ];
    }
    /**
     * BuiltInStandardAttributes
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class BuiltInStandardAttributes
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['country-name' => ['optional' => true] + \phpseclib3\File\ASN1\Maps\CountryName::MAP, 'administration-domain-name' => ['optional' => true] + \phpseclib3\File\ASN1\Maps\AdministrationDomainName::MAP, 'network-address' => ['constant' => 0, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\NetworkAddress::MAP, 'terminal-identifier' => ['constant' => 1, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\TerminalIdentifier::MAP, 'private-domain-name' => ['constant' => 2, 'optional' => true, 'explicit' => true] + \phpseclib3\File\ASN1\Maps\PrivateDomainName::MAP, 'organization-name' => ['constant' => 3, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\OrganizationName::MAP, 'numeric-user-identifier' => ['constant' => 4, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\NumericUserIdentifier::MAP, 'personal-name' => ['constant' => 5, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\PersonalName::MAP, 'organizational-unit-names' => ['constant' => 6, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\OrganizationalUnitNames::MAP]];
    }
    /**
     * Certificate
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Certificate
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['tbsCertificate' => \phpseclib3\File\ASN1\Maps\TBSCertificate::MAP, 'signatureAlgorithm' => \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP, 'signature' => ['type' => \phpseclib3\File\ASN1::TYPE_BIT_STRING]]];
    }
    /**
     * CertificateIssuer
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class CertificateIssuer
    {
        const MAP = \phpseclib3\File\ASN1\Maps\GeneralNames::MAP;
    }
    /**
     * CertificateList
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class CertificateList
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['tbsCertList' => \phpseclib3\File\ASN1\Maps\TBSCertList::MAP, 'signatureAlgorithm' => \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP, 'signature' => ['type' => \phpseclib3\File\ASN1::TYPE_BIT_STRING]]];
    }
    /**
     * CertificatePolicies
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class CertificatePolicies
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'min' => 1, 'max' => -1, 'children' => \phpseclib3\File\ASN1\Maps\PolicyInformation::MAP];
    }
    /**
     * CertificateSerialNumber
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class CertificateSerialNumber
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER];
    }
    /**
     * CertificationRequest
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class CertificationRequest
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['certificationRequestInfo' => \phpseclib3\File\ASN1\Maps\CertificationRequestInfo::MAP, 'signatureAlgorithm' => \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP, 'signature' => ['type' => \phpseclib3\File\ASN1::TYPE_BIT_STRING]]];
    }
    /**
     * CertificationRequestInfo
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class CertificationRequestInfo
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['version' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER, 'mapping' => ['v1']], 'subject' => \phpseclib3\File\ASN1\Maps\Name::MAP, 'subjectPKInfo' => \phpseclib3\File\ASN1\Maps\SubjectPublicKeyInfo::MAP, 'attributes' => ['constant' => 0, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\Attributes::MAP]];
    }
    /**
     * CertPolicyId
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class CertPolicyId
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_OBJECT_IDENTIFIER];
    }
    /**
     * Characteristic_two
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Characteristic_two
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => [
            'm' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER],
            // field size 2**m
            'basis' => ['type' => \phpseclib3\File\ASN1::TYPE_OBJECT_IDENTIFIER],
            'parameters' => ['type' => \phpseclib3\File\ASN1::TYPE_ANY, 'optional' => true],
        ]];
    }
    /**
     * CountryName
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class CountryName
    {
        const MAP = [
            'type' => \phpseclib3\File\ASN1::TYPE_CHOICE,
            // if class isn't present it's assumed to be \phpseclib3\File\ASN1::CLASS_UNIVERSAL or
            // (if constant is present) \phpseclib3\File\ASN1::CLASS_CONTEXT_SPECIFIC
            'class' => \phpseclib3\File\ASN1::CLASS_APPLICATION,
            'cast' => 1,
            'children' => ['x121-dcc-code' => ['type' => \phpseclib3\File\ASN1::TYPE_NUMERIC_STRING], 'iso-3166-alpha2-code' => ['type' => \phpseclib3\File\ASN1::TYPE_PRINTABLE_STRING]],
        ];
    }
    /**
     * CPSuri
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class CPSuri
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_IA5_STRING];
    }
    /**
     * CRLDistributionPoints
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class CRLDistributionPoints
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'min' => 1, 'max' => -1, 'children' => \phpseclib3\File\ASN1\Maps\DistributionPoint::MAP];
    }
    /**
     * CRLNumber
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class CRLNumber
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER];
    }
    /**
     * CRLReason
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class CRLReason
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_ENUMERATED, 'mapping' => [
            'unspecified',
            'keyCompromise',
            'cACompromise',
            'affiliationChanged',
            'superseded',
            'cessationOfOperation',
            'certificateHold',
            // Value 7 is not used.
            8 => 'removeFromCRL',
            'privilegeWithdrawn',
            'aACompromise',
        ]];
    }
    /**
     * Curve
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Curve
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['a' => \phpseclib3\File\ASN1\Maps\FieldElement::MAP, 'b' => \phpseclib3\File\ASN1\Maps\FieldElement::MAP, 'seed' => ['type' => \phpseclib3\File\ASN1::TYPE_BIT_STRING, 'optional' => true]]];
    }
    /**
     * DHParameter
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class DHParameter
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['prime' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER], 'base' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER], 'privateValueLength' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER, 'optional' => true]]];
    }
    /**
     * DigestInfo
     *
     * from https://tools.ietf.org/html/rfc2898#appendix-A.3
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class DigestInfo
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['digestAlgorithm' => \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP, 'digest' => ['type' => \phpseclib3\File\ASN1::TYPE_OCTET_STRING]]];
    }
    /**
     * DirectoryString
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class DirectoryString
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_CHOICE, 'children' => ['teletexString' => ['type' => \phpseclib3\File\ASN1::TYPE_TELETEX_STRING], 'printableString' => ['type' => \phpseclib3\File\ASN1::TYPE_PRINTABLE_STRING], 'universalString' => ['type' => \phpseclib3\File\ASN1::TYPE_UNIVERSAL_STRING], 'utf8String' => ['type' => \phpseclib3\File\ASN1::TYPE_UTF8_STRING], 'bmpString' => ['type' => \phpseclib3\File\ASN1::TYPE_BMP_STRING]]];
    }
    /**
     * DisplayText
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class DisplayText
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_CHOICE, 'children' => ['ia5String' => ['type' => \phpseclib3\File\ASN1::TYPE_IA5_STRING], 'visibleString' => ['type' => \phpseclib3\File\ASN1::TYPE_VISIBLE_STRING], 'bmpString' => ['type' => \phpseclib3\File\ASN1::TYPE_BMP_STRING], 'utf8String' => ['type' => \phpseclib3\File\ASN1::TYPE_UTF8_STRING]]];
    }
    /**
     * DistributionPoint
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class DistributionPoint
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['distributionPoint' => ['constant' => 0, 'optional' => true, 'explicit' => true] + \phpseclib3\File\ASN1\Maps\DistributionPointName::MAP, 'reasons' => ['constant' => 1, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\ReasonFlags::MAP, 'cRLIssuer' => ['constant' => 2, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\GeneralNames::MAP]];
    }
    /**
     * DistributionPointName
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class DistributionPointName
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_CHOICE, 'children' => ['fullName' => ['constant' => 0, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\GeneralNames::MAP, 'nameRelativeToCRLIssuer' => ['constant' => 1, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\RelativeDistinguishedName::MAP]];
    }
    /**
     * DSAParams
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class DSAParams
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['p' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER], 'q' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER], 'g' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER]]];
    }
    /**
     * DSAPrivateKey
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class DSAPrivateKey
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['version' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER], 'p' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER], 'q' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER], 'g' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER], 'y' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER], 'x' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER]]];
    }
    /**
     * DSAPublicKey
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class DSAPublicKey
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER];
    }
    /**
     * DssSigValue
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class DssSigValue
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['r' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER], 's' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER]]];
    }
    /**
     * EcdsaSigValue
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class EcdsaSigValue
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['r' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER], 's' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER]]];
    }
    /**
     * ECParameters
     *
     *  ECParameters ::= CHOICE {
     *    namedCurve         OBJECT IDENTIFIER
     *    -- implicitCurve   NULL
     *    -- specifiedCurve  SpecifiedECDomain
     *  }
     *    -- implicitCurve and specifiedCurve MUST NOT be used in PKIX.
     *    -- Details for SpecifiedECDomain can be found in [X9.62].
     *    -- Any future additions to this CHOICE should be coordinated
     *    -- with ANSI X9.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class ECParameters
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_CHOICE, 'children' => ['namedCurve' => ['type' => \phpseclib3\File\ASN1::TYPE_OBJECT_IDENTIFIER], 'implicitCurve' => ['type' => \phpseclib3\File\ASN1::TYPE_NULL], 'specifiedCurve' => \phpseclib3\File\ASN1\Maps\SpecifiedECDomain::MAP]];
    }
    /**
     * ECPoint
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class ECPoint
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_OCTET_STRING];
    }
    /**
     * ECPrivateKey
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class ECPrivateKey
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['version' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER, 'mapping' => [1 => 'ecPrivkeyVer1']], 'privateKey' => ['type' => \phpseclib3\File\ASN1::TYPE_OCTET_STRING], 'parameters' => ['constant' => 0, 'optional' => true, 'explicit' => true] + \phpseclib3\File\ASN1\Maps\ECParameters::MAP, 'publicKey' => ['type' => \phpseclib3\File\ASN1::TYPE_BIT_STRING, 'constant' => 1, 'optional' => true, 'explicit' => true]]];
    }
    /**
     * EDIPartyName
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class EDIPartyName
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => [
            'nameAssigner' => ['constant' => 0, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\DirectoryString::MAP,
            // partyName is technically required but \phpseclib3\File\ASN1 doesn't currently support non-optional constants and
            // setting it to optional gets the job done in any event.
            'partyName' => ['constant' => 1, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\DirectoryString::MAP,
        ]];
    }
    /**
     * EncryptedData
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class EncryptedData
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_OCTET_STRING];
    }
    /**
     * EncryptedPrivateKeyInfo
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class EncryptedPrivateKeyInfo
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['encryptionAlgorithm' => \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP, 'encryptedData' => \phpseclib3\File\ASN1\Maps\EncryptedData::MAP]];
    }
    /**
     * Extension
     *
     * A certificate using system MUST reject the certificate if it encounters
     * a critical extension it does not recognize; however, a non-critical
     * extension may be ignored if it is not recognized.
     *
     * http://tools.ietf.org/html/rfc5280#section-4.2
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Extension
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['extnId' => ['type' => \phpseclib3\File\ASN1::TYPE_OBJECT_IDENTIFIER], 'critical' => ['type' => \phpseclib3\File\ASN1::TYPE_BOOLEAN, 'optional' => true, 'default' => false], 'extnValue' => ['type' => \phpseclib3\File\ASN1::TYPE_OCTET_STRING]]];
    }
    /**
     * ExtensionAttribute
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class ExtensionAttribute
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['extension-attribute-type' => ['type' => \phpseclib3\File\ASN1::TYPE_PRINTABLE_STRING, 'constant' => 0, 'optional' => true, 'implicit' => true], 'extension-attribute-value' => ['type' => \phpseclib3\File\ASN1::TYPE_ANY, 'constant' => 1, 'optional' => true, 'explicit' => true]]];
    }
    /**
     * ExtensionAttributes
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class ExtensionAttributes
    {
        const MAP = [
            'type' => \phpseclib3\File\ASN1::TYPE_SET,
            'min' => 1,
            'max' => 256,
            // ub-extension-attributes
            'children' => \phpseclib3\File\ASN1\Maps\ExtensionAttribute::MAP,
        ];
    }
    /**
     * Extensions
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Extensions
    {
        const MAP = [
            'type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE,
            'min' => 1,
            // technically, it's MAX, but we'll assume anything < 0 is MAX
            'max' => -1,
            // if 'children' isn't an array then 'min' and 'max' must be defined
            'children' => \phpseclib3\File\ASN1\Maps\Extension::MAP,
        ];
    }
    /**
     * ExtKeyUsageSyntax
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class ExtKeyUsageSyntax
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'min' => 1, 'max' => -1, 'children' => \phpseclib3\File\ASN1\Maps\KeyPurposeId::MAP];
    }
    /**
     * FieldElement
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class FieldElement
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_OCTET_STRING];
    }
    /**
     * FieldID
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class FieldID
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['fieldType' => ['type' => \phpseclib3\File\ASN1::TYPE_OBJECT_IDENTIFIER], 'parameters' => ['type' => \phpseclib3\File\ASN1::TYPE_ANY, 'optional' => true]]];
    }
    /**
     * GeneralName
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class GeneralName
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_CHOICE, 'children' => ['otherName' => ['constant' => 0, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\AnotherName::MAP, 'rfc822Name' => ['type' => \phpseclib3\File\ASN1::TYPE_IA5_STRING, 'constant' => 1, 'optional' => true, 'implicit' => true], 'dNSName' => ['type' => \phpseclib3\File\ASN1::TYPE_IA5_STRING, 'constant' => 2, 'optional' => true, 'implicit' => true], 'x400Address' => ['constant' => 3, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\ORAddress::MAP, 'directoryName' => ['constant' => 4, 'optional' => true, 'explicit' => true] + \phpseclib3\File\ASN1\Maps\Name::MAP, 'ediPartyName' => ['constant' => 5, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\EDIPartyName::MAP, 'uniformResourceIdentifier' => ['type' => \phpseclib3\File\ASN1::TYPE_IA5_STRING, 'constant' => 6, 'optional' => true, 'implicit' => true], 'iPAddress' => ['type' => \phpseclib3\File\ASN1::TYPE_OCTET_STRING, 'constant' => 7, 'optional' => true, 'implicit' => true], 'registeredID' => ['type' => \phpseclib3\File\ASN1::TYPE_OBJECT_IDENTIFIER, 'constant' => 8, 'optional' => true, 'implicit' => true]]];
    }
    /**
     * GeneralNames
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class GeneralNames
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'min' => 1, 'max' => -1, 'children' => \phpseclib3\File\ASN1\Maps\GeneralName::MAP];
    }
    /**
     * GeneralSubtree
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class GeneralSubtree
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['base' => \phpseclib3\File\ASN1\Maps\GeneralName::MAP, 'minimum' => ['constant' => 0, 'optional' => true, 'implicit' => true, 'default' => '0'] + \phpseclib3\File\ASN1\Maps\BaseDistance::MAP, 'maximum' => ['constant' => 1, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\BaseDistance::MAP]];
    }
    /**
     * GeneralSubtrees
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class GeneralSubtrees
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'min' => 1, 'max' => -1, 'children' => \phpseclib3\File\ASN1\Maps\GeneralSubtree::MAP];
    }
    /**
     * HashAglorithm
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class HashAlgorithm
    {
        const MAP = \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP;
    }
    /**
     * HoldInstructionCode
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class HoldInstructionCode
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_OBJECT_IDENTIFIER];
    }
    /**
     * InvalidityDate
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class InvalidityDate
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_GENERALIZED_TIME];
    }
    /**
     * IssuerAltName
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class IssuerAltName
    {
        const MAP = \phpseclib3\File\ASN1\Maps\GeneralNames::MAP;
    }
    /**
     * IssuingDistributionPoint
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class IssuingDistributionPoint
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['distributionPoint' => ['constant' => 0, 'optional' => true, 'explicit' => true] + \phpseclib3\File\ASN1\Maps\DistributionPointName::MAP, 'onlyContainsUserCerts' => ['type' => \phpseclib3\File\ASN1::TYPE_BOOLEAN, 'constant' => 1, 'optional' => true, 'default' => false, 'implicit' => true], 'onlyContainsCACerts' => ['type' => \phpseclib3\File\ASN1::TYPE_BOOLEAN, 'constant' => 2, 'optional' => true, 'default' => false, 'implicit' => true], 'onlySomeReasons' => ['constant' => 3, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\ReasonFlags::MAP, 'indirectCRL' => ['type' => \phpseclib3\File\ASN1::TYPE_BOOLEAN, 'constant' => 4, 'optional' => true, 'default' => false, 'implicit' => true], 'onlyContainsAttributeCerts' => ['type' => \phpseclib3\File\ASN1::TYPE_BOOLEAN, 'constant' => 5, 'optional' => true, 'default' => false, 'implicit' => true]]];
    }
    /**
     * KeyIdentifier
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class KeyIdentifier
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_OCTET_STRING];
    }
    /**
     * KeyPurposeId
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class KeyPurposeId
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_OBJECT_IDENTIFIER];
    }
    /**
     * KeyUsage
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class KeyUsage
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_BIT_STRING, 'mapping' => ['digitalSignature', 'nonRepudiation', 'keyEncipherment', 'dataEncipherment', 'keyAgreement', 'keyCertSign', 'cRLSign', 'encipherOnly', 'decipherOnly']];
    }
    /**
     * MaskGenAglorithm
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class MaskGenAlgorithm
    {
        const MAP = \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP;
    }
    /**
     * Name
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Name
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_CHOICE, 'children' => ['rdnSequence' => \phpseclib3\File\ASN1\Maps\RDNSequence::MAP]];
    }
    /**
     * NameConstraints
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class NameConstraints
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['permittedSubtrees' => ['constant' => 0, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\GeneralSubtrees::MAP, 'excludedSubtrees' => ['constant' => 1, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\GeneralSubtrees::MAP]];
    }
    /**
     * netscape_ca_policy_url
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class netscape_ca_policy_url
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_IA5_STRING];
    }
    /**
     * netscape_cert_type
     *
     * mapping is from <http://www.mozilla.org/projects/security/pki/nss/tech-notes/tn3.html>
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class netscape_cert_type
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_BIT_STRING, 'mapping' => ['SSLClient', 'SSLServer', 'Email', 'ObjectSigning', 'Reserved', 'SSLCA', 'EmailCA', 'ObjectSigningCA']];
    }
    /**
     * netscape_comment
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class netscape_comment
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_IA5_STRING];
    }
    /**
     * NetworkAddress
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class NetworkAddress
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_NUMERIC_STRING];
    }
    /**
     * NoticeReference
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class NoticeReference
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['organization' => \phpseclib3\File\ASN1\Maps\DisplayText::MAP, 'noticeNumbers' => ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'min' => 1, 'max' => 200, 'children' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER]]]];
    }
    /**
     * NumericUserIdentifier
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class NumericUserIdentifier
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_NUMERIC_STRING];
    }
    /**
     * OneAsymmetricKey
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class OneAsymmetricKey
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['version' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER, 'mapping' => ['v1', 'v2']], 'privateKeyAlgorithm' => \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP, 'privateKey' => \phpseclib3\File\ASN1\Maps\PrivateKey::MAP, 'attributes' => ['constant' => 0, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\Attributes::MAP, 'publicKey' => ['constant' => 1, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\PublicKey::MAP]];
    }
    /**
     * ORAddress
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class ORAddress
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['built-in-standard-attributes' => \phpseclib3\File\ASN1\Maps\BuiltInStandardAttributes::MAP, 'built-in-domain-defined-attributes' => ['optional' => true] + \phpseclib3\File\ASN1\Maps\BuiltInDomainDefinedAttributes::MAP, 'extension-attributes' => ['optional' => true] + \phpseclib3\File\ASN1\Maps\ExtensionAttributes::MAP]];
    }
    /**
     * OrganizationalUnitNames
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class OrganizationalUnitNames
    {
        const MAP = [
            'type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE,
            'min' => 1,
            'max' => 4,
            // ub-organizational-units
            'children' => ['type' => \phpseclib3\File\ASN1::TYPE_PRINTABLE_STRING],
        ];
    }
    /**
     * OrganizationName
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class OrganizationName
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_PRINTABLE_STRING];
    }
    /**
     * OtherPrimeInfo
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class OtherPrimeInfo
    {
        // version must be multi if otherPrimeInfos present
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => [
            'prime' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER],
            // ri
            'exponent' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER],
            // di
            'coefficient' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER],
        ]];
    }
    /**
     * OtherPrimeInfos
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class OtherPrimeInfos
    {
        // version must be multi if otherPrimeInfos present
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'min' => 1, 'max' => -1, 'children' => \phpseclib3\File\ASN1\Maps\OtherPrimeInfo::MAP];
    }
    /**
     * PBEParameter
     *
     * from https://tools.ietf.org/html/rfc2898#appendix-A.3
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PBEParameter
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['salt' => ['type' => \phpseclib3\File\ASN1::TYPE_OCTET_STRING], 'iterationCount' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER]]];
    }
    /**
     * PBES2params
     *
     * from https://tools.ietf.org/html/rfc2898#appendix-A.3
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PBES2params
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['keyDerivationFunc' => \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP, 'encryptionScheme' => \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP]];
    }
    /**
     * PBKDF2params
     *
     * from https://tools.ietf.org/html/rfc2898#appendix-A.3
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PBKDF2params
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => [
            // technically, this is a CHOICE in RFC2898 but the other "choice" is, currently, more of a placeholder
            // in the RFC
            'salt' => ['type' => \phpseclib3\File\ASN1::TYPE_OCTET_STRING],
            'iterationCount' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER],
            'keyLength' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER, 'optional' => true],
            'prf' => \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP + ['optional' => true],
        ]];
    }
    /**
     * PBMAC1params
     *
     * from https://tools.ietf.org/html/rfc2898#appendix-A.3
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PBMAC1params
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['keyDerivationFunc' => \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP, 'messageAuthScheme' => \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP]];
    }
    /**
     * Pentanomial
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Pentanomial
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => [
            'k1' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER],
            // k1 > 0
            'k2' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER],
            // k2 > k1
            'k3' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER],
        ]];
    }
    /**
     * PersonalName
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PersonalName
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SET, 'children' => ['surname' => ['type' => \phpseclib3\File\ASN1::TYPE_PRINTABLE_STRING, 'constant' => 0, 'optional' => true, 'implicit' => true], 'given-name' => ['type' => \phpseclib3\File\ASN1::TYPE_PRINTABLE_STRING, 'constant' => 1, 'optional' => true, 'implicit' => true], 'initials' => ['type' => \phpseclib3\File\ASN1::TYPE_PRINTABLE_STRING, 'constant' => 2, 'optional' => true, 'implicit' => true], 'generation-qualifier' => ['type' => \phpseclib3\File\ASN1::TYPE_PRINTABLE_STRING, 'constant' => 3, 'optional' => true, 'implicit' => true]]];
    }
    /**
     * PKCS9String
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PKCS9String
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_CHOICE, 'children' => ['ia5String' => ['type' => \phpseclib3\File\ASN1::TYPE_IA5_STRING], 'directoryString' => \phpseclib3\File\ASN1\Maps\DirectoryString::MAP]];
    }
    /**
     * PolicyInformation
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PolicyInformation
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['policyIdentifier' => \phpseclib3\File\ASN1\Maps\CertPolicyId::MAP, 'policyQualifiers' => ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'min' => 0, 'max' => -1, 'optional' => true, 'children' => \phpseclib3\File\ASN1\Maps\PolicyQualifierInfo::MAP]]];
    }
    /**
     * PolicyMappings
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PolicyMappings
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'min' => 1, 'max' => -1, 'children' => ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['issuerDomainPolicy' => \phpseclib3\File\ASN1\Maps\CertPolicyId::MAP, 'subjectDomainPolicy' => \phpseclib3\File\ASN1\Maps\CertPolicyId::MAP]]];
    }
    /**
     * PolicyQualifierId
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PolicyQualifierId
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_OBJECT_IDENTIFIER];
    }
    /**
     * PolicyQualifierInfo
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PolicyQualifierInfo
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['policyQualifierId' => \phpseclib3\File\ASN1\Maps\PolicyQualifierId::MAP, 'qualifier' => ['type' => \phpseclib3\File\ASN1::TYPE_ANY]]];
    }
    /**
     * PostalAddress
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PostalAddress
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'optional' => true, 'min' => 1, 'max' => -1, 'children' => \phpseclib3\File\ASN1\Maps\DirectoryString::MAP];
    }
    /**
     * Prime_p
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Prime_p
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER];
    }
    /**
     * PrivateDomainName
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PrivateDomainName
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_CHOICE, 'children' => ['numeric' => ['type' => \phpseclib3\File\ASN1::TYPE_NUMERIC_STRING], 'printable' => ['type' => \phpseclib3\File\ASN1::TYPE_PRINTABLE_STRING]]];
    }
    /**
     * PrivateKey
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PrivateKey
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_OCTET_STRING];
    }
    /**
     * PrivateKeyInfo
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PrivateKeyInfo
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['version' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER, 'mapping' => ['v1']], 'privateKeyAlgorithm' => \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP, 'privateKey' => \phpseclib3\File\ASN1\Maps\PrivateKey::MAP, 'attributes' => ['constant' => 0, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\Attributes::MAP]];
    }
    /**
     * PrivateKeyUsagePeriod
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PrivateKeyUsagePeriod
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['notBefore' => ['constant' => 0, 'optional' => true, 'implicit' => true, 'type' => \phpseclib3\File\ASN1::TYPE_GENERALIZED_TIME], 'notAfter' => ['constant' => 1, 'optional' => true, 'implicit' => true, 'type' => \phpseclib3\File\ASN1::TYPE_GENERALIZED_TIME]]];
    }
    /**
     * PublicKey
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PublicKey
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_BIT_STRING];
    }
    /**
     * PublicKeyAndChallenge
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PublicKeyAndChallenge
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['spki' => \phpseclib3\File\ASN1\Maps\SubjectPublicKeyInfo::MAP, 'challenge' => ['type' => \phpseclib3\File\ASN1::TYPE_IA5_STRING]]];
    }
    /**
     * PublicKeyInfo
     *
     * this format is not formally defined anywhere but is none-the-less the form you
     * get when you do "openssl rsa -in private.pem -outform PEM -pubout"
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PublicKeyInfo
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['publicKeyAlgorithm' => \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP, 'publicKey' => ['type' => \phpseclib3\File\ASN1::TYPE_BIT_STRING]]];
    }
    /**
     * RC2CBCParameter
     *
     * from https://tools.ietf.org/html/rfc2898#appendix-A.3
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class RC2CBCParameter
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['rc2ParametersVersion' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER, 'optional' => true], 'iv' => ['type' => \phpseclib3\File\ASN1::TYPE_OCTET_STRING]]];
    }
    /**
     * RDNSequence
     *
     * In practice, RDNs containing multiple name-value pairs (called "multivalued RDNs") are rare,
     * but they can be useful at times when either there is no unique attribute in the entry or you
     * want to ensure that the entry's DN contains some useful identifying information.
     *
     * - https://www.opends.org/wiki/page/DefinitionRelativeDistinguishedName
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class RDNSequence
    {
        const MAP = [
            'type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE,
            // RDNSequence does not define a min or a max, which means it doesn't have one
            'min' => 0,
            'max' => -1,
            'children' => \phpseclib3\File\ASN1\Maps\RelativeDistinguishedName::MAP,
        ];
    }
    /**
     * ReasonFlags
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class ReasonFlags
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_BIT_STRING, 'mapping' => ['unused', 'keyCompromise', 'cACompromise', 'affiliationChanged', 'superseded', 'cessationOfOperation', 'certificateHold', 'privilegeWithdrawn', 'aACompromise']];
    }
    /**
     * RelativeDistinguishedName
     *
     * In practice, RDNs containing multiple name-value pairs (called "multivalued RDNs") are rare,
     * but they can be useful at times when either there is no unique attribute in the entry or you
     * want to ensure that the entry's DN contains some useful identifying information.
     *
     * - https://www.opends.org/wiki/page/DefinitionRelativeDistinguishedName
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class RelativeDistinguishedName
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SET, 'min' => 1, 'max' => -1, 'children' => \phpseclib3\File\ASN1\Maps\AttributeTypeAndValue::MAP];
    }
    /**
     * RevokedCertificate
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class RevokedCertificate
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['userCertificate' => \phpseclib3\File\ASN1\Maps\CertificateSerialNumber::MAP, 'revocationDate' => \phpseclib3\File\ASN1\Maps\Time::MAP, 'crlEntryExtensions' => ['optional' => true] + \phpseclib3\File\ASN1\Maps\Extensions::MAP]];
    }
    /**
     * RSAPrivateKey
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class RSAPrivateKey
    {
        // version must be multi if otherPrimeInfos present
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => [
            'version' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER, 'mapping' => ['two-prime', 'multi']],
            'modulus' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER],
            // n
            'publicExponent' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER],
            // e
            'privateExponent' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER],
            // d
            'prime1' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER],
            // p
            'prime2' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER],
            // q
            'exponent1' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER],
            // d mod (p-1)
            'exponent2' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER],
            // d mod (q-1)
            'coefficient' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER],
            // (inverse of q) mod p
            'otherPrimeInfos' => \phpseclib3\File\ASN1\Maps\OtherPrimeInfos::MAP + ['optional' => true],
        ]];
    }
    /**
     * RSAPublicKey
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class RSAPublicKey
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['modulus' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER], 'publicExponent' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER]]];
    }
    /**
     * RSASSA_PSS_params
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class RSASSA_PSS_params
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['hashAlgorithm' => ['constant' => 0, 'optional' => true, 'explicit' => true] + \phpseclib3\File\ASN1\Maps\HashAlgorithm::MAP, 'maskGenAlgorithm' => ['constant' => 1, 'optional' => true, 'explicit' => true] + \phpseclib3\File\ASN1\Maps\MaskGenAlgorithm::MAP, 'saltLength' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER, 'constant' => 2, 'optional' => true, 'explicit' => true, 'default' => 20], 'trailerField' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER, 'constant' => 3, 'optional' => true, 'explicit' => true, 'default' => 1]]];
    }
    /**
     * SignedPublicKeyAndChallenge
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class SignedPublicKeyAndChallenge
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['publicKeyAndChallenge' => \phpseclib3\File\ASN1\Maps\PublicKeyAndChallenge::MAP, 'signatureAlgorithm' => \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP, 'signature' => ['type' => \phpseclib3\File\ASN1::TYPE_BIT_STRING]]];
    }
    /**
     * SpecifiedECDomain
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class SpecifiedECDomain
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['version' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER, 'mapping' => [1 => 'ecdpVer1', 'ecdpVer2', 'ecdpVer3']], 'fieldID' => \phpseclib3\File\ASN1\Maps\FieldID::MAP, 'curve' => \phpseclib3\File\ASN1\Maps\Curve::MAP, 'base' => \phpseclib3\File\ASN1\Maps\ECPoint::MAP, 'order' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER], 'cofactor' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER, 'optional' => true], 'hash' => ['optional' => true] + \phpseclib3\File\ASN1\Maps\HashAlgorithm::MAP]];
    }
    /**
     * SubjectAltName
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class SubjectAltName
    {
        const MAP = \phpseclib3\File\ASN1\Maps\GeneralNames::MAP;
    }
    /**
     * SubjectDirectoryAttributes
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class SubjectDirectoryAttributes
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'min' => 1, 'max' => -1, 'children' => \phpseclib3\File\ASN1\Maps\Attribute::MAP];
    }
    /**
     * SubjectInfoAccessSyntax
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class SubjectInfoAccessSyntax
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'min' => 1, 'max' => -1, 'children' => \phpseclib3\File\ASN1\Maps\AccessDescription::MAP];
    }
    /**
     * SubjectPublicKeyInfo
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class SubjectPublicKeyInfo
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['algorithm' => \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP, 'subjectPublicKey' => ['type' => \phpseclib3\File\ASN1::TYPE_BIT_STRING]]];
    }
    /**
     * TBSCertificate
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class TBSCertificate
    {
        // assert($TBSCertificate['children']['signature'] == $Certificate['children']['signatureAlgorithm'])
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => [
            // technically, default implies optional, but we'll define it as being optional, none-the-less, just to
            // reenforce that fact
            'version' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER, 'constant' => 0, 'optional' => true, 'explicit' => true, 'mapping' => ['v1', 'v2', 'v3'], 'default' => 'v1'],
            'serialNumber' => \phpseclib3\File\ASN1\Maps\CertificateSerialNumber::MAP,
            'signature' => \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP,
            'issuer' => \phpseclib3\File\ASN1\Maps\Name::MAP,
            'validity' => \phpseclib3\File\ASN1\Maps\Validity::MAP,
            'subject' => \phpseclib3\File\ASN1\Maps\Name::MAP,
            'subjectPublicKeyInfo' => \phpseclib3\File\ASN1\Maps\SubjectPublicKeyInfo::MAP,
            // implicit means that the T in the TLV structure is to be rewritten, regardless of the type
            'issuerUniqueID' => ['constant' => 1, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\UniqueIdentifier::MAP,
            'subjectUniqueID' => ['constant' => 2, 'optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\UniqueIdentifier::MAP,
            // <http://tools.ietf.org/html/rfc2459#page-74> doesn't use the EXPLICIT keyword but if
            // it's not IMPLICIT, it's EXPLICIT
            'extensions' => ['constant' => 3, 'optional' => true, 'explicit' => true] + \phpseclib3\File\ASN1\Maps\Extensions::MAP,
        ]];
    }
    /**
     * TBSCertList
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class TBSCertList
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['version' => ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER, 'mapping' => ['v1', 'v2'], 'optional' => true, 'default' => 'v1'], 'signature' => \phpseclib3\File\ASN1\Maps\AlgorithmIdentifier::MAP, 'issuer' => \phpseclib3\File\ASN1\Maps\Name::MAP, 'thisUpdate' => \phpseclib3\File\ASN1\Maps\Time::MAP, 'nextUpdate' => ['optional' => true] + \phpseclib3\File\ASN1\Maps\Time::MAP, 'revokedCertificates' => ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'optional' => true, 'min' => 0, 'max' => -1, 'children' => \phpseclib3\File\ASN1\Maps\RevokedCertificate::MAP], 'crlExtensions' => ['constant' => 0, 'optional' => true, 'explicit' => true] + \phpseclib3\File\ASN1\Maps\Extensions::MAP]];
    }
    /**
     * TerminalIdentifier
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class TerminalIdentifier
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_PRINTABLE_STRING];
    }
    /**
     * Time
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Time
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_CHOICE, 'children' => ['utcTime' => ['type' => \phpseclib3\File\ASN1::TYPE_UTC_TIME], 'generalTime' => ['type' => \phpseclib3\File\ASN1::TYPE_GENERALIZED_TIME]]];
    }
    /**
     * Trinomial
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Trinomial
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_INTEGER];
    }
    /**
     * UniqueIdentifier
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class UniqueIdentifier
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_BIT_STRING];
    }
    /**
     * UserNotice
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class UserNotice
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['noticeRef' => ['optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\NoticeReference::MAP, 'explicitText' => ['optional' => true, 'implicit' => true] + \phpseclib3\File\ASN1\Maps\DisplayText::MAP]];
    }
    /**
     * Validity
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Validity
    {
        const MAP = ['type' => \phpseclib3\File\ASN1::TYPE_SEQUENCE, 'children' => ['notBefore' => \phpseclib3\File\ASN1\Maps\Time::MAP, 'notAfter' => \phpseclib3\File\ASN1\Maps\Time::MAP]];
    }
}
namespace phpseclib3\File {
    /**
     * Pure-PHP ASN.1 Parser
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class ASN1
    {
        // Tag Classes
        // http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf#page=12
        const CLASS_UNIVERSAL = 0;
        const CLASS_APPLICATION = 1;
        const CLASS_CONTEXT_SPECIFIC = 2;
        const CLASS_PRIVATE = 3;
        // Tag Classes
        // http://www.obj-sys.com/asn1tutorial/node124.html
        const TYPE_BOOLEAN = 1;
        const TYPE_INTEGER = 2;
        const TYPE_BIT_STRING = 3;
        const TYPE_OCTET_STRING = 4;
        const TYPE_NULL = 5;
        const TYPE_OBJECT_IDENTIFIER = 6;
        //const TYPE_OBJECT_DESCRIPTOR = 7;
        //const TYPE_INSTANCE_OF       = 8; // EXTERNAL
        const TYPE_REAL = 9;
        const TYPE_ENUMERATED = 10;
        //const TYPE_EMBEDDED          = 11;
        const TYPE_UTF8_STRING = 12;
        //const TYPE_RELATIVE_OID      = 13;
        const TYPE_SEQUENCE = 16;
        // SEQUENCE OF
        const TYPE_SET = 17;
        // SET OF
        // More Tag Classes
        // http://www.obj-sys.com/asn1tutorial/node10.html
        const TYPE_NUMERIC_STRING = 18;
        const TYPE_PRINTABLE_STRING = 19;
        const TYPE_TELETEX_STRING = 20;
        // T61String
        const TYPE_VIDEOTEX_STRING = 21;
        const TYPE_IA5_STRING = 22;
        const TYPE_UTC_TIME = 23;
        const TYPE_GENERALIZED_TIME = 24;
        const TYPE_GRAPHIC_STRING = 25;
        const TYPE_VISIBLE_STRING = 26;
        // ISO646String
        const TYPE_GENERAL_STRING = 27;
        const TYPE_UNIVERSAL_STRING = 28;
        //const TYPE_CHARACTER_STRING = 29;
        const TYPE_BMP_STRING = 30;
        // Tag Aliases
        // These tags are kinda place holders for other tags.
        const TYPE_CHOICE = -1;
        const TYPE_ANY = -2;
        /**
         * Type mapping table for the ANY type.
         *
         * Structured or unknown types are mapped to a \phpseclib3\File\ASN1\Element.
         * Unambiguous types get the direct mapping (int/real/bool).
         * Others are mapped as a choice, with an extra indexing level.
         *
         * @var array
         */
        const ANY_MAP = [
            self::TYPE_BOOLEAN => true,
            self::TYPE_INTEGER => true,
            self::TYPE_BIT_STRING => 'bitString',
            self::TYPE_OCTET_STRING => 'octetString',
            self::TYPE_NULL => 'null',
            self::TYPE_OBJECT_IDENTIFIER => 'objectIdentifier',
            self::TYPE_REAL => true,
            self::TYPE_ENUMERATED => 'enumerated',
            self::TYPE_UTF8_STRING => 'utf8String',
            self::TYPE_NUMERIC_STRING => 'numericString',
            self::TYPE_PRINTABLE_STRING => 'printableString',
            self::TYPE_TELETEX_STRING => 'teletexString',
            self::TYPE_VIDEOTEX_STRING => 'videotexString',
            self::TYPE_IA5_STRING => 'ia5String',
            self::TYPE_UTC_TIME => 'utcTime',
            self::TYPE_GENERALIZED_TIME => 'generalTime',
            self::TYPE_GRAPHIC_STRING => 'graphicString',
            self::TYPE_VISIBLE_STRING => 'visibleString',
            self::TYPE_GENERAL_STRING => 'generalString',
            self::TYPE_UNIVERSAL_STRING => 'universalString',
            //self::TYPE_CHARACTER_STRING     => 'characterString',
            self::TYPE_BMP_STRING => 'bmpString',
        ];
        /**
         * String type to character size mapping table.
         *
         * Non-convertable types are absent from this table.
         * size == 0 indicates variable length encoding.
         *
         * @var array
         */
        const STRING_TYPE_SIZE = [self::TYPE_UTF8_STRING => 0, self::TYPE_BMP_STRING => 2, self::TYPE_UNIVERSAL_STRING => 4, self::TYPE_PRINTABLE_STRING => 1, self::TYPE_TELETEX_STRING => 1, self::TYPE_IA5_STRING => 1, self::TYPE_VISIBLE_STRING => 1];
        /**
         * Parse BER-encoding
         *
         * Serves a similar purpose to openssl's asn1parse
         *
         * @param Element|string $encoded
         * @return ?array
         */
        public static function decodeBER($encoded)
        {
        }
        /**
         * ASN.1 Map
         *
         * Provides an ASN.1 semantic mapping ($mapping) from a parsed BER-encoding to a human readable format.
         *
         * "Special" mappings may be applied on a per tag-name basis via $special.
         *
         * @param array $decoded
         * @param array $mapping
         * @param array $special
         * @return array|bool|Element|string|null
         */
        public static function asn1map(array $decoded, $mapping, $special = [])
        {
        }
        /**
         * DER-decode the length
         *
         * DER supports lengths up to (2**8)**127, however, we'll only support lengths up to (2**8)**4.  See
         * {@link http://itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf#p=13 X.690 paragraph 8.1.3} for more information.
         *
         * @param string $string
         * @return int
         */
        public static function decodeLength(&$string)
        {
        }
        /**
         * ASN.1 Encode
         *
         * DER-encodes an ASN.1 semantic mapping ($mapping).  Some libraries would probably call this function
         * an ASN.1 compiler.
         *
         * "Special" mappings can be applied via $special.
         *
         * @param Element|string|array $source
         * @param array $mapping
         * @param array $special
         * @return string
         */
        public static function encodeDER($source, $mapping, $special = [])
        {
        }
        /**
         * BER-decode the OID
         *
         * Called by _decode_ber()
         *
         * @param string $content
         * @return string
         */
        public static function decodeOID($content)
        {
        }
        /**
         * DER-encode the OID
         *
         * Called by _encode_der()
         *
         * @param string $source
         * @return string
         */
        public static function encodeOID($source)
        {
        }
        /**
         * Set the time format
         *
         * Sets the time / date format for asn1map().
         *
         * @param string $format
         */
        public static function setTimeFormat($format)
        {
        }
        /**
         * Load OIDs
         *
         * Load the relevant OIDs for a particular ASN.1 semantic mapping.
         * Previously loaded OIDs are retained.
         *
         * @param array $oids
         */
        public static function loadOIDs(array $oids)
        {
        }
        /**
         * Set filters
         *
         * See \phpseclib3\File\X509, etc, for an example.
         * Previously loaded filters are not retained.
         *
         * @param array $filters
         */
        public static function setFilters(array $filters)
        {
        }
        /**
         * String type conversion
         *
         * This is a lazy conversion, dealing only with character size.
         * No real conversion table is used.
         *
         * @param string $in
         * @param int $from
         * @param int $to
         * @return string
         */
        public static function convert($in, $from = self::TYPE_UTF8_STRING, $to = self::TYPE_UTF8_STRING)
        {
        }
        /**
         * Extract raw BER from Base64 encoding
         *
         * @param string $str
         * @return string
         */
        public static function extractBER($str)
        {
        }
        /**
         * DER-encode the length
         *
         * DER supports lengths up to (2**8)**127, however, we'll only support lengths up to (2**8)**4.  See
         * {@link http://itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf#p=13 X.690 paragraph 8.1.3} for more information.
         *
         * @param int $length
         * @return string
         */
        public static function encodeLength($length)
        {
        }
        /**
         * Returns the OID corresponding to a name
         *
         * What's returned in the associative array returned by loadX509() (or load*()) is either a name or an OID if
         * no OID to name mapping is available. The problem with this is that what may be an unmapped OID in one version
         * of phpseclib may not be unmapped in the next version, so apps that are looking at this OID may not be able
         * to work from version to version.
         *
         * This method will return the OID if a name is passed to it and if no mapping is avialable it'll assume that
         * what's being passed to it already is an OID and return that instead. A few examples.
         *
         * getOID('2.16.840.1.101.3.4.2.1') == '2.16.840.1.101.3.4.2.1'
         * getOID('id-sha256') == '2.16.840.1.101.3.4.2.1'
         * getOID('zzz') == 'zzz'
         *
         * @param string $name
         * @return string
         */
        public static function getOID($name)
        {
        }
    }
    /**
     * Pure-PHP X.509 Parser
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class X509
    {
        /**
         * Flag to only accept signatures signed by certificate authorities
         *
         * Not really used anymore but retained all the same to suppress E_NOTICEs from old installs
         *
         */
        const VALIDATE_SIGNATURE_BY_CA = 1;
        /**
         * Return internal array representation
         *
         * @see \phpseclib3\File\X509::getDN()
         */
        const DN_ARRAY = 0;
        /**
         * Return string
         *
         * @see \phpseclib3\File\X509::getDN()
         */
        const DN_STRING = 1;
        /**
         * Return ASN.1 name string
         *
         * @see \phpseclib3\File\X509::getDN()
         */
        const DN_ASN1 = 2;
        /**
         * Return OpenSSL compatible array
         *
         * @see \phpseclib3\File\X509::getDN()
         */
        const DN_OPENSSL = 3;
        /**
         * Return canonical ASN.1 RDNs string
         *
         * @see \phpseclib3\File\X509::getDN()
         */
        const DN_CANON = 4;
        /**
         * Return name hash for file indexing
         *
         * @see \phpseclib3\File\X509::getDN()
         */
        const DN_HASH = 5;
        /**
         * Save as PEM
         *
         * ie. a base64-encoded PEM with a header and a footer
         *
         * @see \phpseclib3\File\X509::saveX509()
         * @see \phpseclib3\File\X509::saveCSR()
         * @see \phpseclib3\File\X509::saveCRL()
         */
        const FORMAT_PEM = 0;
        /**
         * Save as DER
         *
         * @see \phpseclib3\File\X509::saveX509()
         * @see \phpseclib3\File\X509::saveCSR()
         * @see \phpseclib3\File\X509::saveCRL()
         */
        const FORMAT_DER = 1;
        /**
         * Save as a SPKAC
         *
         * @see \phpseclib3\File\X509::saveX509()
         * @see \phpseclib3\File\X509::saveCSR()
         * @see \phpseclib3\File\X509::saveCRL()
         *
         * Only works on CSRs. Not currently supported.
         */
        const FORMAT_SPKAC = 2;
        /**
         * Auto-detect the format
         *
         * Used only by the load*() functions
         *
         * @see \phpseclib3\File\X509::saveX509()
         * @see \phpseclib3\File\X509::saveCSR()
         * @see \phpseclib3\File\X509::saveCRL()
         */
        const FORMAT_AUTO_DETECT = 3;
        /**
         * Attribute value disposition.
         * If disposition is >= 0, this is the index of the target value.
         */
        const ATTR_ALL = -1;
        // All attribute values (array).
        const ATTR_APPEND = -2;
        // Add a value.
        const ATTR_REPLACE = -3;
        /**
         * Default Constructor.
         *
         * @return X509
         */
        public function __construct()
        {
        }
        /**
         * Load X.509 certificate
         *
         * Returns an associative array describing the X.509 cert or a false if the cert failed to load
         *
         * @param array|string $cert
         * @param int $mode
         * @return mixed
         */
        public function loadX509($cert, $mode = self::FORMAT_AUTO_DETECT)
        {
        }
        /**
         * Save X.509 certificate
         *
         * @param array $cert
         * @param int $format optional
         * @return string
         */
        public function saveX509(array $cert, $format = self::FORMAT_PEM)
        {
        }
        /**
         * Load an X.509 certificate as a certificate authority
         *
         * @param string $cert
         * @return bool
         */
        public function loadCA($cert)
        {
        }
        /**
         * Validate an X.509 certificate against a URL
         *
         * From RFC2818 "HTTP over TLS":
         *
         * Matching is performed using the matching rules specified by
         * [RFC2459].  If more than one identity of a given type is present in
         * the certificate (e.g., more than one dNSName name, a match in any one
         * of the set is considered acceptable.) Names may contain the wildcard
         * character * which is considered to match any single domain name
         * component or component fragment. E.g., *.a.com matches foo.a.com but
         * not bar.foo.a.com. f*.com matches foo.com but not bar.com.
         *
         * @param string $url
         * @return bool
         */
        public function validateURL($url)
        {
        }
        /**
         * Validate a date
         *
         * If $date isn't defined it is assumed to be the current date.
         *
         * @param \DateTimeInterface|string $date optional
         * @return bool
         */
        public function validateDate($date = null)
        {
        }
        /**
         * Validate a signature
         *
         * Works on X.509 certs, CSR's and CRL's.
         * Returns true if the signature is verified, false if it is not correct or null on error
         *
         * By default returns false for self-signed certs. Call validateSignature(false) to make this support
         * self-signed.
         *
         * The behavior of this function is inspired by {@link http://php.net/openssl-verify openssl_verify}.
         *
         * @param bool $caonly optional
         * @return mixed
         */
        public function validateSignature($caonly = true)
        {
        }
        /**
         * Sets the recursion limit
         *
         * When validating a signature it may be necessary to download intermediate certs from URI's.
         * An intermediate cert that linked to itself would result in an infinite loop so to prevent
         * that we set a recursion limit. A negative number means that there is no recursion limit.
         *
         * @param int $count
         */
        public static function setRecurLimit($count)
        {
        }
        /**
         * Prevents URIs from being automatically retrieved
         *
         */
        public static function disableURLFetch()
        {
        }
        /**
         * Allows URIs to be automatically retrieved
         *
         */
        public static function enableURLFetch()
        {
        }
        /**
         * Decodes an IP address
         *
         * Takes in a base64 encoded "blob" and returns a human readable IP address
         *
         * @param string $ip
         * @return string
         */
        public static function decodeIP($ip)
        {
        }
        /**
         * Decodes an IP address in a name constraints extension
         *
         * Takes in a base64 encoded "blob" and returns a human readable IP address / mask
         *
         * @param string $ip
         * @return array
         */
        public static function decodeNameConstraintIP($ip)
        {
        }
        /**
         * Encodes an IP address
         *
         * Takes a human readable IP address into a base64-encoded "blob"
         *
         * @param string|array $ip
         * @return string
         */
        public static function encodeIP($ip)
        {
        }
        /**
         * Set a Distinguished Name property
         *
         * @param string $propName
         * @param mixed $propValue
         * @param string $type optional
         * @return bool
         */
        public function setDNProp($propName, $propValue, $type = 'utf8String')
        {
        }
        /**
         * Remove Distinguished Name properties
         *
         * @param string $propName
         */
        public function removeDNProp($propName)
        {
        }
        /**
         * Get Distinguished Name properties
         *
         * @param string $propName
         * @param array $dn optional
         * @param bool $withType optional
         * @return mixed
         */
        public function getDNProp($propName, $dn = null, $withType = false)
        {
        }
        /**
         * Set a Distinguished Name
         *
         * @param mixed $dn
         * @param bool $merge optional
         * @param string $type optional
         * @return bool
         */
        public function setDN($dn, $merge = false, $type = 'utf8String')
        {
        }
        /**
         * Get the Distinguished Name for a certificates subject
         *
         * @param mixed $format optional
         * @param array $dn optional
         * @return array|bool|string
         */
        public function getDN($format = self::DN_ARRAY, $dn = null)
        {
        }
        /**
         * Get the Distinguished Name for a certificate/crl issuer
         *
         * @param int $format optional
         * @return mixed
         */
        public function getIssuerDN($format = self::DN_ARRAY)
        {
        }
        /**
         * Get the Distinguished Name for a certificate/csr subject
         * Alias of getDN()
         *
         * @param int $format optional
         * @return mixed
         */
        public function getSubjectDN($format = self::DN_ARRAY)
        {
        }
        /**
         * Get an individual Distinguished Name property for a certificate/crl issuer
         *
         * @param string $propName
         * @param bool $withType optional
         * @return mixed
         */
        public function getIssuerDNProp($propName, $withType = false)
        {
        }
        /**
         * Get an individual Distinguished Name property for a certificate/csr subject
         *
         * @param string $propName
         * @param bool $withType optional
         * @return mixed
         */
        public function getSubjectDNProp($propName, $withType = false)
        {
        }
        /**
         * Get the certificate chain for the current cert
         *
         * @return mixed
         */
        public function getChain()
        {
        }
        /**
         * Returns the current cert
         *
         * @return array|bool
         */
        public function &getCurrentCert()
        {
        }
        /**
         * Set public key
         *
         * Key needs to be a \phpseclib3\Crypt\RSA object
         *
         * @param PublicKey $key
         * @return void
         */
        public function setPublicKey(\phpseclib3\Crypt\Common\PublicKey $key)
        {
        }
        /**
         * Set private key
         *
         * Key needs to be a \phpseclib3\Crypt\RSA object
         *
         * @param PrivateKey $key
         */
        public function setPrivateKey(\phpseclib3\Crypt\Common\PrivateKey $key)
        {
        }
        /**
         * Set challenge
         *
         * Used for SPKAC CSR's
         *
         * @param string $challenge
         */
        public function setChallenge($challenge)
        {
        }
        /**
         * Gets the public key
         *
         * Returns a \phpseclib3\Crypt\RSA object or a false.
         *
         * @return mixed
         */
        public function getPublicKey()
        {
        }
        /**
         * Load a Certificate Signing Request
         *
         * @param string $csr
         * @param int $mode
         * @return mixed
         */
        public function loadCSR($csr, $mode = self::FORMAT_AUTO_DETECT)
        {
        }
        /**
         * Save CSR request
         *
         * @param array $csr
         * @param int $format optional
         * @return string
         */
        public function saveCSR(array $csr, $format = self::FORMAT_PEM)
        {
        }
        /**
         * Load a SPKAC CSR
         *
         * SPKAC's are produced by the HTML5 keygen element:
         *
         * https://developer.mozilla.org/en-US/docs/HTML/Element/keygen
         *
         * @param string $spkac
         * @return mixed
         */
        public function loadSPKAC($spkac)
        {
        }
        /**
         * Save a SPKAC CSR request
         *
         * @param array $spkac
         * @param int $format optional
         * @return string
         */
        public function saveSPKAC(array $spkac, $format = self::FORMAT_PEM)
        {
        }
        /**
         * Load a Certificate Revocation List
         *
         * @param string $crl
         * @param int $mode
         * @return mixed
         */
        public function loadCRL($crl, $mode = self::FORMAT_AUTO_DETECT)
        {
        }
        /**
         * Save Certificate Revocation List.
         *
         * @param array $crl
         * @param int $format optional
         * @return string
         */
        public function saveCRL(array $crl, $format = self::FORMAT_PEM)
        {
        }
        /**
         * Sign an X.509 certificate
         *
         * $issuer's private key needs to be loaded.
         * $subject can be either an existing X.509 cert (if you want to resign it),
         * a CSR or something with the DN and public key explicitly set.
         *
         * @return mixed
         */
        public function sign(\phpseclib3\File\X509 $issuer, \phpseclib3\File\X509 $subject)
        {
        }
        /**
         * Sign a CSR
         *
         * @return mixed
         */
        public function signCSR()
        {
        }
        /**
         * Sign a SPKAC
         *
         * @return mixed
         */
        public function signSPKAC()
        {
        }
        /**
         * Sign a CRL
         *
         * $issuer's private key needs to be loaded.
         *
         * @return mixed
         */
        public function signCRL(\phpseclib3\File\X509 $issuer, \phpseclib3\File\X509 $crl)
        {
        }
        /**
         * Set certificate start date
         *
         * @param \DateTimeInterface|string $date
         */
        public function setStartDate($date)
        {
        }
        /**
         * Set certificate end date
         *
         * @param \DateTimeInterface|string $date
         */
        public function setEndDate($date)
        {
        }
        /**
         * Set Serial Number
         *
         * @param string $serial
         * @param int $base optional
         */
        public function setSerialNumber($serial, $base = -256)
        {
        }
        /**
         * Turns the certificate into a certificate authority
         *
         */
        public function makeCA()
        {
        }
        /**
         * Remove a certificate, CSR or CRL Extension
         *
         * @param string $id
         * @return bool
         */
        public function removeExtension($id)
        {
        }
        /**
         * Get a certificate, CSR or CRL Extension
         *
         * Returns the extension if it exists and false if not
         *
         * @param string $id
         * @param array $cert optional
         * @param string $path
         * @return mixed
         */
        public function getExtension($id, $cert = null, $path = null)
        {
        }
        /**
         * Returns a list of all extensions in use in certificate, CSR or CRL
         *
         * @param array $cert optional
         * @param string $path optional
         * @return array
         */
        public function getExtensions($cert = null, $path = null)
        {
        }
        /**
         * Set a certificate, CSR or CRL Extension
         *
         * @param string $id
         * @param mixed $value
         * @param bool $critical optional
         * @param bool $replace optional
         * @return bool
         */
        public function setExtension($id, $value, $critical = false, $replace = true)
        {
        }
        /**
         * Remove a CSR attribute.
         *
         * @param string $id
         * @param int $disposition optional
         * @return bool
         */
        public function removeAttribute($id, $disposition = self::ATTR_ALL)
        {
        }
        /**
         * Get a CSR attribute
         *
         * Returns the attribute if it exists and false if not
         *
         * @param string $id
         * @param int $disposition optional
         * @param array $csr optional
         * @return mixed
         */
        public function getAttribute($id, $disposition = self::ATTR_ALL, $csr = null)
        {
        }
        /**
         * Get all requested CSR extensions
         *
         * Returns the list of extensions if there are any and false if not
         *
         * @param array $csr optional
         * @return mixed
         */
        public function getRequestedCertificateExtensions($csr = null)
        {
        }
        /**
         * Returns a list of all CSR attributes in use
         *
         * @param array $csr optional
         * @return array
         */
        public function getAttributes($csr = null)
        {
        }
        /**
         * Set a CSR attribute
         *
         * @param string $id
         * @param mixed $value
         * @param int $disposition optional
         * @return bool
         */
        public function setAttribute($id, $value, $disposition = self::ATTR_ALL)
        {
        }
        /**
         * Sets the subject key identifier
         *
         * This is used by the id-ce-authorityKeyIdentifier and the id-ce-subjectKeyIdentifier extensions.
         *
         * @param string $value
         */
        public function setKeyIdentifier($value)
        {
        }
        /**
         * Compute a public key identifier.
         *
         * Although key identifiers may be set to any unique value, this function
         * computes key identifiers from public key according to the two
         * recommended methods (4.2.1.2 RFC 3280).
         * Highly polymorphic: try to accept all possible forms of key:
         * - Key object
         * - \phpseclib3\File\X509 object with public or private key defined
         * - Certificate or CSR array
         * - \phpseclib3\File\ASN1\Element object
         * - PEM or DER string
         *
         * @param mixed $key optional
         * @param int $method optional
         * @return string binary key identifier
         */
        public function computeKeyIdentifier($key = null, $method = 1)
        {
        }
        /**
         * Set the domain name's which the cert is to be valid for
         *
         * @param mixed ...$domains
         * @return void
         */
        public function setDomain(...$domains)
        {
        }
        /**
         * Set the IP Addresses's which the cert is to be valid for
         *
         * @param mixed[] ...$ipAddresses
         */
        public function setIPAddress(...$ipAddresses)
        {
        }
        /**
         * Revoke a certificate.
         *
         * @param string $serial
         * @param string $date optional
         * @return bool
         */
        public function revoke($serial, $date = null)
        {
        }
        /**
         * Unrevoke a certificate.
         *
         * @param string $serial
         * @return bool
         */
        public function unrevoke($serial)
        {
        }
        /**
         * Get a revoked certificate.
         *
         * @param string $serial
         * @return mixed
         */
        public function getRevoked($serial)
        {
        }
        /**
         * List revoked certificates
         *
         * @param array $crl optional
         * @return array|bool
         */
        public function listRevoked($crl = null)
        {
        }
        /**
         * Remove a Revoked Certificate Extension
         *
         * @param string $serial
         * @param string $id
         * @return bool
         */
        public function removeRevokedCertificateExtension($serial, $id)
        {
        }
        /**
         * Get a Revoked Certificate Extension
         *
         * Returns the extension if it exists and false if not
         *
         * @param string $serial
         * @param string $id
         * @param array $crl optional
         * @return mixed
         */
        public function getRevokedCertificateExtension($serial, $id, $crl = null)
        {
        }
        /**
         * Returns a list of all extensions in use for a given revoked certificate
         *
         * @param string $serial
         * @param array $crl optional
         * @return array|bool
         */
        public function getRevokedCertificateExtensions($serial, $crl = null)
        {
        }
        /**
         * Set a Revoked Certificate Extension
         *
         * @param string $serial
         * @param string $id
         * @param mixed $value
         * @param bool $critical optional
         * @param bool $replace optional
         * @return bool
         */
        public function setRevokedCertificateExtension($serial, $id, $value, $critical = false, $replace = true)
        {
        }
        /**
         * Register the mapping for a custom/unsupported extension.
         *
         * @param string $id
         * @param array $mapping
         */
        public static function registerExtension($id, array $mapping)
        {
        }
        /**
         * Register the mapping for a custom/unsupported extension.
         *
         * @param string $id
         *
         * @return array|null
         */
        public static function getRegisteredExtension($id)
        {
        }
        /**
         * Register the mapping for a custom/unsupported extension.
         *
         * @param string $id
         * @param mixed $value
         * @param bool $critical
         * @param bool $replace
         */
        public function setExtensionValue($id, $value, $critical = false, $replace = false)
        {
        }
    }
}
namespace phpseclib3\Math\BigInteger\Engines {
    /**
     * Base Engine.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Engine implements \JsonSerializable
    {
        /* final protected */
        const PRIMES = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
        /**
         * BigInteger(0)
         *
         * @var array<class-string<static>, static>
         */
        protected static $zero = [];
        /**
         * BigInteger(1)
         *
         * @var array<class-string<static>, static>
         */
        protected static $one = [];
        /**
         * BigInteger(2)
         *
         * @var array<class-string<static>, static>
         */
        protected static $two = [];
        /**
         * Modular Exponentiation Engine
         *
         * @var array<class-string<static>, class-string<static>>
         */
        protected static $modexpEngine;
        /**
         * Engine Validity Flag
         *
         * @var array<class-string<static>, bool>
         */
        protected static $isValidEngine;
        /**
         * Holds the BigInteger's value
         *
         * @var \GMP|string|array|int
         */
        protected $value;
        /**
         * Holds the BigInteger's sign
         *
         * @var bool
         */
        protected $is_negative;
        /**
         * Precision
         *
         * @see static::setPrecision()
         * @var int
         */
        protected $precision = -1;
        /**
         * Precision Bitmask
         *
         * @see static::setPrecision()
         * @var static|false
         */
        protected $bitmask = false;
        /**
         * Recurring Modulo Function
         *
         * @var callable
         */
        protected $reduce;
        /**
         * Mode independent value used for serialization.
         *
         * @see self::__sleep()
         * @see self::__wakeup()
         * @var string
         */
        protected $hex;
        /**
         * Default constructor
         *
         * @param int|numeric-string $x integer Base-10 number or base-$base number if $base set.
         * @param int $base
         */
        public function __construct($x = 0, $base = 10)
        {
        }
        /**
         * Sets engine type.
         *
         * Throws an exception if the type is invalid
         *
         * @param class-string<Engine> $engine
         */
        public static function setModExpEngine($engine)
        {
        }
        /**
         * Converts a BigInteger to a byte string (eg. base-256).
         *
         * Negative numbers are saved as positive numbers, unless $twos_compliment is set to true, at which point, they're
         * saved as two's compliment.
         * @return string
         */
        protected function toBytesHelper()
        {
        }
        /**
         * Converts a BigInteger to a hex string (eg. base-16).
         *
         * @param bool $twos_compliment
         * @return string
         */
        public function toHex($twos_compliment = false)
        {
        }
        /**
         * Converts a BigInteger to a bit string (eg. base-2).
         *
         * Negative numbers are saved as positive numbers, unless $twos_compliment is set to true, at which point, they're
         * saved as two's compliment.
         *
         * @param bool $twos_compliment
         * @return string
         */
        public function toBits($twos_compliment = false)
        {
        }
        /**
         * Calculates modular inverses.
         *
         * Say you have (30 mod 17 * x mod 17) mod 17 == 1.  x can be found using modular inverses.
         *
         * {@internal See {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=21 HAC 14.64} for more information.}
         *
         * @param Engine $n
         * @return static|false
         */
        protected function modInverseHelper(\phpseclib3\Math\BigInteger\Engines\Engine $n)
        {
        }
        /**
         * Serialize
         *
         * Will be called, automatically, when serialize() is called on a BigInteger object.
         *
         * @return array
         */
        public function __sleep()
        {
        }
        /**
         * Serialize
         *
         * Will be called, automatically, when unserialize() is called on a BigInteger object.
         *
         * @return void
         */
        public function __wakeup()
        {
        }
        /**
         * JSON Serialize
         *
         * Will be called, automatically, when json_encode() is called on a BigInteger object.
         *
         * @return array{hex: string, precision?: int]
         */
        #[\ReturnTypeWillChange]
        public function jsonSerialize()
        {
        }
        /**
         * Converts a BigInteger to a base-10 number.
         *
         * @return string
         */
        public function __toString()
        {
        }
        /**
         *  __debugInfo() magic method
         *
         * Will be called, automatically, when print_r() or var_dump() are called
         *
         * @return array
         */
        public function __debugInfo()
        {
        }
        /**
         * Set Precision
         *
         * Some bitwise operations give different results depending on the precision being used.  Examples include left
         * shift, not, and rotates.
         *
         * @param int $bits
         */
        public function setPrecision($bits)
        {
        }
        /**
         * Get Precision
         *
         * Returns the precision if it exists, -1 if it doesn't
         *
         * @return int
         */
        public function getPrecision()
        {
        }
        /**
         * Set Bitmask
         * @return static
         * @param int $bits
         * @see self::setPrecision()
         */
        protected static function setBitmask($bits)
        {
        }
        /**
         * Logical Not
         *
         * @return Engine|string
         */
        public function bitwise_not()
        {
        }
        /**
         * Logical Left Shift
         *
         * Shifts binary strings $shift bits, essentially multiplying by 2**$shift.
         *
         * @param string $x
         * @param int $shift
         * @return void
         */
        protected static function base256_lshift(&$x, $shift)
        {
        }
        /**
         * Logical Left Rotate
         *
         * Instead of the top x bits being dropped they're appended to the shifted bit string.
         *
         * @param int $shift
         * @return Engine
         */
        public function bitwise_leftRotate($shift)
        {
        }
        /**
         * Logical Right Rotate
         *
         * Instead of the bottom x bits being dropped they're prepended to the shifted bit string.
         *
         * @param int $shift
         * @return Engine
         */
        public function bitwise_rightRotate($shift)
        {
        }
        /**
         * Returns the smallest and largest n-bit number
         *
         * @param int $bits
         * @return array{min: static, max: static}
         */
        public static function minMaxBits($bits)
        {
        }
        /**
         * Return the size of a BigInteger in bits
         *
         * @return int
         */
        public function getLength()
        {
        }
        /**
         * Return the size of a BigInteger in bytes
         *
         * @return int
         */
        public function getLengthInBytes()
        {
        }
        /**
         * Performs some pre-processing for powMod
         *
         * @param Engine $e
         * @param Engine $n
         * @return static|false
         */
        protected function powModOuter(\phpseclib3\Math\BigInteger\Engines\Engine $e, \phpseclib3\Math\BigInteger\Engines\Engine $n)
        {
        }
        /**
         * Sliding Window k-ary Modular Exponentiation
         *
         * Based on {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=27 HAC 14.85} /
         * {@link http://math.libtomcrypt.com/files/tommath.pdf#page=210 MPM 7.7}.  In a departure from those algorithims,
         * however, this function performs a modular reduction after every multiplication and squaring operation.
         * As such, this function has the same preconditions that the reductions being used do.
         *
         * @template T of Engine
         * @param Engine $x
         * @param Engine $e
         * @param Engine $n
         * @param class-string<T> $class
         * @return T
         */
        protected static function slidingWindow(\phpseclib3\Math\BigInteger\Engines\Engine $x, \phpseclib3\Math\BigInteger\Engines\Engine $e, \phpseclib3\Math\BigInteger\Engines\Engine $n, $class)
        {
        }
        /**
         * Generates a random number of a certain size
         *
         * Bit length is equal to $size
         *
         * @param int $size
         * @return Engine
         */
        public static function random($size)
        {
        }
        /**
         * Generates a random prime number of a certain size
         *
         * Bit length is equal to $size
         *
         * @param int $size
         * @return Engine
         */
        public static function randomPrime($size)
        {
        }
        /**
         * Performs some pre-processing for randomRangePrime
         *
         * @param Engine $min
         * @param Engine $max
         * @return static|false
         */
        protected static function randomRangePrimeOuter(\phpseclib3\Math\BigInteger\Engines\Engine $min, \phpseclib3\Math\BigInteger\Engines\Engine $max)
        {
        }
        /**
         * Generate a random number between a range
         *
         * Returns a random number between $min and $max where $min and $max
         * can be defined using one of the two methods:
         *
         * BigInteger::randomRange($min, $max)
         * BigInteger::randomRange($max, $min)
         *
         * @param Engine $min
         * @param Engine $max
         * @return Engine
         */
        protected static function randomRangeHelper(\phpseclib3\Math\BigInteger\Engines\Engine $min, \phpseclib3\Math\BigInteger\Engines\Engine $max)
        {
        }
        /**
         * Performs some post-processing for randomRangePrime
         *
         * @param Engine $x
         * @param Engine $min
         * @param Engine $max
         * @return static|false
         */
        protected static function randomRangePrimeInner(\phpseclib3\Math\BigInteger\Engines\Engine $x, \phpseclib3\Math\BigInteger\Engines\Engine $min, \phpseclib3\Math\BigInteger\Engines\Engine $max)
        {
        }
        /**
         * Sets the $t parameter for primality testing
         *
         * @return int
         */
        protected function setupIsPrime()
        {
        }
        /**
         * Tests Primality
         *
         * Uses the {@link http://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test Miller-Rabin primality test}.
         * See {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap4.pdf#page=8 HAC 4.24} for more info.
         *
         * @param int $t
         * @return bool
         */
        protected function testPrimality($t)
        {
        }
        /**
         * Checks a numer to see if it's prime
         *
         * Assuming the $t parameter is not set, this function has an error rate of 2**-80.  The main motivation for the
         * $t parameter is distributability.  BigInteger::randomPrime() can be distributed across multiple pageloads
         * on a website instead of just one.
         *
         * @param int|bool $t
         * @return bool
         */
        public function isPrime($t = false)
        {
        }
        /**
         * Performs a few preliminary checks on root
         *
         * @param int $n
         * @return Engine
         */
        protected function rootHelper($n)
        {
        }
        /**
         * Calculates the nth root of a biginteger.
         *
         * Returns the nth root of a positive biginteger, where n defaults to 2
         *
         * {@internal This function is based off of {@link http://mathforum.org/library/drmath/view/52605.html this page} and {@link http://stackoverflow.com/questions/11242920/calculating-nth-root-with-bcmath-in-php this stackoverflow question}.}
         *
         * @param int $n
         * @return Engine
         */
        protected function rootInner($n)
        {
        }
        /**
         * Calculates the nth root of a biginteger.
         *
         * @param int $n
         * @return Engine
         */
        public function root($n = 2)
        {
        }
        /**
         * Return the minimum BigInteger between an arbitrary number of BigIntegers.
         *
         * @param array $nums
         * @return Engine
         */
        protected static function minHelper(array $nums)
        {
        }
        /**
         * Return the minimum BigInteger between an arbitrary number of BigIntegers.
         *
         * @param array $nums
         * @return Engine
         */
        protected static function maxHelper(array $nums)
        {
        }
        /**
         * Create Recurring Modulo Function
         *
         * Sometimes it may be desirable to do repeated modulos with the same number outside of
         * modular exponentiation
         *
         * @return callable
         */
        public function createRecurringModuloFunction()
        {
        }
        /**
         * Calculates the greatest common divisor and Bezout's identity.
         *
         * @param Engine $n
         * @return array{gcd: Engine, x: Engine, y: Engine}
         */
        protected function extendedGCDHelper(\phpseclib3\Math\BigInteger\Engines\Engine $n)
        {
        }
        /**
         * Bitwise Split
         *
         * Splits BigInteger's into chunks of $split bits
         *
         * @param int $split
         * @return Engine[]
         */
        public function bitwise_split($split)
        {
        }
        /**
         * Logical And
         *
         * @param Engine $x
         * @return Engine
         */
        protected function bitwiseAndHelper(\phpseclib3\Math\BigInteger\Engines\Engine $x)
        {
        }
        /**
         * Logical Or
         *
         * @param Engine $x
         * @return Engine
         */
        protected function bitwiseOrHelper(\phpseclib3\Math\BigInteger\Engines\Engine $x)
        {
        }
        /**
         * Logical Exclusive Or
         *
         * @param Engine $x
         * @return Engine
         */
        protected function bitwiseXorHelper(\phpseclib3\Math\BigInteger\Engines\Engine $x)
        {
        }
    }
    /**
     * BCMath Engine.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class BCMath extends \phpseclib3\Math\BigInteger\Engines\Engine
    {
        /**
         * Can Bitwise operations be done fast?
         *
         * @see parent::bitwise_leftRotate()
         * @see parent::bitwise_rightRotate()
         */
        const FAST_BITWISE = false;
        /**
         * Engine Directory
         *
         * @see parent::setModExpEngine
         */
        const ENGINE_DIR = 'BCMath';
        /**
         * Test for engine validity
         *
         * @return bool
         * @see parent::__construct()
         */
        public static function isValidEngine()
        {
        }
        /**
         * Default constructor
         *
         * @param mixed $x integer Base-10 number or base-$base number if $base set.
         * @param int $base
         * @see parent::__construct()
         */
        public function __construct($x = 0, $base = 10)
        {
        }
        /**
         * Initialize a BCMath BigInteger Engine instance
         *
         * @param int $base
         * @see parent::__construct()
         */
        protected function initialize($base)
        {
        }
        /**
         * Converts a BigInteger to a base-10 number.
         *
         * @return string
         */
        public function toString()
        {
        }
        /**
         * Converts a BigInteger to a byte string (eg. base-256).
         *
         * @param bool $twos_compliment
         * @return string
         */
        public function toBytes($twos_compliment = false)
        {
        }
        /**
         * Adds two BigIntegers.
         *
         * @param BCMath $y
         * @return BCMath
         */
        public function add(\phpseclib3\Math\BigInteger\Engines\BCMath $y)
        {
        }
        /**
         * Subtracts two BigIntegers.
         *
         * @param BCMath $y
         * @return BCMath
         */
        public function subtract(\phpseclib3\Math\BigInteger\Engines\BCMath $y)
        {
        }
        /**
         * Multiplies two BigIntegers.
         *
         * @param BCMath $x
         * @return BCMath
         */
        public function multiply(\phpseclib3\Math\BigInteger\Engines\BCMath $x)
        {
        }
        /**
         * Divides two BigIntegers.
         *
         * Returns an array whose first element contains the quotient and whose second element contains the
         * "common residue".  If the remainder would be positive, the "common residue" and the remainder are the
         * same.  If the remainder would be negative, the "common residue" is equal to the sum of the remainder
         * and the divisor (basically, the "common residue" is the first positive modulo).
         *
         * @param BCMath $y
         * @return array{static, static}
         */
        public function divide(\phpseclib3\Math\BigInteger\Engines\BCMath $y)
        {
        }
        /**
         * Calculates modular inverses.
         *
         * Say you have (30 mod 17 * x mod 17) mod 17 == 1.  x can be found using modular inverses.
         *
         * @param BCMath $n
         * @return false|BCMath
         */
        public function modInverse(\phpseclib3\Math\BigInteger\Engines\BCMath $n)
        {
        }
        /**
         * Calculates the greatest common divisor and Bezout's identity.
         *
         * Say you have 693 and 609.  The GCD is 21.  Bezout's identity states that there exist integers x and y such that
         * 693*x + 609*y == 21.  In point of fact, there are actually an infinite number of x and y combinations and which
         * combination is returned is dependent upon which mode is in use.  See
         * {@link http://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity Bezout's identity - Wikipedia} for more information.
         *
         * @param BCMath $n
         * @return array{gcd: static, x: static, y: static}
         */
        public function extendedGCD(\phpseclib3\Math\BigInteger\Engines\BCMath $n)
        {
        }
        /**
         * Calculates the greatest common divisor
         *
         * Say you have 693 and 609.  The GCD is 21.
         *
         * @param BCMath $n
         * @return BCMath
         */
        public function gcd(\phpseclib3\Math\BigInteger\Engines\BCMath $n)
        {
        }
        /**
         * Absolute value.
         *
         * @return BCMath
         */
        public function abs()
        {
        }
        /**
         * Logical And
         *
         * @param BCMath $x
         * @return BCMath
         */
        public function bitwise_and(\phpseclib3\Math\BigInteger\Engines\BCMath $x)
        {
        }
        /**
         * Logical Or
         *
         * @param BCMath $x
         * @return BCMath
         */
        public function bitwise_or(\phpseclib3\Math\BigInteger\Engines\BCMath $x)
        {
        }
        /**
         * Logical Exclusive Or
         *
         * @param BCMath $x
         * @return BCMath
         */
        public function bitwise_xor(\phpseclib3\Math\BigInteger\Engines\BCMath $x)
        {
        }
        /**
         * Logical Right Shift
         *
         * Shifts BigInteger's by $shift bits, effectively dividing by 2**$shift.
         *
         * @param int $shift
         * @return BCMath
         */
        public function bitwise_rightShift($shift)
        {
        }
        /**
         * Logical Left Shift
         *
         * Shifts BigInteger's by $shift bits, effectively multiplying by 2**$shift.
         *
         * @param int $shift
         * @return BCMath
         */
        public function bitwise_leftShift($shift)
        {
        }
        /**
         * Compares two numbers.
         *
         * Although one might think !$x->compare($y) means $x != $y, it, in fact, means the opposite.  The reason for this
         * is demonstrated thusly:
         *
         * $x  > $y: $x->compare($y)  > 0
         * $x  < $y: $x->compare($y)  < 0
         * $x == $y: $x->compare($y) == 0
         *
         * Note how the same comparison operator is used.  If you want to test for equality, use $x->equals($y).
         *
         * {@internal Could return $this->subtract($x), but that's not as fast as what we do do.}
         *
         * @param BCMath $y
         * @return int in case < 0 if $this is less than $y; > 0 if $this is greater than $y, and 0 if they are equal.
         * @see self::equals()
         */
        public function compare(\phpseclib3\Math\BigInteger\Engines\BCMath $y)
        {
        }
        /**
         * Tests the equality of two numbers.
         *
         * If you need to see if one number is greater than or less than another number, use BigInteger::compare()
         *
         * @param BCMath $x
         * @return bool
         */
        public function equals(\phpseclib3\Math\BigInteger\Engines\BCMath $x)
        {
        }
        /**
         * Performs modular exponentiation.
         *
         * @param BCMath $e
         * @param BCMath $n
         * @return BCMath
         */
        public function modPow(\phpseclib3\Math\BigInteger\Engines\BCMath $e, \phpseclib3\Math\BigInteger\Engines\BCMath $n)
        {
        }
        /**
         * Performs modular exponentiation.
         *
         * Alias for modPow().
         *
         * @param BCMath $e
         * @param BCMath $n
         * @return BCMath
         */
        public function powMod(\phpseclib3\Math\BigInteger\Engines\BCMath $e, \phpseclib3\Math\BigInteger\Engines\BCMath $n)
        {
        }
        /**
         * Performs modular exponentiation.
         *
         * @param BCMath $e
         * @param BCMath $n
         * @return BCMath
         */
        protected function powModInner(\phpseclib3\Math\BigInteger\Engines\BCMath $e, \phpseclib3\Math\BigInteger\Engines\BCMath $n)
        {
        }
        /**
         * Normalize
         *
         * Removes leading zeros and truncates (if necessary) to maintain the appropriate precision
         *
         * @param BCMath $result
         * @return BCMath
         */
        protected function normalize(\phpseclib3\Math\BigInteger\Engines\BCMath $result)
        {
        }
        /**
         * Generate a random prime number between a range
         *
         * If there's not a prime within the given range, false will be returned.
         *
         * @param BCMath $min
         * @param BCMath $max
         * @return false|BCMath
         */
        public static function randomRangePrime(\phpseclib3\Math\BigInteger\Engines\BCMath $min, \phpseclib3\Math\BigInteger\Engines\BCMath $max)
        {
        }
        /**
         * Generate a random number between a range
         *
         * Returns a random number between $min and $max where $min and $max
         * can be defined using one of the two methods:
         *
         * BigInteger::randomRange($min, $max)
         * BigInteger::randomRange($max, $min)
         *
         * @param BCMath $min
         * @param BCMath $max
         * @return BCMath
         */
        public static function randomRange(\phpseclib3\Math\BigInteger\Engines\BCMath $min, \phpseclib3\Math\BigInteger\Engines\BCMath $max)
        {
        }
        /**
         * Make the current number odd
         *
         * If the current number is odd it'll be unchanged.  If it's even, one will be added to it.
         *
         * @see self::randomPrime()
         */
        protected function make_odd()
        {
        }
        /**
         * Test the number against small primes.
         *
         * @see self::isPrime()
         */
        protected function testSmallPrimes()
        {
        }
        /**
         * Scan for 1 and right shift by that amount
         *
         * ie. $s = gmp_scan1($n, 0) and $r = gmp_div_q($n, gmp_pow(gmp_init('2'), $s));
         *
         * @param BCMath $r
         * @return int
         * @see self::isPrime()
         */
        public static function scan1divide(\phpseclib3\Math\BigInteger\Engines\BCMath $r)
        {
        }
        /**
         * Performs exponentiation.
         *
         * @param BCMath $n
         * @return BCMath
         */
        public function pow(\phpseclib3\Math\BigInteger\Engines\BCMath $n)
        {
        }
        /**
         * Return the minimum BigInteger between an arbitrary number of BigIntegers.
         *
         * @param BCMath ...$nums
         * @return BCMath
         */
        public static function min(\phpseclib3\Math\BigInteger\Engines\BCMath ...$nums)
        {
        }
        /**
         * Return the maximum BigInteger between an arbitrary number of BigIntegers.
         *
         * @param BCMath ...$nums
         * @return BCMath
         */
        public static function max(\phpseclib3\Math\BigInteger\Engines\BCMath ...$nums)
        {
        }
        /**
         * Tests BigInteger to see if it is between two integers, inclusive
         *
         * @param BCMath $min
         * @param BCMath $max
         * @return bool
         */
        public function between(\phpseclib3\Math\BigInteger\Engines\BCMath $min, \phpseclib3\Math\BigInteger\Engines\BCMath $max)
        {
        }
        /**
         * Set Bitmask
         *
         * @param int $bits
         * @return Engine
         * @see self::setPrecision()
         */
        protected static function setBitmask($bits)
        {
        }
        /**
         * Is Odd?
         *
         * @return bool
         */
        public function isOdd()
        {
        }
        /**
         * Tests if a bit is set
         *
         * @return bool
         */
        public function testBit($x)
        {
        }
        /**
         * Is Negative?
         *
         * @return bool
         */
        public function isNegative()
        {
        }
        /**
         * Negate
         *
         * Given $k, returns -$k
         *
         * @return BCMath
         */
        public function negate()
        {
        }
    }
}
namespace phpseclib3\Math\BigInteger\Engines\BCMath {
    /**
     * Sliding Window Exponentiation Engine
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Base extends \phpseclib3\Math\BigInteger\Engines\BCMath
    {
        /**
         * Cache constants
         *
         * $cache[self::VARIABLE] tells us whether or not the cached data is still valid.
         *
         */
        const VARIABLE = 0;
        /**
         * $cache[self::DATA] contains the cached data.
         *
         */
        const DATA = 1;
        /**
         * Test for engine validity
         *
         * @return bool
         */
        public static function isValidEngine()
        {
        }
        /**
         * Performs modular exponentiation.
         *
         * @param BCMath $x
         * @param BCMath $e
         * @param BCMath $n
         * @param string $class
         * @return BCMath
         */
        protected static function powModHelper(\phpseclib3\Math\BigInteger\Engines\BCMath $x, \phpseclib3\Math\BigInteger\Engines\BCMath $e, \phpseclib3\Math\BigInteger\Engines\BCMath $n, $class)
        {
        }
        /**
         * Modular reduction preparation
         *
         * @param string $x
         * @param string $n
         * @param string $class
         * @see self::slidingWindow()
         * @return string
         */
        protected static function prepareReduce($x, $n, $class)
        {
        }
        /**
         * Modular multiply
         *
         * @param string $x
         * @param string $y
         * @param string $n
         * @param string $class
         * @see self::slidingWindow()
         * @return string
         */
        protected static function multiplyReduce($x, $y, $n, $class)
        {
        }
        /**
         * Modular square
         *
         * @param string $x
         * @param string $n
         * @param string $class
         * @see self::slidingWindow()
         * @return string
         */
        protected static function squareReduce($x, $n, $class)
        {
        }
    }
    /**
     * Built-In BCMath Modular Exponentiation Engine
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class BuiltIn extends \phpseclib3\Math\BigInteger\Engines\BCMath
    {
        /**
         * Performs modular exponentiation.
         *
         * @param BCMath $x
         * @param BCMath $e
         * @param BCMath $n
         * @return BCMath
         */
        protected static function powModHelper(\phpseclib3\Math\BigInteger\Engines\BCMath $x, \phpseclib3\Math\BigInteger\Engines\BCMath $e, \phpseclib3\Math\BigInteger\Engines\BCMath $n)
        {
        }
    }
}
namespace phpseclib3\Math\BigInteger\Engines\BCMath\Reductions {
    /**
     * PHP Barrett Modular Exponentiation Engine
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Barrett extends \phpseclib3\Math\BigInteger\Engines\BCMath\Base
    {
        /**
         * Cache constants
         *
         * $cache[self::VARIABLE] tells us whether or not the cached data is still valid.
         *
         */
        const VARIABLE = 0;
        /**
         * $cache[self::DATA] contains the cached data.
         *
         */
        const DATA = 1;
        /**
         * Barrett Modular Reduction
         *
         * See {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=14 HAC 14.3.3} /
         * {@link http://math.libtomcrypt.com/files/tommath.pdf#page=165 MPM 6.2.5} for more information.  Modified slightly,
         * so as not to require negative numbers (initially, this script didn't support negative numbers).
         *
         * Employs "folding", as described at
         * {@link http://www.cosic.esat.kuleuven.be/publications/thesis-149.pdf#page=66 thesis-149.pdf#page=66}.  To quote from
         * it, "the idea [behind folding] is to find a value x' such that x (mod m) = x' (mod m), with x' being smaller than x."
         *
         * Unfortunately, the "Barrett Reduction with Folding" algorithm described in thesis-149.pdf is not, as written, all that
         * usable on account of (1) its not using reasonable radix points as discussed in
         * {@link http://math.libtomcrypt.com/files/tommath.pdf#page=162 MPM 6.2.2} and (2) the fact that, even with reasonable
         * radix points, it only works when there are an even number of digits in the denominator.  The reason for (2) is that
         * (x >> 1) + (x >> 1) != x / 2 + x / 2.  If x is even, they're the same, but if x is odd, they're not.  See the in-line
         * comments for details.
         *
         * @param string $n
         * @param string $m
         * @return string
         */
        protected static function reduce($n, $m)
        {
        }
    }
}
namespace phpseclib3\Math\BigInteger\Engines\BCMath {
    /**
     * PHP Default Modular Exponentiation Engine
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class DefaultEngine extends \phpseclib3\Math\BigInteger\Engines\BCMath\Reductions\Barrett
    {
    }
}
namespace phpseclib3\Math\BigInteger\Engines {
    /**
     * OpenSSL Modular Exponentiation Engine
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class OpenSSL
    {
        /**
         * Test for engine validity
         *
         * @return bool
         */
        public static function isValidEngine()
        {
        }
        /**
         * Performs modular exponentiation.
         *
         * @param Engine $x
         * @param Engine $e
         * @param Engine $n
         * @return Engine
         */
        public static function powModHelper(\phpseclib3\Math\BigInteger\Engines\Engine $x, \phpseclib3\Math\BigInteger\Engines\Engine $e, \phpseclib3\Math\BigInteger\Engines\Engine $n)
        {
        }
    }
}
namespace phpseclib3\Math\BigInteger\Engines\BCMath {
    /**
     * OpenSSL Modular Exponentiation Engine
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class OpenSSL extends \phpseclib3\Math\BigInteger\Engines\OpenSSL
    {
    }
}
namespace phpseclib3\Math\BigInteger\Engines\BCMath\Reductions {
    /**
     * PHP Barrett Modular Exponentiation Engine
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class EvalBarrett extends \phpseclib3\Math\BigInteger\Engines\BCMath\Base
    {
        /**
         * Barrett Modular Reduction
         *
         * This calls a dynamically generated loop unrolled function that's specific to a given modulo.
         * Array lookups are avoided as are if statements testing for how many bits the host OS supports, etc.
         *
         * @param string $n
         * @param string $m
         * @return string
         */
        protected static function reduce($n, $m)
        {
        }
        /**
         * Generate Custom Reduction
         *
         * @param BCMath $m
         * @param string $class
         * @return callable|void
         */
        protected static function generateCustomReduction(\phpseclib3\Math\BigInteger\Engines\BCMath $m, $class)
        {
        }
    }
}
namespace phpseclib3\Math\BigInteger\Engines {
    /**
     * GMP Engine.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class GMP extends \phpseclib3\Math\BigInteger\Engines\Engine
    {
        /**
         * Can Bitwise operations be done fast?
         *
         * @see parent::bitwise_leftRotate()
         * @see parent::bitwise_rightRotate()
         */
        const FAST_BITWISE = true;
        /**
         * Engine Directory
         *
         * @see parent::setModExpEngine
         */
        const ENGINE_DIR = 'GMP';
        /**
         * Test for engine validity
         *
         * @return bool
         * @see parent::__construct()
         */
        public static function isValidEngine()
        {
        }
        /**
         * Default constructor
         *
         * @param mixed $x integer Base-10 number or base-$base number if $base set.
         * @param int $base
         * @see parent::__construct()
         */
        public function __construct($x = 0, $base = 10)
        {
        }
        /**
         * Initialize a GMP BigInteger Engine instance
         *
         * @param int $base
         * @see parent::__construct()
         */
        protected function initialize($base)
        {
        }
        /**
         * Converts a BigInteger to a base-10 number.
         *
         * @return string
         */
        public function toString()
        {
        }
        /**
         * Converts a BigInteger to a bit string (eg. base-2).
         *
         * Negative numbers are saved as positive numbers, unless $twos_compliment is set to true, at which point, they're
         * saved as two's compliment.
         *
         * @param bool $twos_compliment
         * @return string
         */
        public function toBits($twos_compliment = false)
        {
        }
        /**
         * Converts a BigInteger to a byte string (eg. base-256).
         *
         * @param bool $twos_compliment
         * @return string
         */
        public function toBytes($twos_compliment = false)
        {
        }
        /**
         * Adds two BigIntegers.
         *
         * @param GMP $y
         * @return GMP
         */
        public function add(\phpseclib3\Math\BigInteger\Engines\GMP $y)
        {
        }
        /**
         * Subtracts two BigIntegers.
         *
         * @param GMP $y
         * @return GMP
         */
        public function subtract(\phpseclib3\Math\BigInteger\Engines\GMP $y)
        {
        }
        /**
         * Multiplies two BigIntegers.
         *
         * @param GMP $x
         * @return GMP
         */
        public function multiply(\phpseclib3\Math\BigInteger\Engines\GMP $x)
        {
        }
        /**
         * Divides two BigIntegers.
         *
         * Returns an array whose first element contains the quotient and whose second element contains the
         * "common residue".  If the remainder would be positive, the "common residue" and the remainder are the
         * same.  If the remainder would be negative, the "common residue" is equal to the sum of the remainder
         * and the divisor (basically, the "common residue" is the first positive modulo).
         *
         * @param GMP $y
         * @return array{GMP, GMP}
         */
        public function divide(\phpseclib3\Math\BigInteger\Engines\GMP $y)
        {
        }
        /**
         * Compares two numbers.
         *
         * Although one might think !$x->compare($y) means $x != $y, it, in fact, means the opposite.  The reason for this
         * is demonstrated thusly:
         *
         * $x  > $y: $x->compare($y)  > 0
         * $x  < $y: $x->compare($y)  < 0
         * $x == $y: $x->compare($y) == 0
         *
         * Note how the same comparison operator is used.  If you want to test for equality, use $x->equals($y).
         *
         * {@internal Could return $this->subtract($x), but that's not as fast as what we do do.}
         *
         * @param GMP $y
         * @return int in case < 0 if $this is less than $y; > 0 if $this is greater than $y, and 0 if they are equal.
         * @see self::equals()
         */
        public function compare(\phpseclib3\Math\BigInteger\Engines\GMP $y)
        {
        }
        /**
         * Tests the equality of two numbers.
         *
         * If you need to see if one number is greater than or less than another number, use BigInteger::compare()
         *
         * @param GMP $x
         * @return bool
         */
        public function equals(\phpseclib3\Math\BigInteger\Engines\GMP $x)
        {
        }
        /**
         * Calculates modular inverses.
         *
         * Say you have (30 mod 17 * x mod 17) mod 17 == 1.  x can be found using modular inverses.
         *
         * @param GMP $n
         * @return false|GMP
         */
        public function modInverse(\phpseclib3\Math\BigInteger\Engines\GMP $n)
        {
        }
        /**
         * Calculates the greatest common divisor and Bezout's identity.
         *
         * Say you have 693 and 609.  The GCD is 21.  Bezout's identity states that there exist integers x and y such that
         * 693*x + 609*y == 21.  In point of fact, there are actually an infinite number of x and y combinations and which
         * combination is returned is dependent upon which mode is in use.  See
         * {@link http://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity Bezout's identity - Wikipedia} for more information.
         *
         * @param GMP $n
         * @return GMP[]
         */
        public function extendedGCD(\phpseclib3\Math\BigInteger\Engines\GMP $n)
        {
        }
        /**
         * Calculates the greatest common divisor
         *
         * Say you have 693 and 609.  The GCD is 21.
         *
         * @param GMP $n
         * @return GMP
         */
        public function gcd(\phpseclib3\Math\BigInteger\Engines\GMP $n)
        {
        }
        /**
         * Absolute value.
         *
         * @return GMP
         */
        public function abs()
        {
        }
        /**
         * Logical And
         *
         * @param GMP $x
         * @return GMP
         */
        public function bitwise_and(\phpseclib3\Math\BigInteger\Engines\GMP $x)
        {
        }
        /**
         * Logical Or
         *
         * @param GMP $x
         * @return GMP
         */
        public function bitwise_or(\phpseclib3\Math\BigInteger\Engines\GMP $x)
        {
        }
        /**
         * Logical Exclusive Or
         *
         * @param GMP $x
         * @return GMP
         */
        public function bitwise_xor(\phpseclib3\Math\BigInteger\Engines\GMP $x)
        {
        }
        /**
         * Logical Right Shift
         *
         * Shifts BigInteger's by $shift bits, effectively dividing by 2**$shift.
         *
         * @param int $shift
         * @return GMP
         */
        public function bitwise_rightShift($shift)
        {
        }
        /**
         * Logical Left Shift
         *
         * Shifts BigInteger's by $shift bits, effectively multiplying by 2**$shift.
         *
         * @param int $shift
         * @return GMP
         */
        public function bitwise_leftShift($shift)
        {
        }
        /**
         * Performs modular exponentiation.
         *
         * @param GMP $e
         * @param GMP $n
         * @return GMP
         */
        public function modPow(\phpseclib3\Math\BigInteger\Engines\GMP $e, \phpseclib3\Math\BigInteger\Engines\GMP $n)
        {
        }
        /**
         * Performs modular exponentiation.
         *
         * Alias for modPow().
         *
         * @param GMP $e
         * @param GMP $n
         * @return GMP
         */
        public function powMod(\phpseclib3\Math\BigInteger\Engines\GMP $e, \phpseclib3\Math\BigInteger\Engines\GMP $n)
        {
        }
        /**
         * Performs modular exponentiation.
         *
         * @param GMP $e
         * @param GMP $n
         * @return GMP
         */
        protected function powModInner(\phpseclib3\Math\BigInteger\Engines\GMP $e, \phpseclib3\Math\BigInteger\Engines\GMP $n)
        {
        }
        /**
         * Normalize
         *
         * Removes leading zeros and truncates (if necessary) to maintain the appropriate precision
         *
         * @param GMP $result
         * @return GMP
         */
        protected function normalize(\phpseclib3\Math\BigInteger\Engines\GMP $result)
        {
        }
        /**
         * Performs some post-processing for randomRangePrime
         *
         * @param Engine $x
         * @param Engine $min
         * @param Engine $max
         * @return GMP
         */
        protected static function randomRangePrimeInner(\phpseclib3\Math\BigInteger\Engines\Engine $x, \phpseclib3\Math\BigInteger\Engines\Engine $min, \phpseclib3\Math\BigInteger\Engines\Engine $max)
        {
        }
        /**
         * Generate a random prime number between a range
         *
         * If there's not a prime within the given range, false will be returned.
         *
         * @param GMP $min
         * @param GMP $max
         * @return false|GMP
         */
        public static function randomRangePrime(\phpseclib3\Math\BigInteger\Engines\GMP $min, \phpseclib3\Math\BigInteger\Engines\GMP $max)
        {
        }
        /**
         * Generate a random number between a range
         *
         * Returns a random number between $min and $max where $min and $max
         * can be defined using one of the two methods:
         *
         * BigInteger::randomRange($min, $max)
         * BigInteger::randomRange($max, $min)
         *
         * @param GMP $min
         * @param GMP $max
         * @return GMP
         */
        public static function randomRange(\phpseclib3\Math\BigInteger\Engines\GMP $min, \phpseclib3\Math\BigInteger\Engines\GMP $max)
        {
        }
        /**
         * Make the current number odd
         *
         * If the current number is odd it'll be unchanged.  If it's even, one will be added to it.
         *
         * @see self::randomPrime()
         */
        protected function make_odd()
        {
        }
        /**
         * Tests Primality
         *
         * @param int $t
         * @return bool
         */
        protected function testPrimality($t)
        {
        }
        /**
         * Calculates the nth root of a biginteger.
         *
         * Returns the nth root of a positive biginteger, where n defaults to 2
         *
         * @param int $n
         * @return GMP
         */
        protected function rootInner($n)
        {
        }
        /**
         * Performs exponentiation.
         *
         * @param GMP $n
         * @return GMP
         */
        public function pow(\phpseclib3\Math\BigInteger\Engines\GMP $n)
        {
        }
        /**
         * Return the minimum BigInteger between an arbitrary number of BigIntegers.
         *
         * @param GMP ...$nums
         * @return GMP
         */
        public static function min(\phpseclib3\Math\BigInteger\Engines\GMP ...$nums)
        {
        }
        /**
         * Return the maximum BigInteger between an arbitrary number of BigIntegers.
         *
         * @param GMP ...$nums
         * @return GMP
         */
        public static function max(\phpseclib3\Math\BigInteger\Engines\GMP ...$nums)
        {
        }
        /**
         * Tests BigInteger to see if it is between two integers, inclusive
         *
         * @param GMP $min
         * @param GMP $max
         * @return bool
         */
        public function between(\phpseclib3\Math\BigInteger\Engines\GMP $min, \phpseclib3\Math\BigInteger\Engines\GMP $max)
        {
        }
        /**
         * Create Recurring Modulo Function
         *
         * Sometimes it may be desirable to do repeated modulos with the same number outside of
         * modular exponentiation
         *
         * @return callable
         */
        public function createRecurringModuloFunction()
        {
        }
        /**
         * Scan for 1 and right shift by that amount
         *
         * ie. $s = gmp_scan1($n, 0) and $r = gmp_div_q($n, gmp_pow(gmp_init('2'), $s));
         *
         * @param GMP $r
         * @return int
         */
        public static function scan1divide(\phpseclib3\Math\BigInteger\Engines\GMP $r)
        {
        }
        /**
         * Is Odd?
         *
         * @return bool
         */
        public function isOdd()
        {
        }
        /**
         * Tests if a bit is set
         *
         * @return bool
         */
        public function testBit($x)
        {
        }
        /**
         * Is Negative?
         *
         * @return bool
         */
        public function isNegative()
        {
        }
        /**
         * Negate
         *
         * Given $k, returns -$k
         *
         * @return GMP
         */
        public function negate()
        {
        }
    }
}
namespace phpseclib3\Math\BigInteger\Engines\GMP {
    /**
     * GMP Modular Exponentiation Engine
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class DefaultEngine extends \phpseclib3\Math\BigInteger\Engines\GMP
    {
        /**
         * Performs modular exponentiation.
         *
         * @param GMP $x
         * @param GMP $e
         * @param GMP $n
         * @return GMP
         */
        protected static function powModHelper(\phpseclib3\Math\BigInteger\Engines\GMP $x, \phpseclib3\Math\BigInteger\Engines\GMP $e, \phpseclib3\Math\BigInteger\Engines\GMP $n)
        {
        }
    }
}
namespace phpseclib3\Math\BigInteger\Engines {
    /**
     * Pure-PHP Engine.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PHP extends \phpseclib3\Math\BigInteger\Engines\Engine
    {
        /**#@+
         * Array constants
         *
         * Rather than create a thousands and thousands of new BigInteger objects in repeated function calls to add() and
         * multiply() or whatever, we'll just work directly on arrays, taking them in as parameters and returning them.
         *
         */
        /**
         * $result[self::VALUE] contains the value.
         */
        const VALUE = 0;
        /**
         * $result[self::SIGN] contains the sign.
         */
        const SIGN = 1;
        /**#@-*/
        /**
         * Karatsuba Cutoff
         *
         * At what point do we switch between Karatsuba multiplication and schoolbook long multiplication?
         *
         */
        const KARATSUBA_CUTOFF = 25;
        /**
         * Can Bitwise operations be done fast?
         *
         * @see parent::bitwise_leftRotate()
         * @see parent::bitwise_rightRotate()
         */
        const FAST_BITWISE = true;
        /**
         * Engine Directory
         *
         * @see parent::setModExpEngine
         */
        const ENGINE_DIR = 'PHP';
        /**
         * Default constructor
         *
         * @param mixed $x integer Base-10 number or base-$base number if $base set.
         * @param int $base
         * @return PHP
         * @see parent::__construct()
         */
        public function __construct($x = 0, $base = 10)
        {
        }
        /**
         * Initialize a PHP BigInteger Engine instance
         *
         * @param int $base
         * @see parent::__construct()
         */
        protected function initialize($base)
        {
        }
        /**
         * Pads strings so that unpack may be used on them
         *
         * @param string $str
         * @return string
         */
        protected function pad($str)
        {
        }
        /**
         * Converts a BigInteger to a base-10 number.
         *
         * @return string
         */
        public function toString()
        {
        }
        /**
         * Converts a BigInteger to a byte string (eg. base-256).
         *
         * @param bool $twos_compliment
         * @return string
         */
        public function toBytes($twos_compliment = false)
        {
        }
        /**
         * Performs addition.
         *
         * @param array $x_value
         * @param bool $x_negative
         * @param array $y_value
         * @param bool $y_negative
         * @return array
         */
        protected static function addHelper(array $x_value, $x_negative, array $y_value, $y_negative)
        {
        }
        /**
         * Performs subtraction.
         *
         * @param array $x_value
         * @param bool $x_negative
         * @param array $y_value
         * @param bool $y_negative
         * @return array
         */
        public static function subtractHelper(array $x_value, $x_negative, array $y_value, $y_negative)
        {
        }
        /**
         * Performs multiplication.
         *
         * @param array $x_value
         * @param bool $x_negative
         * @param array $y_value
         * @param bool $y_negative
         * @return array
         */
        protected static function multiplyHelper(array $x_value, $x_negative, array $y_value, $y_negative)
        {
        }
        /**
         * Performs long multiplication on two BigIntegers
         *
         * Modeled after 'multiply' in MutableBigInteger.java.
         *
         * @param array $x_value
         * @param array $y_value
         * @return array
         */
        protected static function regularMultiply(array $x_value, array $y_value)
        {
        }
        /**
         * Divides two BigIntegers.
         *
         * Returns an array whose first element contains the quotient and whose second element contains the
         * "common residue".  If the remainder would be positive, the "common residue" and the remainder are the
         * same.  If the remainder would be negative, the "common residue" is equal to the sum of the remainder
         * and the divisor (basically, the "common residue" is the first positive modulo).
         *
         * @return array{static, static}
         * @internal This function is based off of
         *     {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=9 HAC 14.20}.
         */
        protected function divideHelper(\phpseclib3\Math\BigInteger\Engines\PHP $y)
        {
        }
        /**
         * Convert an array / boolean to a PHP BigInteger object
         *
         * @param array $arr
         * @return static
         */
        protected function convertToObj(array $arr)
        {
        }
        /**
         * Normalize
         *
         * Removes leading zeros and truncates (if necessary) to maintain the appropriate precision
         *
         * @param PHP $result
         * @return static
         */
        protected function normalize(\phpseclib3\Math\BigInteger\Engines\PHP $result)
        {
        }
        /**
         * Compares two numbers.
         *
         * @param array $x_value
         * @param bool $x_negative
         * @param array $y_value
         * @param bool $y_negative
         * @return int
         * @see static::compare()
         */
        protected static function compareHelper(array $x_value, $x_negative, array $y_value, $y_negative)
        {
        }
        /**
         * Absolute value.
         *
         * @return PHP
         */
        public function abs()
        {
        }
        /**
         * Trim
         *
         * Removes leading zeros
         *
         * @param list<static> $value
         * @return list<static>
         */
        protected static function trim(array $value)
        {
        }
        /**
         * Logical Right Shift
         *
         * Shifts BigInteger's by $shift bits, effectively dividing by 2**$shift.
         *
         * @param int $shift
         * @return PHP
         */
        public function bitwise_rightShift($shift)
        {
        }
        /**
         * Logical Left Shift
         *
         * Shifts BigInteger's by $shift bits, effectively multiplying by 2**$shift.
         *
         * @param int $shift
         * @return PHP
         */
        public function bitwise_leftShift($shift)
        {
        }
        /**
         * Array Repeat
         *
         * @param int $input
         * @param int $multiplier
         * @return array
         */
        protected static function array_repeat($input, $multiplier)
        {
        }
        /**
         * Logical Left Shift
         *
         * Shifts BigInteger's by $shift bits.
         *
         * @param int $shift
         */
        protected function lshift($shift)
        {
        }
        /**
         * Logical Right Shift
         *
         * Shifts BigInteger's by $shift bits.
         *
         * @param int $shift
         */
        protected function rshift($shift)
        {
        }
        /**
         * Performs modular exponentiation.
         *
         * @param PHP $e
         * @param PHP $n
         * @return PHP
         */
        protected function powModInner(\phpseclib3\Math\BigInteger\Engines\PHP $e, \phpseclib3\Math\BigInteger\Engines\PHP $n)
        {
        }
        /**
         * Performs squaring
         *
         * @param list<static> $x
         * @return list<static>
         */
        protected static function square(array $x)
        {
        }
        /**
         * Performs traditional squaring on two BigIntegers
         *
         * Squaring can be done faster than multiplying a number by itself can be.  See
         * {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=7 HAC 14.2.4} /
         * {@link http://math.libtomcrypt.com/files/tommath.pdf#page=141 MPM 5.3} for more information.
         *
         * @param array $value
         * @return array
         */
        protected static function baseSquare(array $value)
        {
        }
        /**
         * Performs Karatsuba "squaring" on two BigIntegers
         *
         * See {@link http://en.wikipedia.org/wiki/Karatsuba_algorithm Karatsuba algorithm} and
         * {@link http://math.libtomcrypt.com/files/tommath.pdf#page=151 MPM 5.3.4}.
         *
         * @param array $value
         * @return array
         */
        protected static function karatsubaSquare(array $value)
        {
        }
        /**
         * Make the current number odd
         *
         * If the current number is odd it'll be unchanged.  If it's even, one will be added to it.
         *
         * @see self::randomPrime()
         */
        protected function make_odd()
        {
        }
        /**
         * Test the number against small primes.
         *
         * @see self::isPrime()
         */
        protected function testSmallPrimes()
        {
        }
        /**
         * Scan for 1 and right shift by that amount
         *
         * ie. $s = gmp_scan1($n, 0) and $r = gmp_div_q($n, gmp_pow(gmp_init('2'), $s));
         *
         * @param PHP $r
         * @return int
         * @see self::isPrime()
         */
        public static function scan1divide(\phpseclib3\Math\BigInteger\Engines\PHP $r)
        {
        }
        /**
         * Performs exponentiation.
         *
         * @param PHP $n
         * @return PHP
         */
        protected function powHelper(\phpseclib3\Math\BigInteger\Engines\PHP $n)
        {
        }
        /**
         * Is Odd?
         *
         * @return bool
         */
        public function isOdd()
        {
        }
        /**
         * Tests if a bit is set
         *
         * @return bool
         */
        public function testBit($x)
        {
        }
        /**
         * Is Negative?
         *
         * @return bool
         */
        public function isNegative()
        {
        }
        /**
         * Negate
         *
         * Given $k, returns -$k
         *
         * @return static
         */
        public function negate()
        {
        }
        /**
         * Bitwise Split
         *
         * Splits BigInteger's into chunks of $split bits
         *
         * @param int $split
         * @return list<static>
         */
        public function bitwise_split($split)
        {
        }
        /**
         * @return bool
         */
        protected static function testJITOnWindows()
        {
        }
        /**
         * Return the size of a BigInteger in bits
         *
         * @return int
         */
        public function getLength()
        {
        }
    }
}
namespace phpseclib3\Math\BigInteger\Engines\PHP {
    /**
     * PHP Modular Exponentiation Engine
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Base extends \phpseclib3\Math\BigInteger\Engines\PHP
    {
        /**
         * Cache constants
         *
         * $cache[self::VARIABLE] tells us whether or not the cached data is still valid.
         *
         */
        const VARIABLE = 0;
        /**
         * $cache[self::DATA] contains the cached data.
         *
         */
        const DATA = 1;
        /**
         * Test for engine validity
         *
         * @return bool
         */
        public static function isValidEngine()
        {
        }
        /**
         * Performs modular exponentiation.
         *
         * The most naive approach to modular exponentiation has very unreasonable requirements, and
         * and although the approach involving repeated squaring does vastly better, it, too, is impractical
         * for our purposes.  The reason being that division - by far the most complicated and time-consuming
         * of the basic operations (eg. +,-,*,/) - occurs multiple times within it.
         *
         * Modular reductions resolve this issue.  Although an individual modular reduction takes more time
         * then an individual division, when performed in succession (with the same modulo), they're a lot faster.
         *
         * The two most commonly used modular reductions are Barrett and Montgomery reduction.  Montgomery reduction,
         * although faster, only works when the gcd of the modulo and of the base being used is 1.  In RSA, when the
         * base is a power of two, the modulo - a product of two primes - is always going to have a gcd of 1 (because
         * the product of two odd numbers is odd), but what about when RSA isn't used?
         *
         * In contrast, Barrett reduction has no such constraint.  As such, some bigint implementations perform a
         * Barrett reduction after every operation in the modpow function.  Others perform Barrett reductions when the
         * modulo is even and Montgomery reductions when the modulo is odd.  BigInteger.java's modPow method, however,
         * uses a trick involving the Chinese Remainder Theorem to factor the even modulo into two numbers - one odd and
         * the other, a power of two - and recombine them, later.  This is the method that this modPow function uses.
         * {@link http://islab.oregonstate.edu/papers/j34monex.pdf Montgomery Reduction with Even Modulus} elaborates.
         *
         * @param PHP $x
         * @param PHP $e
         * @param PHP $n
         * @param string $class
         * @return PHP
         */
        protected static function powModHelper(\phpseclib3\Math\BigInteger\Engines\PHP $x, \phpseclib3\Math\BigInteger\Engines\PHP $e, \phpseclib3\Math\BigInteger\Engines\PHP $n, $class)
        {
        }
        /**
         * Modular reduction preparation
         *
         * @param array $x
         * @param array $n
         * @param string $class
         * @see self::slidingWindow()
         * @return array
         */
        protected static function prepareReduce(array $x, array $n, $class)
        {
        }
        /**
         * Modular multiply
         *
         * @param array $x
         * @param array $y
         * @param array $n
         * @param string $class
         * @see self::slidingWindow()
         * @return array
         */
        protected static function multiplyReduce(array $x, array $y, array $n, $class)
        {
        }
        /**
         * Modular square
         *
         * @param array $x
         * @param array $n
         * @param string $class
         * @see self::slidingWindow()
         * @return array
         */
        protected static function squareReduce(array $x, array $n, $class)
        {
        }
    }
}
namespace phpseclib3\Math\BigInteger\Engines\PHP\Reductions {
    /**
     * PHP Dynamic Barrett Modular Exponentiation Engine
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class EvalBarrett extends \phpseclib3\Math\BigInteger\Engines\PHP\Base
    {
        /**
         * Barrett Modular Reduction
         *
         * This calls a dynamically generated loop unrolled function that's specific to a given modulo.
         * Array lookups are avoided as are if statements testing for how many bits the host OS supports, etc.
         *
         * @param array $n
         * @param array $m
         * @param string $class
         * @return array
         */
        protected static function reduce(array $n, array $m, $class)
        {
        }
        /**
         * Generate Custom Reduction
         *
         * @param PHP $m
         * @param string $class
         * @return callable
         */
        protected static function generateCustomReduction(\phpseclib3\Math\BigInteger\Engines\PHP $m, $class)
        {
        }
    }
}
namespace phpseclib3\Math\BigInteger\Engines\PHP {
    /**
     * PHP Default Modular Exponentiation Engine
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class DefaultEngine extends \phpseclib3\Math\BigInteger\Engines\PHP\Reductions\EvalBarrett
    {
    }
    /**
     * PHP Montgomery Modular Exponentiation Engine
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Montgomery extends \phpseclib3\Math\BigInteger\Engines\PHP\Base
    {
        /**
         * Test for engine validity
         *
         * @return bool
         */
        public static function isValidEngine()
        {
        }
        /**
         * Performs modular exponentiation.
         *
         * @template T of Engine
         * @param Engine $x
         * @param Engine $e
         * @param Engine $n
         * @param class-string<T> $class
         * @return T
         */
        protected static function slidingWindow(\phpseclib3\Math\BigInteger\Engines\Engine $x, \phpseclib3\Math\BigInteger\Engines\Engine $e, \phpseclib3\Math\BigInteger\Engines\Engine $n, $class)
        {
        }
    }
    /**
     * OpenSSL Modular Exponentiation Engine
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class OpenSSL extends \phpseclib3\Math\BigInteger\Engines\OpenSSL
    {
    }
}
namespace phpseclib3\Math\BigInteger\Engines\PHP\Reductions {
    /**
     * PHP Barrett Modular Exponentiation Engine
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Barrett extends \phpseclib3\Math\BigInteger\Engines\PHP\Base
    {
        /**
         * Barrett Modular Reduction
         *
         * See {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=14 HAC 14.3.3} /
         * {@link http://math.libtomcrypt.com/files/tommath.pdf#page=165 MPM 6.2.5} for more information.  Modified slightly,
         * so as not to require negative numbers (initially, this script didn't support negative numbers).
         *
         * Employs "folding", as described at
         * {@link http://www.cosic.esat.kuleuven.be/publications/thesis-149.pdf#page=66 thesis-149.pdf#page=66}.  To quote from
         * it, "the idea [behind folding] is to find a value x' such that x (mod m) = x' (mod m), with x' being smaller than x."
         *
         * Unfortunately, the "Barrett Reduction with Folding" algorithm described in thesis-149.pdf is not, as written, all that
         * usable on account of (1) its not using reasonable radix points as discussed in
         * {@link http://math.libtomcrypt.com/files/tommath.pdf#page=162 MPM 6.2.2} and (2) the fact that, even with reasonable
         * radix points, it only works when there are an even number of digits in the denominator.  The reason for (2) is that
         * (x >> 1) + (x >> 1) != x / 2 + x / 2.  If x is even, they're the same, but if x is odd, they're not.  See the in-line
         * comments for details.
         *
         * @param array $n
         * @param array $m
         * @param class-string<PHP> $class
         * @return array
         */
        protected static function reduce(array $n, array $m, $class)
        {
        }
    }
    /**
     * PHP Classic Modular Exponentiation Engine
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Classic extends \phpseclib3\Math\BigInteger\Engines\PHP\Base
    {
        /**
         * Regular Division
         *
         * @param array $x
         * @param array $n
         * @param string $class
         * @return array
         */
        protected static function reduce(array $x, array $n, $class)
        {
        }
    }
    /**
     * PHP Montgomery Modular Exponentiation Engine
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Montgomery extends \phpseclib3\Math\BigInteger\Engines\PHP\Montgomery
    {
        /**
         * Prepare a number for use in Montgomery Modular Reductions
         *
         * @param array $x
         * @param array $n
         * @param string $class
         * @return array
         */
        protected static function prepareReduce(array $x, array $n, $class)
        {
        }
        /**
         * Montgomery Multiply
         *
         * Interleaves the montgomery reduction and long multiplication algorithms together as described in
         * {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=13 HAC 14.36}
         *
         * @param array $x
         * @param array $n
         * @param string $class
         * @return array
         */
        protected static function reduce(array $x, array $n, $class)
        {
        }
        /**
         * Modular Inverse of a number mod 2**26 (eg. 67108864)
         *
         * Based off of the bnpInvDigit function implemented and justified in the following URL:
         *
         * {@link http://www-cs-students.stanford.edu/~tjw/jsbn/jsbn.js}
         *
         * The following URL provides more info:
         *
         * {@link http://groups.google.com/group/sci.crypt/msg/7a137205c1be7d85}
         *
         * As for why we do all the bitmasking...  strange things can happen when converting from floats to ints. For
         * instance, on some computers, var_dump((int) -4294967297) yields int(-1) and on others, it yields
         * int(-2147483648).  To avoid problems stemming from this, we use bitmasks to guarantee that ints aren't
         * auto-converted to floats.  The outermost bitmask is present because without it, there's no guarantee that
         * the "residue" returned would be the so-called "common residue".  We use fmod, in the last step, because the
         * maximum possible $x is 26 bits and the maximum $result is 16 bits.  Thus, we have to be able to handle up to
         * 40 bits, which only 64-bit floating points will support.
         *
         * Thanks to Pedro Gimeno Fortea for input!
         *
         * @param array $x
         * @param string $class
         * @return int
         */
        protected static function modInverse67108864(array $x, $class)
        {
        }
    }
    /**
     * PHP Montgomery Modular Exponentiation Engine with interleaved multiplication
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class MontgomeryMult extends \phpseclib3\Math\BigInteger\Engines\PHP\Reductions\Montgomery
    {
        /**
         * Montgomery Multiply
         *
         * Interleaves the montgomery reduction and long multiplication algorithms together as described in
         * {@link http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf#page=13 HAC 14.36}
         *
         * @see self::_prepMontgomery()
         * @see self::_montgomery()
         * @param array $x
         * @param array $y
         * @param array $m
         * @param class-string<PHP> $class
         * @return array
         */
        public static function multiplyReduce(array $x, array $y, array $m, $class)
        {
        }
    }
    /**
     * PHP Power Of Two Modular Exponentiation Engine
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class PowerOfTwo extends \phpseclib3\Math\BigInteger\Engines\PHP\Base
    {
        /**
         * Prepare a number for use in Montgomery Modular Reductions
         *
         * @param array $x
         * @param array $n
         * @param string $class
         * @return array
         */
        protected static function prepareReduce(array $x, array $n, $class)
        {
        }
        /**
         * Power Of Two Reduction
         *
         * @param array $x
         * @param array $n
         * @param string $class
         * @return array
         */
        protected static function reduce(array $x, array $n, $class)
        {
        }
    }
}
namespace phpseclib3\Math\BigInteger\Engines {
    /**
     * Pure-PHP 32-bit Engine.
     *
     * Uses 64-bit floats if int size is 4 bits
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class PHP32 extends \phpseclib3\Math\BigInteger\Engines\PHP
    {
        // Constants used by PHP.php
        const BASE = 26;
        const BASE_FULL = 0x4000000;
        const MAX_DIGIT = 0x3ffffff;
        const MSB = 0x2000000;
        /**
         * MAX10 in greatest MAX10LEN satisfying
         * MAX10 = 10**MAX10LEN <= 2**BASE.
         */
        const MAX10 = 10000000;
        /**
         * MAX10LEN in greatest MAX10LEN satisfying
         * MAX10 = 10**MAX10LEN <= 2**BASE.
         */
        const MAX10LEN = 7;
        const MAX_DIGIT2 = 4503599627370496;
        /**
         * Initialize a PHP32 BigInteger Engine instance
         *
         * @param int $base
         * @see parent::initialize()
         */
        protected function initialize($base)
        {
        }
        /**
         * Test for engine validity
         *
         * @see parent::__construct()
         * @return bool
         */
        public static function isValidEngine()
        {
        }
        /**
         * Adds two BigIntegers.
         *
         * @param PHP32 $y
         * @return PHP32
         */
        public function add(\phpseclib3\Math\BigInteger\Engines\PHP32 $y)
        {
        }
        /**
         * Subtracts two BigIntegers.
         *
         * @param PHP32 $y
         * @return PHP32
         */
        public function subtract(\phpseclib3\Math\BigInteger\Engines\PHP32 $y)
        {
        }
        /**
         * Multiplies two BigIntegers.
         *
         * @param PHP32 $y
         * @return PHP32
         */
        public function multiply(\phpseclib3\Math\BigInteger\Engines\PHP32 $y)
        {
        }
        /**
         * Divides two BigIntegers.
         *
         * Returns an array whose first element contains the quotient and whose second element contains the
         * "common residue".  If the remainder would be positive, the "common residue" and the remainder are the
         * same.  If the remainder would be negative, the "common residue" is equal to the sum of the remainder
         * and the divisor (basically, the "common residue" is the first positive modulo).
         *
         * @param PHP32 $y
         * @return array{PHP32, PHP32}
         */
        public function divide(\phpseclib3\Math\BigInteger\Engines\PHP32 $y)
        {
        }
        /**
         * Calculates modular inverses.
         *
         * Say you have (30 mod 17 * x mod 17) mod 17 == 1.  x can be found using modular inverses.
         * @param PHP32 $n
         * @return false|PHP32
         */
        public function modInverse(\phpseclib3\Math\BigInteger\Engines\PHP32 $n)
        {
        }
        /**
         * Calculates modular inverses.
         *
         * Say you have (30 mod 17 * x mod 17) mod 17 == 1.  x can be found using modular inverses.
         * @param PHP32 $n
         * @return PHP32[]
         */
        public function extendedGCD(\phpseclib3\Math\BigInteger\Engines\PHP32 $n)
        {
        }
        /**
         * Calculates the greatest common divisor
         *
         * Say you have 693 and 609.  The GCD is 21.
         *
         * @param PHP32 $n
         * @return PHP32
         */
        public function gcd(\phpseclib3\Math\BigInteger\Engines\PHP32 $n)
        {
        }
        /**
         * Logical And
         *
         * @param PHP32 $x
         * @return PHP32
         */
        public function bitwise_and(\phpseclib3\Math\BigInteger\Engines\PHP32 $x)
        {
        }
        /**
         * Logical Or
         *
         * @param PHP32 $x
         * @return PHP32
         */
        public function bitwise_or(\phpseclib3\Math\BigInteger\Engines\PHP32 $x)
        {
        }
        /**
         * Logical Exclusive Or
         *
         * @param PHP32 $x
         * @return PHP32
         */
        public function bitwise_xor(\phpseclib3\Math\BigInteger\Engines\PHP32 $x)
        {
        }
        /**
         * Compares two numbers.
         *
         * Although one might think !$x->compare($y) means $x != $y, it, in fact, means the opposite.  The reason for this is
         * demonstrated thusly:
         *
         * $x  > $y: $x->compare($y)  > 0
         * $x  < $y: $x->compare($y)  < 0
         * $x == $y: $x->compare($y) == 0
         *
         * Note how the same comparison operator is used.  If you want to test for equality, use $x->equals($y).
         *
         * {@internal Could return $this->subtract($x), but that's not as fast as what we do do.}
         *
         * @param PHP32 $y
         * @return int in case < 0 if $this is less than $y; > 0 if $this is greater than $y, and 0 if they are equal.
         * @see self::equals()
         */
        public function compare(\phpseclib3\Math\BigInteger\Engines\PHP32 $y)
        {
        }
        /**
         * Tests the equality of two numbers.
         *
         * If you need to see if one number is greater than or less than another number, use BigInteger::compare()
         *
         * @param PHP32 $x
         * @return bool
         */
        public function equals(\phpseclib3\Math\BigInteger\Engines\PHP32 $x)
        {
        }
        /**
         * Performs modular exponentiation.
         *
         * @param PHP32 $e
         * @param PHP32 $n
         * @return PHP32
         */
        public function modPow(\phpseclib3\Math\BigInteger\Engines\PHP32 $e, \phpseclib3\Math\BigInteger\Engines\PHP32 $n)
        {
        }
        /**
         * Performs modular exponentiation.
         *
         * Alias for modPow().
         *
         * @param PHP32 $e
         * @param PHP32 $n
         * @return PHP32
         */
        public function powMod(\phpseclib3\Math\BigInteger\Engines\PHP32 $e, \phpseclib3\Math\BigInteger\Engines\PHP32 $n)
        {
        }
        /**
         * Generate a random prime number between a range
         *
         * If there's not a prime within the given range, false will be returned.
         *
         * @param PHP32 $min
         * @param PHP32 $max
         * @return false|PHP32
         */
        public static function randomRangePrime(\phpseclib3\Math\BigInteger\Engines\PHP32 $min, \phpseclib3\Math\BigInteger\Engines\PHP32 $max)
        {
        }
        /**
         * Generate a random number between a range
         *
         * Returns a random number between $min and $max where $min and $max
         * can be defined using one of the two methods:
         *
         * BigInteger::randomRange($min, $max)
         * BigInteger::randomRange($max, $min)
         *
         * @param PHP32 $min
         * @param PHP32 $max
         * @return PHP32
         */
        public static function randomRange(\phpseclib3\Math\BigInteger\Engines\PHP32 $min, \phpseclib3\Math\BigInteger\Engines\PHP32 $max)
        {
        }
        /**
         * Performs exponentiation.
         *
         * @param PHP32 $n
         * @return PHP32
         */
        public function pow(\phpseclib3\Math\BigInteger\Engines\PHP32 $n)
        {
        }
        /**
         * Return the minimum BigInteger between an arbitrary number of BigIntegers.
         *
         * @param PHP32 ...$nums
         * @return PHP32
         */
        public static function min(\phpseclib3\Math\BigInteger\Engines\PHP32 ...$nums)
        {
        }
        /**
         * Return the maximum BigInteger between an arbitrary number of BigIntegers.
         *
         * @param PHP32 ...$nums
         * @return PHP32
         */
        public static function max(\phpseclib3\Math\BigInteger\Engines\PHP32 ...$nums)
        {
        }
        /**
         * Tests BigInteger to see if it is between two integers, inclusive
         *
         * @param PHP32 $min
         * @param PHP32 $max
         * @return bool
         */
        public function between(\phpseclib3\Math\BigInteger\Engines\PHP32 $min, \phpseclib3\Math\BigInteger\Engines\PHP32 $max)
        {
        }
    }
    /**
     * Pure-PHP 64-bit Engine.
     *
     * Uses 64-bit integers if int size is 8 bits
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class PHP64 extends \phpseclib3\Math\BigInteger\Engines\PHP
    {
        // Constants used by PHP.php
        const BASE = 31;
        const BASE_FULL = 0x80000000;
        const MAX_DIGIT = 0x7fffffff;
        const MSB = 0x40000000;
        /**
         * MAX10 in greatest MAX10LEN satisfying
         * MAX10 = 10**MAX10LEN <= 2**BASE.
         */
        const MAX10 = 1000000000;
        /**
         * MAX10LEN in greatest MAX10LEN satisfying
         * MAX10 = 10**MAX10LEN <= 2**BASE.
         */
        const MAX10LEN = 9;
        const MAX_DIGIT2 = 4611686018427387904;
        /**
         * Initialize a PHP64 BigInteger Engine instance
         *
         * @param int $base
         * @see parent::initialize()
         */
        protected function initialize($base)
        {
        }
        /**
         * Test for engine validity
         *
         * @see parent::__construct()
         * @return bool
         */
        public static function isValidEngine()
        {
        }
        /**
         * Adds two BigIntegers.
         *
         * @param PHP64 $y
         * @return PHP64
         */
        public function add(\phpseclib3\Math\BigInteger\Engines\PHP64 $y)
        {
        }
        /**
         * Subtracts two BigIntegers.
         *
         * @param PHP64 $y
         * @return PHP64
         */
        public function subtract(\phpseclib3\Math\BigInteger\Engines\PHP64 $y)
        {
        }
        /**
         * Multiplies two BigIntegers.
         *
         * @param PHP64 $y
         * @return PHP64
         */
        public function multiply(\phpseclib3\Math\BigInteger\Engines\PHP64 $y)
        {
        }
        /**
         * Divides two BigIntegers.
         *
         * Returns an array whose first element contains the quotient and whose second element contains the
         * "common residue".  If the remainder would be positive, the "common residue" and the remainder are the
         * same.  If the remainder would be negative, the "common residue" is equal to the sum of the remainder
         * and the divisor (basically, the "common residue" is the first positive modulo).
         *
         * @param PHP64 $y
         * @return array{PHP64, PHP64}
         */
        public function divide(\phpseclib3\Math\BigInteger\Engines\PHP64 $y)
        {
        }
        /**
         * Calculates modular inverses.
         *
         * Say you have (30 mod 17 * x mod 17) mod 17 == 1.  x can be found using modular inverses.
         * @param PHP64 $n
         * @return false|PHP64
         */
        public function modInverse(\phpseclib3\Math\BigInteger\Engines\PHP64 $n)
        {
        }
        /**
         * Calculates modular inverses.
         *
         * Say you have (30 mod 17 * x mod 17) mod 17 == 1.  x can be found using modular inverses.
         * @param PHP64 $n
         * @return PHP64[]
         */
        public function extendedGCD(\phpseclib3\Math\BigInteger\Engines\PHP64 $n)
        {
        }
        /**
         * Calculates the greatest common divisor
         *
         * Say you have 693 and 609.  The GCD is 21.
         *
         * @param PHP64 $n
         * @return PHP64
         */
        public function gcd(\phpseclib3\Math\BigInteger\Engines\PHP64 $n)
        {
        }
        /**
         * Logical And
         *
         * @param PHP64 $x
         * @return PHP64
         */
        public function bitwise_and(\phpseclib3\Math\BigInteger\Engines\PHP64 $x)
        {
        }
        /**
         * Logical Or
         *
         * @param PHP64 $x
         * @return PHP64
         */
        public function bitwise_or(\phpseclib3\Math\BigInteger\Engines\PHP64 $x)
        {
        }
        /**
         * Logical Exclusive Or
         *
         * @param PHP64 $x
         * @return PHP64
         */
        public function bitwise_xor(\phpseclib3\Math\BigInteger\Engines\PHP64 $x)
        {
        }
        /**
         * Compares two numbers.
         *
         * Although one might think !$x->compare($y) means $x != $y, it, in fact, means the opposite.  The reason for this is
         * demonstrated thusly:
         *
         * $x  > $y: $x->compare($y)  > 0
         * $x  < $y: $x->compare($y)  < 0
         * $x == $y: $x->compare($y) == 0
         *
         * Note how the same comparison operator is used.  If you want to test for equality, use $x->equals($y).
         *
         * {@internal Could return $this->subtract($x), but that's not as fast as what we do do.}
         *
         * @param PHP64 $y
         * @return int in case < 0 if $this is less than $y; > 0 if $this is greater than $y, and 0 if they are equal.
         * @see self::equals()
         */
        public function compare(\phpseclib3\Math\BigInteger\Engines\PHP64 $y)
        {
        }
        /**
         * Tests the equality of two numbers.
         *
         * If you need to see if one number is greater than or less than another number, use BigInteger::compare()
         *
         * @param PHP64 $x
         * @return bool
         */
        public function equals(\phpseclib3\Math\BigInteger\Engines\PHP64 $x)
        {
        }
        /**
         * Performs modular exponentiation.
         *
         * @param PHP64 $e
         * @param PHP64 $n
         * @return PHP64
         */
        public function modPow(\phpseclib3\Math\BigInteger\Engines\PHP64 $e, \phpseclib3\Math\BigInteger\Engines\PHP64 $n)
        {
        }
        /**
         * Performs modular exponentiation.
         *
         * Alias for modPow().
         *
         * @param PHP64 $e
         * @param PHP64 $n
         * @return PHP64|false
         */
        public function powMod(\phpseclib3\Math\BigInteger\Engines\PHP64 $e, \phpseclib3\Math\BigInteger\Engines\PHP64 $n)
        {
        }
        /**
         * Generate a random prime number between a range
         *
         * If there's not a prime within the given range, false will be returned.
         *
         * @param PHP64 $min
         * @param PHP64 $max
         * @return false|PHP64
         */
        public static function randomRangePrime(\phpseclib3\Math\BigInteger\Engines\PHP64 $min, \phpseclib3\Math\BigInteger\Engines\PHP64 $max)
        {
        }
        /**
         * Generate a random number between a range
         *
         * Returns a random number between $min and $max where $min and $max
         * can be defined using one of the two methods:
         *
         * BigInteger::randomRange($min, $max)
         * BigInteger::randomRange($max, $min)
         *
         * @param PHP64 $min
         * @param PHP64 $max
         * @return PHP64
         */
        public static function randomRange(\phpseclib3\Math\BigInteger\Engines\PHP64 $min, \phpseclib3\Math\BigInteger\Engines\PHP64 $max)
        {
        }
        /**
         * Performs exponentiation.
         *
         * @param PHP64 $n
         * @return PHP64
         */
        public function pow(\phpseclib3\Math\BigInteger\Engines\PHP64 $n)
        {
        }
        /**
         * Return the minimum BigInteger between an arbitrary number of BigIntegers.
         *
         * @param PHP64 ...$nums
         * @return PHP64
         */
        public static function min(\phpseclib3\Math\BigInteger\Engines\PHP64 ...$nums)
        {
        }
        /**
         * Return the maximum BigInteger between an arbitrary number of BigIntegers.
         *
         * @param PHP64 ...$nums
         * @return PHP64
         */
        public static function max(\phpseclib3\Math\BigInteger\Engines\PHP64 ...$nums)
        {
        }
        /**
         * Tests BigInteger to see if it is between two integers, inclusive
         *
         * @param PHP64 $min
         * @param PHP64 $max
         * @return bool
         */
        public function between(\phpseclib3\Math\BigInteger\Engines\PHP64 $min, \phpseclib3\Math\BigInteger\Engines\PHP64 $max)
        {
        }
    }
}
namespace phpseclib3\Math {
    /**
     * Pure-PHP arbitrary precision integer arithmetic library. Supports base-2, base-10, base-16, and base-256
     * numbers.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class BigInteger implements \JsonSerializable
    {
        /**
         * Sets engine type.
         *
         * Throws an exception if the type is invalid
         *
         * @param string $main
         * @param list<string> $modexps optional
         * @return void
         */
        public static function setEngine($main, array $modexps = ['DefaultEngine'])
        {
        }
        /**
         * Returns the engine type
         *
         * @return string[]
         */
        public static function getEngine()
        {
        }
        /**
         * Converts base-2, base-10, base-16, and binary strings (base-256) to BigIntegers.
         *
         * If the second parameter - $base - is negative, then it will be assumed that the number's are encoded using
         * two's compliment.  The sole exception to this is -10, which is treated the same as 10 is.
         *
         * @param string|int|Engine $x Base-10 number or base-$base number if $base set.
         * @param int $base
         */
        public function __construct($x = 0, $base = 10)
        {
        }
        /**
         * Converts a BigInteger to a base-10 number.
         *
         * @return string
         */
        public function toString()
        {
        }
        /**
         *  __toString() magic method
         */
        public function __toString()
        {
        }
        /**
         *  __debugInfo() magic method
         *
         * Will be called, automatically, when print_r() or var_dump() are called
         */
        public function __debugInfo()
        {
        }
        /**
         * Converts a BigInteger to a byte string (eg. base-256).
         *
         * @param bool $twos_compliment
         * @return string
         */
        public function toBytes($twos_compliment = false)
        {
        }
        /**
         * Converts a BigInteger to a hex string (eg. base-16).
         *
         * @param bool $twos_compliment
         * @return string
         */
        public function toHex($twos_compliment = false)
        {
        }
        /**
         * Converts a BigInteger to a bit string (eg. base-2).
         *
         * Negative numbers are saved as positive numbers, unless $twos_compliment is set to true, at which point, they're
         * saved as two's compliment.
         *
         * @param bool $twos_compliment
         * @return string
         */
        public function toBits($twos_compliment = false)
        {
        }
        /**
         * Adds two BigIntegers.
         *
         * @param BigInteger $y
         * @return BigInteger
         */
        public function add(\phpseclib3\Math\BigInteger $y)
        {
        }
        /**
         * Subtracts two BigIntegers.
         *
         * @param BigInteger $y
         * @return BigInteger
         */
        public function subtract(\phpseclib3\Math\BigInteger $y)
        {
        }
        /**
         * Multiplies two BigIntegers
         *
         * @param BigInteger $x
         * @return BigInteger
         */
        public function multiply(\phpseclib3\Math\BigInteger $x)
        {
        }
        /**
         * Divides two BigIntegers.
         *
         * Returns an array whose first element contains the quotient and whose second element contains the
         * "common residue".  If the remainder would be positive, the "common residue" and the remainder are the
         * same.  If the remainder would be negative, the "common residue" is equal to the sum of the remainder
         * and the divisor (basically, the "common residue" is the first positive modulo).
         *
         * Here's an example:
         * <code>
         * <?php
         *    $a = new \phpseclib3\Math\BigInteger('10');
         *    $b = new \phpseclib3\Math\BigInteger('20');
         *
         *    list($quotient, $remainder) = $a->divide($b);
         *
         *    echo $quotient->toString(); // outputs 0
         *    echo "\r\n";
         *    echo $remainder->toString(); // outputs 10
         * ?>
         * </code>
         *
         * @param BigInteger $y
         * @return BigInteger[]
         */
        public function divide(\phpseclib3\Math\BigInteger $y)
        {
        }
        /**
         * Calculates modular inverses.
         *
         * Say you have (30 mod 17 * x mod 17) mod 17 == 1.  x can be found using modular inverses.
         *
         * @param BigInteger $n
         * @return BigInteger
         */
        public function modInverse(\phpseclib3\Math\BigInteger $n)
        {
        }
        /**
         * Calculates modular inverses.
         *
         * Say you have (30 mod 17 * x mod 17) mod 17 == 1.  x can be found using modular inverses.
         *
         * @param BigInteger $n
         * @return BigInteger[]
         */
        public function extendedGCD(\phpseclib3\Math\BigInteger $n)
        {
        }
        /**
         * Calculates the greatest common divisor
         *
         * Say you have 693 and 609.  The GCD is 21.
         *
         * @param BigInteger $n
         * @return BigInteger
         */
        public function gcd(\phpseclib3\Math\BigInteger $n)
        {
        }
        /**
         * Absolute value.
         *
         * @return BigInteger
         */
        public function abs()
        {
        }
        /**
         * Set Precision
         *
         * Some bitwise operations give different results depending on the precision being used.  Examples include left
         * shift, not, and rotates.
         *
         * @param int $bits
         */
        public function setPrecision($bits)
        {
        }
        /**
         * Get Precision
         *
         * Returns the precision if it exists, false if it doesn't
         *
         * @return int|bool
         */
        public function getPrecision()
        {
        }
        /**
         * Serialize
         *
         * Will be called, automatically, when serialize() is called on a BigInteger object.
         *
         * __sleep() / __wakeup() have been around since PHP 4.0
         *
         * \Serializable was introduced in PHP 5.1 and deprecated in PHP 8.1:
         * https://wiki.php.net/rfc/phase_out_serializable
         *
         * __serialize() / __unserialize() were introduced in PHP 7.4:
         * https://wiki.php.net/rfc/custom_object_serialization
         *
         * @return array
         */
        public function __sleep()
        {
        }
        /**
         * Serialize
         *
         * Will be called, automatically, when unserialize() is called on a BigInteger object.
         */
        public function __wakeup()
        {
        }
        /**
         * JSON Serialize
         *
         * Will be called, automatically, when json_encode() is called on a BigInteger object.
         *
         * @return array{hex: string, precision?: int]
         */
        #[\ReturnTypeWillChange]
        public function jsonSerialize()
        {
        }
        /**
         * Performs modular exponentiation.
         *
         * @param BigInteger $e
         * @param BigInteger $n
         * @return BigInteger
         */
        public function powMod(\phpseclib3\Math\BigInteger $e, \phpseclib3\Math\BigInteger $n)
        {
        }
        /**
         * Performs modular exponentiation.
         *
         * @param BigInteger $e
         * @param BigInteger $n
         * @return BigInteger
         */
        public function modPow(\phpseclib3\Math\BigInteger $e, \phpseclib3\Math\BigInteger $n)
        {
        }
        /**
         * Compares two numbers.
         *
         * Although one might think !$x->compare($y) means $x != $y, it, in fact, means the opposite.  The reason for this
         * is demonstrated thusly:
         *
         * $x  > $y: $x->compare($y)  > 0
         * $x  < $y: $x->compare($y)  < 0
         * $x == $y: $x->compare($y) == 0
         *
         * Note how the same comparison operator is used.  If you want to test for equality, use $x->equals($y).
         *
         * {@internal Could return $this->subtract($x), but that's not as fast as what we do do.}
         *
         * @param BigInteger $y
         * @return int in case < 0 if $this is less than $y; > 0 if $this is greater than $y, and 0 if they are equal.
         * @see self::equals()
         */
        public function compare(\phpseclib3\Math\BigInteger $y)
        {
        }
        /**
         * Tests the equality of two numbers.
         *
         * If you need to see if one number is greater than or less than another number, use BigInteger::compare()
         *
         * @param BigInteger $x
         * @return bool
         */
        public function equals(\phpseclib3\Math\BigInteger $x)
        {
        }
        /**
         * Logical Not
         *
         * @return BigInteger
         */
        public function bitwise_not()
        {
        }
        /**
         * Logical And
         *
         * @param BigInteger $x
         * @return BigInteger
         */
        public function bitwise_and(\phpseclib3\Math\BigInteger $x)
        {
        }
        /**
         * Logical Or
         *
         * @param BigInteger $x
         * @return BigInteger
         */
        public function bitwise_or(\phpseclib3\Math\BigInteger $x)
        {
        }
        /**
         * Logical Exclusive Or
         *
         * @param BigInteger $x
         * @return BigInteger
         */
        public function bitwise_xor(\phpseclib3\Math\BigInteger $x)
        {
        }
        /**
         * Logical Right Shift
         *
         * Shifts BigInteger's by $shift bits, effectively dividing by 2**$shift.
         *
         * @param int $shift
         * @return BigInteger
         */
        public function bitwise_rightShift($shift)
        {
        }
        /**
         * Logical Left Shift
         *
         * Shifts BigInteger's by $shift bits, effectively multiplying by 2**$shift.
         *
         * @param int $shift
         * @return BigInteger
         */
        public function bitwise_leftShift($shift)
        {
        }
        /**
         * Logical Left Rotate
         *
         * Instead of the top x bits being dropped they're appended to the shifted bit string.
         *
         * @param int $shift
         * @return BigInteger
         */
        public function bitwise_leftRotate($shift)
        {
        }
        /**
         * Logical Right Rotate
         *
         * Instead of the bottom x bits being dropped they're prepended to the shifted bit string.
         *
         * @param int $shift
         * @return BigInteger
         */
        public function bitwise_rightRotate($shift)
        {
        }
        /**
         * Returns the smallest and largest n-bit number
         *
         * @param int $bits
         * @return BigInteger[]
         */
        public static function minMaxBits($bits)
        {
        }
        /**
         * Return the size of a BigInteger in bits
         *
         * @return int
         */
        public function getLength()
        {
        }
        /**
         * Return the size of a BigInteger in bytes
         *
         * @return int
         */
        public function getLengthInBytes()
        {
        }
        /**
         * Generates a random number of a certain size
         *
         * Bit length is equal to $size
         *
         * @param int $size
         * @return BigInteger
         */
        public static function random($size)
        {
        }
        /**
         * Generates a random prime number of a certain size
         *
         * Bit length is equal to $size
         *
         * @param int $size
         * @return BigInteger
         */
        public static function randomPrime($size)
        {
        }
        /**
         * Generate a random prime number between a range
         *
         * If there's not a prime within the given range, false will be returned.
         *
         * @param BigInteger $min
         * @param BigInteger $max
         * @return false|BigInteger
         */
        public static function randomRangePrime(\phpseclib3\Math\BigInteger $min, \phpseclib3\Math\BigInteger $max)
        {
        }
        /**
         * Generate a random number between a range
         *
         * Returns a random number between $min and $max where $min and $max
         * can be defined using one of the two methods:
         *
         * BigInteger::randomRange($min, $max)
         * BigInteger::randomRange($max, $min)
         *
         * @param BigInteger $min
         * @param BigInteger $max
         * @return BigInteger
         */
        public static function randomRange(\phpseclib3\Math\BigInteger $min, \phpseclib3\Math\BigInteger $max)
        {
        }
        /**
         * Checks a numer to see if it's prime
         *
         * Assuming the $t parameter is not set, this function has an error rate of 2**-80.  The main motivation for the
         * $t parameter is distributability.  BigInteger::randomPrime() can be distributed across multiple pageloads
         * on a website instead of just one.
         *
         * @param int|bool $t
         * @return bool
         */
        public function isPrime($t = false)
        {
        }
        /**
         * Calculates the nth root of a biginteger.
         *
         * Returns the nth root of a positive biginteger, where n defaults to 2
         *
         * @param int $n optional
         * @return BigInteger
         */
        public function root($n = 2)
        {
        }
        /**
         * Performs exponentiation.
         *
         * @param BigInteger $n
         * @return BigInteger
         */
        public function pow(\phpseclib3\Math\BigInteger $n)
        {
        }
        /**
         * Return the minimum BigInteger between an arbitrary number of BigIntegers.
         *
         * @param BigInteger ...$nums
         * @return BigInteger
         */
        public static function min(\phpseclib3\Math\BigInteger ...$nums)
        {
        }
        /**
         * Return the maximum BigInteger between an arbitrary number of BigIntegers.
         *
         * @param BigInteger ...$nums
         * @return BigInteger
         */
        public static function max(\phpseclib3\Math\BigInteger ...$nums)
        {
        }
        /**
         * Tests BigInteger to see if it is between two integers, inclusive
         *
         * @param BigInteger $min
         * @param BigInteger $max
         * @return bool
         */
        public function between(\phpseclib3\Math\BigInteger $min, \phpseclib3\Math\BigInteger $max)
        {
        }
        /**
         * Clone
         */
        public function __clone()
        {
        }
        /**
         * Is Odd?
         *
         * @return bool
         */
        public function isOdd()
        {
        }
        /**
         * Tests if a bit is set
         *
         * @param int $x
         * @return bool
         */
        public function testBit($x)
        {
        }
        /**
         * Is Negative?
         *
         * @return bool
         */
        public function isNegative()
        {
        }
        /**
         * Negate
         *
         * Given $k, returns -$k
         *
         * @return BigInteger
         */
        public function negate()
        {
        }
        /**
         * Scan for 1 and right shift by that amount
         *
         * ie. $s = gmp_scan1($n, 0) and $r = gmp_div_q($n, gmp_pow(gmp_init('2'), $s));
         *
         * @param BigInteger $r
         * @return int
         */
        public static function scan1divide(\phpseclib3\Math\BigInteger $r)
        {
        }
        /**
         * Create Recurring Modulo Function
         *
         * Sometimes it may be desirable to do repeated modulos with the same number outside of
         * modular exponentiation
         *
         * @return callable
         */
        public function createRecurringModuloFunction()
        {
        }
        /**
         * Bitwise Split
         *
         * Splits BigInteger's into chunks of $split bits
         *
         * @param int $split
         * @return BigInteger[]
         */
        public function bitwise_split($split)
        {
        }
    }
}
namespace phpseclib3\Math\Common\FiniteField {
    /**
     * Finite Field Integer
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class Integer implements \JsonSerializable
    {
        /**
         * JSON Serialize
         *
         * Will be called, automatically, when json_encode() is called on a BigInteger object.
         *
         * PHP Serialize isn't supported because unserializing would require the factory be
         * serialized as well and that just sounds like too much
         *
         * @return array{hex: string}
         */
        #[\ReturnTypeWillChange]
        public function jsonSerialize()
        {
        }
        /**
         * Converts an Integer to a hex string (eg. base-16).
         *
         * @return string
         */
        abstract public function toHex();
    }
}
namespace phpseclib3\Math\BinaryField {
    /**
     * Binary Finite Fields
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class Integer extends \phpseclib3\Math\Common\FiniteField\Integer
    {
        /**
         * Holds the BinaryField's value
         *
         * @var string
         */
        protected $value;
        /**
         * Keeps track of current instance
         *
         * @var int
         */
        protected $instanceID;
        /**
         * Holds the PrimeField's modulo
         *
         * @var array<int, string>
         */
        protected static $modulo;
        /**
         * Holds a pre-generated function to perform modulo reductions
         *
         * @var callable[]
         */
        protected static $reduce;
        /**
         * Default constructor
         */
        public function __construct($instanceID, $num = '')
        {
        }
        /**
         * Set the modulo for a given instance
         * @param int $instanceID
         * @param string $modulo
         */
        public static function setModulo($instanceID, $modulo)
        {
        }
        /**
         * Set the modulo for a given instance
         */
        public static function setRecurringModuloFunction($instanceID, callable $function)
        {
        }
        /**
         * Tests the equality of two numbers.
         *
         * @return bool
         */
        public function equals(self $x)
        {
        }
        /**
         * Compares two numbers.
         *
         * @return int
         */
        public function compare(self $x)
        {
        }
        /**
         * Adds two BinaryFieldIntegers.
         *
         * @return static
         */
        public function add(self $y)
        {
        }
        /**
         * Subtracts two BinaryFieldIntegers.
         *
         * @return static
         */
        public function subtract(self $x)
        {
        }
        /**
         * Multiplies two BinaryFieldIntegers.
         *
         * @return static
         */
        public function multiply(self $y)
        {
        }
        /**
         * Returns the modular inverse of a BinaryFieldInteger
         *
         * @return static
         */
        public function modInverse()
        {
        }
        /**
         * Divides two PrimeFieldIntegers.
         *
         * @return static
         */
        public function divide(self $x)
        {
        }
        /**
         * Negate
         *
         * A negative number can be written as 0-12. With modulos, 0 is the same thing as the modulo
         * so 0-12 is the same thing as modulo-12
         *
         * @return object
         */
        public function negate()
        {
        }
        /**
         * Returns the modulo
         *
         * @return string
         */
        public static function getModulo($instanceID)
        {
        }
        /**
         * Converts an Integer to a byte string (eg. base-256).
         *
         * @return string
         */
        public function toBytes()
        {
        }
        /**
         * Converts an Integer to a hex string (eg. base-16).
         *
         * @return string
         */
        public function toHex()
        {
        }
        /**
         * Converts an Integer to a bit string (eg. base-2).
         *
         * @return string
         */
        public function toBits()
        {
        }
        /**
         * Converts an Integer to a BigInteger
         *
         * @return string
         */
        public function toBigInteger()
        {
        }
        /**
         *  __toString() magic method
         *
         */
        public function __toString()
        {
        }
        /**
         *  __debugInfo() magic method
         *
         */
        public function __debugInfo()
        {
        }
    }
}
namespace phpseclib3\Math\Common {
    /**
     * Finite Fields
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    abstract class FiniteField
    {
    }
}
namespace phpseclib3\Math {
    /**
     * Binary Finite Fields
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class BinaryField extends \phpseclib3\Math\Common\FiniteField
    {
        /**
         * Keeps track of current instance
         *
         * @var int
         */
        protected $instanceID;
        /**
         * Default constructor
         */
        public function __construct(...$indices)
        {
        }
        /**
         * Returns an instance of a dynamically generated PrimeFieldInteger class
         *
         * @param string $num
         * @return Integer
         */
        public function newInteger($num)
        {
        }
        /**
         * Returns an integer on the finite field between one and the prime modulo
         *
         * @return Integer
         */
        public function randomInteger()
        {
        }
        /**
         * Returns the length of the modulo in bytes
         *
         * @return int
         */
        public function getLengthInBytes()
        {
        }
        /**
         * Returns the length of the modulo in bits
         *
         * @return int
         */
        public function getLength()
        {
        }
        /**
         * Converts a base-2 string to a base-256 string
         *
         * @param string $x
         * @param int|null $size
         * @return string
         */
        public static function base2ToBase256($x, $size = null)
        {
        }
        /**
         * Converts a base-256 string to a base-2 string
         *
         * @param string $x
         * @return string
         */
        public static function base256ToBase2($x)
        {
        }
    }
}
namespace phpseclib3\Math\PrimeField {
    /**
     * Prime Finite Fields
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class Integer extends \phpseclib3\Math\Common\FiniteField\Integer
    {
        /**
         * Holds the PrimeField's value
         *
         * @var BigInteger
         */
        protected $value;
        /**
         * Keeps track of current instance
         *
         * @var int
         */
        protected $instanceID;
        /**
         * Holds the PrimeField's modulo
         *
         * @var array<int, BigInteger>
         */
        protected static $modulo;
        /**
         * Holds a pre-generated function to perform modulo reductions
         *
         * @var array<int, callable(BigInteger):BigInteger>
         */
        protected static $reduce;
        /**
         * Zero
         *
         * @var BigInteger
         */
        protected static $zero;
        /**
         * Default constructor
         *
         * @param int $instanceID
         * @param BigInteger $num
         */
        public function __construct($instanceID, $num = null)
        {
        }
        /**
         * Set the modulo for a given instance
         *
         * @param int $instanceID
         * @return void
         */
        public static function setModulo($instanceID, \phpseclib3\Math\BigInteger $modulo)
        {
        }
        /**
         * Set the modulo for a given instance
         *
         * @param int $instanceID
         * @return void
         */
        public static function setRecurringModuloFunction($instanceID, callable $function)
        {
        }
        /**
         * Delete the modulo for a given instance
         */
        public static function cleanupCache($instanceID)
        {
        }
        /**
         * Returns the modulo
         *
         * @param int $instanceID
         * @return BigInteger
         */
        public static function getModulo($instanceID)
        {
        }
        /**
         * Tests a parameter to see if it's of the right instance
         *
         * Throws an exception if the incorrect class is being utilized
         *
         * @return void
         */
        public static function checkInstance(self $x, self $y)
        {
        }
        /**
         * Tests the equality of two numbers.
         *
         * @return bool
         */
        public function equals(self $x)
        {
        }
        /**
         * Compares two numbers.
         *
         * @return int
         */
        public function compare(self $x)
        {
        }
        /**
         * Adds two PrimeFieldIntegers.
         *
         * @return static
         */
        public function add(self $x)
        {
        }
        /**
         * Subtracts two PrimeFieldIntegers.
         *
         * @return static
         */
        public function subtract(self $x)
        {
        }
        /**
         * Multiplies two PrimeFieldIntegers.
         *
         * @return static
         */
        public function multiply(self $x)
        {
        }
        /**
         * Divides two PrimeFieldIntegers.
         *
         * @return static
         */
        public function divide(self $x)
        {
        }
        /**
         * Performs power operation on a PrimeFieldInteger.
         *
         * @return static
         */
        public function pow(\phpseclib3\Math\BigInteger $x)
        {
        }
        /**
         * Calculates the square root
         *
         * @link https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm
         * @return static|false
         */
        public function squareRoot()
        {
        }
        /**
         * Is Odd?
         *
         * @return bool
         */
        public function isOdd()
        {
        }
        /**
         * Negate
         *
         * A negative number can be written as 0-12. With modulos, 0 is the same thing as the modulo
         * so 0-12 is the same thing as modulo-12
         *
         * @return static
         */
        public function negate()
        {
        }
        /**
         * Converts an Integer to a byte string (eg. base-256).
         *
         * @return string
         */
        public function toBytes()
        {
        }
        /**
         * Converts an Integer to a hex string (eg. base-16).
         *
         * @return string
         */
        public function toHex()
        {
        }
        /**
         * Converts an Integer to a bit string (eg. base-2).
         *
         * @return string
         */
        public function toBits()
        {
        }
        /**
         * Returns the w-ary non-adjacent form (wNAF)
         *
         * @param int $w optional
         * @return array<int, int>
         */
        public function getNAF($w = 1)
        {
        }
        /**
         * Converts an Integer to a BigInteger
         *
         * @return BigInteger
         */
        public function toBigInteger()
        {
        }
        /**
         *  __toString() magic method
         *
         * @return string
         */
        public function __toString()
        {
        }
        /**
         *  __debugInfo() magic method
         *
         * @return array
         */
        public function __debugInfo()
        {
        }
    }
}
namespace phpseclib3\Math {
    /**
     * Prime Finite Fields
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class PrimeField extends \phpseclib3\Math\Common\FiniteField
    {
        /**
         * Keeps track of current instance
         *
         * @var int
         */
        protected $instanceID;
        /**
         * Default constructor
         */
        public function __construct(\phpseclib3\Math\BigInteger $modulo)
        {
        }
        /**
         * Use a custom defined modular reduction function
         *
         * @return void
         */
        public function setReduction(\Closure $func)
        {
        }
        /**
         * Returns an instance of a dynamically generated PrimeFieldInteger class
         *
         * @return Integer
         */
        public function newInteger(\phpseclib3\Math\BigInteger $num)
        {
        }
        /**
         * Returns an integer on the finite field between one and the prime modulo
         *
         * @return Integer
         */
        public function randomInteger()
        {
        }
        /**
         * Returns the length of the modulo in bytes
         *
         * @return int
         */
        public function getLengthInBytes()
        {
        }
        /**
         * Returns the length of the modulo in bits
         *
         * @return int
         */
        public function getLength()
        {
        }
        /**
         *  Destructor
         */
        public function __destruct()
        {
        }
    }
}
namespace phpseclib3\Net\SFTP {
    /**
     * SFTP Stream Wrapper
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class Stream
    {
        /**
         * SFTP instances
         *
         * Rather than re-create the connection we re-use instances if possible
         *
         * @var array
         */
        public static $instances;
        /**
         * Context resource
         *
         * Technically this needs to be publicly accessible so PHP can set it directly
         *
         * @var resource
         */
        public $context;
        /**
         * Registers this class as a URL wrapper.
         *
         * @param string $protocol The wrapper name to be registered.
         * @return bool True on success, false otherwise.
         */
        public static function register($protocol = 'sftp')
        {
        }
        /**
         * The Constructor
         *
         */
        public function __construct()
        {
        }
        /**
         * Path Parser
         *
         * Extract a path from a URI and actually connect to an SSH server if appropriate
         *
         * If "notification" is set as a context parameter the message code for successful login is
         * NET_SSH2_MSG_USERAUTH_SUCCESS. For a failed login it's NET_SSH2_MSG_USERAUTH_FAILURE.
         *
         * @param string $path
         * @return string
         */
        protected function parse_path($path)
        {
        }
        /**
         * __call Magic Method
         *
         * When you're utilizing an SFTP stream you're not calling the methods in this class directly - PHP is calling them for you.
         * Which kinda begs the question... what methods is PHP calling and what parameters is it passing to them? This function
         * lets you figure that out.
         *
         * If NET_SFTP_STREAM_LOGGING is defined all calls will be output on the screen and then (regardless of whether or not
         * NET_SFTP_STREAM_LOGGING is enabled) the parameters will be passed through to the appropriate method.
         *
         * @param string $name
         * @param array $arguments
         * @return mixed
         */
        public function __call($name, array $arguments)
        {
        }
    }
}
namespace phpseclib3\Net {
    /**
     * Pure-PHP implementation of SSHv2.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class SSH2
    {
        /**#@+
         * Compression Types
         *
         */
        /**
         * No compression
         */
        const NET_SSH2_COMPRESSION_NONE = 1;
        /**
         * zlib compression
         */
        const NET_SSH2_COMPRESSION_ZLIB = 2;
        /**
         * zlib@openssh.com
         */
        const NET_SSH2_COMPRESSION_ZLIB_AT_OPENSSH = 3;
        /**#@-*/
        // Execution Bitmap Masks
        const MASK_CONSTRUCTOR = 0x1;
        const MASK_CONNECTED = 0x2;
        const MASK_LOGIN_REQ = 0x4;
        const MASK_LOGIN = 0x8;
        const MASK_SHELL = 0x10;
        const MASK_DISCONNECT = 0x20;
        /*
         * Channel constants
         *
         * RFC4254 refers not to client and server channels but rather to sender and recipient channels.  we don't refer
         * to them in that way because RFC4254 toggles the meaning. the client sends a SSH_MSG_CHANNEL_OPEN message with
         * a sender channel and the server sends a SSH_MSG_CHANNEL_OPEN_CONFIRMATION in response, with a sender and a
         * recipient channel.  at first glance, you might conclude that SSH_MSG_CHANNEL_OPEN_CONFIRMATION's sender channel
         * would be the same thing as SSH_MSG_CHANNEL_OPEN's sender channel, but it's not, per this snippet:
         *     The 'recipient channel' is the channel number given in the original
         *     open request, and 'sender channel' is the channel number allocated by
         *     the other side.
         *
         * @see \phpseclib3\Net\SSH2::send_channel_packet()
         * @see \phpseclib3\Net\SSH2::get_channel_packet()
         */
        const CHANNEL_EXEC = 1;
        // PuTTy uses 0x100
        const CHANNEL_SHELL = 2;
        const CHANNEL_SUBSYSTEM = 3;
        const CHANNEL_AGENT_FORWARD = 4;
        const CHANNEL_KEEP_ALIVE = 5;
        /**
         * Returns the message numbers
         *
         * @see \phpseclib3\Net\SSH2::getLog()
         */
        const LOG_SIMPLE = 1;
        /**
         * Returns the message content
         *
         * @see \phpseclib3\Net\SSH2::getLog()
         */
        const LOG_COMPLEX = 2;
        /**
         * Outputs the content real-time
         */
        const LOG_REALTIME = 3;
        /**
         * Dumps the content real-time to a file
         */
        const LOG_REALTIME_FILE = 4;
        /**
         * Outputs the message numbers real-time
         */
        const LOG_SIMPLE_REALTIME = 5;
        /*
         * Dumps the message numbers real-time
         */
        const LOG_REALTIME_SIMPLE = 5;
        /**
         * Make sure that the log never gets larger than this
         *
         * @see \phpseclib3\Net\SSH2::getLog()
         */
        const LOG_MAX_SIZE = 1048576;
        // 1024 * 1024
        /**
         * Returns when a string matching $expect exactly is found
         *
         * @see \phpseclib3\Net\SSH2::read()
         */
        const READ_SIMPLE = 1;
        /**
         * Returns when a string matching the regular expression $expect is found
         *
         * @see \phpseclib3\Net\SSH2::read()
         */
        const READ_REGEX = 2;
        /**
         * Returns whenever a data packet is received.
         *
         * Some data packets may only contain a single character so it may be necessary
         * to call read() multiple times when using this option
         *
         * @see \phpseclib3\Net\SSH2::read()
         */
        const READ_NEXT = 3;
        /**
         * The Socket Object
         *
         * @var resource|closed-resource|null
         */
        public $fsock;
        /**
         * Execution Bitmap
         *
         * The bits that are set represent functions that have been called already.  This is used to determine
         * if a requisite function has been successfully executed.  If not, an error should be thrown.
         *
         * @var int
         */
        protected $bitmap = 0;
        /**
         * Server Identifier
         *
         * @see self::getServerIdentification()
         * @var string|false
         */
        protected $server_identifier = false;
        /**
         * Server Channels
         *
         * Maps client channels to server channels
         *
         * @see self::get_channel_packet()
         * @see self::exec()
         * @var array
         */
        protected $server_channels = [];
        /**
         * Channel Status
         *
         * Contains the type of the last sent message
         *
         * @see self::get_channel_packet()
         * @var array
         */
        protected $channel_status = [];
        /**
         * The Window Size
         *
         * Bytes the other party can send before it must wait for the window to be adjusted (0x7FFFFFFF = 2GB)
         *
         * @var int
         * @see self::send_channel_packet()
         * @see self::exec()
         */
        protected $window_size = 0x7fffffff;
        /**
         * Window size, server to client
         *
         * Window size indexed by channel
         *
         * @see self::send_channel_packet()
         * @var array
         */
        protected $window_size_server_to_client = [];
        /**
         * Timeout
         *
         * @see self::setTimeout()
         */
        protected $timeout;
        /**
         * Current Timeout
         *
         * @see self::get_channel_packet()
         */
        protected $curTimeout;
        /**
         * Did read() timeout or return normally?
         *
         * @see self::isTimeout()
         * @var bool
         */
        protected $is_timeout = false;
        /**
         * Preferred Signature Format
         *
         * @var string|false
         */
        protected $preferred_signature_format = false;
        /**
         * Authentication Credentials
         *
         * @var array
         */
        protected $auth = [];
        /**
         * Default Constructor.
         *
         * $host can either be a string, representing the host, or a stream resource.
         * If $host is a stream resource then $port doesn't do anything, altho $timeout
         * still will be used
         *
         * @param mixed $host
         * @param int $port
         * @param int $timeout
         * @see self::login()
         */
        public function __construct($host, $port = 22, $timeout = 10)
        {
        }
        /**
         * Set Crypto Engine Mode
         *
         * Possible $engine values:
         * OpenSSL, mcrypt, Eval, PHP
         *
         * @param int $engine
         */
        public static function setCryptoEngine($engine)
        {
        }
        /**
         * Send Identification String First
         *
         * https://tools.ietf.org/html/rfc4253#section-4.2 says "when the connection has been established,
         * both sides MUST send an identification string". It does not say which side sends it first. In
         * theory it shouldn't matter but it is a fact of life that some SSH servers are simply buggy
         *
         */
        public function sendIdentificationStringFirst()
        {
        }
        /**
         * Send Identification String Last
         *
         * https://tools.ietf.org/html/rfc4253#section-4.2 says "when the connection has been established,
         * both sides MUST send an identification string". It does not say which side sends it first. In
         * theory it shouldn't matter but it is a fact of life that some SSH servers are simply buggy
         *
         */
        public function sendIdentificationStringLast()
        {
        }
        /**
         * Send SSH_MSG_KEXINIT First
         *
         * https://tools.ietf.org/html/rfc4253#section-7.1 says "key exchange begins by each sending
         * sending the [SSH_MSG_KEXINIT] packet". It does not say which side sends it first. In theory
         * it shouldn't matter but it is a fact of life that some SSH servers are simply buggy
         *
         */
        public function sendKEXINITFirst()
        {
        }
        /**
         * Send SSH_MSG_KEXINIT Last
         *
         * https://tools.ietf.org/html/rfc4253#section-7.1 says "key exchange begins by each sending
         * sending the [SSH_MSG_KEXINIT] packet". It does not say which side sends it first. In theory
         * it shouldn't matter but it is a fact of life that some SSH servers are simply buggy
         *
         */
        public function sendKEXINITLast()
        {
        }
        /**
         * Login
         *
         * The $password parameter can be a plaintext password, a \phpseclib3\Crypt\RSA|EC|DSA object, a \phpseclib3\System\SSH\Agent object or an array
         *
         * @param string $username
         * @param string|PrivateKey|array[]|Agent|null ...$args
         * @return bool
         * @see self::_login()
         */
        public function login($username, ...$args)
        {
        }
        /**
         * Login Helper
         *
         * @param string $username
         * @param string|PrivateKey|array[]|Agent|null ...$args
         * @return bool
         * @see self::_login_helper()
         */
        protected function sublogin($username, ...$args)
        {
        }
        /**
         * Return the currently configured timeout
         *
         * @return int
         */
        public function getTimeout()
        {
        }
        /**
         * Set Timeout
         *
         * $ssh->exec('ping 127.0.0.1'); on a Linux host will never return and will run indefinitely.  setTimeout() makes it so it'll timeout.
         * Setting $timeout to false or 0 will revert to the default socket timeout.
         *
         * @param mixed $timeout
         */
        public function setTimeout($timeout)
        {
        }
        /**
         * Set Keep Alive
         *
         * Sends an SSH2_MSG_IGNORE message every x seconds, if x is a positive non-zero number.
         *
         * @param int $interval
         */
        public function setKeepAlive($interval)
        {
        }
        /**
         * Get the output from stdError
         *
         */
        public function getStdError()
        {
        }
        /**
         * Execute Command
         *
         * If $callback is set to false then \phpseclib3\Net\SSH2::get_channel_packet(self::CHANNEL_EXEC) will need to be called manually.
         * In all likelihood, this is not a feature you want to be taking advantage of.
         *
         * @param string $command
         * @param callable $callback
         * @return string|bool
         * @psalm-return ($callback is callable ? bool : string|bool)
         * @throws \RuntimeException on connection error
         */
        public function exec($command, $callback = null)
        {
        }
        /**
         * How many channels are currently open?
         *
         * @return int
         */
        public function getOpenChannelCount()
        {
        }
        /**
         * Opens a channel
         *
         * @param string $channel
         * @param bool $skip_extended
         * @return bool
         */
        protected function open_channel($channel, $skip_extended = false)
        {
        }
        /**
         * Creates an interactive shell
         *
         * Returns bool(true) if the shell was opened.
         * Returns bool(false) if the shell was already open.
         *
         * @see self::isShellOpen()
         * @see self::read()
         * @see self::write()
         * @return bool
         * @throws InsufficientSetupException if not authenticated
         * @throws \UnexpectedValueException on receipt of unexpected packets
         * @throws \RuntimeException on other errors
         */
        public function openShell()
        {
        }
        /**
         * Request agent forwarding of remote server
         *
         * @return bool
         */
        public function requestAgentForwarding()
        {
        }
        /**
         * Returns the output of an interactive shell
         *
         * Returns when there's a match for $expect, which can take the form of a string literal or,
         * if $mode == self::READ_REGEX, a regular expression.
         *
         * If not specifying a channel, an open interactive channel will be selected, or, if there are
         * no open channels, an interactive shell will be created. If there are multiple open
         * interactive channels, a legacy behavior will apply in which channel selection prioritizes
         * an active subsystem, the exec pty, and, lastly, the shell. If using multiple interactive
         * channels, callers are discouraged from relying on this legacy behavior and should specify
         * the intended channel.
         *
         * @see self::write()
         * @param string $expect
         * @param int $mode One of the self::READ_* constants
         * @param int|null $channel Channel id returned by self::getInteractiveChannelId()
         * @return string|bool|null
         * @throws \RuntimeException on connection error
         * @throws InsufficientSetupException on unexpected channel status, possibly due to closure
         */
        public function read($expect = '', $mode = self::READ_SIMPLE, $channel = null)
        {
        }
        /**
         * Inputs a command into an interactive shell.
         *
         * If not specifying a channel, an open interactive channel will be selected, or, if there are
         * no open channels, an interactive shell will be created. If there are multiple open
         * interactive channels, a legacy behavior will apply in which channel selection prioritizes
         * an active subsystem, the exec pty, and, lastly, the shell. If using multiple interactive
         * channels, callers are discouraged from relying on this legacy behavior and should specify
         * the intended channel.
         *
         * @see SSH2::read()
         * @param string $cmd
         * @param int|null $channel Channel id returned by self::getInteractiveChannelId()
         * @return void
         * @throws \RuntimeException on connection error
         * @throws InsufficientSetupException on unexpected channel status, possibly due to closure
         * @throws TimeoutException if the write could not be completed within the requested self::setTimeout()
         */
        public function write($cmd, $channel = null)
        {
        }
        /**
         * Start a subsystem.
         *
         * Right now only one subsystem at a time is supported. To support multiple subsystem's stopSubsystem() could accept
         * a string that contained the name of the subsystem, but at that point, only one subsystem of each type could be opened.
         * To support multiple subsystem's of the same name maybe it'd be best if startSubsystem() generated a new channel id and
         * returns that and then that that was passed into stopSubsystem() but that'll be saved for a future date and implemented
         * if there's sufficient demand for such a feature.
         *
         * @see self::stopSubsystem()
         * @param string $subsystem
         * @return bool
         */
        public function startSubsystem($subsystem)
        {
        }
        /**
         * Stops a subsystem.
         *
         * @see self::startSubsystem()
         * @return bool
         */
        public function stopSubsystem()
        {
        }
        /**
         * Closes a channel
         *
         * If read() timed out you might want to just close the channel and have it auto-restart on the next read() call
         *
         * If not specifying a channel, an open interactive channel will be selected. If there are
         * multiple open interactive channels, a legacy behavior will apply in which channel selection
         * prioritizes an active subsystem, the exec pty, and, lastly, the shell. If using multiple
         * interactive channels, callers are discouraged from relying on this legacy behavior and
         * should specify the intended channel.
         *
         * @param int|null $channel Channel id returned by self::getInteractiveChannelId()
         * @return void
         */
        public function reset($channel = null)
        {
        }
        /**
         * Is timeout?
         *
         * Did exec() or read() return because they timed out or because they encountered the end?
         *
         */
        public function isTimeout()
        {
        }
        /**
         * Disconnect
         *
         */
        public function disconnect()
        {
        }
        /**
         * Destructor.
         *
         * Will be called, automatically, if you're supporting just PHP5.  If you're supporting PHP4, you'll need to call
         * disconnect().
         *
         */
        public function __destruct()
        {
        }
        /**
         * Is the connection still active?
         *
         * $level has 3x possible values:
         * 0 (default): phpseclib takes a passive approach to see if the connection is still active by calling feof()
         *    on the socket
         * 1: phpseclib takes an active approach to see if the connection is still active by sending an SSH_MSG_IGNORE
         *    packet that doesn't require a response
         * 2: phpseclib takes an active approach to see if the connection is still active by sending an SSH_MSG_CHANNEL_OPEN
         *    packet and imediately trying to close that channel. some routers, in particular, however, will only let you
         *    open one channel, so this approach could yield false positives
         *
         * @param int $level
         * @return bool
         */
        public function isConnected($level = 0)
        {
        }
        /**
         * Have you successfully been logged in?
         *
         * @return bool
         */
        public function isAuthenticated()
        {
        }
        /**
         * Is the interactive shell active?
         *
         * @return bool
         */
        public function isShellOpen()
        {
        }
        /**
         * Is the exec pty active?
         *
         * @return bool
         */
        public function isPTYOpen()
        {
        }
        /**
         * Is the given interactive channel active?
         *
         * @param int $channel Channel id returned by self::getInteractiveChannelId()
         * @return bool
         */
        public function isInteractiveChannelOpen($channel)
        {
        }
        /**
         * Returns a channel identifier, presently of the last interactive channel opened, regardless of current status.
         * Returns 0 if no interactive channel has been opened.
         *
         * @see self::isInteractiveChannelOpen()
         * @return int
         */
        public function getInteractiveChannelId()
        {
        }
        /**
         * Pings a server connection, or tries to reconnect if the connection has gone down
         *
         * Inspired by http://php.net/manual/en/mysqli.ping.php
         *
         * @return bool
         */
        public function ping()
        {
        }
        /**
         * Resets a connection for re-use
         */
        protected function reset_connection()
        {
        }
        /**
         * Enable Quiet Mode
         *
         * Suppress stderr from output
         *
         */
        public function enableQuietMode()
        {
        }
        /**
         * Disable Quiet Mode
         *
         * Show stderr in output
         *
         */
        public function disableQuietMode()
        {
        }
        /**
         * Returns whether Quiet Mode is enabled or not
         *
         * @see self::enableQuietMode()
         * @see self::disableQuietMode()
         * @return bool
         */
        public function isQuietModeEnabled()
        {
        }
        /**
         * Enable request-pty when using exec()
         *
         */
        public function enablePTY()
        {
        }
        /**
         * Disable request-pty when using exec()
         *
         */
        public function disablePTY()
        {
        }
        /**
         * Returns whether request-pty is enabled or not
         *
         * @see self::enablePTY()
         * @see self::disablePTY()
         * @return bool
         */
        public function isPTYEnabled()
        {
        }
        /**
         * Gets channel data
         *
         * Returns the data as a string. bool(true) is returned if:
         *
         * - the server closes the channel
         * - if the connection times out
         * - if a window adjust packet is received on the given negated client channel
         * - if the channel status is CHANNEL_OPEN and the response was CHANNEL_OPEN_CONFIRMATION
         * - if the channel status is CHANNEL_REQUEST and the response was CHANNEL_SUCCESS
         * - if the channel status is CHANNEL_CLOSE and the response was CHANNEL_CLOSE
         *
         * bool(false) is returned if:
         *
         * - if the channel status is CHANNEL_REQUEST and the response was CHANNEL_FAILURE
         *
         * @param int $client_channel Specifies the channel to return data for, and data received
         *        on other channels is buffered. The respective negative value of a channel is
         *        also supported for the case that the caller is awaiting adjustment of the data
         *        window, and where data received on that respective channel is also buffered.
         * @param bool $skip_extended
         * @return mixed
         * @throws \RuntimeException on connection error
         */
        protected function get_channel_packet($client_channel, $skip_extended = false)
        {
        }
        /**
         * Sends Binary Packets
         *
         * See '6. Binary Packet Protocol' of rfc4253 for more info.
         *
         * @param string $data
         * @param string $logged
         * @see self::_get_binary_packet()
         * @return void
         */
        protected function send_binary_packet($data, $logged = null)
        {
        }
        /**
         * Logs data packet helper
         *
         * @param int $constant
         * @param string $message_number
         * @param string $message
         * @param array &$message_number_log
         * @param array &$message_log
         * @param int &$log_size
         * @param resource &$realtime_log_file
         * @param bool &$realtime_log_wrap
         * @param int &$realtime_log_size
         */
        protected function append_log_helper($constant, $message_number, $message, array &$message_number_log, array &$message_log, &$log_size, &$realtime_log_file, &$realtime_log_wrap, &$realtime_log_size)
        {
        }
        /**
         * Sends channel data
         *
         * Spans multiple SSH_MSG_CHANNEL_DATAs if appropriate
         *
         * @param int $client_channel
         * @param string $data
         * @return void
         */
        protected function send_channel_packet($client_channel, $data)
        {
        }
        /**
         * Disconnect
         *
         * @param int $reason
         * @return false
         */
        protected function disconnect_helper($reason)
        {
        }
        /**
         * Define Array
         *
         * Takes any number of arrays whose indices are integers and whose values are strings and defines a bunch of
         * named constants from it, using the value as the name of the constant and the index as the value of the constant.
         * If any of the constants that would be defined already exists, none of the constants will be defined.
         *
         * @param mixed[] ...$args
         * @access protected
         */
        protected static function define_array(...$args)
        {
        }
        /**
         * Returns a log of the packets that have been sent and received.
         *
         * Returns a string if NET_SSH2_LOGGING == self::LOG_COMPLEX, an array if NET_SSH2_LOGGING == self::LOG_SIMPLE and false if !defined('NET_SSH2_LOGGING')
         *
         * @return array|false|string
         */
        public function getLog()
        {
        }
        /**
         * Formats a log for printing
         *
         * @param array $message_log
         * @param array $message_number_log
         * @return string
         */
        protected function format_log(array $message_log, array $message_number_log)
        {
        }
        /**
         * Returns all errors / debug messages on the SSH layer
         *
         * If you are looking for messages from the SFTP layer, please see SFTP::getSFTPErrors()
         *
         * @return string[]
         */
        public function getErrors()
        {
        }
        /**
         * Returns the last error received on the SSH layer
         *
         * If you are looking for messages from the SFTP layer, please see SFTP::getLastSFTPError()
         *
         * @return string
         */
        public function getLastError()
        {
        }
        /**
         * Return the server identification.
         *
         * @return string|false
         */
        public function getServerIdentification()
        {
        }
        /**
         * Returns a list of algorithms the server supports
         *
         * @return array
         */
        public function getServerAlgorithms()
        {
        }
        /**
         * Returns a list of KEX algorithms that phpseclib supports
         *
         * @return array
         */
        public static function getSupportedKEXAlgorithms()
        {
        }
        /**
         * Returns a list of host key algorithms that phpseclib supports
         *
         * @return array
         */
        public static function getSupportedHostKeyAlgorithms()
        {
        }
        /**
         * Returns a list of symmetric key algorithms that phpseclib supports
         *
         * @return array
         */
        public static function getSupportedEncryptionAlgorithms()
        {
        }
        /**
         * Returns a list of MAC algorithms that phpseclib supports
         *
         * @return array
         */
        public static function getSupportedMACAlgorithms()
        {
        }
        /**
         * Returns a list of compression algorithms that phpseclib supports
         *
         * @return array
         */
        public static function getSupportedCompressionAlgorithms()
        {
        }
        /**
         * Return list of negotiated algorithms
         *
         * Uses the same format as https://www.php.net/ssh2-methods-negotiated
         *
         * @return array
         */
        public function getAlgorithmsNegotiated()
        {
        }
        /**
         * Force multiple channels (even if phpseclib has decided to disable them)
         */
        public function forceMultipleChannels()
        {
        }
        /**
         * Allows you to set the terminal
         *
         * @param string $term
         */
        public function setTerminal($term)
        {
        }
        /**
         * Accepts an associative array with up to four parameters as described at
         * <https://www.php.net/manual/en/function.ssh2-connect.php>
         *
         * @param array $methods
         */
        public function setPreferredAlgorithms(array $methods)
        {
        }
        /**
         * Returns the banner message.
         *
         * Quoting from the RFC, "in some jurisdictions, sending a warning message before
         * authentication may be relevant for getting legal protection."
         *
         * @return string
         */
        public function getBannerMessage()
        {
        }
        /**
         * Returns the server public host key.
         *
         * Caching this the first time you connect to a server and checking the result on subsequent connections
         * is recommended.  Returns false if the server signature is not signed correctly with the public host key.
         *
         * @return string|false
         * @throws \RuntimeException on badly formatted keys
         * @throws NoSupportedAlgorithmsException when the key isn't in a supported format
         */
        public function getServerPublicHostKey()
        {
        }
        /**
         * Returns the exit status of an SSH command or false.
         *
         * @return false|int
         */
        public function getExitStatus()
        {
        }
        /**
         * Returns the number of columns for the terminal window size.
         *
         * @return int
         */
        public function getWindowColumns()
        {
        }
        /**
         * Returns the number of rows for the terminal window size.
         *
         * @return int
         */
        public function getWindowRows()
        {
        }
        /**
         * Sets the number of columns for the terminal window size.
         *
         * @param int $value
         */
        public function setWindowColumns($value)
        {
        }
        /**
         * Sets the number of rows for the terminal window size.
         *
         * @param int $value
         */
        public function setWindowRows($value)
        {
        }
        /**
         * Sets the number of columns and rows for the terminal window size.
         *
         * @param int $columns
         * @param int $rows
         */
        public function setWindowSize($columns = 80, $rows = 24)
        {
        }
        /**
         * To String Magic Method
         *
         * @return string
         */
        #[\ReturnTypeWillChange]
        public function __toString()
        {
        }
        /**
         * Get Resource ID
         *
         * We use {} because that symbols should not be in URL according to
         * {@link http://tools.ietf.org/html/rfc3986#section-2 RFC}.
         * It will safe us from any conflicts, because otherwise regexp will
         * match all alphanumeric domains.
         *
         * @return string
         */
        public function getResourceId()
        {
        }
        /**
         * Return existing connection
         *
         * @param string $id
         *
         * @return bool|SSH2 will return false if no such connection
         */
        public static function getConnectionByResourceId($id)
        {
        }
        /**
         * Return all excising connections
         *
         * @return array<string, SSH2>
         */
        public static function getConnections()
        {
        }
        /**
         * Return the list of authentication methods that may productively continue authentication.
         *
         * @see https://tools.ietf.org/html/rfc4252#section-5.1
         * @return array|null
         */
        public function getAuthMethodsToContinue()
        {
        }
        /**
         * Enables "smart" multi-factor authentication (MFA)
         */
        public function enableSmartMFA()
        {
        }
        /**
         * Disables "smart" multi-factor authentication (MFA)
         */
        public function disableSmartMFA()
        {
        }
        /**
         * How many bytes until the next key re-exchange?
         *
         * @param int $bytes
         */
        public function bytesUntilKeyReexchange($bytes)
        {
        }
    }
    /**
     * Pure-PHP implementations of SFTP.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class SFTP extends \phpseclib3\Net\SSH2
    {
        /**
         * SFTP channel constant
         *
         * \phpseclib3\Net\SSH2::exec() uses 0 and \phpseclib3\Net\SSH2::read() / \phpseclib3\Net\SSH2::write() use 1.
         *
         * @see \phpseclib3\Net\SSH2::send_channel_packet()
         * @see \phpseclib3\Net\SSH2::get_channel_packet()
         */
        const CHANNEL = 0x100;
        /**
         * Reads data from a local file.
         *
         * @see \phpseclib3\Net\SFTP::put()
         */
        const SOURCE_LOCAL_FILE = 1;
        /**
         * Reads data from a string.
         *
         * @see \phpseclib3\Net\SFTP::put()
         */
        // this value isn't really used anymore but i'm keeping it reserved for historical reasons
        const SOURCE_STRING = 2;
        /**
         * Reads data from callback:
         * function callback($length) returns string to proceed, null for EOF
         *
         * @see \phpseclib3\Net\SFTP::put()
         */
        const SOURCE_CALLBACK = 16;
        /**
         * Resumes an upload
         *
         * @see \phpseclib3\Net\SFTP::put()
         */
        const RESUME = 4;
        /**
         * Append a local file to an already existing remote file
         *
         * @see \phpseclib3\Net\SFTP::put()
         */
        const RESUME_START = 8;
        /**
         * Sort Options
         *
         * @see self::_comparator()
         * @see self::setListOrder()
         * @var array
         */
        protected $sortOptions = [];
        /**
         * Default Constructor.
         *
         * Connects to an SFTP server
         *
         * $host can either be a string, representing the host, or a stream resource.
         *
         * @param mixed $host
         * @param int $port
         * @param int $timeout
         */
        public function __construct($host, $port = 22, $timeout = 10)
        {
        }
        /**
         * Disable the stat cache
         *
         */
        public function disableStatCache()
        {
        }
        /**
         * Enable the stat cache
         *
         */
        public function enableStatCache()
        {
        }
        /**
         * Clear the stat cache
         *
         */
        public function clearStatCache()
        {
        }
        /**
         * Enable path canonicalization
         *
         */
        public function enablePathCanonicalization()
        {
        }
        /**
         * Disable path canonicalization
         *
         * If this is enabled then $sftp->pwd() will not return the canonicalized absolute path
         *
         */
        public function disablePathCanonicalization()
        {
        }
        /**
         * Enable arbitrary length packets
         *
         */
        public function enableArbitraryLengthPackets()
        {
        }
        /**
         * Disable arbitrary length packets
         *
         */
        public function disableArbitraryLengthPackets()
        {
        }
        /**
         * Returns the current directory name
         *
         * @return string|bool
         */
        public function pwd()
        {
        }
        /**
         * Canonicalize the Server-Side Path Name
         *
         * SFTP doesn't provide a mechanism by which the current working directory can be changed, so we'll emulate it.  Returns
         * the absolute (canonicalized) path.
         *
         * If canonicalize_paths has been disabled using disablePathCanonicalization(), $path is returned as-is.
         *
         * @see self::chdir()
         * @see self::disablePathCanonicalization()
         * @param string $path
         * @throws \UnexpectedValueException on receipt of unexpected packets
         * @return mixed
         */
        public function realpath($path)
        {
        }
        /**
         * Changes the current directory
         *
         * @param string $dir
         * @throws \UnexpectedValueException on receipt of unexpected packets
         * @return bool
         */
        public function chdir($dir)
        {
        }
        /**
         * Returns a list of files in the given directory
         *
         * @param string $dir
         * @param bool $recursive
         * @return array|false
         */
        public function nlist($dir = '.', $recursive = false)
        {
        }
        /**
         * Returns a detailed list of files in the given directory
         *
         * @param string $dir
         * @param bool $recursive
         * @return array|false
         */
        public function rawlist($dir = '.', $recursive = false)
        {
        }
        /**
         * Defines how nlist() and rawlist() will be sorted - if at all.
         *
         * If sorting is enabled directories and files will be sorted independently with
         * directories appearing before files in the resultant array that is returned.
         *
         * Any parameter returned by stat is a valid sort parameter for this function.
         * Filename comparisons are case insensitive.
         *
         * Examples:
         *
         * $sftp->setListOrder('filename', SORT_ASC);
         * $sftp->setListOrder('size', SORT_DESC, 'filename', SORT_ASC);
         * $sftp->setListOrder(true);
         *    Separates directories from files but doesn't do any sorting beyond that
         * $sftp->setListOrder();
         *    Don't do any sort of sorting
         *
         * @param string ...$args
         */
        public function setListOrder(...$args)
        {
        }
        /**
         * Returns general information about a file.
         *
         * Returns an array on success and false otherwise.
         *
         * @param string $filename
         * @return array|false
         */
        public function stat($filename)
        {
        }
        /**
         * Returns general information about a file or symbolic link.
         *
         * Returns an array on success and false otherwise.
         *
         * @param string $filename
         * @return array|false
         */
        public function lstat($filename)
        {
        }
        /**
         * Truncates a file to a given length
         *
         * @param string $filename
         * @param int $new_size
         * @return bool
         */
        public function truncate($filename, $new_size)
        {
        }
        /**
         * Sets access and modification time of file.
         *
         * If the file does not exist, it will be created.
         *
         * @param string $filename
         * @param int $time
         * @param int $atime
         * @throws \UnexpectedValueException on receipt of unexpected packets
         * @return bool
         */
        public function touch($filename, $time = null, $atime = null)
        {
        }
        /**
         * Changes file or directory owner
         *
         * $uid should be an int for SFTPv3 and a string for SFTPv4+. Ideally the string
         * would be of the form "user@dns_domain" but it does not need to be.
         * `$sftp->getSupportedVersions()['version']` will return the specific version
         * that's being used.
         *
         * Returns true on success or false on error.
         *
         * @param string $filename
         * @param int|string $uid
         * @param bool $recursive
         * @return bool
         */
        public function chown($filename, $uid, $recursive = false)
        {
        }
        /**
         * Changes file or directory group
         *
         * $gid should be an int for SFTPv3 and a string for SFTPv4+. Ideally the string
         * would be of the form "user@dns_domain" but it does not need to be.
         * `$sftp->getSupportedVersions()['version']` will return the specific version
         * that's being used.
         *
         * Returns true on success or false on error.
         *
         * @param string $filename
         * @param int|string $gid
         * @param bool $recursive
         * @return bool
         */
        public function chgrp($filename, $gid, $recursive = false)
        {
        }
        /**
         * Set permissions on a file.
         *
         * Returns the new file permissions on success or false on error.
         * If $recursive is true than this just returns true or false.
         *
         * @param int $mode
         * @param string $filename
         * @param bool $recursive
         * @throws \UnexpectedValueException on receipt of unexpected packets
         * @return mixed
         */
        public function chmod($mode, $filename, $recursive = false)
        {
        }
        /**
         * Return the target of a symbolic link
         *
         * @param string $link
         * @throws \UnexpectedValueException on receipt of unexpected packets
         * @return mixed
         */
        public function readlink($link)
        {
        }
        /**
         * Create a symlink
         *
         * symlink() creates a symbolic link to the existing target with the specified name link.
         *
         * @param string $target
         * @param string $link
         * @throws \UnexpectedValueException on receipt of unexpected packets
         * @return bool
         */
        public function symlink($target, $link)
        {
        }
        /**
         * Creates a directory.
         *
         * @param string $dir
         * @param int $mode
         * @param bool $recursive
         * @return bool
         */
        public function mkdir($dir, $mode = -1, $recursive = false)
        {
        }
        /**
         * Removes a directory.
         *
         * @param string $dir
         * @throws \UnexpectedValueException on receipt of unexpected packets
         * @return bool
         */
        public function rmdir($dir)
        {
        }
        /**
         * Uploads a file to the SFTP server.
         *
         * By default, \phpseclib3\Net\SFTP::put() does not read from the local filesystem.  $data is dumped directly into $remote_file.
         * So, for example, if you set $data to 'filename.ext' and then do \phpseclib3\Net\SFTP::get(), you will get a file, twelve bytes
         * long, containing 'filename.ext' as its contents.
         *
         * Setting $mode to self::SOURCE_LOCAL_FILE will change the above behavior.  With self::SOURCE_LOCAL_FILE, $remote_file will
         * contain as many bytes as filename.ext does on your local filesystem.  If your filename.ext is 1MB then that is how
         * large $remote_file will be, as well.
         *
         * Setting $mode to self::SOURCE_CALLBACK will use $data as callback function, which gets only one parameter -- number
         * of bytes to return, and returns a string if there is some data or null if there is no more data
         *
         * If $data is a resource then it'll be used as a resource instead.
         *
         * Currently, only binary mode is supported.  As such, if the line endings need to be adjusted, you will need to take
         * care of that, yourself.
         *
         * $mode can take an additional two parameters - self::RESUME and self::RESUME_START. These are bitwise AND'd with
         * $mode. So if you want to resume upload of a 300mb file on the local file system you'd set $mode to the following:
         *
         * self::SOURCE_LOCAL_FILE | self::RESUME
         *
         * If you wanted to simply append the full contents of a local file to the full contents of a remote file you'd replace
         * self::RESUME with self::RESUME_START.
         *
         * If $mode & (self::RESUME | self::RESUME_START) then self::RESUME_START will be assumed.
         *
         * $start and $local_start give you more fine grained control over this process and take precident over self::RESUME
         * when they're non-negative. ie. $start could let you write at the end of a file (like self::RESUME) or in the middle
         * of one. $local_start could let you start your reading from the end of a file (like self::RESUME_START) or in the
         * middle of one.
         *
         * Setting $local_start to > 0 or $mode | self::RESUME_START doesn't do anything unless $mode | self::SOURCE_LOCAL_FILE.
         *
         * {@internal ASCII mode for SFTPv4/5/6 can be supported by adding a new function - \phpseclib3\Net\SFTP::setMode().}
         *
         * @param string $remote_file
         * @param string|resource $data
         * @param int $mode
         * @param int $start
         * @param int $local_start
         * @param callable|null $progressCallback
         * @throws \UnexpectedValueException on receipt of unexpected packets
         * @throws \BadFunctionCallException if you're uploading via a callback and the callback function is invalid
         * @throws FileNotFoundException if you're uploading via a file and the file doesn't exist
         * @return bool
         */
        public function put($remote_file, $data, $mode = self::SOURCE_STRING, $start = -1, $local_start = -1, $progressCallback = null)
        {
        }
        /**
         * Downloads a file from the SFTP server.
         *
         * Returns a string containing the contents of $remote_file if $local_file is left undefined or a boolean false if
         * the operation was unsuccessful.  If $local_file is defined, returns true or false depending on the success of the
         * operation.
         *
         * $offset and $length can be used to download files in chunks.
         *
         * @param string $remote_file
         * @param string|bool|resource|callable $local_file
         * @param int $offset
         * @param int $length
         * @param callable|null $progressCallback
         * @throws \UnexpectedValueException on receipt of unexpected packets
         * @return string|bool
         */
        public function get($remote_file, $local_file = false, $offset = 0, $length = -1, $progressCallback = null)
        {
        }
        /**
         * Deletes a file on the SFTP server.
         *
         * @param string $path
         * @param bool $recursive
         * @return bool
         * @throws \UnexpectedValueException on receipt of unexpected packets
         */
        public function delete($path, $recursive = true)
        {
        }
        /**
         * Checks whether a file or directory exists
         *
         * @param string $path
         * @return bool
         */
        public function file_exists($path)
        {
        }
        /**
         * Tells whether the filename is a directory
         *
         * @param string $path
         * @return bool
         */
        public function is_dir($path)
        {
        }
        /**
         * Tells whether the filename is a regular file
         *
         * @param string $path
         * @return bool
         */
        public function is_file($path)
        {
        }
        /**
         * Tells whether the filename is a symbolic link
         *
         * @param string $path
         * @return bool
         */
        public function is_link($path)
        {
        }
        /**
         * Tells whether a file exists and is readable
         *
         * @param string $path
         * @return bool
         */
        public function is_readable($path)
        {
        }
        /**
         * Tells whether the filename is writable
         *
         * @param string $path
         * @return bool
         */
        public function is_writable($path)
        {
        }
        /**
         * Tells whether the filename is writeable
         *
         * Alias of is_writable
         *
         * @param string $path
         * @return bool
         */
        public function is_writeable($path)
        {
        }
        /**
         * Gets last access time of file
         *
         * @param string $path
         * @return mixed
         */
        public function fileatime($path)
        {
        }
        /**
         * Gets file modification time
         *
         * @param string $path
         * @return mixed
         */
        public function filemtime($path)
        {
        }
        /**
         * Gets file permissions
         *
         * @param string $path
         * @return mixed
         */
        public function fileperms($path)
        {
        }
        /**
         * Gets file owner
         *
         * @param string $path
         * @return mixed
         */
        public function fileowner($path)
        {
        }
        /**
         * Gets file group
         *
         * @param string $path
         * @return mixed
         */
        public function filegroup($path)
        {
        }
        /**
         * Gets file size
         *
         * @param string $path
         * @param bool $recursive
         * @return mixed
         */
        public function filesize($path, $recursive = false)
        {
        }
        /**
         * Gets file type
         *
         * @param string $path
         * @return string|false
         */
        public function filetype($path)
        {
        }
        /**
         * Renames a file or a directory on the SFTP server.
         *
         * If the file already exists this will return false
         *
         * @param string $oldname
         * @param string $newname
         * @return bool
         * @throws \UnexpectedValueException on receipt of unexpected packets
         */
        public function rename($oldname, $newname)
        {
        }
        /**
         * Parse Attributes
         *
         * See '7.  File Attributes' of draft-ietf-secsh-filexfer-13 for more info.
         *
         * @param string $response
         * @return array
         */
        protected function parseAttributes(&$response)
        {
        }
        /**
         * Resets a connection for re-use
         */
        protected function reset_connection()
        {
        }
        /**
         * Returns a log of the packets that have been sent and received.
         *
         * Returns a string if NET_SFTP_LOGGING == self::LOG_COMPLEX, an array if NET_SFTP_LOGGING == self::LOG_SIMPLE and false if !defined('NET_SFTP_LOGGING')
         *
         * @return array|string|false
         */
        public function getSFTPLog()
        {
        }
        /**
         * Returns all errors on the SFTP layer
         *
         * @return array
         */
        public function getSFTPErrors()
        {
        }
        /**
         * Returns the last error on the SFTP layer
         *
         * @return string
         */
        public function getLastSFTPError()
        {
        }
        /**
         * Get supported SFTP versions
         *
         * @return array
         */
        public function getSupportedVersions()
        {
        }
        /**
         * Get supported SFTP extensions
         *
         * @return array
         */
        public function getSupportedExtensions()
        {
        }
        /**
         * Get supported SFTP versions
         *
         * @return int|false
         */
        public function getNegotiatedVersion()
        {
        }
        /**
         * Set preferred version
         *
         * If you're preferred version isn't supported then the highest supported
         * version of SFTP will be utilized. Set to null or false or int(0) to
         * unset the preferred version
         *
         * @param int $version
         */
        public function setPreferredVersion($version)
        {
        }
        /**
         * Disconnect
         *
         * @param int $reason
         * @return false
         */
        protected function disconnect_helper($reason)
        {
        }
        /**
         * Enable Date Preservation
         *
         */
        public function enableDatePreservation()
        {
        }
        /**
         * Disable Date Preservation
         *
         */
        public function disableDatePreservation()
        {
        }
        /**
         * POSIX Rename
         *
         * Where rename() fails "if there already exists a file with the name specified by newpath"
         * (draft-ietf-secsh-filexfer-02#section-6.5), posix_rename() overwrites the existing file in an atomic fashion.
         * ie. "there is no observable instant in time where the name does not refer to either the old or the new file"
         * (draft-ietf-secsh-filexfer-13#page-39).
         *
         * @param string $oldname
         * @param string $newname
         * @return bool
         */
        public function posix_rename($oldname, $newname)
        {
        }
        /**
         * Returns general information about a file system.
         *
         * The function statvfs() returns information about a mounted filesystem.
         * @see https://man7.org/linux/man-pages/man3/statvfs.3.html
         *
         * @param string $path
         * @return false|array{bsize: int, frsize: int, blocks: int, bfree: int, bavail: int, files: int, ffree: int, favail: int, fsid: int, flag: int, namemax: int}
         */
        public function statvfs($path)
        {
        }
    }
}
namespace phpseclib3\System\SSH\Common\Traits {
    /**
     * ReadBytes trait
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    trait ReadBytes
    {
        /**
         * Read data
         *
         * @param int $length
         * @throws \RuntimeException on connection errors
         */
        public function readBytes($length)
        {
        }
    }
}
namespace phpseclib3\System\SSH\Agent {
    /**
     * Pure-PHP ssh-agent client identity object
     *
     * Instantiation should only be performed by \phpseclib3\System\SSH\Agent class.
     * This could be thought of as implementing an interface that phpseclib3\Crypt\RSA
     * implements. ie. maybe a Net_SSH_Auth_PublicKey interface or something.
     * The methods in this interface would be getPublicKey and sign since those are the
     * methods phpseclib looks for to perform public key authentication.
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     * @internal
     */
    class Identity implements \phpseclib3\Crypt\Common\PrivateKey
    {
        use \phpseclib3\System\SSH\Common\Traits\ReadBytes;
        // Signature Flags
        // See https://tools.ietf.org/html/draft-miller-ssh-agent-00#section-5.3
        const SSH_AGENT_RSA2_256 = 2;
        const SSH_AGENT_RSA2_512 = 4;
        /**
         * Default Constructor.
         *
         * @param resource $fsock
         */
        public function __construct($fsock)
        {
        }
        /**
         * Set Public Key
         *
         * Called by \phpseclib3\System\SSH\Agent::requestIdentities()
         *
         * @param PublicKey $key
         */
        public function withPublicKey(\phpseclib3\Crypt\Common\PublicKey $key)
        {
        }
        /**
         * Set Public Key
         *
         * Called by \phpseclib3\System\SSH\Agent::requestIdentities(). The key blob could be extracted from $this->key
         * but this saves a small amount of computation.
         *
         * @param string $key_blob
         */
        public function withPublicKeyBlob($key_blob)
        {
        }
        /**
         * Get Public Key
         *
         * Wrapper for $this->key->getPublicKey()
         *
         * @return mixed
         */
        public function getPublicKey()
        {
        }
        /**
         * Sets the hash
         *
         * @param string $hash
         */
        public function withHash($hash)
        {
        }
        /**
         * Sets the padding
         *
         * Only PKCS1 padding is supported
         *
         * @param string $padding
         */
        public function withPadding($padding)
        {
        }
        /**
         * Determines the signature padding mode
         *
         * Valid values are: ASN1, SSH2, Raw
         *
         * @param string $format
         */
        public function withSignatureFormat($format)
        {
        }
        /**
         * Returns the curve
         *
         * Returns a string if it's a named curve, an array if not
         *
         * @return string|array
         */
        public function getCurve()
        {
        }
        /**
         * Create a signature
         *
         * See "2.6.2 Protocol 2 private key signature request"
         *
         * @param string $message
         * @return string
         * @throws \RuntimeException on connection errors
         * @throws UnsupportedAlgorithmException if the algorithm is unsupported
         */
        public function sign($message)
        {
        }
        /**
         * Returns the private key
         *
         * @param string $type
         * @param array $options optional
         * @return string
         */
        public function toString($type, array $options = [])
        {
        }
        /**
         * Sets the password
         *
         * @param string|bool $password
         * @return never
         */
        public function withPassword($password = false)
        {
        }
        /**
         * Sets the comment
         */
        public function withComment($comment = null)
        {
        }
        /**
         * Returns the comment
         *
         * @return null|string
         */
        public function getComment()
        {
        }
    }
}
namespace phpseclib3\System\SSH {
    /**
     * Pure-PHP ssh-agent client identity factory
     *
     * requestIdentities() method pumps out \phpseclib3\System\SSH\Agent\Identity objects
     *
     * @author  Jim Wigginton <terrafrost@php.net>
     */
    class Agent
    {
        use \phpseclib3\System\SSH\Common\Traits\ReadBytes;
        // Message numbers
        // to request SSH1 keys you have to use SSH_AGENTC_REQUEST_RSA_IDENTITIES (1)
        const SSH_AGENTC_REQUEST_IDENTITIES = 11;
        // this is the SSH2 response; the SSH1 response is SSH_AGENT_RSA_IDENTITIES_ANSWER (2).
        const SSH_AGENT_IDENTITIES_ANSWER = 12;
        // the SSH1 request is SSH_AGENTC_RSA_CHALLENGE (3)
        const SSH_AGENTC_SIGN_REQUEST = 13;
        // the SSH1 response is SSH_AGENT_RSA_RESPONSE (4)
        const SSH_AGENT_SIGN_RESPONSE = 14;
        // Agent forwarding status
        // no forwarding requested and not active
        const FORWARD_NONE = 0;
        // request agent forwarding when opportune
        const FORWARD_REQUEST = 1;
        // forwarding has been request and is active
        const FORWARD_ACTIVE = 2;
        /**
         * Unused
         */
        const SSH_AGENT_FAILURE = 5;
        /**
         * Default Constructor
         *
         * @return Agent
         * @throws BadConfigurationException if SSH_AUTH_SOCK cannot be found
         * @throws \RuntimeException on connection errors
         */
        public function __construct($address = null)
        {
        }
        /**
         * Request Identities
         *
         * See "2.5.2 Requesting a list of protocol 2 keys"
         * Returns an array containing zero or more \phpseclib3\System\SSH\Agent\Identity objects
         *
         * @return array
         * @throws \RuntimeException on receipt of unexpected packets
         */
        public function requestIdentities()
        {
        }
        /**
         * Returns the SSH Agent identity matching a given public key or null if no identity is found
         *
         * @return ?Identity
         */
        public function findIdentityByPublicKey(\phpseclib3\Crypt\Common\PublicKey $key)
        {
        }
        /**
         * Signal that agent forwarding should
         * be requested when a channel is opened
         *
         * @return void
         */
        public function startSSHForwarding()
        {
        }
        /**
         * On successful channel open
         *
         * This method is called upon successful channel
         * open to give the SSH Agent an opportunity
         * to take further action. i.e. request agent forwarding
         *
         * @param SSH2 $ssh
         */
        public function registerChannelOpen(\phpseclib3\Net\SSH2 $ssh)
        {
        }
        /**
         * Forward data to SSH Agent and return data reply
         *
         * @param string $data
         * @return string Data from SSH Agent
         * @throws \RuntimeException on connection errors
         */
        public function forwardData($data)
        {
        }
    }
}
namespace PHPStan\PhpDocParser\Ast {
    /**
     * Inspired by https://github.com/nikic/PHP-Parser/tree/36a6dcd04e7b0285e8f0868f44bd4927802f7df1
     *
     * Copyright (c) 2011, Nikita Popov
     * All rights reserved.
     */
    interface NodeVisitor
    {
        /**
         * Called once before traversal.
         *
         * Return value semantics:
         *  * null:      $nodes stays as-is
         *  * otherwise: $nodes is set to the return value
         *
         * @param Node[] $nodes Array of nodes
         *
         * @return Node[]|null Array of nodes
         */
        public function beforeTraverse(array $nodes): ?array;
        /**
         * Called when entering a node.
         *
         * Return value semantics:
         *  * null
         *        => $node stays as-is
         *  * array (of Nodes)
         *        => The return value is merged into the parent array (at the position of the $node)
         *  * NodeTraverser::REMOVE_NODE
         *        => $node is removed from the parent array
         *  * NodeTraverser::DONT_TRAVERSE_CHILDREN
         *        => Children of $node are not traversed. $node stays as-is
         *  * NodeTraverser::DONT_TRAVERSE_CURRENT_AND_CHILDREN
         *        => Further visitors for the current node are skipped, and its children are not
         *           traversed. $node stays as-is.
         *  * NodeTraverser::STOP_TRAVERSAL
         *        => Traversal is aborted. $node stays as-is
         *  * otherwise
         *        => $node is set to the return value
         *
         * @param Node $node Node
         *
         * @return Node|Node[]|NodeTraverser::*|null Replacement node (or special return value)
         */
        public function enterNode(\PHPStan\PhpDocParser\Ast\Node $node);
        /**
         * Called when leaving a node.
         *
         * Return value semantics:
         *  * null
         *        => $node stays as-is
         *  * NodeTraverser::REMOVE_NODE
         *        => $node is removed from the parent array
         *  * NodeTraverser::STOP_TRAVERSAL
         *        => Traversal is aborted. $node stays as-is
         *  * array (of Nodes)
         *        => The return value is merged into the parent array (at the position of the $node)
         *  * otherwise
         *        => $node is set to the return value
         *
         * @param Node $node Node
         *
         * @return Node|Node[]|NodeTraverser::REMOVE_NODE|NodeTraverser::STOP_TRAVERSAL|null Replacement node (or special return value)
         */
        public function leaveNode(\PHPStan\PhpDocParser\Ast\Node $node);
        /**
         * Called once after traversal.
         *
         * Return value semantics:
         *  * null:      $nodes stays as-is
         *  * otherwise: $nodes is set to the return value
         *
         * @param Node[] $nodes Array of nodes
         *
         * @return Node[]|null Array of nodes
         */
        public function afterTraverse(array $nodes): ?array;
    }
    /**
     * Inspired by https://github.com/nikic/PHP-Parser/tree/36a6dcd04e7b0285e8f0868f44bd4927802f7df1
     *
     * Copyright (c) 2011, Nikita Popov
     * All rights reserved.
     */
    abstract class AbstractNodeVisitor implements \PHPStan\PhpDocParser\Ast\NodeVisitor
    {
        public function beforeTraverse(array $nodes): ?array
        {
        }
        public function enterNode(\PHPStan\PhpDocParser\Ast\Node $node)
        {
        }
        public function leaveNode(\PHPStan\PhpDocParser\Ast\Node $node)
        {
        }
        public function afterTraverse(array $nodes): ?array
        {
        }
    }
    final class Attribute
    {
        public const START_LINE = 'startLine';
        public const END_LINE = 'endLine';
        public const START_INDEX = 'startIndex';
        public const END_INDEX = 'endIndex';
        public const ORIGINAL_NODE = 'originalNode';
        public const COMMENTS = 'comments';
    }
    class Comment
    {
        public string $text;
        public int $startLine;
        public int $startIndex;
        public function __construct(string $text, int $startLine = -1, int $startIndex = -1)
        {
        }
        public function getReformattedText(): string
        {
        }
    }
    interface Node
    {
        public function __toString(): string;
        /**
         * @param mixed $value
         */
        public function setAttribute(string $key, $value): void;
        public function hasAttribute(string $key): bool;
        /**
         * @return mixed
         */
        public function getAttribute(string $key);
    }
}
namespace PHPStan\PhpDocParser\Ast\ConstExpr {
    interface ConstExprNode extends \PHPStan\PhpDocParser\Ast\Node
    {
    }
}
namespace PHPStan\PhpDocParser\Ast {
    trait NodeAttributes
    {
        /** @var array<string, mixed> */
        private array $attributes = [];
        /**
         * @param mixed $value
         */
        public function setAttribute(string $key, $value): void
        {
        }
        public function hasAttribute(string $key): bool
        {
        }
        /**
         * @return mixed
         */
        public function getAttribute(string $key)
        {
        }
    }
}
namespace PHPStan\PhpDocParser\Ast\ConstExpr {
    class ConstExprArrayItemNode implements \PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public ?\PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprNode $key = null;
        public \PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprNode $value;
        public function __construct(?\PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprNode $key, \PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprNode $value)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ConstExprArrayNode implements \PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        /** @var ConstExprArrayItemNode[] */
        public array $items;
        /**
         * @param ConstExprArrayItemNode[] $items
         */
        public function __construct(array $items)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ConstExprFalseNode implements \PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public function __toString(): string
        {
        }
    }
    class ConstExprFloatNode implements \PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public string $value;
        public function __construct(string $value)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ConstExprIntegerNode implements \PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public string $value;
        public function __construct(string $value)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ConstExprNullNode implements \PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public function __toString(): string
        {
        }
    }
    class ConstExprStringNode implements \PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprNode
    {
        public const SINGLE_QUOTED = 1;
        public const DOUBLE_QUOTED = 2;
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public string $value;
        /** @var self::SINGLE_QUOTED|self::DOUBLE_QUOTED */
        public $quoteType;
        /**
         * @param self::SINGLE_QUOTED|self::DOUBLE_QUOTED $quoteType
         */
        public function __construct(string $value, int $quoteType)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ConstExprTrueNode implements \PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public function __toString(): string
        {
        }
    }
    class ConstFetchNode implements \PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        /** @var string class name for class constants or empty string for non-class constants */
        public string $className;
        public string $name;
        public function __construct(string $className, string $name)
        {
        }
        public function __toString(): string
        {
        }
    }
    class DoctrineConstExprStringNode extends \PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprStringNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public string $value;
        public function __construct(string $value)
        {
        }
        public function __toString(): string
        {
        }
        public static function unescape(string $value): string
        {
        }
    }
}
namespace PHPStan\PhpDocParser\Ast {
    /**
     * Inspired by https://github.com/nikic/PHP-Parser/tree/36a6dcd04e7b0285e8f0868f44bd4927802f7df1
     *
     * Copyright (c) 2011, Nikita Popov
     * All rights reserved.
     */
    final class NodeTraverser
    {
        /**
         * If NodeVisitor::enterNode() returns DONT_TRAVERSE_CHILDREN, child nodes
         * of the current node will not be traversed for any visitors.
         *
         * For subsequent visitors enterNode() will still be called on the current
         * node and leaveNode() will also be invoked for the current node.
         */
        public const DONT_TRAVERSE_CHILDREN = 1;
        /**
         * If NodeVisitor::enterNode() or NodeVisitor::leaveNode() returns
         * STOP_TRAVERSAL, traversal is aborted.
         *
         * The afterTraverse() method will still be invoked.
         */
        public const STOP_TRAVERSAL = 2;
        /**
         * If NodeVisitor::leaveNode() returns REMOVE_NODE for a node that occurs
         * in an array, it will be removed from the array.
         *
         * For subsequent visitors leaveNode() will still be invoked for the
         * removed node.
         */
        public const REMOVE_NODE = 3;
        /**
         * If NodeVisitor::enterNode() returns DONT_TRAVERSE_CURRENT_AND_CHILDREN, child nodes
         * of the current node will not be traversed for any visitors.
         *
         * For subsequent visitors enterNode() will not be called as well.
         * leaveNode() will be invoked for visitors that has enterNode() method invoked.
         */
        public const DONT_TRAVERSE_CURRENT_AND_CHILDREN = 4;
        /**
         * @param list<NodeVisitor> $visitors
         */
        public function __construct(array $visitors)
        {
        }
        /**
         * Traverses an array of nodes using the registered visitors.
         *
         * @param Node[] $nodes Array of nodes
         *
         * @return Node[] Traversed array of nodes
         */
        public function traverse(array $nodes): array
        {
        }
    }
}
namespace PHPStan\PhpDocParser\Ast\NodeVisitor {
    final class CloningVisitor extends \PHPStan\PhpDocParser\Ast\AbstractNodeVisitor
    {
        public function enterNode(\PHPStan\PhpDocParser\Ast\Node $originalNode): \PHPStan\PhpDocParser\Ast\Node
        {
        }
    }
}
namespace PHPStan\PhpDocParser\Ast\PhpDoc {
    interface PhpDocTagValueNode extends \PHPStan\PhpDocParser\Ast\Node
    {
    }
    class AssertTagMethodValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        public string $parameter;
        public string $method;
        public bool $isNegated;
        public bool $isEquality;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $type, string $parameter, string $method, bool $isNegated, string $description, bool $isEquality)
        {
        }
        public function __toString(): string
        {
        }
    }
    class AssertTagPropertyValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        public string $parameter;
        public string $property;
        public bool $isNegated;
        public bool $isEquality;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $type, string $parameter, string $property, bool $isNegated, string $description, bool $isEquality)
        {
        }
        public function __toString(): string
        {
        }
    }
    class AssertTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        public string $parameter;
        public bool $isNegated;
        public bool $isEquality;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $type, string $parameter, bool $isNegated, string $description, bool $isEquality)
        {
        }
        public function __toString(): string
        {
        }
    }
    class DeprecatedTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(string $description)
        {
        }
        public function __toString(): string
        {
        }
    }
}
namespace PHPStan\PhpDocParser\Ast\PhpDoc\Doctrine {
    class DoctrineAnnotation implements \PHPStan\PhpDocParser\Ast\Node
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public string $name;
        /** @var list<DoctrineArgument> */
        public array $arguments;
        /**
         * @param list<DoctrineArgument> $arguments
         */
        public function __construct(string $name, array $arguments)
        {
        }
        public function __toString(): string
        {
        }
    }
    /**
     * @phpstan-type ValueType = DoctrineAnnotation|IdentifierTypeNode|DoctrineArray|ConstExprNode
     */
    class DoctrineArgument implements \PHPStan\PhpDocParser\Ast\Node
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public ?\PHPStan\PhpDocParser\Ast\Type\IdentifierTypeNode $key = null;
        /** @var ValueType */
        public $value;
        /**
         * @param ValueType $value
         */
        public function __construct(?\PHPStan\PhpDocParser\Ast\Type\IdentifierTypeNode $key, $value)
        {
        }
        public function __toString(): string
        {
        }
    }
    class DoctrineArray implements \PHPStan\PhpDocParser\Ast\Node
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        /** @var list<DoctrineArrayItem> */
        public array $items;
        /**
         * @param list<DoctrineArrayItem> $items
         */
        public function __construct(array $items)
        {
        }
        public function __toString(): string
        {
        }
    }
    /**
     * @phpstan-import-type ValueType from DoctrineArgument
     * @phpstan-type KeyType = ConstExprIntegerNode|ConstExprStringNode|IdentifierTypeNode|ConstFetchNode|null
     */
    class DoctrineArrayItem implements \PHPStan\PhpDocParser\Ast\Node
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        /** @var KeyType */
        public $key;
        /** @var ValueType */
        public $value;
        /**
         * @param KeyType $key
         * @param ValueType $value
         */
        public function __construct($key, $value)
        {
        }
        public function __toString(): string
        {
        }
    }
    class DoctrineTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\PhpDoc\Doctrine\DoctrineAnnotation $annotation;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(\PHPStan\PhpDocParser\Ast\PhpDoc\Doctrine\DoctrineAnnotation $annotation, string $description)
        {
        }
        public function __toString(): string
        {
        }
    }
}
namespace PHPStan\PhpDocParser\Ast\PhpDoc {
    class ExtendsTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\GenericTypeNode $type;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\GenericTypeNode $type, string $description)
        {
        }
        public function __toString(): string
        {
        }
    }
    class GenericTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        /** @var string (may be empty) */
        public string $value;
        public function __construct(string $value)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ImplementsTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\GenericTypeNode $type;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\GenericTypeNode $type, string $description)
        {
        }
        public function __toString(): string
        {
        }
    }
    /**
     * @property ParserException $exception
     */
    class InvalidTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        /** @var string (may be empty) */
        public string $value;
        public function __construct(string $value, \PHPStan\PhpDocParser\Parser\ParserException $exception)
        {
        }
        public function __get(string $name): ?\PHPStan\PhpDocParser\Parser\ParserException
        {
        }
        public function __toString(): string
        {
        }
    }
    class MethodTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public bool $isStatic;
        public ?\PHPStan\PhpDocParser\Ast\Type\TypeNode $returnType = null;
        public string $methodName;
        /** @var TemplateTagValueNode[] */
        public array $templateTypes;
        /** @var MethodTagValueParameterNode[] */
        public array $parameters;
        /** @var string (may be empty) */
        public string $description;
        /**
         * @param MethodTagValueParameterNode[] $parameters
         * @param TemplateTagValueNode[] $templateTypes
         */
        public function __construct(bool $isStatic, ?\PHPStan\PhpDocParser\Ast\Type\TypeNode $returnType, string $methodName, array $parameters, string $description, array $templateTypes)
        {
        }
        public function __toString(): string
        {
        }
    }
    class MethodTagValueParameterNode implements \PHPStan\PhpDocParser\Ast\Node
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public ?\PHPStan\PhpDocParser\Ast\Type\TypeNode $type = null;
        public bool $isReference;
        public bool $isVariadic;
        public string $parameterName;
        public ?\PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprNode $defaultValue = null;
        public function __construct(?\PHPStan\PhpDocParser\Ast\Type\TypeNode $type, bool $isReference, bool $isVariadic, string $parameterName, ?\PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprNode $defaultValue)
        {
        }
        public function __toString(): string
        {
        }
    }
    class MixinTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $type, string $description)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ParamClosureThisTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        public string $parameterName;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $type, string $parameterName, string $description)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ParamImmediatelyInvokedCallableTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public string $parameterName;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(string $parameterName, string $description)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ParamLaterInvokedCallableTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public string $parameterName;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(string $parameterName, string $description)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ParamOutTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        public string $parameterName;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $type, string $parameterName, string $description)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ParamTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        public bool $isReference;
        public bool $isVariadic;
        public string $parameterName;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $type, bool $isVariadic, string $parameterName, string $description, bool $isReference)
        {
        }
        public function __toString(): string
        {
        }
    }
    interface PhpDocChildNode extends \PHPStan\PhpDocParser\Ast\Node
    {
    }
    class PhpDocNode implements \PHPStan\PhpDocParser\Ast\Node
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        /** @var PhpDocChildNode[] */
        public array $children;
        /**
         * @param PhpDocChildNode[] $children
         */
        public function __construct(array $children)
        {
        }
        /**
         * @return PhpDocTagNode[]
         */
        public function getTags(): array
        {
        }
        /**
         * @return PhpDocTagNode[]
         */
        public function getTagsByName(string $tagName): array
        {
        }
        /**
         * @return VarTagValueNode[]
         */
        public function getVarTagValues(string $tagName = '@var'): array
        {
        }
        /**
         * @return ParamTagValueNode[]
         */
        public function getParamTagValues(string $tagName = '@param'): array
        {
        }
        /**
         * @return TypelessParamTagValueNode[]
         */
        public function getTypelessParamTagValues(string $tagName = '@param'): array
        {
        }
        /**
         * @return ParamImmediatelyInvokedCallableTagValueNode[]
         */
        public function getParamImmediatelyInvokedCallableTagValues(string $tagName = '@param-immediately-invoked-callable'): array
        {
        }
        /**
         * @return ParamLaterInvokedCallableTagValueNode[]
         */
        public function getParamLaterInvokedCallableTagValues(string $tagName = '@param-later-invoked-callable'): array
        {
        }
        /**
         * @return ParamClosureThisTagValueNode[]
         */
        public function getParamClosureThisTagValues(string $tagName = '@param-closure-this'): array
        {
        }
        /**
         * @return PureUnlessCallableIsImpureTagValueNode[]
         */
        public function getPureUnlessCallableIsImpureTagValues(string $tagName = '@pure-unless-callable-is-impure'): array
        {
        }
        /**
         * @return TemplateTagValueNode[]
         */
        public function getTemplateTagValues(string $tagName = '@template'): array
        {
        }
        /**
         * @return ExtendsTagValueNode[]
         */
        public function getExtendsTagValues(string $tagName = '@extends'): array
        {
        }
        /**
         * @return ImplementsTagValueNode[]
         */
        public function getImplementsTagValues(string $tagName = '@implements'): array
        {
        }
        /**
         * @return UsesTagValueNode[]
         */
        public function getUsesTagValues(string $tagName = '@use'): array
        {
        }
        /**
         * @return ReturnTagValueNode[]
         */
        public function getReturnTagValues(string $tagName = '@return'): array
        {
        }
        /**
         * @return ThrowsTagValueNode[]
         */
        public function getThrowsTagValues(string $tagName = '@throws'): array
        {
        }
        /**
         * @return MixinTagValueNode[]
         */
        public function getMixinTagValues(string $tagName = '@mixin'): array
        {
        }
        /**
         * @return RequireExtendsTagValueNode[]
         */
        public function getRequireExtendsTagValues(string $tagName = '@phpstan-require-extends'): array
        {
        }
        /**
         * @return RequireImplementsTagValueNode[]
         */
        public function getRequireImplementsTagValues(string $tagName = '@phpstan-require-implements'): array
        {
        }
        /**
         * @return DeprecatedTagValueNode[]
         */
        public function getDeprecatedTagValues(): array
        {
        }
        /**
         * @return PropertyTagValueNode[]
         */
        public function getPropertyTagValues(string $tagName = '@property'): array
        {
        }
        /**
         * @return PropertyTagValueNode[]
         */
        public function getPropertyReadTagValues(string $tagName = '@property-read'): array
        {
        }
        /**
         * @return PropertyTagValueNode[]
         */
        public function getPropertyWriteTagValues(string $tagName = '@property-write'): array
        {
        }
        /**
         * @return MethodTagValueNode[]
         */
        public function getMethodTagValues(string $tagName = '@method'): array
        {
        }
        /**
         * @return TypeAliasTagValueNode[]
         */
        public function getTypeAliasTagValues(string $tagName = '@phpstan-type'): array
        {
        }
        /**
         * @return TypeAliasImportTagValueNode[]
         */
        public function getTypeAliasImportTagValues(string $tagName = '@phpstan-import-type'): array
        {
        }
        /**
         * @return AssertTagValueNode[]
         */
        public function getAssertTagValues(string $tagName = '@phpstan-assert'): array
        {
        }
        /**
         * @return AssertTagPropertyValueNode[]
         */
        public function getAssertPropertyTagValues(string $tagName = '@phpstan-assert'): array
        {
        }
        /**
         * @return AssertTagMethodValueNode[]
         */
        public function getAssertMethodTagValues(string $tagName = '@phpstan-assert'): array
        {
        }
        /**
         * @return SelfOutTagValueNode[]
         */
        public function getSelfOutTypeTagValues(string $tagName = '@phpstan-this-out'): array
        {
        }
        /**
         * @return ParamOutTagValueNode[]
         */
        public function getParamOutTypeTagValues(string $tagName = '@param-out'): array
        {
        }
        public function __toString(): string
        {
        }
    }
    class PhpDocTagNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocChildNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public string $name;
        public \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode $value;
        public function __construct(string $name, \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode $value)
        {
        }
        public function __toString(): string
        {
        }
    }
    class PhpDocTextNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocChildNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public string $text;
        public function __construct(string $text)
        {
        }
        public function __toString(): string
        {
        }
    }
    class PropertyTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        public string $propertyName;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $type, string $propertyName, string $description)
        {
        }
        public function __toString(): string
        {
        }
    }
    class PureUnlessCallableIsImpureTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public string $parameterName;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(string $parameterName, string $description)
        {
        }
        public function __toString(): string
        {
        }
    }
    class RequireExtendsTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $type, string $description)
        {
        }
        public function __toString(): string
        {
        }
    }
    class RequireImplementsTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $type, string $description)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ReturnTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $type, string $description)
        {
        }
        public function __toString(): string
        {
        }
    }
    class SelfOutTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $type, string $description)
        {
        }
        public function __toString(): string
        {
        }
    }
    class TemplateTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        /** @var non-empty-string */
        public string $name;
        public ?\PHPStan\PhpDocParser\Ast\Type\TypeNode $bound;
        public ?\PHPStan\PhpDocParser\Ast\Type\TypeNode $default;
        public ?\PHPStan\PhpDocParser\Ast\Type\TypeNode $lowerBound;
        /** @var string (may be empty) */
        public string $description;
        /**
         * @param non-empty-string $name
         */
        public function __construct(string $name, ?\PHPStan\PhpDocParser\Ast\Type\TypeNode $bound, string $description, ?\PHPStan\PhpDocParser\Ast\Type\TypeNode $default = null, ?\PHPStan\PhpDocParser\Ast\Type\TypeNode $lowerBound = null)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ThrowsTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $type, string $description)
        {
        }
        public function __toString(): string
        {
        }
    }
    class TypeAliasImportTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public string $importedAlias;
        public \PHPStan\PhpDocParser\Ast\Type\IdentifierTypeNode $importedFrom;
        public ?string $importedAs = null;
        public function __construct(string $importedAlias, \PHPStan\PhpDocParser\Ast\Type\IdentifierTypeNode $importedFrom, ?string $importedAs)
        {
        }
        public function __toString(): string
        {
        }
    }
    class TypeAliasTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public string $alias;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        public function __construct(string $alias, \PHPStan\PhpDocParser\Ast\Type\TypeNode $type)
        {
        }
        public function __toString(): string
        {
        }
    }
    class TypelessParamTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public bool $isReference;
        public bool $isVariadic;
        public string $parameterName;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(bool $isVariadic, string $parameterName, string $description, bool $isReference)
        {
        }
        public function __toString(): string
        {
        }
    }
    class UsesTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\GenericTypeNode $type;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\GenericTypeNode $type, string $description)
        {
        }
        public function __toString(): string
        {
        }
    }
    class VarTagValueNode implements \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        /** @var string (may be empty) */
        public string $variableName;
        /** @var string (may be empty) */
        public string $description;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $type, string $variableName, string $description)
        {
        }
        public function __toString(): string
        {
        }
    }
}
namespace PHPStan\PhpDocParser\Ast\Type {
    class ArrayShapeItemNode implements \PHPStan\PhpDocParser\Ast\Node
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        /** @var ConstExprIntegerNode|ConstExprStringNode|IdentifierTypeNode|null */
        public $keyName;
        public bool $optional;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $valueType;
        /**
         * @param ConstExprIntegerNode|ConstExprStringNode|IdentifierTypeNode|null $keyName
         */
        public function __construct($keyName, bool $optional, \PHPStan\PhpDocParser\Ast\Type\TypeNode $valueType)
        {
        }
        public function __toString(): string
        {
        }
    }
    interface TypeNode extends \PHPStan\PhpDocParser\Ast\Node
    {
    }
    class ArrayShapeNode implements \PHPStan\PhpDocParser\Ast\Type\TypeNode
    {
        public const KIND_ARRAY = 'array';
        public const KIND_LIST = 'list';
        public const KIND_NON_EMPTY_ARRAY = 'non-empty-array';
        public const KIND_NON_EMPTY_LIST = 'non-empty-list';
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        /** @var ArrayShapeItemNode[] */
        public array $items;
        public bool $sealed;
        /** @var self::KIND_* */
        public $kind;
        public ?\PHPStan\PhpDocParser\Ast\Type\ArrayShapeUnsealedTypeNode $unsealedType = null;
        /**
         * @param ArrayShapeItemNode[] $items
         * @param self::KIND_* $kind
         */
        public static function createSealed(array $items, string $kind = self::KIND_ARRAY): self
        {
        }
        /**
         * @param ArrayShapeItemNode[] $items
         * @param self::KIND_* $kind
         */
        public static function createUnsealed(array $items, ?\PHPStan\PhpDocParser\Ast\Type\ArrayShapeUnsealedTypeNode $unsealedType, string $kind = self::KIND_ARRAY): self
        {
        }
        public function __toString(): string
        {
        }
    }
    class ArrayShapeUnsealedTypeNode implements \PHPStan\PhpDocParser\Ast\Node
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $valueType;
        public ?\PHPStan\PhpDocParser\Ast\Type\TypeNode $keyType = null;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $valueType, ?\PHPStan\PhpDocParser\Ast\Type\TypeNode $keyType)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ArrayTypeNode implements \PHPStan\PhpDocParser\Ast\Type\TypeNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $type)
        {
        }
        public function __toString(): string
        {
        }
    }
    class CallableTypeNode implements \PHPStan\PhpDocParser\Ast\Type\TypeNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\IdentifierTypeNode $identifier;
        /** @var TemplateTagValueNode[] */
        public array $templateTypes;
        /** @var CallableTypeParameterNode[] */
        public array $parameters;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $returnType;
        /**
         * @param CallableTypeParameterNode[] $parameters
         * @param TemplateTagValueNode[]  $templateTypes
         */
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\IdentifierTypeNode $identifier, array $parameters, \PHPStan\PhpDocParser\Ast\Type\TypeNode $returnType, array $templateTypes)
        {
        }
        public function __toString(): string
        {
        }
    }
    class CallableTypeParameterNode implements \PHPStan\PhpDocParser\Ast\Node
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        public bool $isReference;
        public bool $isVariadic;
        /** @var string (may be empty) */
        public string $parameterName;
        public bool $isOptional;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $type, bool $isReference, bool $isVariadic, string $parameterName, bool $isOptional)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ConditionalTypeForParameterNode implements \PHPStan\PhpDocParser\Ast\Type\TypeNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public string $parameterName;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $targetType;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $if;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $else;
        public bool $negated;
        public function __construct(string $parameterName, \PHPStan\PhpDocParser\Ast\Type\TypeNode $targetType, \PHPStan\PhpDocParser\Ast\Type\TypeNode $if, \PHPStan\PhpDocParser\Ast\Type\TypeNode $else, bool $negated)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ConditionalTypeNode implements \PHPStan\PhpDocParser\Ast\Type\TypeNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $subjectType;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $targetType;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $if;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $else;
        public bool $negated;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $subjectType, \PHPStan\PhpDocParser\Ast\Type\TypeNode $targetType, \PHPStan\PhpDocParser\Ast\Type\TypeNode $if, \PHPStan\PhpDocParser\Ast\Type\TypeNode $else, bool $negated)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ConstTypeNode implements \PHPStan\PhpDocParser\Ast\Type\TypeNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprNode $constExpr;
        public function __construct(\PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprNode $constExpr)
        {
        }
        public function __toString(): string
        {
        }
    }
    class GenericTypeNode implements \PHPStan\PhpDocParser\Ast\Type\TypeNode
    {
        public const VARIANCE_INVARIANT = 'invariant';
        public const VARIANCE_COVARIANT = 'covariant';
        public const VARIANCE_CONTRAVARIANT = 'contravariant';
        public const VARIANCE_BIVARIANT = 'bivariant';
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\IdentifierTypeNode $type;
        /** @var TypeNode[] */
        public array $genericTypes;
        /** @var (self::VARIANCE_*)[] */
        public array $variances;
        /**
         * @param TypeNode[] $genericTypes
         * @param (self::VARIANCE_*)[] $variances
         */
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\IdentifierTypeNode $type, array $genericTypes, array $variances = [])
        {
        }
        public function __toString(): string
        {
        }
    }
    class IdentifierTypeNode implements \PHPStan\PhpDocParser\Ast\Type\TypeNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public string $name;
        public function __construct(string $name)
        {
        }
        public function __toString(): string
        {
        }
    }
    class IntersectionTypeNode implements \PHPStan\PhpDocParser\Ast\Type\TypeNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        /** @var TypeNode[] */
        public array $types;
        /**
         * @param TypeNode[] $types
         */
        public function __construct(array $types)
        {
        }
        public function __toString(): string
        {
        }
    }
    class InvalidTypeNode implements \PHPStan\PhpDocParser\Ast\Type\TypeNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public function __construct(\PHPStan\PhpDocParser\Parser\ParserException $exception)
        {
        }
        public function getException(): \PHPStan\PhpDocParser\Parser\ParserException
        {
        }
        public function __toString(): string
        {
        }
    }
    class NullableTypeNode implements \PHPStan\PhpDocParser\Ast\Type\TypeNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $type)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ObjectShapeItemNode implements \PHPStan\PhpDocParser\Ast\Node
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        /** @var ConstExprStringNode|IdentifierTypeNode */
        public $keyName;
        public bool $optional;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $valueType;
        /**
         * @param ConstExprStringNode|IdentifierTypeNode $keyName
         */
        public function __construct($keyName, bool $optional, \PHPStan\PhpDocParser\Ast\Type\TypeNode $valueType)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ObjectShapeNode implements \PHPStan\PhpDocParser\Ast\Type\TypeNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        /** @var ObjectShapeItemNode[] */
        public array $items;
        /**
         * @param ObjectShapeItemNode[] $items
         */
        public function __construct(array $items)
        {
        }
        public function __toString(): string
        {
        }
    }
    class OffsetAccessTypeNode implements \PHPStan\PhpDocParser\Ast\Type\TypeNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $type;
        public \PHPStan\PhpDocParser\Ast\Type\TypeNode $offset;
        public function __construct(\PHPStan\PhpDocParser\Ast\Type\TypeNode $type, \PHPStan\PhpDocParser\Ast\Type\TypeNode $offset)
        {
        }
        public function __toString(): string
        {
        }
    }
    class ThisTypeNode implements \PHPStan\PhpDocParser\Ast\Type\TypeNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        public function __toString(): string
        {
        }
    }
    class UnionTypeNode implements \PHPStan\PhpDocParser\Ast\Type\TypeNode
    {
        use \PHPStan\PhpDocParser\Ast\NodeAttributes;
        /** @var TypeNode[] */
        public array $types;
        /**
         * @param TypeNode[] $types
         */
        public function __construct(array $types)
        {
        }
        public function __toString(): string
        {
        }
    }
}
namespace PHPStan\PhpDocParser\Lexer {
    /**
     * Implementation based on Nette Tokenizer (New BSD License; https://github.com/nette/tokenizer)
     */
    class Lexer
    {
        public const TOKEN_REFERENCE = 0;
        public const TOKEN_UNION = 1;
        public const TOKEN_INTERSECTION = 2;
        public const TOKEN_NULLABLE = 3;
        public const TOKEN_OPEN_PARENTHESES = 4;
        public const TOKEN_CLOSE_PARENTHESES = 5;
        public const TOKEN_OPEN_ANGLE_BRACKET = 6;
        public const TOKEN_CLOSE_ANGLE_BRACKET = 7;
        public const TOKEN_OPEN_SQUARE_BRACKET = 8;
        public const TOKEN_CLOSE_SQUARE_BRACKET = 9;
        public const TOKEN_COMMA = 10;
        public const TOKEN_VARIADIC = 11;
        public const TOKEN_DOUBLE_COLON = 12;
        public const TOKEN_DOUBLE_ARROW = 13;
        public const TOKEN_EQUAL = 14;
        public const TOKEN_OPEN_PHPDOC = 15;
        public const TOKEN_CLOSE_PHPDOC = 16;
        public const TOKEN_PHPDOC_TAG = 17;
        public const TOKEN_DOCTRINE_TAG = 18;
        public const TOKEN_FLOAT = 19;
        public const TOKEN_INTEGER = 20;
        public const TOKEN_SINGLE_QUOTED_STRING = 21;
        public const TOKEN_DOUBLE_QUOTED_STRING = 22;
        public const TOKEN_DOCTRINE_ANNOTATION_STRING = 23;
        public const TOKEN_IDENTIFIER = 24;
        public const TOKEN_THIS_VARIABLE = 25;
        public const TOKEN_VARIABLE = 26;
        public const TOKEN_HORIZONTAL_WS = 27;
        public const TOKEN_PHPDOC_EOL = 28;
        public const TOKEN_OTHER = 29;
        public const TOKEN_END = 30;
        public const TOKEN_COLON = 31;
        public const TOKEN_WILDCARD = 32;
        public const TOKEN_OPEN_CURLY_BRACKET = 33;
        public const TOKEN_CLOSE_CURLY_BRACKET = 34;
        public const TOKEN_NEGATED = 35;
        public const TOKEN_ARROW = 36;
        public const TOKEN_COMMENT = 37;
        public const TOKEN_LABELS = [self::TOKEN_REFERENCE => '\'&\'', self::TOKEN_UNION => '\'|\'', self::TOKEN_INTERSECTION => '\'&\'', self::TOKEN_NULLABLE => '\'?\'', self::TOKEN_NEGATED => '\'!\'', self::TOKEN_OPEN_PARENTHESES => '\'(\'', self::TOKEN_CLOSE_PARENTHESES => '\')\'', self::TOKEN_OPEN_ANGLE_BRACKET => '\'<\'', self::TOKEN_CLOSE_ANGLE_BRACKET => '\'>\'', self::TOKEN_OPEN_SQUARE_BRACKET => '\'[\'', self::TOKEN_CLOSE_SQUARE_BRACKET => '\']\'', self::TOKEN_OPEN_CURLY_BRACKET => '\'{\'', self::TOKEN_CLOSE_CURLY_BRACKET => '\'}\'', self::TOKEN_COMMA => '\',\'', self::TOKEN_COMMENT => '\'//\'', self::TOKEN_COLON => '\':\'', self::TOKEN_VARIADIC => '\'...\'', self::TOKEN_DOUBLE_COLON => '\'::\'', self::TOKEN_DOUBLE_ARROW => '\'=>\'', self::TOKEN_ARROW => '\'->\'', self::TOKEN_EQUAL => '\'=\'', self::TOKEN_OPEN_PHPDOC => '\'/**\'', self::TOKEN_CLOSE_PHPDOC => '\'*/\'', self::TOKEN_PHPDOC_TAG => 'TOKEN_PHPDOC_TAG', self::TOKEN_DOCTRINE_TAG => 'TOKEN_DOCTRINE_TAG', self::TOKEN_PHPDOC_EOL => 'TOKEN_PHPDOC_EOL', self::TOKEN_FLOAT => 'TOKEN_FLOAT', self::TOKEN_INTEGER => 'TOKEN_INTEGER', self::TOKEN_SINGLE_QUOTED_STRING => 'TOKEN_SINGLE_QUOTED_STRING', self::TOKEN_DOUBLE_QUOTED_STRING => 'TOKEN_DOUBLE_QUOTED_STRING', self::TOKEN_DOCTRINE_ANNOTATION_STRING => 'TOKEN_DOCTRINE_ANNOTATION_STRING', self::TOKEN_IDENTIFIER => 'type', self::TOKEN_THIS_VARIABLE => '\'$this\'', self::TOKEN_VARIABLE => 'variable', self::TOKEN_HORIZONTAL_WS => 'TOKEN_HORIZONTAL_WS', self::TOKEN_OTHER => 'TOKEN_OTHER', self::TOKEN_END => 'TOKEN_END', self::TOKEN_WILDCARD => '*'];
        public const VALUE_OFFSET = 0;
        public const TYPE_OFFSET = 1;
        public const LINE_OFFSET = 2;
        public function __construct(\PHPStan\PhpDocParser\ParserConfig $config)
        {
        }
        /**
         * @return list<array{string, int, int}>
         */
        public function tokenize(string $s): array
        {
        }
    }
}
namespace PHPStan\PhpDocParser\Parser {
    class ConstExprParser
    {
        public function __construct(\PHPStan\PhpDocParser\ParserConfig $config)
        {
        }
        /**
         * @internal
         */
        public function toDoctrine(): self
        {
        }
        public function parse(\PHPStan\PhpDocParser\Parser\TokenIterator $tokens): \PHPStan\PhpDocParser\Ast\ConstExpr\ConstExprNode
        {
        }
        /**
         * This method is supposed to be called with TokenIterator after reading TOKEN_DOUBLE_QUOTED_STRING and shifting
         * to the next token.
         */
        public function parseDoctrineString(string $text, \PHPStan\PhpDocParser\Parser\TokenIterator $tokens): \PHPStan\PhpDocParser\Ast\ConstExpr\DoctrineConstExprStringNode
        {
        }
    }
    class ParserException extends \Exception
    {
        public function __construct(string $currentTokenValue, int $currentTokenType, int $currentOffset, int $expectedTokenType, ?string $expectedTokenValue, ?int $currentTokenLine)
        {
        }
        public function getCurrentTokenValue(): string
        {
        }
        public function getCurrentTokenType(): int
        {
        }
        public function getCurrentOffset(): int
        {
        }
        public function getExpectedTokenType(): int
        {
        }
        public function getExpectedTokenValue(): ?string
        {
        }
        public function getCurrentTokenLine(): ?int
        {
        }
    }
    /**
     * @phpstan-import-type ValueType from Doctrine\DoctrineArgument as DoctrineValueType
     */
    class PhpDocParser
    {
        public function __construct(\PHPStan\PhpDocParser\ParserConfig $config, \PHPStan\PhpDocParser\Parser\TypeParser $typeParser, \PHPStan\PhpDocParser\Parser\ConstExprParser $constantExprParser)
        {
        }
        public function parse(\PHPStan\PhpDocParser\Parser\TokenIterator $tokens): \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocNode
        {
        }
        public function parseTag(\PHPStan\PhpDocParser\Parser\TokenIterator $tokens): \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagNode
        {
        }
        public function parseTagValue(\PHPStan\PhpDocParser\Parser\TokenIterator $tokens, string $tag): \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocTagValueNode
        {
        }
    }
    class StringUnescaper
    {
        public static function unescapeString(string $string): string
        {
        }
    }
    class TokenIterator
    {
        /**
         * @param list<array{string, int, int}> $tokens
         */
        public function __construct(array $tokens, int $index = 0)
        {
        }
        /**
         * @return list<array{string, int, int}>
         */
        public function getTokens(): array
        {
        }
        public function getContentBetween(int $startPos, int $endPos): string
        {
        }
        public function getTokenCount(): int
        {
        }
        public function currentTokenValue(): string
        {
        }
        public function currentTokenType(): int
        {
        }
        public function currentTokenOffset(): int
        {
        }
        public function currentTokenLine(): int
        {
        }
        public function currentTokenIndex(): int
        {
        }
        public function endIndexOfLastRelevantToken(): int
        {
        }
        public function isCurrentTokenValue(string $tokenValue): bool
        {
        }
        public function isCurrentTokenType(int ...$tokenType): bool
        {
        }
        public function isPrecededByHorizontalWhitespace(): bool
        {
        }
        /**
         * @throws ParserException
         */
        public function consumeTokenType(int $tokenType): void
        {
        }
        /**
         * @throws ParserException
         */
        public function consumeTokenValue(int $tokenType, string $tokenValue): void
        {
        }
        /** @phpstan-impure */
        public function tryConsumeTokenValue(string $tokenValue): bool
        {
        }
        /**
         * @return list<Comment>
         */
        public function flushComments(): array
        {
        }
        /** @phpstan-impure */
        public function tryConsumeTokenType(int $tokenType): bool
        {
        }
        /**
         * @deprecated Use skipNewLineTokensAndConsumeComments instead (when parsing a type)
         */
        public function skipNewLineTokens(): void
        {
        }
        public function skipNewLineTokensAndConsumeComments(): void
        {
        }
        public function getSkippedHorizontalWhiteSpaceIfAny(): string
        {
        }
        /** @phpstan-impure */
        public function joinUntil(int ...$tokenType): string
        {
        }
        public function next(): void
        {
        }
        public function addEndOfLineToSkippedTokens(): void
        {
        }
        public function removeEndOfLineFromSkippedTokens(): void
        {
        }
        /** @phpstan-impure */
        public function forwardToTheEnd(): void
        {
        }
        public function pushSavePoint(): void
        {
        }
        public function dropSavePoint(): void
        {
        }
        public function rollback(): void
        {
        }
        /**
         * Check whether the position is directly preceded by a certain token type.
         *
         * During this check TOKEN_HORIZONTAL_WS and TOKEN_PHPDOC_EOL are skipped
         */
        public function hasTokenImmediatelyBefore(int $pos, int $expectedTokenType): bool
        {
        }
        /**
         * Check whether the position is directly followed by a certain token type.
         *
         * During this check TOKEN_HORIZONTAL_WS and TOKEN_PHPDOC_EOL are skipped
         */
        public function hasTokenImmediatelyAfter(int $pos, int $expectedTokenType): bool
        {
        }
        public function getDetectedNewline(): ?string
        {
        }
        /**
         * Whether the given position is immediately surrounded by parenthesis.
         */
        public function hasParentheses(int $startPos, int $endPos): bool
        {
        }
    }
    class TypeParser
    {
        public function __construct(\PHPStan\PhpDocParser\ParserConfig $config, \PHPStan\PhpDocParser\Parser\ConstExprParser $constExprParser)
        {
        }
        /** @phpstan-impure */
        public function parse(\PHPStan\PhpDocParser\Parser\TokenIterator $tokens): \PHPStan\PhpDocParser\Ast\Type\TypeNode
        {
        }
        /**
         * @internal
         * @template T of Ast\Node
         * @param T $type
         * @return T
         */
        public function enrichWithAttributes(\PHPStan\PhpDocParser\Parser\TokenIterator $tokens, \PHPStan\PhpDocParser\Ast\Node $type, int $startLine, int $startIndex): \PHPStan\PhpDocParser\Ast\Node
        {
        }
        /** @phpstan-impure */
        public function isHtml(\PHPStan\PhpDocParser\Parser\TokenIterator $tokens): bool
        {
        }
        /** @phpstan-impure */
        public function parseGeneric(\PHPStan\PhpDocParser\Parser\TokenIterator $tokens, \PHPStan\PhpDocParser\Ast\Type\IdentifierTypeNode $baseType): \PHPStan\PhpDocParser\Ast\Type\GenericTypeNode
        {
        }
        /**
         * @phpstan-impure
         * @return array{Ast\Type\TypeNode, Ast\Type\GenericTypeNode::VARIANCE_*}
         */
        public function parseGenericTypeArgument(\PHPStan\PhpDocParser\Parser\TokenIterator $tokens): array
        {
        }
        /**
         * @throws ParserException
         * @param ?callable(TokenIterator): string $parseDescription
         */
        public function parseTemplateTagValue(\PHPStan\PhpDocParser\Parser\TokenIterator $tokens, ?callable $parseDescription = null): \PHPStan\PhpDocParser\Ast\PhpDoc\TemplateTagValueNode
        {
        }
    }
}
namespace PHPStan\PhpDocParser {
    class ParserConfig
    {
        public bool $useLinesAttributes;
        public bool $useIndexAttributes;
        public bool $useCommentsAttributes;
        /**
         * @param array{lines?: bool, indexes?: bool, comments?: bool} $usedAttributes
         */
        public function __construct(array $usedAttributes)
        {
        }
    }
}
namespace PHPStan\PhpDocParser\Printer {
    /**
     * Inspired by https://github.com/nikic/PHP-Parser/tree/36a6dcd04e7b0285e8f0868f44bd4927802f7df1
     *
     * Copyright (c) 2011, Nikita Popov
     * All rights reserved.
     *
     * Implements the Myers diff algorithm.
     *
     * @internal
     */
    class DiffElem
    {
        public const TYPE_KEEP = 0;
        public const TYPE_REMOVE = 1;
        public const TYPE_ADD = 2;
        public const TYPE_REPLACE = 3;
        /** @var self::TYPE_* */
        public $type;
        /** @var mixed Is null for add operations */
        public $old;
        /** @var mixed Is null for remove operations */
        public $new;
        /**
         * @param self::TYPE_* $type
         * @param mixed $old Is null for add operations
         * @param mixed $new Is null for remove operations
         */
        public function __construct(int $type, $old, $new)
        {
        }
    }
    /**
     * Inspired by https://github.com/nikic/PHP-Parser/tree/36a6dcd04e7b0285e8f0868f44bd4927802f7df1
     *
     * Copyright (c) 2011, Nikita Popov
     * All rights reserved.
     *
     * Implements the Myers diff algorithm.
     *
     * Myers, Eugene W. "An O (ND) difference algorithm and its variations."
     * Algorithmica 1.1 (1986): 251-266.
     *
     * @template T
     * @internal
     */
    class Differ
    {
        /**
         * Create differ over the given equality relation.
         *
         * @param callable(T, T): bool $isEqual Equality relation
         */
        public function __construct(callable $isEqual)
        {
        }
        /**
         * Calculate diff (edit script) from $old to $new.
         *
         * @param T[] $old Original array
         * @param T[] $new New array
         *
         * @return DiffElem[] Diff (edit script)
         */
        public function diff(array $old, array $new): array
        {
        }
        /**
         * Calculate diff, including "replace" operations.
         *
         * If a sequence of remove operations is followed by the same number of add operations, these
         * will be coalesced into replace operations.
         *
         * @param T[] $old Original array
         * @param T[] $new New array
         *
         * @return DiffElem[] Diff (edit script), including replace operations
         */
        public function diffWithReplacements(array $old, array $new): array
        {
        }
    }
    /**
     * Inspired by https://github.com/nikic/PHP-Parser/tree/36a6dcd04e7b0285e8f0868f44bd4927802f7df1
     *
     * Copyright (c) 2011, Nikita Popov
     * All rights reserved.
     */
    final class Printer
    {
        public function printFormatPreserving(\PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocNode $node, \PHPStan\PhpDocParser\Ast\PhpDoc\PhpDocNode $originalNode, \PHPStan\PhpDocParser\Parser\TokenIterator $originalTokens): string
        {
        }
        public function print(\PHPStan\PhpDocParser\Ast\Node $node): string
        {
        }
    }
}
namespace Psr\Log {
    /**
     * This is a simple Logger trait that classes unable to extend AbstractLogger
     * (because they extend another class, etc) can include.
     *
     * It simply delegates all log-level-specific methods to the `log` method to
     * reduce boilerplate code that a simple Logger that does the same thing with
     * messages regardless of the error level has to implement.
     */
    trait LoggerTrait
    {
        /**
         * System is unusable.
         */
        public function emergency(string|\Stringable $message, array $context = []): void
        {
        }
        /**
         * Action must be taken immediately.
         *
         * Example: Entire website down, database unavailable, etc. This should
         * trigger the SMS alerts and wake you up.
         */
        public function alert(string|\Stringable $message, array $context = []): void
        {
        }
        /**
         * Critical conditions.
         *
         * Example: Application component unavailable, unexpected exception.
         */
        public function critical(string|\Stringable $message, array $context = []): void
        {
        }
        /**
         * Runtime errors that do not require immediate action but should typically
         * be logged and monitored.
         */
        public function error(string|\Stringable $message, array $context = []): void
        {
        }
        /**
         * Exceptional occurrences that are not errors.
         *
         * Example: Use of deprecated APIs, poor use of an API, undesirable things
         * that are not necessarily wrong.
         */
        public function warning(string|\Stringable $message, array $context = []): void
        {
        }
        /**
         * Normal but significant events.
         */
        public function notice(string|\Stringable $message, array $context = []): void
        {
        }
        /**
         * Interesting events.
         *
         * Example: User logs in, SQL logs.
         */
        public function info(string|\Stringable $message, array $context = []): void
        {
        }
        /**
         * Detailed debug information.
         */
        public function debug(string|\Stringable $message, array $context = []): void
        {
        }
        /**
         * Logs with an arbitrary level.
         *
         * @param mixed $level
         *
         * @throws \Psr\Log\InvalidArgumentException
         */
        abstract public function log($level, string|\Stringable $message, array $context = []): void;
    }
    /**
     * This is a simple Logger implementation that other Loggers can inherit from.
     *
     * It simply delegates all log-level-specific methods to the `log` method to
     * reduce boilerplate code that a simple Logger that does the same thing with
     * messages regardless of the error level has to implement.
     */
    abstract class AbstractLogger implements \Psr\Log\LoggerInterface
    {
        use \Psr\Log\LoggerTrait;
    }
    class InvalidArgumentException extends \InvalidArgumentException
    {
    }
    /**
     * Describes a logger-aware instance.
     */
    interface LoggerAwareInterface
    {
        /**
         * Sets a logger instance on the object.
         */
        public function setLogger(\Psr\Log\LoggerInterface $logger): void;
    }
    /**
     * Basic Implementation of LoggerAwareInterface.
     */
    trait LoggerAwareTrait
    {
        /**
         * The logger instance.
         */
        protected ?\Psr\Log\LoggerInterface $logger = null;
        /**
         * Sets a logger.
         */
        public function setLogger(\Psr\Log\LoggerInterface $logger): void
        {
        }
    }
    /**
     * Describes log levels.
     */
    class LogLevel
    {
        const EMERGENCY = 'emergency';
        const ALERT = 'alert';
        const CRITICAL = 'critical';
        const ERROR = 'error';
        const WARNING = 'warning';
        const NOTICE = 'notice';
        const INFO = 'info';
        const DEBUG = 'debug';
    }
    /**
     * This Logger can be used to avoid conditional log calls.
     *
     * Logging should always be optional, and if no logger is provided to your
     * library creating a NullLogger instance to have something to throw logs at
     * is a good way to avoid littering your code with `if ($this->logger) { }`
     * blocks.
     */
    class NullLogger extends \Psr\Log\AbstractLogger
    {
        /**
         * Logs with an arbitrary level.
         *
         * @param mixed[] $context
         *
         * @throws \Psr\Log\InvalidArgumentException
         */
        public function log($level, string|\Stringable $message, array $context = []): void
        {
        }
    }
}
namespace {
    /**
     * Defines application features from the specific context.
     */
    class FeatureContext implements \Behat\Behat\Context\Context, \Behat\Behat\Context\SnippetAcceptingContext
    {
        /**
         * @var Configuration
         */
        protected $configuration;
        /**
         * @param string $bin
         */
        public function __construct($bin = 'supervisord')
        {
        }
        /**
         * @BeforeScenario
         */
        public function setUpSupervisor(\Behat\Behat\Hook\Scope\BeforeScenarioScope $scope)
        {
        }
        protected function setUpConnector()
        {
        }
        /**
         * @AfterScenario
         */
        public function stopSupervisor(\Behat\Behat\Hook\Scope\AfterScenarioScope $scope)
        {
        }
        /**
         * @Given I have Supervisor running
         */
        public function iHaveSupervisorRunning()
        {
        }
        /**
         * @When I ask for the API version
         */
        public function iAskForTheApiVersion()
        {
        }
        /**
         * @Then I should get at least :ver version
         */
        public function iShouldGetAtLeastVersion($ver)
        {
        }
        /**
         * @When I ask for Supervisor version
         */
        public function iAskForSupervisorVersion()
        {
        }
        /**
         * @Given my Supervisor instance is called :identifier
         */
        public function mySupervisorInstanceIsCalled($identifier)
        {
        }
        /**
         * @When I ask for Supervisor identification
         */
        public function iAskForSupervisorIdentification()
        {
        }
        /**
         * @Then I should get :identifier as identifier
         */
        public function iShouldGetAsIdentifier($identifier)
        {
        }
        /**
         * @When I ask for the state
         */
        public function iAskForTheState()
        {
        }
        /**
         * @Then I should get :code as statecode and :name as statename
         */
        public function iShouldGetAsStatecodeAndAsStatename($code, $name)
        {
        }
        /**
         * @When I ask for the PID
         */
        public function iAskForThePid()
        {
        }
        /**
         * @Then I should get the real PID
         */
        public function iShouldGetTheRealPid()
        {
        }
        /**
         * @When I ask for the log
         */
        public function iAskForTheLog()
        {
        }
        /**
         * @Then I should get an INFO about supervisord started
         */
        public function iShouldGetAnInfoAboutSupervisordStarted()
        {
        }
        /**
         * @When I try to call :action action
         */
        public function iTryToCallAction($action)
        {
        }
        /**
         * @When I check if the log is really empty
         */
        public function iCheckIfTheLogIsReallyEmpty()
        {
        }
        /**
         * @Then I should get a success response
         */
        public function iShouldGetASuccessResponse()
        {
        }
        /**
         * @Then it should be stopped
         */
        public function itShouldBeStopped()
        {
        }
        /**
         * @Then it should be running again
         */
        public function itShouldBeRunningAgain()
        {
        }
        /**
         * @Given I have a process called :process
         */
        public function iHaveAProcessCalled($process)
        {
        }
        /**
         * @When I wait for start
         */
        public function iWaitForStart()
        {
        }
        /**
         * @When I get information about the processes
         */
        public function iGetInformationAboutTheProcesses()
        {
        }
        /**
         * @Then I should see running
         */
        public function iShouldSeeRunning()
        {
        }
        /**
         * @Given autostart is disabled
         */
        public function autostartIsDisabled()
        {
        }
        /**
         * @When I get information about the processes before action
         */
        public function iGetInformationAboutTheProcessesBeforeAction()
        {
        }
        /**
         * @When I :action the process
         */
        public function iTheProcess($action)
        {
        }
        /**
         * @Then I should see not running first
         */
        public function iShouldSeeNotRunningFirst()
        {
        }
        /**
         * @When I :action the processes
         */
        public function iTheProcesses($action)
        {
        }
        /**
         * @Then I should get a success response for all
         */
        public function iShouldGetASuccessResponseForAll()
        {
        }
        /**
         * @Then I should see running first
         */
        public function iShouldSeeRunningFirst()
        {
        }
        /**
         * @Then I should see not running
         */
        public function iShouldSeeNotRunning()
        {
        }
        /**
         * @Given it is part of group called :grp
         */
        public function itIsPartOfGroupCalled($grp)
        {
        }
        /**
         * @When I :action the processes in the group
         */
        public function iTheProcessesInTheGroup($action)
        {
        }
        /**
         * @Then I should see them as part of the group
         */
        public function iShouldSeeThemAsPartOfTheGroup()
        {
        }
    }
}
namespace Supervisor\Exception {
    /**
     * Fault codes are taken from the source code, not the documentation.
     * The most common ones are covered by the XML-RPC doc.
     *
     * @link http://supervisord.org/api.html
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    class SupervisorException extends \RuntimeException
    {
        /**
         * Creates a new Fault exception if a named one from the table above is present.
         */
        public static function create(\fXmlRpc\Exception\FaultException $faultException): \fXmlRpc\Exception\FaultException|\Supervisor\Exception\SupervisorException
        {
        }
    }
}
namespace Supervisor\Exception\Fault {
    /**
     * Implements ABNORMAL_TERMINATION Fault exception.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class AbnormalTerminationException extends \Supervisor\Exception\SupervisorException
    {
    }
    /**
     * Implements ALREADY_ADDED Fault exception.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class AlreadyAddedException extends \Supervisor\Exception\SupervisorException
    {
    }
    /**
     * Implements ALREADY_STARTED Fault exception.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class AlreadyStartedException extends \Supervisor\Exception\SupervisorException
    {
    }
    /**
     * Implements BAD_ARGUMENTS Fault exception.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class BadArgumentsException extends \Supervisor\Exception\SupervisorException
    {
    }
    /**
     * Implements BAD_NAME Fault exception.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class BadNameException extends \Supervisor\Exception\SupervisorException
    {
    }
    /**
     * Implements BAD_SIGNAL Fault exception.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class BadSignalException extends \Supervisor\Exception\SupervisorException
    {
    }
    /**
     * Implements CANT_REREAD Fault exception.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class CantRereadException extends \Supervisor\Exception\SupervisorException
    {
    }
    /**
     * Implements FAILED Fault exception.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class FailedException extends \Supervisor\Exception\SupervisorException
    {
    }
    /**
     * Implements INCORRECT_PARAMETERS Fault exception.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class IncorrectParametersException extends \Supervisor\Exception\SupervisorException
    {
    }
    /**
     * Implements NO_FILE Fault exception.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class NoFileException extends \Supervisor\Exception\SupervisorException
    {
    }
    /**
     * Implements NOT_EXECUTABLE Fault exception.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class NotExecutableException extends \Supervisor\Exception\SupervisorException
    {
    }
    /**
     * Implements NOT_RUNNING Fault exception.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class NotRunningException extends \Supervisor\Exception\SupervisorException
    {
    }
    /**
     * Implements SHUTDOWN_STATE Fault exception.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class ShutdownStateException extends \Supervisor\Exception\SupervisorException
    {
    }
    /**
     * Implements SIGNATURE_UNSUPPORTED Fault exception.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class SignatureUnsupportedException extends \Supervisor\Exception\SupervisorException
    {
    }
    /**
     * Implements SPAWN_ERROR Fault exception.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class SpawnErrorException extends \Supervisor\Exception\SupervisorException
    {
    }
    /**
     * Implements STILL_RUNNING Fault exception.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class StillRunningException extends \Supervisor\Exception\SupervisorException
    {
    }
    /**
     * Implements SUCCESS Fault exception.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class SuccessException extends \Supervisor\Exception\SupervisorException
    {
    }
    /**
     * Implements UNKNOWN_METHOD Fault exception.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     */
    final class UnknownMethodException extends \Supervisor\Exception\SupervisorException
    {
    }
}
namespace Supervisor {
    /**
     * Process object holding data for a single process.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     * @author Buster Neece <buster@busterneece.com>
     */
    interface ProcessInterface extends \ArrayAccess
    {
        /**
         * Returns the process info array.
         */
        public function getPayload(): array;
        /**
         * Returns the process name.
         */
        public function getName(): string;
        /**
         * Checks whether the process is running.
         */
        public function isRunning(): bool;
        /**
         * Checks whether the process is running.
         */
        public function getState(): \Supervisor\ProcessStates;
        /**
         * Checks if process is in the given state.
         */
        public function checkState(int|\Supervisor\ProcessStates $state): bool;
        /**
         * Returns process name.
         */
        public function __toString(): string;
    }
    /**
     * Process object holding data for a single process.
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     * @author Buster Neece <buster@busterneece.com>
     */
    final class Process implements \Supervisor\ProcessInterface
    {
        public function __construct(private readonly array $payload = [])
        {
        }
        /**
         * @inheritDoc
         */
        public function getPayload(): array
        {
        }
        /**
         * @inheritDoc
         */
        public function getName(): string
        {
        }
        /**
         * @inheritDoc
         */
        public function getState(): \Supervisor\ProcessStates
        {
        }
        /**
         * @inheritDoc
         */
        public function isRunning(): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function checkState(int|\Supervisor\ProcessStates $state): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function __toString(): string
        {
        }
        /**
         * @inheritDoc
         */
        public function offsetGet($offset): mixed
        {
        }
        /**
         * @inheritDoc
         */
        public function offsetExists($offset): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function offsetSet($offset, $value): void
        {
        }
        /**
         * @inheritDoc
         */
        public function offsetUnset($offset): void
        {
        }
    }
    /**
     * A class documenting the results of a "reloadAndApplyConfig" operation.
     */
    interface ReloadResultInterface
    {
        /**
         * @return string[] Process group names that were affected by the reload (added, modified, or removed).
         */
        public function getAffected(): array;
        /**
         * @return string[] Process group names that were added in the reload.
         */
        public function getAdded(): array;
        /**
         * @return string[] Process group names that were added in the reload.
         */
        public function getModified(): array;
        /**
         * @return string[] Process group names that were removed in the reload.
         */
        public function getRemoved(): array;
    }
    /**
     * A class documenting the results of a "reloadAndApplyConfig" operation.
     */
    final class ReloadResult implements \Supervisor\ReloadResultInterface
    {
        public function __construct(private readonly array $added = [], private readonly array $modified = [], private readonly array $removed = [])
        {
        }
        /**
         * @inheritDoc
         */
        public function getAffected(): array
        {
        }
        /**
         * @inheritDoc
         */
        public function getAdded(): array
        {
        }
        /**
         * @inheritDoc
         */
        public function getModified(): array
        {
        }
        /**
         * @inheritDoc
         */
        public function getRemoved(): array
        {
        }
        public static function fromReloadConfig(array $reloadResult): self
        {
        }
    }
    /**
     * Supervisor API.
     *
     * @link http://supervisord.org/api.html
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     * @author Buster Neece <buster@busterneece.com>
     *
     * @method string getAPIVersion()
     * @method string getSupervisorVersion()
     * @method string getIdentification()
     * @method array getState()
     * @method int getPID()
     * @method string readLog(integer $offset, integer $limit)
     * @method bool clearLog()
     * @method bool shutdown()
     * @method bool restart()
     * @method array getProcessInfo(string $processName)
     * @method array getAllProcessInfo()
     * @method bool startProcess(string $name, boolean $wait = true)
     * @method array startAllProcesses(boolean $wait = true)
     * @method array startProcessGroup(string $name, boolean $wait = true)
     * @method bool stopProcess(string $name, boolean $wait = true)
     * @method array stopAllProcesses(boolean $wait = true)
     * @method array stopProcessGroup(string $name, boolean $wait = true)
     * @method bool sendProcessStdin(string $name, string $chars)
     * @method bool addProcessGroup(string $name)
     * @method bool removeProcessGroup(string $name)
     * @method string readProcessStdoutLog(string $name, integer $offset, integer $limit)
     * @method string readProcessStderrLog(string $name, integer $offset, integer $limit)
     * @method array tailProcessStdoutLog(string $name, integer $offset, integer $limit)
     * @method array tailProcessStderrLog(string $name, integer $offset, integer $limit)
     * @method bool clearProcessLogs(string $name)
     * @method array clearAllProcessLogs()
     * @method array reloadConfig()
     * @method bool signalProcess(string $name, string $signal)
     * @method array signalProcessGroup(string $name, string $signal)
     * @method array signalAllProcesses(string $signal)
     */
    interface SupervisorInterface
    {
        /**
         * Calls a method.
         *
         * @param string $namespace
         * @param string $method
         * @param array $arguments
         *
         * @return mixed
         */
        public function call(string $namespace, string $method, array $arguments = []): mixed;
        /**
         * Magic __call method.
         *
         * Handles all calls to supervisor namespace
         *
         * @param string $method
         * @param array $arguments
         *
         * @return mixed
         */
        public function __call(string $method, array $arguments);
        /**
         * Checks if a connection is present.
         *
         * It is done by sending a bump request to the server and catching any thrown exceptions
         */
        public function isConnected(): bool;
        /**
         * Is service running?
         */
        public function isRunning(): bool;
        /**
         * Get the supervisord service state.
         */
        public function getServiceState(): \Supervisor\ServiceStates;
        /**
         * Checks if supervisord is in given state.
         */
        public function checkState(int|\Supervisor\ServiceStates $checkState): bool;
        /**
         * Returns all processes as Process objects.
         *
         * @return ProcessInterface[]
         */
        public function getAllProcesses(): array;
        /**
         * Returns a specific Process.
         *
         * @param string $name Process name or 'group:name'
         *
         * @return ProcessInterface
         */
        public function getProcess(string $name): \Supervisor\ProcessInterface;
        /**
         * Reload configuration and apply process changes immediately, i.e.:
         *   - Start any processes newly added in the configuration,
         *   - Stop and restart any processes modified in the configuration, and
         *   - Stop any processes
         *
         * @param bool $wait Wait for processes to stop before continuing execution.
         * @param bool $stopModifiedGroups Fully stop all modified groups.
         * @param bool $startNewProcesses Start all processes in the process group.
         *
         * @throws SupervisorException
         *
         * @return ReloadResultInterface
         */
        public function reloadAndApplyConfig(bool $wait = true, bool $stopModifiedGroups = true, bool $startNewProcesses = true): \Supervisor\ReloadResultInterface;
    }
    /**
     * @link http://supervisord.org/api.html
     *
     * @author Márk Sági-Kazár <mark.sagikazar@gmail.com>
     * @author Buster Neece <buster@busterneece.com>
     *
     * @method string getAPIVersion()
     * @method string getSupervisorVersion()
     * @method string getIdentification()
     * @method array getState()
     * @method int getPID()
     * @method string readLog(integer $offset, integer $limit)
     * @method bool clearLog()
     * @method bool shutdown()
     * @method bool restart()
     * @method array getProcessInfo(string $processName)
     * @method array getAllProcessInfo()
     * @method bool startProcess(string $name, boolean $wait = true)
     * @method array startAllProcesses(boolean $wait = true)
     * @method array startProcessGroup(string $name, boolean $wait = true)
     * @method bool stopProcess(string $name, boolean $wait = true)
     * @method array stopAllProcesses(boolean $wait = true)
     * @method array stopProcessGroup(string $name, boolean $wait = true)
     * @method bool sendProcessStdin(string $name, string $chars)
     * @method bool addProcessGroup(string $name)
     * @method bool removeProcessGroup(string $name)
     * @method string readProcessStdoutLog(string $name, integer $offset, integer $limit)
     * @method string readProcessStderrLog(string $name, integer $offset, integer $limit)
     * @method array tailProcessStdoutLog(string $name, integer $offset, integer $limit)
     * @method array tailProcessStderrLog(string $name, integer $offset, integer $limit)
     * @method bool clearProcessLogs(string $name)
     * @method array clearAllProcessLogs()
     * @method array reloadConfig()
     * @method bool signalProcess(string $name, string $signal)
     * @method array signalProcessGroup(string $name, string $signal)
     * @method array signalAllProcesses(string $signal)
     */
    final class Supervisor implements \Supervisor\SupervisorInterface
    {
        public function __construct(private readonly \fXmlRpc\ClientInterface $client, ?\Psr\Log\LoggerInterface $logger = null)
        {
        }
        /**
         * @inheritDoc
         */
        public function call(string $namespace, string $method, array $arguments = []): mixed
        {
        }
        /**
         * @inheritDoc
         */
        public function __call(string $method, array $arguments)
        {
        }
        /**
         * @inheritDoc
         */
        public function isConnected(): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function isRunning(): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function getServiceState(): \Supervisor\ServiceStates
        {
        }
        /**
         * @inheritDoc
         */
        public function checkState(int|\Supervisor\ServiceStates $checkState): bool
        {
        }
        /**
         * @inheritDoc
         */
        public function getAllProcesses(): array
        {
        }
        /**
         * @inheritDoc
         */
        public function getProcess(string $name): \Supervisor\ProcessInterface
        {
        }
        /**
         * @inheritDoc
         */
        public function reloadAndApplyConfig(bool $wait = true, bool $stopModifiedGroups = true, bool $startNewProcesses = true): \Supervisor\ReloadResultInterface
        {
        }
    }
}
namespace Webmozart\Assert {
    /**
     * This trait provides nurllOr*, all* and allNullOr* variants of assertion base methods.
     * Do not use this trait directly: it will change, and is not designed for reuse.
     */
    trait Mixin
    {
        /**
         * @psalm-pure
         * @psalm-assert string|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrString($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<string> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allString($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<string|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrString($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert non-empty-string|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrStringNotEmpty($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<non-empty-string> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allStringNotEmpty($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<non-empty-string|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrStringNotEmpty($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert int|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrInteger($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<int> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allInteger($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<int|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrInteger($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert numeric|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIntegerish($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<numeric> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIntegerish($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<numeric|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIntegerish($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert positive-int|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrPositiveInteger($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<positive-int> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allPositiveInteger($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<positive-int|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrPositiveInteger($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert float|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrFloat($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<float> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allFloat($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<float|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrFloat($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert numeric|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrNumeric($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<numeric> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNumeric($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<numeric|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrNumeric($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert positive-int|0|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrNatural($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<positive-int|0> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNatural($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<positive-int|0|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrNatural($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert bool|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrBoolean($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<bool> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allBoolean($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<bool|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrBoolean($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert scalar|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrScalar($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<scalar> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allScalar($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<scalar|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrScalar($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert object|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrObject($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<object> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allObject($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<object|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrObject($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert resource|null $value
         *
         * @param mixed       $value
         * @param string|null $type    type of resource this should be. @see https://www.php.net/manual/en/function.get-resource-type.php
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrResource($value, $type = null, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<resource> $value
         *
         * @param mixed       $value
         * @param string|null $type    type of resource this should be. @see https://www.php.net/manual/en/function.get-resource-type.php
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allResource($value, $type = null, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<resource|null> $value
         *
         * @param mixed       $value
         * @param string|null $type    type of resource this should be. @see https://www.php.net/manual/en/function.get-resource-type.php
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrResource($value, $type = null, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert callable|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIsCallable($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<callable> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIsCallable($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<callable|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIsCallable($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert array|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIsArray($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<array> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIsArray($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<array|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIsArray($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable|null $value
         *
         * @deprecated use "isIterable" or "isInstanceOf" instead
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIsTraversable($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<iterable> $value
         *
         * @deprecated use "isIterable" or "isInstanceOf" instead
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIsTraversable($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<iterable|null> $value
         *
         * @deprecated use "isIterable" or "isInstanceOf" instead
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIsTraversable($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert array|ArrayAccess|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIsArrayAccessible($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<array|ArrayAccess> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIsArrayAccessible($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<array|ArrayAccess|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIsArrayAccessible($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert countable|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIsCountable($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<countable> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIsCountable($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<countable|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIsCountable($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIsIterable($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<iterable> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIsIterable($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<iterable|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIsIterable($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert ExpectedType|null $value
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIsInstanceOf($value, $class, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert iterable<ExpectedType> $value
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIsInstanceOf($value, $class, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert iterable<ExpectedType|null> $value
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIsInstanceOf($value, $class, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrNotInstanceOf($value, $class, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNotInstanceOf($value, $class, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert iterable<!ExpectedType|null> $value
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrNotInstanceOf($value, $class, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param array<class-string> $classes
         *
         * @param mixed                $value
         * @param array<object|string> $classes
         * @param string               $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIsInstanceOfAny($value, $classes, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param array<class-string> $classes
         *
         * @param mixed                $value
         * @param array<object|string> $classes
         * @param string               $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIsInstanceOfAny($value, $classes, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param array<class-string> $classes
         *
         * @param mixed                $value
         * @param array<object|string> $classes
         * @param string               $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIsInstanceOfAny($value, $classes, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert ExpectedType|class-string<ExpectedType>|null $value
         *
         * @param object|string|null $value
         * @param string             $class
         * @param string             $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIsAOf($value, $class, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert iterable<ExpectedType|class-string<ExpectedType>> $value
         *
         * @param iterable<object|string> $value
         * @param string                  $class
         * @param string                  $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIsAOf($value, $class, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert iterable<ExpectedType|class-string<ExpectedType>|null> $value
         *
         * @param iterable<object|string|null> $value
         * @param string                       $class
         * @param string                       $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIsAOf($value, $class, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template UnexpectedType of object
         * @psalm-param class-string<UnexpectedType> $class
         *
         * @param object|string|null $value
         * @param string             $class
         * @param string             $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIsNotA($value, $class, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template UnexpectedType of object
         * @psalm-param class-string<UnexpectedType> $class
         *
         * @param iterable<object|string> $value
         * @param string                  $class
         * @param string                  $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIsNotA($value, $class, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template UnexpectedType of object
         * @psalm-param class-string<UnexpectedType> $class
         * @psalm-assert iterable<!UnexpectedType|null> $value
         * @psalm-assert iterable<!class-string<UnexpectedType>|null> $value
         *
         * @param iterable<object|string|null> $value
         * @param string                       $class
         * @param string                       $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIsNotA($value, $class, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param array<class-string> $classes
         *
         * @param object|string|null $value
         * @param string[]           $classes
         * @param string             $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIsAnyOf($value, $classes, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param array<class-string> $classes
         *
         * @param iterable<object|string> $value
         * @param string[]                $classes
         * @param string                  $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIsAnyOf($value, $classes, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param array<class-string> $classes
         *
         * @param iterable<object|string|null> $value
         * @param string[]                     $classes
         * @param string                       $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIsAnyOf($value, $classes, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert empty $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIsEmpty($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<empty> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIsEmpty($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<empty|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIsEmpty($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrNotEmpty($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNotEmpty($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<!empty|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrNotEmpty($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNull($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNotNull($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert true|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrTrue($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<true> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allTrue($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<true|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrTrue($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert false|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrFalse($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<false> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allFalse($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<false|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrFalse($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrNotFalse($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNotFalse($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<!false|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrNotFalse($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIp($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIp($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIp($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIpv4($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIpv4($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIpv4($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIpv6($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIpv6($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIpv6($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrEmail($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allEmail($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrEmail($value, $message = '')
        {
        }
        /**
         * @param array|null $values
         * @param string     $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrUniqueValues($values, $message = '')
        {
        }
        /**
         * @param iterable<array> $values
         * @param string          $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allUniqueValues($values, $message = '')
        {
        }
        /**
         * @param iterable<array|null> $values
         * @param string               $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrUniqueValues($values, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrEq($value, $expect, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allEq($value, $expect, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrEq($value, $expect, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrNotEq($value, $expect, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNotEq($value, $expect, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrNotEq($value, $expect, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrSame($value, $expect, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allSame($value, $expect, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrSame($value, $expect, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrNotSame($value, $expect, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNotSame($value, $expect, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrNotSame($value, $expect, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrGreaterThan($value, $limit, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allGreaterThan($value, $limit, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrGreaterThan($value, $limit, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrGreaterThanEq($value, $limit, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allGreaterThanEq($value, $limit, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrGreaterThanEq($value, $limit, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrLessThan($value, $limit, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allLessThan($value, $limit, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrLessThan($value, $limit, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrLessThanEq($value, $limit, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allLessThanEq($value, $limit, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrLessThanEq($value, $limit, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $min
         * @param mixed  $max
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrRange($value, $min, $max, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $min
         * @param mixed  $max
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allRange($value, $min, $max, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $min
         * @param mixed  $max
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrRange($value, $min, $max, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param array  $values
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrOneOf($value, $values, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param array  $values
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allOneOf($value, $values, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param array  $values
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrOneOf($value, $values, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param array  $values
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrInArray($value, $values, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param array  $values
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allInArray($value, $values, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param array  $values
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrInArray($value, $values, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string|null $value
         * @param string      $subString
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrContains($value, $subString, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $subString
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allContains($value, $subString, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string|null> $value
         * @param string                $subString
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrContains($value, $subString, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string|null $value
         * @param string      $subString
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrNotContains($value, $subString, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $subString
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNotContains($value, $subString, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string|null> $value
         * @param string                $subString
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrNotContains($value, $subString, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string|null $value
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrNotWhitespaceOnly($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNotWhitespaceOnly($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string|null> $value
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrNotWhitespaceOnly($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string|null $value
         * @param string      $prefix
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrStartsWith($value, $prefix, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $prefix
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allStartsWith($value, $prefix, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string|null> $value
         * @param string                $prefix
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrStartsWith($value, $prefix, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string|null $value
         * @param string      $prefix
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrNotStartsWith($value, $prefix, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $prefix
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNotStartsWith($value, $prefix, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string|null> $value
         * @param string                $prefix
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrNotStartsWith($value, $prefix, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrStartsWithLetter($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allStartsWithLetter($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrStartsWithLetter($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string|null $value
         * @param string      $suffix
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrEndsWith($value, $suffix, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $suffix
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allEndsWith($value, $suffix, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string|null> $value
         * @param string                $suffix
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrEndsWith($value, $suffix, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string|null $value
         * @param string      $suffix
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrNotEndsWith($value, $suffix, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $suffix
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNotEndsWith($value, $suffix, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string|null> $value
         * @param string                $suffix
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrNotEndsWith($value, $suffix, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string|null $value
         * @param string      $pattern
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrRegex($value, $pattern, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $pattern
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allRegex($value, $pattern, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string|null> $value
         * @param string                $pattern
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrRegex($value, $pattern, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string|null $value
         * @param string      $pattern
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrNotRegex($value, $pattern, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $pattern
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNotRegex($value, $pattern, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string|null> $value
         * @param string                $pattern
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrNotRegex($value, $pattern, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrUnicodeLetters($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allUnicodeLetters($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrUnicodeLetters($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrAlpha($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allAlpha($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrAlpha($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string|null $value
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrDigits($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allDigits($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string|null> $value
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrDigits($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string|null $value
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrAlnum($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allAlnum($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string|null> $value
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrAlnum($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert lowercase-string|null $value
         *
         * @param string|null $value
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrLower($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<lowercase-string> $value
         *
         * @param iterable<string> $value
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allLower($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<lowercase-string|null> $value
         *
         * @param iterable<string|null> $value
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrLower($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string|null $value
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrUpper($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allUpper($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<!lowercase-string|null> $value
         *
         * @param iterable<string|null> $value
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrUpper($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string|null $value
         * @param int         $length
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrLength($value, $length, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param int              $length
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allLength($value, $length, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string|null> $value
         * @param int                   $length
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrLength($value, $length, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string|null $value
         * @param int|float   $min
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrMinLength($value, $min, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param int|float        $min
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allMinLength($value, $min, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string|null> $value
         * @param int|float             $min
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrMinLength($value, $min, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string|null $value
         * @param int|float   $max
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrMaxLength($value, $max, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param int|float        $max
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allMaxLength($value, $max, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string|null> $value
         * @param int|float             $max
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrMaxLength($value, $max, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string|null $value
         * @param int|float   $min
         * @param int|float   $max
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrLengthBetween($value, $min, $max, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param int|float        $min
         * @param int|float        $max
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allLengthBetween($value, $min, $max, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string|null> $value
         * @param int|float             $min
         * @param int|float             $max
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrLengthBetween($value, $min, $max, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrFileExists($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allFileExists($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrFileExists($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrFile($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allFile($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrFile($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrDirectory($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allDirectory($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrDirectory($value, $message = '')
        {
        }
        /**
         * @param string|null $value
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrReadable($value, $message = '')
        {
        }
        /**
         * @param iterable<string> $value
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allReadable($value, $message = '')
        {
        }
        /**
         * @param iterable<string|null> $value
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrReadable($value, $message = '')
        {
        }
        /**
         * @param string|null $value
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrWritable($value, $message = '')
        {
        }
        /**
         * @param iterable<string> $value
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allWritable($value, $message = '')
        {
        }
        /**
         * @param iterable<string|null> $value
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrWritable($value, $message = '')
        {
        }
        /**
         * @psalm-assert class-string|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrClassExists($value, $message = '')
        {
        }
        /**
         * @psalm-assert iterable<class-string> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allClassExists($value, $message = '')
        {
        }
        /**
         * @psalm-assert iterable<class-string|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrClassExists($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert class-string<ExpectedType>|ExpectedType|null $value
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrSubclassOf($value, $class, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert iterable<class-string<ExpectedType>|ExpectedType> $value
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allSubclassOf($value, $class, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert iterable<class-string<ExpectedType>|ExpectedType|null> $value
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrSubclassOf($value, $class, $message = '')
        {
        }
        /**
         * @psalm-assert class-string|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrInterfaceExists($value, $message = '')
        {
        }
        /**
         * @psalm-assert iterable<class-string> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allInterfaceExists($value, $message = '')
        {
        }
        /**
         * @psalm-assert iterable<class-string|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrInterfaceExists($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $interface
         * @psalm-assert class-string<ExpectedType>|null $value
         *
         * @param mixed  $value
         * @param mixed  $interface
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrImplementsInterface($value, $interface, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $interface
         * @psalm-assert iterable<class-string<ExpectedType>> $value
         *
         * @param mixed  $value
         * @param mixed  $interface
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allImplementsInterface($value, $interface, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $interface
         * @psalm-assert iterable<class-string<ExpectedType>|null> $value
         *
         * @param mixed  $value
         * @param mixed  $interface
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrImplementsInterface($value, $interface, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param class-string|object|null $classOrObject
         *
         * @param string|object|null $classOrObject
         * @param mixed              $property
         * @param string             $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrPropertyExists($classOrObject, $property, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param iterable<class-string|object> $classOrObject
         *
         * @param iterable<string|object> $classOrObject
         * @param mixed                   $property
         * @param string                  $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allPropertyExists($classOrObject, $property, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param iterable<class-string|object|null> $classOrObject
         *
         * @param iterable<string|object|null> $classOrObject
         * @param mixed                        $property
         * @param string                       $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrPropertyExists($classOrObject, $property, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param class-string|object|null $classOrObject
         *
         * @param string|object|null $classOrObject
         * @param mixed              $property
         * @param string             $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrPropertyNotExists($classOrObject, $property, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param iterable<class-string|object> $classOrObject
         *
         * @param iterable<string|object> $classOrObject
         * @param mixed                   $property
         * @param string                  $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allPropertyNotExists($classOrObject, $property, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param iterable<class-string|object|null> $classOrObject
         *
         * @param iterable<string|object|null> $classOrObject
         * @param mixed                        $property
         * @param string                       $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrPropertyNotExists($classOrObject, $property, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param class-string|object|null $classOrObject
         *
         * @param string|object|null $classOrObject
         * @param mixed              $method
         * @param string             $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrMethodExists($classOrObject, $method, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param iterable<class-string|object> $classOrObject
         *
         * @param iterable<string|object> $classOrObject
         * @param mixed                   $method
         * @param string                  $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allMethodExists($classOrObject, $method, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param iterable<class-string|object|null> $classOrObject
         *
         * @param iterable<string|object|null> $classOrObject
         * @param mixed                        $method
         * @param string                       $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrMethodExists($classOrObject, $method, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param class-string|object|null $classOrObject
         *
         * @param string|object|null $classOrObject
         * @param mixed              $method
         * @param string             $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrMethodNotExists($classOrObject, $method, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param iterable<class-string|object> $classOrObject
         *
         * @param iterable<string|object> $classOrObject
         * @param mixed                   $method
         * @param string                  $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allMethodNotExists($classOrObject, $method, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param iterable<class-string|object|null> $classOrObject
         *
         * @param iterable<string|object|null> $classOrObject
         * @param mixed                        $method
         * @param string                       $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrMethodNotExists($classOrObject, $method, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param array|null $array
         * @param string|int $key
         * @param string     $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrKeyExists($array, $key, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<array> $array
         * @param string|int      $key
         * @param string          $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allKeyExists($array, $key, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<array|null> $array
         * @param string|int           $key
         * @param string               $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrKeyExists($array, $key, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param array|null $array
         * @param string|int $key
         * @param string     $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrKeyNotExists($array, $key, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<array> $array
         * @param string|int      $key
         * @param string          $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allKeyNotExists($array, $key, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<array|null> $array
         * @param string|int           $key
         * @param string               $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrKeyNotExists($array, $key, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert array-key|null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrValidArrayKey($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<array-key> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allValidArrayKey($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<array-key|null> $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrValidArrayKey($value, $message = '')
        {
        }
        /**
         * @param Countable|array|null $array
         * @param int                  $number
         * @param string               $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrCount($array, $number, $message = '')
        {
        }
        /**
         * @param iterable<Countable|array> $array
         * @param int                       $number
         * @param string                    $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allCount($array, $number, $message = '')
        {
        }
        /**
         * @param iterable<Countable|array|null> $array
         * @param int                            $number
         * @param string                         $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrCount($array, $number, $message = '')
        {
        }
        /**
         * @param Countable|array|null $array
         * @param int|float            $min
         * @param string               $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrMinCount($array, $min, $message = '')
        {
        }
        /**
         * @param iterable<Countable|array> $array
         * @param int|float                 $min
         * @param string                    $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allMinCount($array, $min, $message = '')
        {
        }
        /**
         * @param iterable<Countable|array|null> $array
         * @param int|float                      $min
         * @param string                         $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrMinCount($array, $min, $message = '')
        {
        }
        /**
         * @param Countable|array|null $array
         * @param int|float            $max
         * @param string               $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrMaxCount($array, $max, $message = '')
        {
        }
        /**
         * @param iterable<Countable|array> $array
         * @param int|float                 $max
         * @param string                    $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allMaxCount($array, $max, $message = '')
        {
        }
        /**
         * @param iterable<Countable|array|null> $array
         * @param int|float                      $max
         * @param string                         $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrMaxCount($array, $max, $message = '')
        {
        }
        /**
         * @param Countable|array|null $array
         * @param int|float            $min
         * @param int|float            $max
         * @param string               $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrCountBetween($array, $min, $max, $message = '')
        {
        }
        /**
         * @param iterable<Countable|array> $array
         * @param int|float                 $min
         * @param int|float                 $max
         * @param string                    $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allCountBetween($array, $min, $max, $message = '')
        {
        }
        /**
         * @param iterable<Countable|array|null> $array
         * @param int|float                      $min
         * @param int|float                      $max
         * @param string                         $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrCountBetween($array, $min, $max, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert list|null $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIsList($array, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<list> $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIsList($array, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<list|null> $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIsList($array, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert non-empty-list|null $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIsNonEmptyList($array, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<non-empty-list> $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIsNonEmptyList($array, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable<non-empty-list|null> $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIsNonEmptyList($array, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template T
         * @psalm-param mixed|array<T>|null $array
         * @psalm-assert array<string, T>|null $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIsMap($array, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template T
         * @psalm-param iterable<mixed|array<T>> $array
         * @psalm-assert iterable<array<string, T>> $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIsMap($array, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template T
         * @psalm-param iterable<mixed|array<T>|null> $array
         * @psalm-assert iterable<array<string, T>|null> $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIsMap($array, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template T
         * @psalm-param mixed|array<T>|null $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrIsNonEmptyMap($array, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template T
         * @psalm-param iterable<mixed|array<T>> $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allIsNonEmptyMap($array, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template T
         * @psalm-param iterable<mixed|array<T>|null> $array
         * @psalm-assert iterable<array<string, T>|null> $array
         * @psalm-assert iterable<!empty|null> $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrIsNonEmptyMap($array, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string|null $value
         * @param string      $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrUuid($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string> $value
         * @param string           $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allUuid($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param iterable<string|null> $value
         * @param string                $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrUuid($value, $message = '')
        {
        }
        /**
         * @psalm-param class-string<Throwable> $class
         *
         * @param Closure|null $expression
         * @param string       $class
         * @param string       $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function nullOrThrows($expression, $class = 'Exception', $message = '')
        {
        }
        /**
         * @psalm-param class-string<Throwable> $class
         *
         * @param iterable<Closure> $expression
         * @param string            $class
         * @param string            $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allThrows($expression, $class = 'Exception', $message = '')
        {
        }
        /**
         * @psalm-param class-string<Throwable> $class
         *
         * @param iterable<Closure|null> $expression
         * @param string                 $class
         * @param string                 $message
         *
         * @throws InvalidArgumentException
         *
         * @return void
         */
        public static function allNullOrThrows($expression, $class = 'Exception', $message = '')
        {
        }
    }
    /**
     * Efficient assertions to validate the input/output of your methods.
     *
     * @since  1.0
     *
     * @author Bernhard Schussek <bschussek@gmail.com>
     */
    class Assert
    {
        use \Webmozart\Assert\Mixin;
        /**
         * @psalm-pure
         * @psalm-assert string $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function string($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert non-empty-string $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function stringNotEmpty($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert int $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function integer($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert numeric $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function integerish($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert positive-int $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function positiveInteger($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert float $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function float($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert numeric $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function numeric($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert positive-int|0 $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function natural($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert bool $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function boolean($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert scalar $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function scalar($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert object $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function object($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert resource $value
         *
         * @param mixed       $value
         * @param string|null $type    type of resource this should be. @see https://www.php.net/manual/en/function.get-resource-type.php
         * @param string      $message
         *
         * @throws InvalidArgumentException
         */
        public static function resource($value, $type = null, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert callable $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isCallable($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert array $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isArray($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable $value
         *
         * @deprecated use "isIterable" or "isInstanceOf" instead
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isTraversable($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert array|ArrayAccess $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isArrayAccessible($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert countable $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isCountable($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert iterable $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isIterable($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert ExpectedType $value
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function isInstanceOf($value, $class, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert !ExpectedType $value
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function notInstanceOf($value, $class, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param array<class-string> $classes
         *
         * @param mixed                $value
         * @param array<object|string> $classes
         * @param string               $message
         *
         * @throws InvalidArgumentException
         */
        public static function isInstanceOfAny($value, array $classes, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert ExpectedType|class-string<ExpectedType> $value
         *
         * @param object|string $value
         * @param string        $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function isAOf($value, $class, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template UnexpectedType of object
         * @psalm-param class-string<UnexpectedType> $class
         * @psalm-assert !UnexpectedType $value
         * @psalm-assert !class-string<UnexpectedType> $value
         *
         * @param object|string $value
         * @param string        $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function isNotA($value, $class, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param array<class-string> $classes
         *
         * @param object|string $value
         * @param string[]      $classes
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function isAnyOf($value, array $classes, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert empty $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isEmpty($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert !empty $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notEmpty($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function null($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert !null $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notNull($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert true $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function true($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert false $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function false($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert !false $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notFalse($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function ip($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function ipv4($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function ipv6($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function email($value, $message = '')
        {
        }
        /**
         * Does non strict comparisons on the items, so ['3', 3] will not pass the assertion.
         *
         * @param array  $values
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function uniqueValues(array $values, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function eq($value, $expect, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notEq($value, $expect, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function same($value, $expect, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $expect
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notSame($value, $expect, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function greaterThan($value, $limit, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function greaterThanEq($value, $limit, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function lessThan($value, $limit, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $limit
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function lessThanEq($value, $limit, $message = '')
        {
        }
        /**
         * Inclusive range, so Assert::(3, 3, 5) passes.
         *
         * @psalm-pure
         *
         * @param mixed  $value
         * @param mixed  $min
         * @param mixed  $max
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function range($value, $min, $max, $message = '')
        {
        }
        /**
         * A more human-readable alias of Assert::inArray().
         *
         * @psalm-pure
         *
         * @param mixed  $value
         * @param array  $values
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function oneOf($value, array $values, $message = '')
        {
        }
        /**
         * Does strict comparison, so Assert::inArray(3, ['3']) does not pass the assertion.
         *
         * @psalm-pure
         *
         * @param mixed  $value
         * @param array  $values
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function inArray($value, array $values, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $subString
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function contains($value, $subString, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $subString
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notContains($value, $subString, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notWhitespaceOnly($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $prefix
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function startsWith($value, $prefix, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $prefix
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notStartsWith($value, $prefix, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function startsWithLetter($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $suffix
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function endsWith($value, $suffix, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $suffix
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notEndsWith($value, $suffix, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $pattern
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function regex($value, $pattern, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $pattern
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function notRegex($value, $pattern, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function unicodeLetters($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function alpha($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function digits($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function alnum($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert lowercase-string $value
         *
         * @param string $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function lower($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert !lowercase-string $value
         *
         * @param string $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function upper($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string $value
         * @param int    $length
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function length($value, $length, $message = '')
        {
        }
        /**
         * Inclusive min.
         *
         * @psalm-pure
         *
         * @param string    $value
         * @param int|float $min
         * @param string    $message
         *
         * @throws InvalidArgumentException
         */
        public static function minLength($value, $min, $message = '')
        {
        }
        /**
         * Inclusive max.
         *
         * @psalm-pure
         *
         * @param string    $value
         * @param int|float $max
         * @param string    $message
         *
         * @throws InvalidArgumentException
         */
        public static function maxLength($value, $max, $message = '')
        {
        }
        /**
         * Inclusive , so Assert::lengthBetween('asd', 3, 5); passes the assertion.
         *
         * @psalm-pure
         *
         * @param string    $value
         * @param int|float $min
         * @param int|float $max
         * @param string    $message
         *
         * @throws InvalidArgumentException
         */
        public static function lengthBetween($value, $min, $max, $message = '')
        {
        }
        /**
         * Will also pass if $value is a directory, use Assert::file() instead if you need to be sure it is a file.
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function fileExists($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function file($value, $message = '')
        {
        }
        /**
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function directory($value, $message = '')
        {
        }
        /**
         * @param string $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function readable($value, $message = '')
        {
        }
        /**
         * @param string $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function writable($value, $message = '')
        {
        }
        /**
         * @psalm-assert class-string $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function classExists($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $class
         * @psalm-assert class-string<ExpectedType>|ExpectedType $value
         *
         * @param mixed         $value
         * @param string|object $class
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function subclassOf($value, $class, $message = '')
        {
        }
        /**
         * @psalm-assert class-string $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function interfaceExists($value, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template ExpectedType of object
         * @psalm-param class-string<ExpectedType> $interface
         * @psalm-assert class-string<ExpectedType> $value
         *
         * @param mixed  $value
         * @param mixed  $interface
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function implementsInterface($value, $interface, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param class-string|object $classOrObject
         *
         * @param string|object $classOrObject
         * @param mixed         $property
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function propertyExists($classOrObject, $property, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param class-string|object $classOrObject
         *
         * @param string|object $classOrObject
         * @param mixed         $property
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function propertyNotExists($classOrObject, $property, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param class-string|object $classOrObject
         *
         * @param string|object $classOrObject
         * @param mixed         $method
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function methodExists($classOrObject, $method, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-param class-string|object $classOrObject
         *
         * @param string|object $classOrObject
         * @param mixed         $method
         * @param string        $message
         *
         * @throws InvalidArgumentException
         */
        public static function methodNotExists($classOrObject, $method, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param array      $array
         * @param string|int $key
         * @param string     $message
         *
         * @throws InvalidArgumentException
         */
        public static function keyExists($array, $key, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param array      $array
         * @param string|int $key
         * @param string     $message
         *
         * @throws InvalidArgumentException
         */
        public static function keyNotExists($array, $key, $message = '')
        {
        }
        /**
         * Checks if a value is a valid array key (int or string).
         *
         * @psalm-pure
         * @psalm-assert array-key $value
         *
         * @param mixed  $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function validArrayKey($value, $message = '')
        {
        }
        /**
         * Does not check if $array is countable, this can generate a warning on php versions after 7.2.
         *
         * @param Countable|array $array
         * @param int             $number
         * @param string          $message
         *
         * @throws InvalidArgumentException
         */
        public static function count($array, $number, $message = '')
        {
        }
        /**
         * Does not check if $array is countable, this can generate a warning on php versions after 7.2.
         *
         * @param Countable|array $array
         * @param int|float       $min
         * @param string          $message
         *
         * @throws InvalidArgumentException
         */
        public static function minCount($array, $min, $message = '')
        {
        }
        /**
         * Does not check if $array is countable, this can generate a warning on php versions after 7.2.
         *
         * @param Countable|array $array
         * @param int|float       $max
         * @param string          $message
         *
         * @throws InvalidArgumentException
         */
        public static function maxCount($array, $max, $message = '')
        {
        }
        /**
         * Does not check if $array is countable, this can generate a warning on php versions after 7.2.
         *
         * @param Countable|array $array
         * @param int|float       $min
         * @param int|float       $max
         * @param string          $message
         *
         * @throws InvalidArgumentException
         */
        public static function countBetween($array, $min, $max, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert list $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isList($array, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-assert non-empty-list $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isNonEmptyList($array, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template T
         * @psalm-param mixed|array<T> $array
         * @psalm-assert array<string, T> $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isMap($array, $message = '')
        {
        }
        /**
         * @psalm-pure
         * @psalm-template T
         * @psalm-param mixed|array<T> $array
         * @psalm-assert array<string, T> $array
         * @psalm-assert !empty $array
         *
         * @param mixed  $array
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function isNonEmptyMap($array, $message = '')
        {
        }
        /**
         * @psalm-pure
         *
         * @param string $value
         * @param string $message
         *
         * @throws InvalidArgumentException
         */
        public static function uuid($value, $message = '')
        {
        }
        /**
         * @psalm-param class-string<Throwable> $class
         *
         * @param Closure $expression
         * @param string  $class
         * @param string  $message
         *
         * @throws InvalidArgumentException
         */
        public static function throws(\Closure $expression, $class = 'Exception', $message = '')
        {
        }
        /**
         * @throws BadMethodCallException
         */
        public static function __callStatic($name, $arguments)
        {
        }
        /**
         * @param mixed $value
         *
         * @return string
         */
        protected static function valueToString($value)
        {
        }
        /**
         * @param mixed $value
         *
         * @return string
         */
        protected static function typeToString($value)
        {
        }
        protected static function strlen($value)
        {
        }
        /**
         * @param string $message
         *
         * @throws InvalidArgumentException
         *
         * @psalm-pure this method is not supposed to perform side-effects
         * @psalm-return never
         */
        protected static function reportInvalidArgument($message)
        {
        }
    }
    class InvalidArgumentException extends \InvalidArgumentException
    {
    }
}
namespace Mimey {
    /**
     * Class for converting MIME types to file extensions and vice versa.
     */
    class MimeMappingBuilder
    {
        /** @var array The mapping array. */
        protected $mapping;
        /**
         * Add a conversion.
         *
         * @param string $mime The MIME type.
         * @param string $extension The extension.
         * @param bool   $prepend_extension Whether this should be the preferred conversion for MIME type to extension.
         * @param bool   $prepend_mime Whether this should be the preferred conversion for extension to MIME type.
         */
        public function add($mime, $extension, $prepend_extension = true, $prepend_mime = true)
        {
        }
        /**
         * @return array The mapping.
         */
        public function getMapping()
        {
        }
        /**
         * Compile the current mapping to PHP.
         *
         * @return string The compiled PHP code to save to a file.
         */
        public function compile()
        {
        }
        /**
         * Save the current mapping to a file.
         *
         * @param string   $file    The file to save to.
         * @param int      $flags   Flags for `file_put_contents`.
         * @param resource $context Context for `file_put_contents`.
         *
         * @return int|bool The number of bytes that were written to the file, or false on failure.
         */
        public function save($file, $flags = null, $context = null)
        {
        }
        /**
         * Create a new mapping builder based on the built-in types.
         *
         * @return MimeMappingBuilder A mapping builder with built-in types loaded.
         */
        public static function create()
        {
        }
        /**
         * Create a new mapping builder based on types from a file.
         *
         * @param string $file The compiled PHP file to load.
         *
         * @return MimeMappingBuilder A mapping builder with types loaded from a file.
         */
        public static function load($file)
        {
        }
        /**
         * Create a new mapping builder that has no types defined.
         *
         * @return MimeMappingBuilder A mapping builder with no types defined.
         */
        public static function blank()
        {
        }
    }
    /**
     * Generates a mapping for use in the MimeTypes class.
     *
     * Reads text in the format of httpd's mime.types and generates a PHP array containing the mappings.
     */
    class MimeMappingGenerator
    {
        protected $mime_types_text;
        /**
         * Create a new generator instance with the given mime.types text.
         *
         * @param string $mime_types_text The text from the mime.types file.
         */
        public function __construct($mime_types_text)
        {
        }
        /**
         * Read the given mime.types text and return a mapping compatible with the MimeTypes class.
         *
         * @return array The mapping.
         */
        public function generateMapping()
        {
        }
        /**
         * Read the given mime.types text and generate mapping code.
         *
         * @return string The mapping PHP code for inclusion.
         */
        public function generateMappingCode()
        {
        }
    }
    /**
     * An interface for converting between MIME types and file extensions.
     */
    interface MimeTypesInterface
    {
        /**
         * Get the first MIME type that matches the given file extension.
         *
         * @param string $extension The file extension to check.
         *
         * @return string|null The first matching MIME type or null if nothing matches.
         */
        public function getMimeType($extension);
        /**
         * Get the first file extension (without the dot) that matches the given MIME type.
         *
         * @param string $mime_type The MIME type to check.
         *
         * @return string|null The first matching extension or null if nothing matches.
         */
        public function getExtension($mime_type);
        /**
         * Get all MIME types that match the given extension.
         *
         * @param string $extension The file extension to check.
         *
         * @return array An array of MIME types that match the given extension; can be empty.
         */
        public function getAllMimeTypes($extension);
        /**
         * Get all file extensions (without the dots) that match the given MIME type.
         *
         * @param string $mime_type The MIME type to check.
         *
         * @return array An array of file extensions that match the given MIME type; can be empty.
         */
        public function getAllExtensions($mime_type);
    }
    /**
     * Class for converting MIME types to file extensions and vice versa.
     */
    class MimeTypes implements \Mimey\MimeTypesInterface
    {
        /** @var array The mapping array. */
        protected $mapping;
        /**
         * Create a new mime types instance with the given mappings.
         *
         * If no mappings are defined, they will default to the ones included with this package.
         *
         * @param array $mapping An associative array containing two entries.
         * Entry "mimes" being an associative array of extension to array of MIME types.
         * Entry "extensions" being an associative array of MIME type to array of extensions.
         * Example:
         * <code>
         * array(
         *   'extensions' => array(
         *     'application/json' => array('json'),
         *     'image/jpeg'       => array('jpg', 'jpeg'),
         *     ...
         *   ),
         *   'mimes' => array(
         *     'json' => array('application/json'),
         *     'jpeg' => array('image/jpeg'),
         *     ...
         *   )
         * )
         * </code>
         */
        public function __construct($mapping = null)
        {
        }
        /**
         * @inheritdoc
         */
        public function getMimeType($extension)
        {
        }
        /**
         * @inheritdoc
         */
        public function getExtension($mime_type)
        {
        }
        /**
         * @inheritdoc
         */
        public function getAllMimeTypes($extension)
        {
        }
        /**
         * @inheritdoc
         */
        public function getAllExtensions($mime_type)
        {
        }
        /**
         * Get the built-in mapping.
         *
         * @return array The built-in mapping.
         */
        protected static function getBuiltIn()
        {
        }
    }
}
namespace Mimey\Tests {
    class MimeMappingBuilderTest extends \PHPUnit\Framework\TestCase
    {
        public function testFromEmpty()
        {
        }
        public function testFromBuiltIn()
        {
        }
        public function testAppendExtension()
        {
        }
        public function testAppendMime()
        {
        }
        public function testSave()
        {
        }
    }
    class MimeMappingGeneratorTest extends \PHPUnit\Framework\TestCase
    {
        public function testGenerateMapping()
        {
        }
    }
    class MimeTypesTest extends \PHPUnit\Framework\TestCase
    {
        /** @var \Mimey\MimeTypes */
        protected $mime;
        protected function setUp(): void
        {
        }
        public function getMimeTypeProvider()
        {
        }
        /**
         * @dataProvider getMimeTypeProvider
         */
        public function testGetMimeType($expectedMimeType, $extension)
        {
        }
        public function getExtensionProvider()
        {
        }
        /**
         * @dataProvider getExtensionProvider
         */
        public function testGetExtension($expectedExtension, $mimeType)
        {
        }
        public function getAllMimeTypesProvider()
        {
        }
        /**
         * @dataProvider getAllMimeTypesProvider
         */
        public function testGetAllMimeTypes($expectedMimeTypes, $extension)
        {
        }
        public function getAllExtensionsProvider()
        {
        }
        /**
         * @dataProvider getAllExtensionsProvider
         */
        public function testGetAllExtensions($expectedExtensions, $mimeType)
        {
        }
        public function testGetMimeTypeUndefined()
        {
        }
        public function testGetExtensionUndefined()
        {
        }
        public function testGetAllMimeTypesUndefined()
        {
        }
        public function testGetAllExtensionsUndefined()
        {
        }
        public function testBuiltInMapping()
        {
        }
    }
}
namespace Clue\StreamFilter {
    /**
     * Append a filter callback to the given stream.
     *
     * Each stream can have a list of filters attached.
     * This function appends a filter to the end of this list.
     *
     * If the given filter can not be added, it throws an `Exception`.
     *
     * The `$stream` can be any valid stream resource, such as:
     *
     * ```php
     * $stream = fopen('demo.txt', 'w+');
     * ```
     *
     * The `$callback` should be a valid callable function which accepts
     * an individual chunk of data and should return the updated chunk:
     *
     * ```php
     * $filter = Clue\StreamFilter\append($stream, function ($chunk) {
     *     // will be called each time you read or write a $chunk to/from the stream
     *     return $chunk;
     * });
     * ```
     *
     * As such, you can also use native PHP functions or any other `callable`:
     *
     * ```php
     * Clue\StreamFilter\append($stream, 'strtoupper');
     *
     * // will write "HELLO" to the underlying stream
     * fwrite($stream, 'hello');
     * ```
     *
     * If the `$callback` accepts invocation without parameters,
     * then this signature will be invoked once ending (flushing) the filter:
     *
     * ```php
     * Clue\StreamFilter\append($stream, function ($chunk = null) {
     *     if ($chunk === null) {
     *         // will be called once ending the filter
     *         return 'end';
     *     }
     *     // will be called each time you read or write a $chunk to/from the stream
     *     return $chunk;
     * });
     *
     * fclose($stream);
     * ```
     *
     * > Note: Legacy PHP versions (PHP < 5.4) do not support passing additional data
     * from the end signal handler if the stream is being closed.
     *
     * If your callback throws an `Exception`, then the filter process will be aborted.
     * In order to play nice with PHP's stream handling,
     * the `Exception` will be transformed to a PHP warning instead:
     *
     * ```php
     * Clue\StreamFilter\append($stream, function ($chunk) {
     *     throw new \RuntimeException('Unexpected chunk');
     * });
     *
     * // raises an E_USER_WARNING with "Error invoking filter: Unexpected chunk"
     * fwrite($stream, 'hello');
     * ```
     *
     * The optional `$read_write` parameter can be used to only invoke the `$callback`
     * when either writing to the stream or only when reading from the stream:
     *
     * ```php
     * Clue\StreamFilter\append($stream, function ($chunk) {
     *     // will be called each time you write to the stream
     *     return $chunk;
     * }, STREAM_FILTER_WRITE);
     *
     * Clue\StreamFilter\append($stream, function ($chunk) {
     *     // will be called each time you read from the stream
     *     return $chunk;
     * }, STREAM_FILTER_READ);
     * ```
     *
     * This function returns a filter resource which can be passed to [`remove()`](#remove).
     *
     * > Note that once a filter has been added to stream, the stream can no longer be passed to
     * > [`stream_select()`](https://www.php.net/manual/en/function.stream-select.php)
     * > (and family).
     * >
     * > > Warning: stream_select(): cannot cast a filtered stream on this system in {file} on line {line}
     * >
     * > This is due to limitations of PHP's stream filter support, as it can no longer reliably
     * > tell when the underlying stream resource is actually ready.
     * > As an alternative, consider calling `stream_select()` on the unfiltered stream and
     * > then pass the unfiltered data through the [`fun()`](#fun) function.
     *
     * @param resource $stream
     * @param callable $callback
     * @param int $read_write
     * @return resource filter resource which can be used for `remove()`
     * @throws \Exception on error
     * @uses stream_filter_append()
     */
    function append($stream, $callback, $read_write = STREAM_FILTER_ALL)
    {
    }
    /**
     * Prepend a filter callback to the given stream.
     *
     * Each stream can have a list of filters attached.
     * This function prepends a filter to the start of this list.
     *
     * If the given filter can not be added, it throws an `Exception`.
     *
     * ```php
     * $filter = Clue\StreamFilter\prepend($stream, function ($chunk) {
     *     // will be called each time you read or write a $chunk to/from the stream
     *     return $chunk;
     * });
     * ```
     *
     * This function returns a filter resource which can be passed to [`remove()`](#remove).
     *
     * Except for the position in the list of filters, this function behaves exactly
     * like the [`append()`](#append) function.
     * For more details about its behavior, see also the [`append()`](#append) function.
     *
     * @param resource $stream
     * @param callable $callback
     * @param int $read_write
     * @return resource filter resource which can be used for `remove()`
     * @throws \Exception on error
     * @uses stream_filter_prepend()
     */
    function prepend($stream, $callback, $read_write = STREAM_FILTER_ALL)
    {
    }
    /**
     * Create a filter function which uses the given built-in `$filter`.
     *
     * PHP comes with a useful set of [built-in filters](https://www.php.net/manual/en/filters.php).
     * Using `fun()` makes accessing these as easy as passing an input string to filter
     * and getting the filtered output string.
     *
     * ```php
     * $fun = Clue\StreamFilter\fun('string.rot13');
     *
     * assert('grfg' === $fun('test'));
     * assert('test' === $fun($fun('test'));
     * ```
     *
     * Please note that not all filter functions may be available depending
     * on installed PHP extensions and the PHP version in use.
     * In particular, [HHVM](https://hhvm.com/) may not offer the same filter functions
     * or parameters as Zend PHP.
     * Accessing an unknown filter function will result in a `RuntimeException`:
     *
     * ```php
     * Clue\StreamFilter\fun('unknown'); // throws RuntimeException
     * ```
     *
     * Some filters may accept or require additional filter parameters – most
     * filters do not require filter parameters.
     * If given, the optional `$parameters` argument will be passed to the
     * underlying filter handler as-is.
     * In particular, note how *not passing* this parameter at all differs from
     * explicitly passing a `null` value (which many filters do not accept).
     * Please refer to the individual filter definition for more details.
     * For example, the `string.strip_tags` filter can be invoked like this:
     *
     * ```php
     * $fun = Clue\StreamFilter\fun('string.strip_tags', '<a><b>');
     *
     * $ret = $fun('<b>h<br>i</b>');
     * assert('<b>hi</b>' === $ret);
     * ```
     *
     * Under the hood, this function allocates a temporary memory stream, so it's
     * recommended to clean up the filter function after use.
     * Also, some filter functions (in particular the
     * [zlib compression filters](https://www.php.net/manual/en/filters.compression.php))
     * may use internal buffers and may emit a final data chunk on close.
     * The filter function can be closed by invoking without any arguments:
     *
     * ```php
     * $fun = Clue\StreamFilter\fun('zlib.deflate');
     *
     * $ret = $fun('hello') . $fun('world') . $fun();
     * assert('helloworld' === gzinflate($ret));
     * ```
     *
     * The filter function must not be used anymore after it has been closed.
     * Doing so will result in a `RuntimeException`:
     *
     * ```php
     * $fun = Clue\StreamFilter\fun('string.rot13');
     * $fun();
     *
     * $fun('test'); // throws RuntimeException
     * ```
     *
     * > Note: If you're using the zlib compression filters, then you should be wary
     * about engine inconsistencies between different PHP versions and HHVM.
     * These inconsistencies exist in the underlying PHP engines and there's little we
     * can do about this in this library.
     * [Our test suite](tests/) contains several test cases that exhibit these issues.
     * If you feel some test case is missing or outdated, we're happy to accept PRs! :)
     *
     * @param string $filter     built-in filter name. See stream_get_filters() or http://php.net/manual/en/filters.php
     * @param mixed  $parameters (optional) parameters to pass to the built-in filter as-is
     * @return callable a filter callback which can be append()'ed or prepend()'ed
     * @throws \RuntimeException on error
     * @link http://php.net/manual/en/filters.php
     * @see stream_get_filters()
     * @see append()
     */
    function fun($filter, $parameters = null)
    {
    }
    /**
     * Remove a filter previously added via `append()` or `prepend()`.
     *
     * ```php
     * $filter = Clue\StreamFilter\append($stream, function () {
     *     // …
     * });
     * Clue\StreamFilter\remove($filter);
     * ```
     *
     * @param resource $filter
     * @return bool true on success or false on error
     * @throws \RuntimeException on error
     * @uses stream_filter_remove()
     */
    function remove($filter)
    {
    }
    /**
     * Registers the callback filter and returns the resulting filter name
     *
     * There should be little reason to call this function manually.
     *
     * @return string filter name
     * @uses CallbackFilter
     */
    function register()
    {
    }
}
/**
 * Short description
 *
 * Long description here...
 *
 * PHP version 7.x
 *
 * @category   CategoryName
 * @package    Namespace
 * @author     trproc
 * @copyright  2021 edoc solutions ag
 * @license    proprietary
 * @link       https://edoc.de
 */
namespace edoc\utils\Arrays {
    function merge(&$first, $second)
    {
    }
}
/**
 * Short description
 *
 * Long description here...
 *
 * PHP version 7.x
 *
 * @category   CategoryName
 * @package    Namespace
 * @author     trproc
 * @copyright  2021 edoc solutions ag
 * @license    proprietary
 * @link       https://edoc.de
 */
namespace edoc\utils\FS {
    function copy(string $from, string $to)
    {
    }
}
/**
 * Short description
 *
 * Long description here...
 *
 * PHP version 7.x
 *
 * @category   CategoryName
 * @package    Namespace
 * @author     trproc
 * @copyright  2021 edoc solutions ag
 * @license    proprietary
 * @link       https://edoc.de
 */
namespace edoc\utils\FS {
    function delete(array $paths)
    {
    }
}
namespace edoc\utils\FS {
    function destroydir($path)
    {
    }
}
namespace edoc\utils\FS {
    function tempdir($path, $prefix = '', $mode = 0700, $autodestroy = true)
    {
    }
}
namespace GuzzleHttp {
    /**
     * Debug function used to describe the provided value type and class.
     *
     * @param mixed $input Any type of variable to describe the type of. This
     *                     parameter misses a typehint because of that.
     *
     * @return string Returns a string containing the type of the variable and
     *                if a class is provided, the class name.
     *
     * @deprecated describe_type will be removed in guzzlehttp/guzzle:8.0. Use Utils::describeType instead.
     */
    function describe_type($input): string
    {
    }
    /**
     * Parses an array of header lines into an associative array of headers.
     *
     * @param iterable $lines Header lines array of strings in the following
     *                        format: "Name: Value"
     *
     * @deprecated headers_from_lines will be removed in guzzlehttp/guzzle:8.0. Use Utils::headersFromLines instead.
     */
    function headers_from_lines(iterable $lines): array
    {
    }
    /**
     * Returns a debug stream based on the provided variable.
     *
     * @param mixed $value Optional value
     *
     * @return resource
     *
     * @deprecated debug_resource will be removed in guzzlehttp/guzzle:8.0. Use Utils::debugResource instead.
     */
    function debug_resource($value = null)
    {
    }
    /**
     * Chooses and creates a default handler to use based on the environment.
     *
     * The returned handler is not wrapped by any default middlewares.
     *
     * @return callable(\Psr\Http\Message\RequestInterface, array): \GuzzleHttp\Promise\PromiseInterface Returns the best handler for the given system.
     *
     * @throws \RuntimeException if no viable Handler is available.
     *
     * @deprecated choose_handler will be removed in guzzlehttp/guzzle:8.0. Use Utils::chooseHandler instead.
     */
    function choose_handler(): callable
    {
    }
    /**
     * Get the default User-Agent string to use with Guzzle.
     *
     * @deprecated default_user_agent will be removed in guzzlehttp/guzzle:8.0. Use Utils::defaultUserAgent instead.
     */
    function default_user_agent(): string
    {
    }
    /**
     * Returns the default cacert bundle for the current system.
     *
     * First, the openssl.cafile and curl.cainfo php.ini settings are checked.
     * If those settings are not configured, then the common locations for
     * bundles found on Red Hat, CentOS, Fedora, Ubuntu, Debian, FreeBSD, OS X
     * and Windows are checked. If any of these file locations are found on
     * disk, they will be utilized.
     *
     * Note: the result of this function is cached for subsequent calls.
     *
     * @throws \RuntimeException if no bundle can be found.
     *
     * @deprecated default_ca_bundle will be removed in guzzlehttp/guzzle:8.0. This function is not needed in PHP 5.6+.
     */
    function default_ca_bundle(): string
    {
    }
    /**
     * Creates an associative array of lowercase header names to the actual
     * header casing.
     *
     * @deprecated normalize_header_keys will be removed in guzzlehttp/guzzle:8.0. Use Utils::normalizeHeaderKeys instead.
     */
    function normalize_header_keys(array $headers): array
    {
    }
    /**
     * Returns true if the provided host matches any of the no proxy areas.
     *
     * This method will strip a port from the host if it is present. Each pattern
     * can be matched with an exact match (e.g., "foo.com" == "foo.com") or a
     * partial match: (e.g., "foo.com" == "baz.foo.com" and ".foo.com" ==
     * "baz.foo.com", but ".foo.com" != "foo.com").
     *
     * Areas are matched in the following cases:
     * 1. "*" (without quotes) always matches any hosts.
     * 2. An exact match.
     * 3. The area starts with "." and the area is the last part of the host. e.g.
     *    '.mit.edu' will match any host that ends with '.mit.edu'.
     *
     * @param string   $host         Host to check against the patterns.
     * @param string[] $noProxyArray An array of host patterns.
     *
     * @throws Exception\InvalidArgumentException
     *
     * @deprecated is_host_in_noproxy will be removed in guzzlehttp/guzzle:8.0. Use Utils::isHostInNoProxy instead.
     */
    function is_host_in_noproxy(string $host, array $noProxyArray): bool
    {
    }
    /**
     * Wrapper for json_decode that throws when an error occurs.
     *
     * @param string $json    JSON data to parse
     * @param bool   $assoc   When true, returned objects will be converted
     *                        into associative arrays.
     * @param int    $depth   User specified recursion depth.
     * @param int    $options Bitmask of JSON decode options.
     *
     * @return object|array|string|int|float|bool|null
     *
     * @throws Exception\InvalidArgumentException if the JSON cannot be decoded.
     *
     * @see https://www.php.net/manual/en/function.json-decode.php
     * @deprecated json_decode will be removed in guzzlehttp/guzzle:8.0. Use Utils::jsonDecode instead.
     */
    function json_decode(string $json, bool $assoc = false, int $depth = 512, int $options = 0)
    {
    }
    /**
     * Wrapper for JSON encoding that throws when an error occurs.
     *
     * @param mixed $value   The value being encoded
     * @param int   $options JSON encode option bitmask
     * @param int   $depth   Set the maximum depth. Must be greater than zero.
     *
     * @throws Exception\InvalidArgumentException if the JSON cannot be encoded.
     *
     * @see https://www.php.net/manual/en/function.json-encode.php
     * @deprecated json_encode will be removed in guzzlehttp/guzzle:8.0. Use Utils::jsonEncode instead.
     */
    function json_encode($value, int $options = 0, int $depth = 512): string
    {
    }
}
namespace Laminas\Diactoros {
    /**
     * Create an uploaded file instance from an array of values.
     *
     * @param array $spec A single $_FILES entry.
     * @throws Exception\InvalidArgumentException If one or more of the tmp_name,
     *     size, or error keys are missing from $spec.
     */
    function createUploadedFile(array $spec): \Laminas\Diactoros\UploadedFile
    {
    }
}
namespace Laminas\Diactoros {
    /**
     * @param array $server Values obtained from the SAPI (generally `$_SERVER`).
     * @return array<non-empty-string, mixed> Header/value pairs
     */
    function marshalHeadersFromSapi(array $server): array
    {
    }
}
namespace Laminas\Diactoros {
    /**
     * Retrieve the request method from the SAPI parameters.
     */
    function marshalMethodFromSapi(array $server): string
    {
    }
}
namespace Laminas\Diactoros {
    /**
     * Return HTTP protocol version (X.Y) as discovered within a `$_SERVER` array.
     *
     * @throws Exception\UnrecognizedProtocolVersionException If the
     *     $server['SERVER_PROTOCOL'] value is malformed.
     */
    function marshalProtocolVersionFromSapi(array $server): string
    {
    }
}
namespace Laminas\Diactoros {
    /**
     * Marshal the $_SERVER array
     *
     * Pre-processes and returns the $_SERVER superglobal. In particularly, it
     * attempts to detect the Authorization header, which is often not aggregated
     * correctly under various SAPI/httpd combinations.
     *
     * @param null|callable $apacheRequestHeaderCallback Callback that can be used to
     *     retrieve Apache request headers. This defaults to
     *     `apache_request_headers` under the Apache mod_php.
     * @return array Either $server verbatim, or with an added HTTP_AUTHORIZATION header.
     */
    function normalizeServer(array $server, ?callable $apacheRequestHeaderCallback = null): array
    {
    }
}
namespace Laminas\Diactoros {
    /**
     * Normalize uploaded files
     *
     * Transforms each value into an UploadedFile instance, and ensures that nested
     * arrays are normalized.
     *
     * @return UploadedFileInterface[]
     * @throws Exception\InvalidArgumentException For unrecognized values.
     */
    function normalizeUploadedFiles(array $files): array
    {
    }
}
namespace Laminas\Diactoros {
    /**
     * Parse a cookie header according to RFC 6265.
     *
     * PHP will replace special characters in cookie names, which results in other cookies not being available due to
     * overwriting. Thus, the server request should take the cookies from the request header instead.
     *
     * @param string $cookieHeader A string cookie header value.
     * @return array<non-empty-string, string> key/value cookie pairs.
     */
    function parseCookieHeader($cookieHeader): array
    {
    }
}
namespace {
    /** @var \FastRoute\RouteCollector $routeCollector */
    $routeCollector = new \FastRoute\RouteCollector(new \FastRoute\RouteParser\Std(), new \FastRoute\DataGenerator\GroupCountBased());
    function loadEnvVar($name, $default = \null)
    {
    }
    /** @var \DI\Container $container */
    $container = require __DIR__ . '/../app/bootstrap.php';
    function deleteDir($path, $maxAge)
    {
    }
    /** @var \DI\Container $container */
    $container = require __DIR__ . '/../app/bootstrap.php';
    /** @var Container $container */
    $container = require \dirname(__DIR__, 1) . '/app/bootstrap.php';
    /** @var \DI\Container $container */
    $container = require __DIR__ . '/../app/bootstrap.php';
    /** @var RouteCollector $routeCollector */
    $cookieSameSite = \edoc\appserver\core\Config::getInstance()->get('cookie.same_site', \null);
    /** @var \edoc\appserver\App $app */
    $app = $container->get(\edoc\appserver\core\AppLoader::class)->loadApp($_POST['appId']);
    function _t($value): string
    {
    }
    function __($value)
    {
    }
    function set_error_reporting($level)
    {
    }
    function ini_get_bytes($name)
    {
    }
    function log_error_in_file($type, $message)
    {
    }
    function addComposerRepository($composerPath)
    {
    }
    function filter_id_string(string $data)
    {
    }
    function includeIfExists(string $file): ?\Composer\Autoload\ClassLoader
    {
    }
    /**
     * Get all HTTP header key/values as an associative array for the current request.
     *
     * @return string[string] The HTTP header key/value pairs.
     */
    function getallheaders()
    {
    }
}